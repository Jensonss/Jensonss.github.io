{"meta":{"title":"Jenson","subtitle":"走出舒适区","description":"Android Java Python C C++","author":"Jenson","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2017-04-22T09:00:42.000Z","updated":"2017-04-27T03:55:54.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个从运维转战开发的程序猿。2012年因为兴趣自学了因为开源而崛起Android。 我的经历 2010年野鸡专科毕业 2011年，财政局做了一年的数据维护 2013年，做了一年的IPTV Android机顶盒开发 2014年3-6月，做了三个月政府审查上报类项目Android客户端，负责框架搭建 2014年9月到2016年10月，做了两年Android IM即时通讯APP聊天功能开发及维护并各种性能优化。 自我评价 热爱编程，自我驱动型学习，喜欢看书 热爱户外，双休时间喜欢和驴友徒步穿越 喜欢摄影，被基友勾搭，逐渐喜欢用镜头留住精彩的瞬间 联系我QQ: 840418528Email: songjlforever@foxmail.com"},{"title":"分类","date":"2017-04-22T09:16:26.000Z","updated":"2017-04-22T09:19:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-04-22T09:16:02.000Z","updated":"2017-04-22T09:19:10.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac下配置adb","slug":"Mac下配置adb","date":"2017-07-13T13:10:42.000Z","updated":"2017-07-13T13:30:41.000Z","comments":true,"path":"2017/07/13/Mac下配置adb/","link":"","permalink":"http://yoursite.com/2017/07/13/Mac下配置adb/","excerpt":"","text":"0x00 前言Mac和windows一样，如果要在终端命令行全局使用非系统命令，需要手动把命令环境配置到指定文件中，具体操作就是把命令文件所属路径配置到.bash_profile里面。 0x01 分别找到双方路径找到adb我是通过Android studio中的idk location找到SDK位置/Users/jenson/Library/Android/sdk . 找到.bash_profile 使用命令行cd $home 进入home路径下， 因为mac下以点开头的文件为隐藏文件，所以使用ls -al 查看所有文件，查看列表是否有.bash_profile文件， 如果没有，使用touch .bash_profile 创建，如果有则执行命令open -e .bash_profile 使用文本编辑器打开文件， 在下面按格式添加SDK路径： 12export PATH=/Users/jenson/Library/Android/sdk/platform-tools:$PATHexport PATH=/Users/jenson/Library/Android/sdk/tools:$PATH ​ open -e .bash_profile提示open命令不存在通过Finder根据路径找到.bash_profile文件，编辑添加 12export PATH=&quot;/usr/bin:/bin:/usr/sbin:/sbin&quot;export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Java知识点","slug":"Java知识点","date":"2017-06-30T10:51:23.000Z","updated":"2017-06-30T11:28:04.000Z","comments":true,"path":"2017/06/30/Java知识点/","link":"","permalink":"http://yoursite.com/2017/06/30/Java知识点/","excerpt":"","text":"字符串1、==对基本数据类型来说比较的是值是否相等，但对于引用类型来说，其和equals医院，比较的都是对象地址，前提是equals没有被重写。 123456789String c = \"c\";final String c1 = \"c\";String s0 = \"a\" + \"b\" + c1;String s1 = \"a\" + \"b\" + c;String s2 = \"a\" + \"b\" + \"c\";String s3 = \"abc\";System.out.println(s0 == s3);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s2 == s3);//true 根据Java编译时优化方案，s2中加号的三个值都为固定常量，所以s2在编译时也被认为是常量，即编译期就确定了s2的值，并且和s3一样，所以打印true 在s1中，a和b的值是常量，但是c属于局部变量，而且也没有谁指定c这个值是不可变的。既然是可变量，导致s1也被编译期认为是不确定值， 接下来s0，a和b不用说了都是常量，而c1虽然和c一样也是局部变量，但是c1有finla修饰，明确告诉编译器明面上我是一个局部变量，但是同时我的值是不可变的，final修饰了，现在不变，将来也不会改变，所以编译器在编译期确定了s0 的值。所以把s0也作为常量和s3一样，都在常量池 编译器优化要在编译期能确定的值得情况下进行，而能确定值的只能是在常量池中的内容。 2、string.intern()，当字符串调用这个方法时，都会拿着当前字符串的值去常量池中找，如果找到则返回常量池这个常量地址，否则在常量池创建一个常量并把字符串填进去，然后返回创建的地址。当然这是在JDK1.6情况下，在1.7及以后会有不同 123456789String c = \"c\";final String c1 = \"c\";String s0 = \"a\" + \"b\" + c1;String s1 = \"a\" + \"b\" + c;String s2 = \"a\" + \"b\" + \"c\";String s3 = \"abc\";System.out.println(s0 == s3);System.out.println(s1.intern() == s3);//trueSystem.out.println(s2 == s3); 由于intern()需要去常量池中做字符串比较，而常量池又很可能有多个常量，所以一般来说intern()效率并不高","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Django创建数据表时syncdb提示Unknown command：‘syncdb'","slug":"Django创建数据表时syncdb提示Unknown-command：‘syncdb","date":"2017-06-27T08:32:23.000Z","updated":"2017-06-27T08:36:05.000Z","comments":true,"path":"2017/06/27/Django创建数据表时syncdb提示Unknown-command：‘syncdb/","link":"","permalink":"http://yoursite.com/2017/06/27/Django创建数据表时syncdb提示Unknown-command：‘syncdb/","excerpt":"","text":"异常信息如下 123JensondeMini:dj_test01 jenson$ python3 ./manage.py syncdbUnknown command: &apos;syncdb&apos;Type &apos;manage.py help&apos; for usage. 主要是因为使用的版本太新，如果你安装的Django Version &gt;= 1.9就会出现这个问题 解决方法就是把python3 ./manage.py syncdb 替换成python3 ./manage.py migrate 之后就会初始化数据表成功 1234567891011121314151617JensondeMini:dj_test01 jenson$ python3 ./manage.py migrateOperations to perform: Apply all migrations: admin, auth, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying sessions.0001_initial... OK","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python入门系列(3):元组、列表和字典","slug":"Python入门系列-3-元组、列表和字典","date":"2017-06-26T11:00:58.000Z","updated":"2017-06-26T15:04:21.000Z","comments":true,"path":"2017/06/26/Python入门系列-3-元组、列表和字典/","link":"","permalink":"http://yoursite.com/2017/06/26/Python入门系列-3-元组、列表和字典/","excerpt":"","text":"0x00 前言​ 上一节说明了Python字符串和简单数据类型的基本用法，因为比较简单，所以没有做太多说明，这一节介绍下列表、元组和字典。之所以把这三个放在同一节讲是因为这三个数据结构有很多相似地方，对比学习让人印象更深。 0x01 列表什么是列表？如何表示列表？​ 列表就是由一组特定顺序的元素组成，使用中括号“[ ]”来表示，元素之间使用逗号分隔，例如：animal = [‘cat’, ‘dog’, ‘monkey’] 访问列表​ 列表的访问通过索引下标来访问，索引和其他大多数语言一样从0开始。 也就是说访问第一个元素为：animal[0]。而和其他语言不一样的是Python中索引可以为负值，如：animal[-1]实际为最后一个元素，以此类推。 列表增加元素​ 元素的添加分为两种，列表末尾追加和任意位置添加 末尾追加 使用方法append，animal.append(’fox‘) 任意位置添加 使用方法insert，animal.insert(1,’fox’)。第一个参数为索引值 列表删除元素元素删除也可以通过四种方式实现： 使用del 如果知道元素所处列表位置，则使用del animal[ i ] 使用pop 如果只需删除了列表末尾元素，则直接使用animal.pop方法。类似出栈 使用pop 如果要删除任意位置元素，使用animal.pop（i)，参数为索引值 使用remove 如果知道元素值而不知道位置，则使用animal.remove（value），参数为元素值 列表修改元素​ 修改列表元素的语法与访问列表元素的语法类似，如果要进行元素修改只要拿到元素后对其进行从新赋值即可：animal[1] = ‘bird’。 列表元素遍历列表遍历使用循环即可。 12for ani in animal: print(ani) 0x02 元组元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 Python 的元组与列表类似，不同之处在于元组的元素不能修改。 元组中只包含一个元素时，需要在元素后面添加逗号 ​ tup1 = (10,) 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组 1234cats = ('xm','dm')print(cats)del catsprint(cats)#打印异常 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 1234cats = ('xm', 'dm')cat1 = ('mm',)allCat = cats + cat1print(allCat)#('xm', 'dm', 'mm') ​ 0x03 字典","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Pytyon","slug":"Pytyon","permalink":"http://yoursite.com/tags/Pytyon/"}]},{"title":"算法之朴素模式匹配","slug":"算法之朴素模式匹配","date":"2017-05-25T07:49:26.000Z","updated":"2017-05-25T09:47:51.000Z","comments":true,"path":"2017/05/25/算法之朴素模式匹配/","link":"","permalink":"http://yoursite.com/2017/05/25/算法之朴素模式匹配/","excerpt":"","text":"0x00 前言不论英文还是中文，在看文章时经常会遇到查找某个单词或字组的时候，把一篇文章看作是一个大的字符串，要查找的内容作为子串，这种在大串中查找子串的操作叫做串的模式匹配。 我们知道了这种行为叫串的模式匹配，但我们不清楚的是到底如何匹配，具体的操作是什么？ 0x01 我如何操作在我看来要从大串中寻找子串，最直接的方法就是从大串起始位置开始，挨个字符比对，如果存在子串总会找出来。这种简单直接的方法称为 朴素的模式匹配算法 0x02 代码实现如果借用字符串截取操作，直接实现子串的查找就比较方便： 1234567891011121314public static int index(String s, String t, int pos) &#123; int m = s.length(); int n = t.length(); while (pos &lt;= (m - n + 1)) &#123; String sub = s.substring(pos, n); //直接在对比位置截取和子串相同长度的一个串来和子串对比 if (t.equals(sub)) &#123; return pos; &#125; else &#123; pos++; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"两个栈实现队列功能","slug":"两个栈实现队列功能","date":"2017-05-18T08:28:16.000Z","updated":"2017-05-18T10:36:21.000Z","comments":true,"path":"2017/05/18/两个栈实现队列功能/","link":"","permalink":"http://yoursite.com/2017/05/18/两个栈实现队列功能/","excerpt":"","text":"0x00 前言用2个栈实现队列，首先要明白栈和队列的区别：栈是FILO，队列是FIFO。明白了这两点就比较容易实现了。 0x01 分析栈是一端开口，队列是两端开口，如果要让栈实现队列功能，需要2个栈一个负责进数据，一个负责出数据。为了保证出数据的顺序，在出数据栈不为空时，入数据的栈中数据不能往出数据的栈里存。 0x02 实现在2个栈数据都为空时注意抛出异常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Stack;/** * 两个栈实现队列功能 * @author jenson */public class StackToQueue &#123; private Stack&lt;Integer&gt; inStack = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; outStack = new Stack&lt;&gt;(); /** * 添加元素 * @param value */ public void add(int value) &#123; inStack.push(value); &#125; /** * 出队列 * @return */ public int poll() &#123; if (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123; queueEmptyException(); &#125; else &#123; if (outStack.isEmpty()) &#123; reverse(); &#125; &#125; return outStack.pop(); &#125; /** * 查看队列头的元素 &lt;/br&gt; * 注意一点：如果出栈队列为空，则把入栈数据倒入到处栈，然后从出栈取&lt;br&gt; * 如果两个栈都为空抛异常 * */ public int peek() &#123; if (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123; queueEmptyException(); &#125; else &#123; if (outStack.isEmpty()) &#123; reverse(); &#125; &#125; return outStack.peek(); &#125; /** * 入栈数据倒入到出栈 */ private void reverse() &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125; private void queueEmptyException() &#123; throw new RuntimeException(&quot;队列为空&quot;); &#125; public static void main(String[] args) &#123; StackToQueue stackToQueue = new StackToQueue(); stackToQueue.add(9); stackToQueue.add(5); stackToQueue.add(2); stackToQueue.add(7); System.out.println(stackToQueue.peek()); System.out.println(stackToQueue.poll()); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"设计一个有获取元素最小值getMin的栈","slug":"设计一个有获取元素最小值getMin的栈","date":"2017-05-17T08:24:42.000Z","updated":"2017-05-18T08:28:29.000Z","comments":true,"path":"2017/05/17/设计一个有获取元素最小值getMin的栈/","link":"","permalink":"http://yoursite.com/2017/05/17/设计一个有获取元素最小值getMin的栈/","excerpt":"","text":"0x00 前言栈可以看成一个瓶子，只有一个口，另一端被封底。这样数据进出都只能从一个口经过。这样就导致的一个直接结果就是数据FILO问题。要找到栈中最小数据，单靠一个栈不能完成，需要外部提供辅助。 0x01 分析一个存好数据的栈，要从里面找到最小数值，不可避免的要把数据出栈，然后进行对比。这时有个问题就来了，找到最小数值后，其他数据还有用吗？换句话说，其他数据还要不要了？如果不要的话，比较完成后不用再次存储，如果要德话，比较期间还要注意数据的保存。这里注意要分这两种情况来考虑。 0x02 不要其他数据的实现既然不需要其他数据，那就直接把数据弹出栈就好了，每次弹栈时对比临时值，如果当前弹栈数据比临时值大则直接弹栈，否则就把值赋给临时值。 123456789101112131415161718192021222324252627public class StackMin &#123; private Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); public int getStackMin() &#123; int min = 0; while (!stack.isEmpty()) &#123; int current = stack.pop(); if (min != 0) &#123; if (min &gt; current) &#123; min = current; &#125; &#125; else &#123; min = current; &#125; &#125; return min; &#125; public static void main(String[] args) &#123; StackMin stackMin = new StackMin(); stackMin.stack.push(9); stackMin.stack.push(5); stackMin.stack.push(2); stackMin.stack.push(7); System.out.println(stackMin.getStackMin()); &#125;&#125; 这里代码只实现了getStackMin方法，栈的其他方法就直接定义一个方法后直接调用Stack方法即可。 0x03 需要其他数据的实现如果要保留栈的数据，那最直接的想法是在弹栈比较期间，把弹出栈的数据顺路给入道一个新的栈中，这里相比上面，需要多一个栈即可实现。 1234567891011121314151617181920212223242526272829public class StackMin &#123; private Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; backUp = new Stack&lt;&gt;();//备份栈 public int getStackMin() &#123; int min = 0; while (!stack.isEmpty()) &#123; int current = stack.pop(); if (min != 0) &#123; if (min &gt; current) &#123; min = current; &#125; &#125; else &#123; min = current; &#125; backUp.push(current);//弹出栈时进入备份栈 &#125; return min; &#125; public static void main(String[] args) &#123; StackMin stackMin = new StackMin(); stackMin.stack.push(9); stackMin.stack.push(5); stackMin.stack.push(2); stackMin.stack.push(7); System.out.println(stackMin.getStackMin()); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法排序之快速排序","slug":"算法排序之快速排序","date":"2017-05-16T10:21:50.000Z","updated":"2017-05-16T15:39:30.000Z","comments":true,"path":"2017/05/16/算法排序之快速排序/","link":"","permalink":"http://yoursite.com/2017/05/16/算法排序之快速排序/","excerpt":"","text":"实现目标本例中希望通过快速排序，使得数组最终按非递减顺序排列。 数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 } 数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 } 实现分析快排是根据分治思想， ①选取一个基数， ②将无序数组分为大小两个数组，其中一个数组值全都比基数小，另一个数组值全都比基数大。 ③然后将这两个数组分别再次分组，递归重复①②的步骤直到每个拆分后的数组不可再分割为止。也就是说最后每个元素单独为一个数组为止。 ④最后得出数组就是排序好的。 代码实现123456789101112131415161718192021222324252627282930313233343536public static int partition3(int[] arr, int low, int high) &#123; int i, j; i = low; int base = arr[i]; for (j = i + 1; j &lt;= high; j++) &#123; if (arr[j] &lt; base) &#123; i++; swap(arr, i, j); &#125; &#125; swap(arr, low, i); return i;&#125;/***交换数组中两个值**/public static void swap(int[] arr, int i, int j) &#123; if (i != j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125;&#125;/***right为数组最大下标而不是数组长度**/public static void quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int piv = partition3(arr, left, right); quickSort(arr, left, piv - 1); quickSort(arr, piv + 1, right); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"数学归纳法","slug":"数学归纳法","date":"2017-05-16T06:08:56.000Z","updated":"2017-05-17T03:38:46.000Z","comments":true,"path":"2017/05/16/数学归纳法/","link":"","permalink":"http://yoursite.com/2017/05/16/数学归纳法/","excerpt":"","text":"什么是数学归纳法数学归纳法就是证明一个命题在自然数范围内成立 这里命题也可以当成是断言。 比如断言自然数n，nx2为偶数。 求储蓄罐里的钱有一个空储蓄罐， 第一天，往里面存1元钱； 第二天，往里面存2元钱； 第三天，往里面存3元钱； 第四天，往里面存4元钱； 。 。 。 每天都存钱，第一百天时储蓄罐里一共有多少钱？ 这个问题如何求解呢？其实最直接的方法就是从1开始加，一直加到100，但是这种暴力求解效率极差。 德国9岁孩子高斯也遇到了同样问题，但是他却马上得出了答案。 他是这么考虑的： 1+2+3…+100顺序计算结果和100+99+98…+1这样的逆序结果是一样的。 这样的话，顺序的1+逆序的100，顺序的2+逆序的99，顺序的3+逆序的98，这样最后结果是100个101相加 = 100x101 = 10100 。因为逆序和顺序相等，所以这个和是2倍的顺序，所以顺序的和为10100/2 =5050。最终得出1加到100的和为5050。 高斯据此得出以下公式： 1+2+3…+100 = （100+1）x100/2； 当然上面只是求1到100的和，那如果要求1到1000，到10000呢，公式是不是仍然成立？ 高斯断言：对于任意自然数n：1+2+3…+n = （n+1)xn/2都成立； 接下来要证明高斯的断言是否成立。 数学归纳法证明最简单的数学归纳法是证明当n等于任意一个自然数时断言成立，证明包括两步： 1.证明n=1时，断言p(1)成立 2.证明n=k为任何自然数时，若p(k)成立，则p(k+1)也成立。 由此，关于高斯公式的证明如下： 1.当n=1时， 1 = （1+1）x1/2 = 1，高斯公式成立； 2.当n=k时，1+2+…+k = (k+1)xk/2 成立; 3.当n=k+1时，证明1+2+…+k+(k+1) = ((k+1)+1)x(k+1)/2成立； 因为2成立，所以3中公式代入后： (k+1)xk/2+（k+1） = ((k+1)+1)x(k+1)/2 （k+1）x（k+2）/2 = （k+1）x（k+2）/2 左右两边相等， 得出结论：对于自然数n，断言p(n)都成立。 为什么数学归纳法只证明两步就成立了1.证明断言p(1)成立，也就是n=1成立； 2.通过p(m)成立推导出p(m+1)也成立。 3.根据上面结论，p(1+1)也就是p(2)成立； 4.p(2+1)也就是p(3)成立； 5.p(3+1)也就是p(4)成立； 6.循环推导，最终推导出值为n时p(n)成立。","categories":[{"name":"程序员的数学","slug":"程序员的数学","permalink":"http://yoursite.com/categories/程序员的数学/"}],"tags":[{"name":"程序员的数学","slug":"程序员的数学","permalink":"http://yoursite.com/tags/程序员的数学/"}]},{"title":"为什么每一个IT人员应该有一把人体工学电脑椅","slug":"为什么每一个IT人员应该有一把人体工学电脑椅","date":"2017-05-15T09:32:36.000Z","updated":"2017-05-15T11:42:59.000Z","comments":true,"path":"2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/","link":"","permalink":"http://yoursite.com/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/","excerpt":"","text":"说在前面的话工欲善其事，必先利其器。可能也有强迫症的原因，上班时总是会想尽办法提高工作效率，同时给自己创造一个愉悦的工作状态。对于能提高效率的硬件因素自然不能放过。什么罗技鼠标、机械键盘宿舍公司各一套。为了方便显示器调整，又买了乐哥支架，这样能随时调整角度，避免一个姿势容易疲劳。但是最近又出现了一个问题：一个姿势坐半个小时就浑身不自在，脖子僵硬大脑供血不足，严重时候还有恶心呕吐现象。其实不用说也猜到了—颈椎病，如果置之不理以后腰椎可能也会出现病症。毕竟这是很多IT从业人员的通病，如何缓解病况才不致于影响工作效率呢？个人感觉一把人体工学电脑椅是必须的。 什么是人体工学电脑椅看下百度百科 对人体工学电脑椅的定义：人体工学电脑椅也称人体工学椅、人体工学办公椅，它是以“人体工程学”理论为基础，通过对人们在使用电脑椅的过程中的各个数据进行统计汇总，并根据最终统计的数据而设计研发的电脑椅。 我们日常坐的椅子都是批量生产，都有固定的规格，并不能适应所有人，所以人体工学椅子和普通椅子一个明显区别就是：可调节！可调节的手托、可调节的坐垫高度、可调节的坐垫前后深度、可调节的枕托、可调节的背靠、可调节的腰托等。 一把质量差的电脑椅质量差的电脑椅能有咋的，顶多坏了摔一跤？还是看图最直观： 上图的爆炸是气压棒爆炸引起的。 电脑椅升降功能大都是靠气压棒来实现的。那么什么是气压棒呢？ 看下百度百科 对气压棒的定义，其实说白了气压棒就是靠对棒内气体压缩和释放来达到升降电脑椅的。正品气压棒里面是高纯度氮气填充，并不会爆炸，而一些无良厂商为了节省成本，往往会以价格更为低廉的氧气作为填充物。氧气易燃，遇明火极易产生爆炸，酿成不可挽回的事故。 一个气压棒引起的事故 1.2007年4月20日晚，浙江省舟山市定海区，一位娄女士坐的椅子发生爆炸，座椅被炸穿，娄女士穿的裤子被炸了个大洞，硬塑料、木屑、海绵、布料、密封圈等大量碎片崩进娄女士体内达十厘米。 2.2007年11月26日晚，烟台开发区68岁的吴老先生所坐的气压升降椅发生爆炸，臀部、腿部、直肠肛管和小肠受伤严重。 3.2008年3月26日晚，江西赣州市，一位林先生家中的电脑椅突然发生爆炸，林先生背上、手上等处受伤，一根大约15厘米长的小铁棍炸飞到天花板上。 4.2009年1月14日，山东胶州14岁少年小刚(化名)独自在家上网，在调节气压椅升降时，突然发生爆炸，顶杆从臀部顶进小刚体内，伤及多条血管，后因失血过多，抢救无效死亡。 5.2010.5.12晚上9点半左右，厦门湖里殿前一户出租屋传出巨响。一名女子被突然发生爆裂的升降椅击伤。升降旋转椅突然爆炸，产生的冲击力将椅子里的螺丝小垫片等零件像子弹一样从臀部射入人体内。升降椅的气压杆插入伤者的肛门。女子当场晕倒在地。所幸经过5个多小时的手术，射入体内的椅子零件全被取出，刘小姐无生命危险。 6.2010年5月，福建一女子因气压升降椅爆炸伤势严重当场昏迷，臀部被炸伤，直肠被撕裂了一个口子，阴道也穿了一个孔。后检查椅子的购物单据，没有任何厂名、厂址、电话之类信息。 7.24岁的小林坐在升降旋转椅上吹头发，椅子爆炸，螺丝钉从她肛门边上穿进去，从子宫直肠陷凹处穿出。经过手术，医生从她的体内和臀部取出大量的螺丝钉和塑料碎片。医生说，还算幸运，穿过体内的螺丝钉没有伤及重要的脏器，手术后小林已脱离生命危险。 请务必一定要提醒你的家人和朋友注意： 1、务必购买正规厂家生产的升降椅，切勿贪图便宜，购买劣质货。 2、椅子在使用时，不要反复升降，不要滑来滑去，更不要猛地一下子坐上去。这易造成气压杆受力不均，长时间产生不均衡磨损，易爆炸。据模拟测算，爆炸会产生24个左右大气压，其威力至少能击穿6块密度板，顷刻能洞穿血肉之躯! 3、如果不是专业人士，不要拆开气缸，也不要让椅子靠近太热的东西，比如烤火炉或烤箱。 4、使用一段时间后，应该及时让专业人员检查，一旦发现裂痕、松动迹象，应及时维修更换。 如何挑选人体工学电脑椅价格从价格上来说，和其他商品一样，往往都是一分钱一分货，一块钱二分货。 国际品牌有欧美的Herman Miller、日本的岗村，这些高端系列普遍价格过万或者近万元，当然也有三五千的，但是可选性比较少。 国内品牌有ergonor、ergomax以及黑白调、西昊等。国产价位3000以上就算是高端了，譬如金豪+e、l和ergomax旗舰版。 个人感觉如果要买人体工学电脑椅，还是要舍得投资的，毕竟这投资的是自己的健康。建议起步买2k-3k的。毕竟这个价位在国内属于高端，国外品牌也能买到。这个价位的各方面功能齐全，可以都体验下，为以后的挑选打下基础。 网布坐垫和椅背的材质有皮质、网布和海绵坐垫，我更喜欢全网布的，夏天透气性更好，但是也有个问题：如果网布质量不好，可能坐一段时间后网布就失去弹性，变得松垮。 高端电脑椅网布大都进口，进口网布主要是美国matrex，韩国wintex次之，其他基本就是国产的。 进口网和国产网的差别： 价格：进口的美国Matrex网最贵，韩国Wintex网次之，国产网价格最便宜网，而且进口网涉及空运报关原因，货期长。 耐用性：在厂家的垂直堕下机械测试中，进口Matrex网和Wintex网可以通过10万次强力冲击，国产网在按不同牌子在6-8万次之间会出现爆裂! 材质：美国Matrex网和Wintex网材质柔软，弹力强，国产网比较硬，弹力及恢复力差。 Matrex表面反光呈黏手手感，Wintex网表面反光呈光滑手感，国产网按不同牌子部分表面光滑，部分表面粗糙。 据Matrex网和Wintex网国内代理商的说法，国内厂商用进口网布的并不多，内销产品基本都不会使用进口网，进口网一般都是外国客户指定要求才用的，原因在于进口网不仅更贵，而且在订购数量方面有要求，由于涉及空运报关因素，邮寄周期也比较长，这样就限制了小厂家的采购，掌柜曾经在网上看过一些网店几百产品也宣称使用Matrex网，那是不可能的，进口网，基本上只出现在2K以上的产品。 Matrex和wintex网布都是有吊牌的，如果商家真的采用这两种品牌，一定会拿出来当噱头显摆一番的，而不是轻描淡写的一句采用进口网布草草了事。网上那些说进口网布，但又不敢指明具体品牌的，就当时国产就行了或者不要买，毕竟涉嫌欺诈。 气压棒气压棒是有分级的，目前是共有四级：普遍使用的时三级，少数所谓高端使用四级。 常用气压棒品牌：国内知名的有：安徽莱特，安德福，常州巨威，安吉斯诺尔，等还有一些进口的：韩国KGS，韩国三弘，德国SUS棒，台湾MID棒等等。 买回来后看气压棒有没有钢印，查看钢印信息是否和商家描述一致，如果有问题即时质疑。 底座一般来说都有底座防爆措施，但是价格越高底座用料越实，甚至是全铝合金底盘。我的2k 的gavee整个椅子70多斤重，厚重的材质更容易给人以安全感。 我对铝合金椅身有特殊好感，或许害怕塑料椅身不结实，也或许铝合金抛光后看起来更高端也更敦实。 这是我的电脑椅样式：","categories":[{"name":"职场杂谈","slug":"职场杂谈","permalink":"http://yoursite.com/categories/职场杂谈/"}],"tags":[{"name":"职场杂谈","slug":"职场杂谈","permalink":"http://yoursite.com/tags/职场杂谈/"}]},{"title":"四个人过桥问题","slug":"四个人过桥问题","date":"2017-05-11T07:55:37.000Z","updated":"2017-05-11T11:50:31.000Z","comments":true,"path":"2017/05/11/四个人过桥问题/","link":"","permalink":"http://yoursite.com/2017/05/11/四个人过桥问题/","excerpt":"","text":"有甲乙丙丁4个人要过桥，他们都在桥一端，他们只有17分钟时间过桥。时间在晚上，过桥需要用到手电筒，而且手电筒必须来回都用到且手电筒不能扔来扔去，一次只能有2个人同时过桥。每个人走路速度不同，甲过桥需要1分钟，乙过桥需要2分钟，丙过桥需要5分钟，丁过桥需要10分钟。两个人一起走路，速度决定于走的慢的那个。请你给这四人规划合适的搭配过桥。 看到这道题脑子第一想法是：5和10分钟不能分开，如果分开，这俩人就占了15分钟。然而刚让这俩一起过桥，然后就让5分钟的哥们拿着手电筒回来了~~~一脸懵逼试了好几种都没有通过。后来发现我又被自己看问题角度给局限住了，每2个人过桥后，就一直一门心思的让刚过来的2个人中的一个人送手电筒返回，其实送手电筒的这个人只要在同一岸边的就行。说到这里，答案以及开始浮出水面了： 步骤 A B ①甲和乙一起过河，花费2分钟 丙丁 甲乙 ②甲带手电筒返回，花费1分钟 甲丙丁 乙 ③丙和丁一起过河，花费10分钟 甲 乙丙丁 ④乙带手电筒返回，花费2分钟 甲乙 丙丁 ⑤甲和乙一起过河，花费2分钟 甲乙丙丁 上面5个步骤刚好四人全部过桥，花费时间17分钟，当然②中也可以由乙带手电筒返回，不过④要由甲带手电筒。这样也是17分钟，其他时间应该是大于17分钟的。 其实这道题和农夫过河一样，都不难，只要看问题时，眼界要能钻进问题角落深入分析，又能抽出眼界，站在一定高度俯视问题全局。 网上据说这道题在西雅图一个有名软件公司的考官面试时也出过这道题，怎么样你答对了吗？","categories":[{"name":"趣题","slug":"趣题","permalink":"http://yoursite.com/categories/趣题/"}],"tags":[{"name":"趣题","slug":"趣题","permalink":"http://yoursite.com/tags/趣题/"}]},{"title":"农夫带着狼、羊和白菜过河问题","slug":"农夫带着狼、羊和白菜过河问题","date":"2017-05-10T09:55:25.000Z","updated":"2017-05-10T16:19:40.000Z","comments":true,"path":"2017/05/10/农夫带着狼、羊和白菜过河问题/","link":"","permalink":"http://yoursite.com/2017/05/10/农夫带着狼、羊和白菜过河问题/","excerpt":"","text":"一个农夫带着一只狼，一只羊和一棵白菜来到河边要过河，船只狭小，一次农夫只能带一样物品过河，如果农夫不在场，狼会吃羊，羊也会吃白菜。那么农夫如何才能过河或者证明出无解。 这是一道自古有之的谜题，但是一些公司也有把这作为笔试题… 看到这个题我的第一个想法就是船上系一根绳，把狼和白菜一起放船上，待漂到对岸后再用绳子拉过来，然后农夫抱着羊过河。不过这太投机取巧了啊哈哈。还是来点务实的吧： 务实的想法就是要农夫一直和船一起。毕竟不能指望顺风船自动漂对岸然后狼羊白菜自动下船吧。 食物链是这样的：狼&gt;羊&gt;白菜 农夫只要离开，食物链就会发生吞食，所以要让食物链隔开。 那么第一步做法就明白了：必须带羊过河~~ 我们假设A为现在所在岸边，B为目的岸边 步骤 A B ①农夫带着羊过河 狼和白菜 羊 ②农夫独自返回A ③农夫带着白菜过河 狼 羊和白菜 ④农夫带着羊返回 羊和狼 白菜 ⑤农夫带着狼过河 羊 白菜和狼 ⑥农夫独自返回A ⑦农夫带着羊过河 白菜、狼和羊 其实这个解法不是唯一的。 虽然第一步都是要带着羊过河，但是第三步带着白菜和带狼都是可以的。 步骤 A B ③农夫带着狼过河 白菜 羊和狼 ④农夫带着羊返回A 白菜和羊 狼 ⑤农夫带着白菜过河 羊 狼和白菜 ⑥农夫独自返回A ⑦农夫带着羊过河 狼、白菜和羊","categories":[{"name":"趣题","slug":"趣题","permalink":"http://yoursite.com/categories/趣题/"}],"tags":[{"name":"趣题","slug":"趣题","permalink":"http://yoursite.com/tags/趣题/"}]},{"title":"详解设计模式之责任链模式","slug":"详解设计模式之责任链模式","date":"2017-05-10T04:36:14.000Z","updated":"2017-05-10T09:18:28.000Z","comments":true,"path":"2017/05/10/详解设计模式之责任链模式/","link":"","permalink":"http://yoursite.com/2017/05/10/详解设计模式之责任链模式/","excerpt":"","text":"说在前面的话责任链模式也叫职责链，抛开设计模式不谈，单看“责任链”这三个字，关注点一下子就放到了“链”字上了。链即锁链、链条，像链子一样环环相扣的东西。比如我们数据结构中的链表，当前对象持有下一个对象的地址。同样，设计模式中的责任链也是如此，任务一环套一环，环环相扣。 面试流程分析作为技术人员离职再就业少不了要面试的，那么我们就拿面试流程来细说。假设面试流程分为三步：组长面试，CTO面试，HR终面，一共三面。 不考虑其他任何方面的优化，一个人的面试如何实现？12345678910111213//面试类static class Viewer &#123; public void interview(int level) &#123; if (0 == level) &#123;// 组长面试 // TODO &#125; else if (1 == level) &#123;// CTO面试 // TODO &#125; else if (2 == level) &#123;// HR终面 // TODO &#125; &#125;&#125; 123456789//客户端public static void main(String[] args) &#123; Viewer viewer = new Viewer(); viewer.interview(0); viewer.interview(1); viewer.interview(2);&#125; 从上面实现方式可以看出，面试方法，如果要面试三次，那么客户端要调用三次，面试方法interview中对level判断，不同级别有不同人面试，如果以后增加四面，那么就要修改interview方法。 另外每次的面试 viewer.interview 都在客户端调用，但是按照正常流程组长面试完，如果觉得可以，应该流程传递到CTO哪里了，CTO谈完了觉得技术良好，最后交给HR谈待遇，流程抽象提取后是这样： 这不就是开头说的“链”吗？ 下面看看用链如何实现面试的：先定义一个链接口来控制面试流程： 1234567891011121314151617181920212223public interface Chain &#123; /** * 面试方法 * * @param level */ void interview(); /** * 是否通过 * * @return */ boolean isCross(); /** * 下一个面试官 * * @param chain */ void next(Chain chain);&#125; 然后定义组长Grouper、CTO、HR三个面试官类实现Chain接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778static class Grouper implements Chain &#123; private Chain next = null; @Override public void interview() &#123; // TODO Auto-generated method stub if (isCross() &amp;&amp; next != null) &#123; System.out.println(&quot;组长面试通过&quot;); next.interview(); &#125; &#125; @Override public boolean isCross() &#123; // TODO Auto-generated method stub return true; &#125; @Override public void next(Chain chain) &#123; // TODO Auto-generated method stub this.next = chain; &#125;&#125;static class CTO implements Chain &#123; private Chain next = null; @Override public void interview() &#123; // TODO Auto-generated method stub if (isCross() &amp;&amp; next != null) &#123; System.out.println(&quot;CTO面试通过&quot;); next.interview(); &#125; &#125; @Override public boolean isCross() &#123; // TODO Auto-generated method stub return true; &#125; @Override public void next(Chain chain) &#123; // TODO Auto-generated method stub this.next = chain; &#125;&#125;static class HR implements Chain &#123; private Chain next = null; @Override public void interview() &#123; // TODO Auto-generated method stub System.out.println(&quot;HR面试通过&quot;); if (isCross() &amp;&amp; next != null) &#123; next.interview(); &#125; &#125; @Override public boolean isCross() &#123; // TODO Auto-generated method stub return true; &#125; @Override public void next(Chain chain) &#123; // TODO Auto-generated method stub &#125;&#125; 然后看看客户端调用： 12345678public static void main(String[] args) &#123; Grouper grouper = new Grouper(); CTO cto = new CTO(); HR hr = new HR(); grouper.next(cto); cto.next(hr); grouper.interview();&#125; 通过grouper.next(cto);和cto.next(hr); 设置完链式关系，最后只要通过grouper.interview(); 调用一次面试就可以了。因为grouper最为链首，其中存储了下一个链元素next。只要条件达成（本次面试通过），则自动执行下一个任务，这就是任务链的好处。 可能还有一个疑问：grouper.next(cto); 等流程还是在客户端设置的，这无疑要增加了客户端对底层这些类的认知度。 其实完全可以把这些细节隐藏在底层的。比如我们把流程在Grouper构造方法中设置： 123456public Grouper() &#123; CTO cto = new CTO(); HR hr = new HR(); next(cto); cto.next(hr);&#125; 这时客户端是如此的简洁： 1234public static void main(String[] args) &#123; Grouper grouper = new Grouper(); grouper.interview();&#125; 其实上面的一般方法还有其他的实现方法，但是无疑常见的实现要么耦合性较强，要么需要客户端对底层认知度高。 说了半天，现在来步入主题看看到底什么是责任链 责任链模式 模式出现意图 让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着链传递请求，直到有一个对象处理它或者处理完毕为止。 责任链uml图","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"详解设计模式之建造者模式","slug":"详解设计模式之建造者模式","date":"2017-05-10T04:28:13.000Z","updated":"2017-05-10T07:24:11.000Z","comments":true,"path":"2017/05/10/详解设计模式之建造者模式/","link":"","permalink":"http://yoursite.com/2017/05/10/详解设计模式之建造者模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Android网络框架okhttp执行流程分析","slug":"Android网络框架执行流程分析","date":"2017-05-09T16:58:46.000Z","updated":"2017-05-09T17:10:51.000Z","comments":true,"path":"2017/05/10/Android网络框架执行流程分析/","link":"","permalink":"http://yoursite.com/2017/05/10/Android网络框架执行流程分析/","excerpt":"","text":"说在前面的话Android开发中，网络框架okhttp可以说是越来越风光，Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp，能够被谷歌认可，足见okhttp的强大之处了。既如此还有什么理由不去深入理解下它呢？很惭愧，这么好的东西以前一直处于简单调用，今天有时间把流程看了一下，简单总结了下执行请求时的大概流程作为备忘。 执行流程","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android关于Activity生命周期误解","slug":"Android关于Activity生命周期误解","date":"2017-05-05T03:03:36.000Z","updated":"2017-05-07T06:28:04.000Z","comments":true,"path":"2017/05/05/Android关于Activity生命周期误解/","link":"","permalink":"http://yoursite.com/2017/05/05/Android关于Activity生命周期误解/","excerpt":"","text":"两个Activity A和B，先启动A，通过A打开B，在关闭B，这时候两个Activity的生命周期分别是如何执行的？ 我的答案是： A启动时 A onCreate onStart onResume 点击启动B之后 A onPause onStop, B onCreate onStart onResume B关闭之后 B onPause onStop onDestory ,A onRestart onStart onResume 但是想的太简单了，我以为的并不是我以为的。下面是打印的生命周期执行： 123456789101112131415161705-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onCreate05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume05-05 11:01:33.861 5494-5542/com.example.jenson.myapplication I/OpenGLRenderer: Initialized EGL, version 1.405-05 11:01:46.391 5494-5494/com.example.jenson.myapplication I/MainActivity: onPause05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onCreate05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStart05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onResume05-05 11:01:46.691 5494-5494/com.example.jenson.myapplication I/MainActivity: onStop05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 005-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 105-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/FirstActivity: onPause05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onRestart05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStop05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onDestroy 记住一点：启动一个新Activity，先把自己onPause，然后等新Activity启动成功即onResume后再onStop，关闭当前Activity时，还是先把自己onPause，下一帧的Activity(相对于Activity栈来说)执行恢复onResume，然后自己再执行onStop、onDestory 虽然知道了真相，但是现在还不清楚为什么要这样设计，，有时间还要看看这里的源码，mark下。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android性能优化之UI优化","slug":"Android性能优化之UI优化","date":"2017-05-04T04:00:30.000Z","updated":"2017-05-04T10:23:36.000Z","comments":true,"path":"2017/05/04/Android性能优化之UI优化/","link":"","permalink":"http://yoursite.com/2017/05/04/Android性能优化之UI优化/","excerpt":"","text":"为什么要进行UI优化UI的现实在应用层需要经过测量、布局、绘制三步，每一步都会耗费一定时间，如果UI繁重，导致耗费时间过多造成画面卡顿，造成不好的用户体验。研究显示，0-100ms的延迟会让用户感知到瞬时的卡顿，100-300ms的延迟会让用户感觉迟缓，300-1000ms的延迟让用户感觉“手机卡死了”，1000ms以上的延迟会让用户想要去干别的事情，由此可见有良好的UI优化习惯很重要。 优化到什么程度如今屏幕刷新频率大都是60FPS，就是说每帧绘制只要16ms，即保证你的UI页面在16ms内绘制渲染完成，就会让用户感觉到体验是流畅的，所以我们需要做的就是确保我们的APP页面渲染小于16ms。 如何优化布局优化 减少xml布局层级 Merge的使用 Merge是合并的意思，使用Merge合并子元素和父View，而Merge本身可以被忽略。使用Merge的场合： xml布局中，根元素是FrameLayout时； 自定义View中，父元素尽量是FrameLayout或者LinearLayout； Merge不能乱用： Merge只能用在xml布局根元素； 使用Merge加载一个布局时，必须制定一个ViewGroup作为其父元素，并且设置attachToRoot参数为True（inflate(int,ViewGroup,boolean)）； 不能在ViewStub中使用Merge标签，原因就是ViewStub的inflate方法中没有attachToRoot的设置 合理使用RelativeLayout和LinearLayout RelativeLayout一定程度上可以减少布局层级，但是其对子View测量次数多于LinearLayout。所以综合考虑：如果层级较多情况下，使用RelativeLayout能减少层级的话，优先使用RelativeLayout以便保持界面扁平化；如果层级相同的情况下优先使用LinearLayout，这样能减少子View多次测量。 ViewStub提高加载速度 ViewStub默认不可见不占位置， 如果在特定情况下才显示某些布局，可以使用ViewStub。 显示ViewStub有两种方法：ViewStub.inflate()和ViewStub.setVisibility(View.Visible)； 使用ViewStub注意： Viewstub只能加载一次，之后该对象引用会被置空； Viewstub只能用来加载一个布局文件，而不是某个View Viewstub中不能嵌套Merge include实现view复用 对于在多个页面都会使用的公共布局诸如Title栏或导航栏，提取出来通过使用inlucde引入，这样只需要维护一份代码即可。 避免过度绘制 什么是过度绘制 过度绘制是说屏幕上某一像素在同一帧时间内被绘制多次。在UI布局中如果不可见的部分UI也在进行绘制，这会导致浪费多余的CPU和GPU资源。 引起过度绘制原因 xml布局中控件重叠且都设置了背景或图片 自定义View，onDraw方法中同一区域绘制了多次 如何避免过度绘制 布局优化 移除xml中非必须背景，或根据条件设置 移除window默认背景 按需设置占位背景图 自定义View优化 在自定义 V i e w中可以通过 c a n v a s . c l i p R e c t （ ）来帮助系统识别那些可见的区域 。这个方法可以指定一块矩形区域 ，只有在这个区域内才会被绘制 ，其他的区域会被忽视 。 c a n v a s . c l i p R e c t （ ）可以很好地帮助那些有多组重叠组件的自定义 V i e w来控制显示的区域 。 c l i p R e c t方法还可以帮助节约 C P U与 G P U资源 ，在 c l i p R e c t区域之外的绘制指令都不会被执行 ，那些部分内容在矩形区域内的组件 ，仍然会得到绘制 ，并且可以使用 c a n v a s . q u i c k r e j e c t （ ）来判断是否没和某个矩形相交 ，从而跳过那些非矩形区域内的绘制操作 。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"算法查找之二分查找","slug":"算法查找之二分查找","date":"2017-05-03T14:52:40.000Z","updated":"2017-05-03T16:14:38.000Z","comments":true,"path":"2017/05/03/算法查找之二分查找/","link":"","permalink":"http://yoursite.com/2017/05/03/算法查找之二分查找/","excerpt":"","text":"实现目标查看24是否在数组{ 8，14，24，28，30，31，32 }中， 如果在数组中则返回数组元素下标，否则返回-1 。 数组下标从0开始，查找24时最终返回下标2。 实现分析 说明 二分法前提是数组是有序的； 要查找的数我们称为关键值 阐述实现 在一个有序数组中二分查找一个数，数组长度为n。 1、设置左右下标变量：left，right，初始时left为0，right为n-1。 2、求出中间下标，得到中间数 3、如果中间数等于关键值则直接返回下标， ​ 如果中间数大于关键值则 right为中间下标-1 ​ 如果中间数小于关键值则 left为中间下标+1 4、如果未结束，则重复步骤2和3，重复的前提是不管left和right的值 如何改变，都要保证left&lt;right。 阐述转换通用代码 步骤1：int left=0,right =n-1; 步骤4中说重复2和3步，说明这是一个循环，循环条件是left&lt;right， 所以使用while(left&lt;right) 代码实现1234567891011121314public static int binarySearch(int[] arr, int key) &#123; int left = 0, right = arr.length - 1; while (left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; if (arr[mid] == key) &#123; return mid; &#125; else if (arr[mid] &gt; key) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法排序之交换排序","slug":"算法排序之交换排序","date":"2017-05-03T13:04:13.000Z","updated":"2017-05-03T14:27:27.000Z","comments":true,"path":"2017/05/03/算法排序之交换排序/","link":"","permalink":"http://yoursite.com/2017/05/03/算法排序之交换排序/","excerpt":"","text":"实现目标本例中希望通过交换排序，使得数组最终按非递减顺序排列。 数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 } 数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 } 实现分析 说明 希望数组按非递减顺序排列，我们可以得到两点消息：1、数组中可能会有重复的元素，所以才说是非递减。2、排序后第一个元素是最小值 ，最后一个元素是最大值。 阐述实现 第一轮，第一个元素分别与后面的每个元素比较，如果大于后面的元素则进行交换，把较小值交换到第一个元素位置，本轮结束后的第一个元素就是数组中最小值。 第二轮，由于第一轮的第一个元素已经求出了最小值，所以第二轮从第二个元素开始，与后面的每个元素分别比较，如果大于后面的元素则进行交换，把较小值交换到第二个元素位置，本轮结束后的第二个元素就是数组中倒数第二小的值。 以此类推，进行n-1轮比较，n为数组长度。之所以是n-1轮而不是n轮，是因为第i轮的i个元素要和后面的元素进行比较，如果是n轮，它本身就是最后的元素，不需要比较了。 阐述转换通用代码 交换方法提取： 12345void swap(int[] arr, int i,int j)&#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp ;&#125; 第一轮： 123456int i=0；for(int j=i+1;j&lt;n;j++)&#123; if(arr[i]&gt;arr[j])&#123; swap(arr,i,j); &#125;&#125; 第二轮： 123456int i=1；for(int j=i+1;j&lt;n;j++)&#123; if(arr[i]&gt;arr[j])&#123; swap(arr,i,j); &#125;&#125; 每轮遍历出一个当前未排序中最小值，以此类推，遍历n-1轮： 123for(int i=0;i&lt;n-1;i++)&#123; &#125; ​ 代码实现123456789101112public static void swapSort(int[] arr) &#123; int length = arr.length; for (int i = 0; i &lt; length-1 ; i++) &#123; for (int j = i + 1; j &lt; length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Java字符串压缩去重","slug":"Java字符串压缩去重","date":"2017-05-03T09:42:06.000Z","updated":"2017-05-03T10:04:26.000Z","comments":true,"path":"2017/05/03/Java字符串压缩去重/","link":"","permalink":"http://yoursite.com/2017/05/03/Java字符串压缩去重/","excerpt":"","text":"说在前面的话去一家公司面试，开始就一道笔试题，做对了就继续，做不对就不用往下面了。内容是读取文件内容并压缩内容去重，压缩去重意思是如果内容为ABBCCCCAA压缩后字符串显示为A1B2C3A2。以此类推。其实这道题不难，但是我脑子转悠慢，读取文件和遍历字符做出来了，但是其余的没有做出了，或者说大概思路对了，但是卡在某一个点。总之有点废物就是了。。 我的做法12345678910111213141516171819202122public static String compress(String str)&#123; StringBuffer mystr = new StringBuffer(); //我这里是从0开始的 int count = 0; //而这也是初始为0，这样的设置导致下面判断时候一直 //无所适从，对于何时该给count++， //何时该给mystr.append有点混乱 char last = 0; int length = str.length(); for(int i=0;i&lt;length;i++)&#123; char c = str.charAt(i); if(last!=c)&#123; last = c; count++; mystr.append(last); mystr.append(count); &#125;else&#123; count++; &#125; &#125; return mystr.toString();&#125; 正确地做法 直接使用string做法 1234567891011121314151617181920public String compressBad (String str) &#123; String mystr = &quot; &quot;; int count = 1; char last = str.charAt(0); for (int i = 1; i &lt; str.length(); i++) &#123; if (last == str.charAt(i)) &#123; count++; &#125; else &#123; mystr += last + count; last = str.charAt(i); count = 1; &#125; &#125; return mystr += last + count; &#125; ​ 使用StringBuffer 1234567891011121314151617181920212223242526public static String compressBetter(String str) &#123; StringBuffer mystr = new StringBuffer(); int count = 1; //取出第一个字符作为比较字符 char last = str.charAt(0); for (int i = 1; i &lt; str.length(); i++) &#123; //如果当前字符和之前的字符相同，说明是重复的， //直接在数量值+1； if (last == str.charAt(i)) &#123; count++; &#125; else &#123; //如果不相同，说明开始了一个新的字符， //这时要做的只有两件事： //1、结束上格字符计数并添加字符串， mystr.append(last); mystr.append(count); //2、2、开始新的字符计数 last = str.charAt(i); count = 1; &#125; &#125; //最后一个字符计数并显示 mystr.append(last); mystr.append(count); return mystr.toString();&#125; ​ 感想作为IT从业者，大部分时间都在写业务逻辑，很多基本功已经近乎荒废了，这是非常不可取的。眼光放长远些，我们的技术不应该局限于某一种语言，而应该把重心放在跨语言的那些通用技术。比如：操作系统、算法和数据结构、网络及设计模式重构思想等，这些东西在任何语言中都会用到而且也会是重点。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"hexo网站换电脑后怎么办","slug":"hexo博客换电脑后怎么办","date":"2017-05-02T08:31:28.000Z","updated":"2017-05-02T11:54:47.000Z","comments":true,"path":"2017/05/02/hexo博客换电脑后怎么办/","link":"","permalink":"http://yoursite.com/2017/05/02/hexo博客换电脑后怎么办/","excerpt":"","text":"说在前面的话这两天遇到个问题，在自己的电脑上面搭建的搭建环境发布了几个文章，后来换了个电脑，这个电脑也有环境和几个老的文章，但是我执行了hexo d -g 后，网站中新的文章都被删除了。所以现在的问题是，换电脑后如何保证hexo环境文件的同步。 加入版本控制作为一名开发，实现同步，首先就想到版本控制，而网站又是hexo+github实现的。所以就打算把hexo环境及文章都纳入Git版本控制。 当前项目的master分支中被发布后的静态页面占用，所以要么单独开一个项目，要么新建一个分支，最终采用新建分支办法。 在hexo目录下执行git init初始化 然后git add .把当前目录及子文件都添加到暂存区 然后 git commit -m &quot;message&quot;提交到本地库 最后执行git push origin branch推送到分支中。这样以后发布文章后随时push，在其他电脑中把分支内容pull到本地库即可。","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"Android进程和线程","slug":"Android进程和线程","date":"2017-04-27T12:36:13.000Z","updated":"2017-04-27T12:59:25.000Z","comments":true,"path":"2017/04/27/Android进程和线程/","link":"","permalink":"http://yoursite.com/2017/04/27/Android进程和线程/","excerpt":"","text":"进程一般情况下，进程是应用程序的单元，一个应用对应一个进程同时对应一个主线程。但是通过设置 android:process，可以使原本一个应用中的组件运行在多个进程中。 如果进程名称设置为“:remote”，那么这个进程的名字是包名+设置的名字，以冒号开头的进程属于私有进程，其他应用的组件不能和它跑在一个进程。如果进程名设置是完整的(“非冒号开头”)，则属于全局进程，其他应用可以通过shareUID方式和它共享一个进程。 进程优先级分类根据进程的优先级可以分为五级， 前台进程 用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：​ 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）​ 托管某个 Service，后者绑定到用户正在交互的 Activity​ 托管正在“前台”运行的 Service（服务已调用 startForeground()）​ 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）​ 托管正执行其 onReceive() 方法的 BroadcastReceiver通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。 可见进程 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：​ 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。​ 托管绑定到可见（或前台）Activity 的 Service。可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 服务进程 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 后台进程 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。 空进程 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 线程线程可以看作是一个轻量级的进程，在Android中启动应用时系统会为APP创建一个UI线程，Android UI是非线程安全的。 在Android开发中注意两点： ①不能在UI线程以外的其他线程操作UI，否则异常。 ②不能阻塞UI线程，否则ANR。 当然在某些特殊条件下，非UI线程操作 UI没有报错，参考我的[为什么我在工作线程刷新UI没报错？] 。 Android 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法： Activity.runOnUiThread(Runnable)View.post(Runnable)View.postDelayed(Runnable, long)","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android内存分析工具之MAT详解","slug":"Android内存分析工具之MAT详解","date":"2017-04-27T05:07:09.000Z","updated":"2017-04-27T07:44:03.000Z","comments":true,"path":"2017/04/27/Android内存分析工具之MAT详解/","link":"","permalink":"http://yoursite.com/2017/04/27/Android内存分析工具之MAT详解/","excerpt":"","text":"说在前面的话关于Android内存优化可参见我的另一篇文章[Android性能优化之内存优化]。Android性能优化中内存优化可谓重中之重，而内存泄露又是Android内存优化的重灾区。重灾区就要重拳出击，整治内存泄露，Mat是必备的利器。 关于MatMat，全面Memory Analyzer Tool，Java内存分析工具。注意一点，Mat是由eclipse社区维护，所以如果使用Android studio开发的话，需要单独下载，官方通道。我用的是mac版，后面也会使用mac版来分析。 Mat使用注意：我的测试app包名为：com.example.jenson.myapplication 在eclipse中集成了Mat，可以直接拿来使用，而使用Android studio时。这两个是分开的，所以我们要先导出dump文件。 Android studio导出dump文件打开Android Monitor窗口， 点击圆圈中的按钮，过几秒中会自动生成一个dump文件，然后自动打开如下图的窗口： 在Heap Snapshot下的几个文件就是自动生成的dump文件，但是这不是标准的dump文件，所以需要选择文件右键导出标准dump文件，保存到一个目录下： Mat打开标准dump文件使用Mat，菜单open File选择刚才导出的dump文件，经过分析后回显示如下所示的项目： Mat从多角度提供了内存分析，其中包括Histogram、Dominator Tree、Leak Suspects和Top consumers等。 overview是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在Inspector栏目显示这块区域的相关信息。 Leak Suspectss是一个关于内存泄露猜想的饼图，Problem Suspect 1是泄露猜想的描述。看我这里说的像是字节数组，这么大的数组难不成是图片，要知道图片在内存中就是以字节数组形式存在的。 平常内存分析比较常用的还是Histogram、Dominator Tree。 开始分析内存这里我们使用Histogram进行分析，切换到Histogram页面。这个页面主要有4个列，Class Name、Objects、Shallow Heap和Retained Heap。其中Class Name是全类名，Objects是这个类的对象实例个数。Shallow Heap是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。Retained Heap指当前对象大小和当前对象能直接或间接引用的对象大小的总和。这个栏目是分析重点。 内存分析是分析的整个系统的内存泄露，而我们只要查找我们APP的内存泄露情况。这无疑增加了很多工作，不过幸亏Histogram支持正则表达式查找，在Regex中输入我们的包名进行过滤，直奔和我们APP有关的内存泄露： 过滤后就显示了我们APP相关内存信息，按Retained Heap大小排列下，发现Student和MainActivity这两个类问题比较大。但是MainActivity的Objects数量为1，而Student的为130，看起来Student问题更严重，所以先从Student入手： 首先看下是哪里的引用导致了Student不能被GC回收。 右键使用Merge Shortest Paths to GC Roots显示距GC Root最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。进入结果页查看： 啧啧，原来Student不能被回收竟然就是这个MainActivity搞的鬼，可以看到这个类里面有个students集合里面存放的正式不能回收的Student对象。 看代码： 123456789101112131415static List&lt;Student&gt; students=new ArrayList&lt;&gt;();static final String tag=&quot;MainActivity&quot;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sample_text = (TextView) findViewById(R.id.sample_text); TestNative testNative = new TestNative(); sample_text.setText(testNative.stringFromJNI()); for (int i = 0; i &lt; 10; i++) &#123; Student student = new Student(&quot;jenson&quot; + i, i); students.add(student); &#125;&#125; 原来不能被回收是因为用static修饰了students集合。这导致其生命周期边长，在Activity销毁时，仍然存在。问题找到了，去掉static完成内存泄露修复。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"2016公司清明节坝上草原","slug":"2016公司清明节坝上草原","date":"2017-04-25T09:35:56.000Z","updated":"2017-04-25T10:00:50.000Z","comments":true,"path":"2017/04/25/2016公司清明节坝上草原/","link":"","permalink":"http://yoursite.com/2017/04/25/2016公司清明节坝上草原/","excerpt":"","text":"说在前面的话公司应承了很久的出游终于兑现了。不过讲真公司还是比较抠门，两年一次的出游只有两天时间，其中赶路时间就占了一半。 目的：丰宁坝上草原 人物：公司同事 在草原玩的照片基本没有拍，当天到那就下午三四点。而后又阴天下雨了，基本没有怎么玩，拍的比较多的是行宫和湖边。 上图到了行宫，看到骑兵都忍不住上前合影： 小鱼同志，身高不够，蹦起来够~ 我就刚刚好了。 主任幸福的一家~ 进入行宫大门不久后需要经过的南天门： 回顾行宫大门，白云压顶，壮观~ 这好似是一个古代官员的蒙古包~ 嗯~没错，三贱客哈哈 从小迷宫走出来时，工作人员给的哈达~妥妥的披上。 蓝天白云南天门，怎一个美字了得！ 湿地大门口留念。小鱼、佳姐和李博。 老李的风采，感觉要立地成佛。 小末哥看起来好厉害的样子，这样子回公司会不会挨收拾？ 主任家的公子套上小鱼的衣服。可爱，那么小就那么帅，长大了还了得 远处的白云、草浪","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"2016圆明园荷花节","slug":"2016圆明园荷花节","date":"2017-04-25T09:27:35.000Z","updated":"2017-04-25T09:33:12.000Z","comments":true,"path":"2017/04/25/2016圆明园荷花节/","link":"","permalink":"http://yoursite.com/2017/04/25/2016圆明园荷花节/","excerpt":"","text":"说在前面的话2016年的圆明园荷花节热闹不亚于往年，但是这次拍照片却没有多少可观的。感觉好照片也要讲缘分，比如这次就没有遇到蜻蜓，更没有遇到小孩和猫咪。只能干巴巴的拍荷花。 上图","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"2015圆明园荷花节","slug":"2015圆明园荷花节","date":"2017-04-25T08:15:01.000Z","updated":"2017-04-25T09:17:29.000Z","comments":true,"path":"2017/04/25/2015圆明园荷花节/","link":"","permalink":"http://yoursite.com/2017/04/25/2015圆明园荷花节/","excerpt":"","text":"说在前面的话圆明园每年夏季荷花盛开时都会有荷花节。而我也已经2015、2016两年都去参观了，当然今年也不会例外。每年参观人很多，如果天气比较热，最好早点去，如果去的太晚可能拍不到状态好的荷花。盛开又饱满的荷花一般都距离岸边比较远，最好用长焦拍摄。 直接上图 这个小孩和猫德照片说下：当时是已经拍完荷花在出来的路上，到大门口了，看到路边土坡上有一只猫咪，我个人比较喜欢猫狗，就上前逗了几下，这时一个小孩也上来，好像他也很喜欢的样子，摸着猫咪竟没注意到他左手的雪糕其实已经化了。孩子妈在旁边站着看着。小孩摸着猫咪，猫咪竟也不怕眼生，自顾的舔舐腿毛~~画面好不温馨，赶紧后退几步(镜头最近对焦距离1.2米)拍下这一幕。 再说下这个蜻蜓的图片：这个蜻蜓是在圆明园的黑天鹅区？名字好像忘了，但是那个区确实有个很大的石雕还是金属的天鹅塑像。在那部分水域也有些荷花。拿镜头扫射时发现的蜻蜓正落在荷叶杆上休憩。其实那片区域是有围栏的，不能靠近。幸亏长焦镜头直接拉到最远才看得清。换个角度把荷叶作为背景。咔嚓按下快门~~","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"hexo本地图片发布后不能显示的问题","slug":"hexo本地图片发布后不能显示的问题","date":"2017-04-25T07:16:33.000Z","updated":"2017-04-25T08:18:11.000Z","comments":true,"path":"2017/04/25/hexo本地图片发布后不能显示的问题/","link":"","permalink":"http://yoursite.com/2017/04/25/hexo本地图片发布后不能显示的问题/","excerpt":"","text":"说在前面的话工作好几年，终于花了点时间搞了个自己的网站，基于Hexo+Github+个性域名，玩的不亦乐乎。但是这两天发现个问题比较蛋疼。就是Hexo基于MarkDown文本的。如果在写文章时想加入图片，如果你的图片来自其他网站，那么当你发布后是没有问题的，因为其url就是那个图片网址。但是如果你的图片来自你的本地、这样在你预览时是没有问题的，但是细心看下就会发现，markdown中的本地图片是url地址是本地地址。这样如果你发布文章后，别人肯定是看不到你的图片的。这样体验很不好。最开始的想法就是先在简书发布，发布后图片url都是来自简书网站url，而非本地，这样是没问题的，但是这样自己的网站显示个图片还要依赖简书平台，可能代码写多了，总感觉耦合性太强啊~~所以就在找怎么把两个平台独立开来，而自己网站又能发布图片的方法。 经过查找发现hexo-asset-image插件可以比较好的支持本地图片发布。 开启资源文件支持在hexo目录下的_config.yml配置文件中找到这个配置： 1post_asset_folder: false 把这里的false改为true。开启hexo的媒体文件支持。 安装插件在命令行中，跳转到hexo目录下，执行： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 会自动安装插件，插件会安装到node_moudules目录下， 同时还会自动在hexo目录下package.json中添加一行： 1&quot;hexo-asset-image&quot;: &quot;git+https://github.com/CodeFalling/hexo-asset-image.git&quot;, 说这些就是想告诉你，不用的时候如何卸载：删掉那个文件夹和那一行就行了。 以上执行完毕后，在命令行执行：hexo new “文件”时，会在_post文件夹下同时生成md文件和同名文件夹，这个同名文件夹就是用来放图片的，把你在该文章中需要显示的图片放进去，然后在markdown中选择该目录下的图片使用，这样当md编译生成html文件时，会把图片拷贝到html文件同目录中。最后执行hexo d -g 部署到服务器时，图片也就被部署到服务器中了。 注意：如果直接把图片拖动到markdown编辑器中，其路径可能为绝对路径，需要改下： 修改为相对路径： 结尾上面说了hexo new “名称” ，这样每次同时生成文件和文件夹，当然也可以不使用命令行，直接在_post目录下手动创建md文件和文件夹亦可，手动创建的好处时如果你的文章不需要图片，那么你可以不创建对应的文件夹。","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"Android开发之JNI深入解析","slug":"Android开发之JNI深入解析","date":"2017-04-24T16:55:54.000Z","updated":"2017-04-25T07:17:12.000Z","comments":true,"path":"2017/04/25/Android开发之JNI深入解析/","link":"","permalink":"http://yoursite.com/2017/04/25/Android开发之JNI深入解析/","excerpt":"","text":"说在前面的话 本来是没有打算写JNI的，因为本来是在看Binder机制原理的，但是看着看着就跑偏看到了JNI。。。 通过本章可以了解到这些： jni介绍 为什么要学习jni jni使用流程是怎样的 如何Java调用C 如何C调用Java 了解jni源码和机制 ​ 什么是jni、ndkjni(java native interface)，Java本地接口。在Java中接口就是一套协议标准，同样这里也是如此，jni是一套让Java和C互通有无的一套标准。看到这脑子里应该有个大概情况： ndk,它只是一套开发工具集，如果再给它加个形容词，那就是本地开发工具集，即Native Development Kit。 注意区别ndk和jni，一个是一套软件，一个是套标准。 为什么使用jni 1、效率问题 C和C++效率比Java要高一些，虽然这种差距随着Java性能优化有越来越小的趋势，但是总归还是存在的。 2、安全问题 虽然没有绝对的安全，但是相对来说C语言的反汇编比Java更不容易看懂 3、代码复用 C语言年代久远，有很多现成的库，如果Java需要使用同样的功能，不需要自己从新实现，jni直接调用库即可。 jni步骤流程就像使用Java类要先加载类文件一样，要使用jni，首先要加载类库，然后通过Java层方法调用JNI层方法。调用流程如下： 上面是调用流程，调用的前提是先完成开发，也就是说开发流程是要先完成Java层方法和Native层方法。 基础介绍的差不多了，下面开始进入实际开发部分： Java调用C看看一般开发时Java如何调用CJava层和JNI层之间源码是有对应规律的。 JNI实现文件命名为：Java全类名(下划线作分隔符) JNI实现方法命名为：Java_为前缀+全类名(下划线作分隔符)+方法名 例如，现在Java定义native方法如下： 12345public class TestNative &#123; // Used to load the &apos;native-lib&apos; library on application startup. public native int add(int a,int b); public native String stringFromJNI();&#125; 那么按照规范，jni实现方法名为： 1234Java_com_example_jenson_myapplication_TestNative_add(JNIEnv *env, jobject instance, jint a, jint b) &#123; return a+b;&#125; Java声明方法和jni实现方法都已经实现了，接下来就是调用实现库(.so文件，关于so的编译不在讲): 123static &#123; System.loadLibrary(&quot;native-lib&quot;); &#125; 上面是最普通也是最简单的jni开发流程三步走，但是其中有很多问题没有弄明白，比如JNIENV是什么，Java中参数int为什么变为jint了等等。 学习最好的方法就是看代码，那么我们就看看系统jni使用示例：Log打印系统。 看看Log打印系统Java如何调用C首先我们看下Log.java的源码才好下手。 简单介绍Log.java源码看看Log.i()方法实现： public static int i(String tag, String msg, Throwable tr) { return println_native(LOG_ID_MAIN, INFO, tag, msg + &apos;\\n&apos; + getStackTraceString(tr)); } public static int w(String tag, String msg) { return println_native(LOG_ID_MAIN, WARN, tag, msg); } 可以看出真正的打印是在 println_native 方法中，而这个方法是一个本地方法： 12public static native int println_native(int bufID,int priority, String tag, String msg);public static native boolean isLoggable(String tag, int level); 原来JNI中Java层的实现这么简单，只需要声明一个native修饰的方法，传入必须的参数就行了。 下面研究中心要转移到jni层实现了，源码那么多如何找到jni实现呢？ JNI层源码探究 查找JNI层实现 按照上面说的规范，直接查找Java类Log的全类名。 例如 Log类全类名为android.util.Log，其对应的Native文件名称应该为android_util_Log。我们试下： 果真找到了，下面开始探究源码： JNI源码开扒 我们首先找到Java层println_native方法JNI层的实现，按照上面的命名规范，没有找到 Java_android_util_Log_println_native ，但是却找到了这个方法：android_util_Log_printlnnative ，看来Android系统级的JNI没有遵循规范啊。不过没关系，*只要记住JNI有两种方式：一种是遵守JNI命名规范的日常使用方法，另一种是是这种系统级JNI没有Java前缀就行了* 。不影响我们看代码： 可以看出该方法代码比较少，因为我们是研究JNI，而不是研究Log如何打印，所以方法中对于其他方法调用不再深入研究，但是现在Java声明方法和JNI实现方法都找到了，但是系统式如何把这两个给关联起来的呢？我们继续往下看： ​ Java和JNI双方的方法如何对上眼的 在该文件中有这样一个方法 register_android_util_Log，我们看下实现： 这个方法前面大部分代码给我的第一感觉就是：这么TM和Java的反射好像啊！难道是C++版反射？反正意思就是通过Java的Log类拿到该类的几个变量(C语言中习惯称为域) 看最后一行调用了AndroidRunTime的方法，顾名思义是注册本地方法，其中参数 gMethods 值得一看： 这是一个静态结构体数组，这个比较有意思，看注释可以看出大括弧的三个元素分别是名称、签名和函数指针。而名称恰恰是Java里面声明的本地方法，签名是本地方法的签名，函数指针指向的是Native实现方法。一个数组就把Java方法和Native方法给关联起来了。因为Java支持方法重载，为了确保调用的唯一性，于是就有了方法签名，下面说说方法签名机制： 首先看下签名规则： | Java类型 | 类型签名 || ——- | ——- || boolean | Z || byte | B || char | C || long | J || float | F || double | D || short | S || int | I || 其他类 | L全类名; || 数组 | [元素类型签名 | 注意：方法签名格式分为两部分：参数类型签名+返回值类型签名，类型签名之间没有空格，其中参数类型签名使用()括起来，有多少参数就有多少参数类型签名，格式为： (参数1类型签名参数n类型签名)返回值类型签名 ,注意全类名用”/“分隔。 拿 boolean isLoggable(String tag, int level) 举例来说其方法签名为(Ljava/lang/String;I)Z 。 说完了方法签名规则，我们继续，在android_util_Log文件中有jni方法，所以有了 register_android_util_Log 来注册该文件的jni方法，那么在其他有jni方法的文件中是不是也有类似的register_xxx方法呢？怀着好奇心，打开Parcel看看： 1234567891011121314151617int register_android_os_Parcel(JNIEnv* env)&#123; jclass clazz; clazz = env-&gt;FindClass(kParcelPathName); LOG_FATAL_IF(clazz == NULL, &quot;Unable to find class android.os.Parcel&quot;); gParcelOffsets.clazz = (jclass) env-&gt;NewGlobalRef(clazz); gParcelOffsets.mNativePtr = env-&gt;GetFieldID(clazz, &quot;mNativePtr&quot;, &quot;J&quot;); gParcelOffsets.obtain = env-&gt;GetStaticMethodID(clazz, &quot;obtain&quot;, &quot;()Landroid/os/Parcel;&quot;); gParcelOffsets.recycle = env-&gt;GetMethodID(clazz, &quot;recycle&quot;, &quot;()V&quot;); return AndroidRuntime::registerNativeMethods( env, kParcelPathName, gParcelMethods, NELEM(gParcelMethods));&#125; 看到register_android_os_Parcel 方法证实了我的猜测，所以根据归纳法暂且可以认为系统的涉及jni方法的文件中都会有对应的注册方法而且最终都调用了AndroidRunTime::registerNativeMethods()。 其实registerNativeMethods方法的第二个参数是类文件路径： 1AndroidRuntime::registerNativeMethods(env, &quot;android/util/Log&quot;, gMethods, NELEM(gMethods)); 而mMethods数组中又对应了JNI实现方法和Java方法，通过registerNativeMethods方法调用jniRegisterNativeMethods()然后调用RegisterNatives方法最终告诉了JVM Java类和JNI实现方法的映射关系，这样就完了Java调用C。 ​ Java类型和JNI类型如何对应的 首先看下基本类型的对应关系： | Java类型 | JNI类型 | 字长 || ——- | ——– | —- || boolean | jboolean | 8位 || byte | jbyte | 8位 || char | jchar | 16位 || short | jshort | 16位 || int | jint | 32位 || long | jlong | 64位 || float | jfloat | 32位 || double | jdouble | 64位 || void | void | | 很好奇jboolean这些类型是怎么来的，既然是jni类型就先去jni.h头文件下看看有没有定义： 竟然找到了，本来以为jxx是jni新开发的类型，原来就是对C类型起了一个别名。简单理解就是把Java基本类型的值给到了占用同样字节大小的C类型上。 下面再看看引用类型对应关系： | Java类型 | JNI类型 || —————————————- | —————————————- || java.lang.Class | class || java.lang.String | string || java.lang.Throwable | throwable || Object[]、boolean[]、byte[]、char[]、short[]、int[]、long[]、float[]、double[] | jobjectArray、jbooleanArray、jbyteArray、jcharArray、jshortArray、jintArray、jlongArray、jfloatArray、jdoubleArray || java.lang.Object | jobject | ​ C调用Java上面介绍了Java如何调用C，本节讲下C如何调用Java： C调用Java按流程走也很简单，通过全类名找到类，找到类构造方法，根据构造方法构建对象，根据对象调用变量和方法。OK，我们通过一个示例来讲解下： 示例流程是这样子，我们通过Java方法stringFromJNI调用JNI实现方法，但是在实现方法中并没有直接返回一个字符串，而是该方法中调用了一个Java方法，其实现如下： 123public String callByNative( )&#123; return &quot;callByNative&quot;;&#125; 返回的字符串直接显示在TextView中： 123sample_text = (TextView) findViewById(R.id.sample_text);TestNative testNative = new TestNative();sample_text.setText(testNative.stringFromJNI()); 接下来我们需要自己在stringFromJNI的实现方法中调用Java层的callByNative： 首先通过全类名找到类，通过FindClass方法,参数为全类名： 1jclass clazz = env-&gt;FindClass(&quot;com/example/jenson/myapplication/TestNative&quot;); 然后通过构造方法构建对象，要调用构造方法先找到构造方法的ID： 12jmethodID mid = env-&gt;GetMethodID(clazz,&quot;&lt;init&gt;&quot;,&quot;()V&quot;);jobject obj= env-&gt;NewObject(clazz,mid); 要注意的是：构造方法比较特殊，所以第二个参数的方法名要传”“，第三个参数为方法签名，至于签名规则上面有介绍，根据参数自己填写签名。 创建对象时使用NewObject，需要传入创建对象使用的类及构造方法对应的id。 对象上面已经创建完成，接下来可以调用实例方法callByNative了： 12mid = env-&gt;GetMethodID(clazz,&quot;callByNative&quot;,&quot;()Ljava/lang/String;&quot;);jstring js = (jstring) env-&gt;CallObjectMethod(obj, mid); 注意调用一个方法前要先获取方法ID，然后通过CallMethod方法传入对象和方法ID，达到实例方法调用。 因为callByNative方法返回的是String，所以按照上面说的应该调用CallStringMethod方法，但是jni没有这个方法，所以直接使用了CallObjectMethod，然后强制转换来得到String，比较Object是一切类基类。 最终stringFromJNI实现代码如下： 12345678910111213Java_com_example_jenson_myapplication_TestNative_stringFromJNI(JNIEnv *env, jobject instance) &#123; // 这里通过C调用callByNative方法 jclass clazz = env-&gt;FindClass(&quot;com/example/jenson/myapplication/TestNative&quot;); jmethodID mid = env-&gt;GetMethodID(clazz,&quot;&lt;init&gt;&quot;,&quot;()V&quot;); jobject obj= env-&gt;NewObject(clazz,mid); mid = env-&gt;GetMethodID(clazz,&quot;callByNative&quot;,&quot;()Ljava/lang/String;&quot;); jstring js = (jstring) env-&gt;CallObjectMethod(obj, mid); if (js ==NULL) &#123; js = (jstring) &quot;hello&quot;; &#125; return js;&#125; 看下执行结果，达到了我们的要求： jnienv提供了很多参数实现C调用Java，诸如：GetMethodID、FindClass、GetFieldID，还有静态方法和域：GetStaticMethodID、GetStaticFieldID等，感兴趣的可以去jni.h去研究下。 JNIENV是什么鬼JNI异常处理","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Hexo+GitHub 30分钟拥有属于自己的网站","slug":"30分钟搭建自己的网站","date":"2017-04-23T04:57:00.000Z","updated":"2017-04-23T10:23:58.000Z","comments":true,"path":"2017/04/23/30分钟搭建自己的网站/","link":"","permalink":"http://yoursite.com/2017/04/23/30分钟搭建自己的网站/","excerpt":"","text":"说在前面的话 很多ITer都想拥有一个个人网站，记录自己工作经验和生活。哪怕已经有了简书这样好的一个平台，但是那种情节并没有就此打消。下面给大家分享下我个人网站创建流程及中途遇到的坑，希望对那些想建站却又嫌麻烦的朋友有所帮助。 准备工作在开始前要做好系列准备工作，如环境搭建、GitHub账号注册等。下面分别来看下要做哪些： GitHub官网 账号注册 如果你还没有GitHub账号，请前往官网注册。如果已经注册过，请登录 创建仓库 登录后，点击左上角+号创建仓库：在新的创建页面，写上 yourname.github.io ，然后下方选框勾上(我当时没有勾后来本地文件向git提交时出了点小问题)。yourname最好就是你的GitHub的名字， Git客户端安装 安装 Git可以直接从官网下载 系统版本自行选择。Git安装基本也可以认为一路next点过来，如果你的 on the Desktop没有勾选的话，为了方便可以勾选上 验证 同样为了查看是否正确安装，需要从命令行查看能否正确显示版本信息： 1git --version 如果显示了版本信息，则说明正确安装：1git version 2.12.2.windows.2 配置git 配置Git的user name和email： 12git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的git使用的邮箱&quot; 生成密钥： 使用ssh-keygen -t rsa -C 你的git使用的邮箱 命令生成密钥，输入命令后连续点击好像三四次回车就行，出现的一些设置提示不用管，全部默认就行。执行完成后会生成密钥文件如图： 密钥和GitHub关联 编辑器打开id_rsa.pub复制所有内容。 打开GitHub Setting如图： 找到SSH key，点击new SSH key，把内容粘贴到key文本框中，title随意起，保存，如下图： Node.js 安装 我笔记本是win系统，所以关于Node.js下载：32位下载64位下载如果是其他系统，需要自行去官网下载。关于安装没有什么注意的，反正我是一路next，如图： 验证 安装完成后，可以像JDK一样，使用命令行验证是否正确安装，在cmd命令窗口执行以下： 12node -vnpm -v 如果正确显示了当前版本号，则说明安装成功： 12v4.2.32.14.7 否则，请根据具体异常信息搜索下。 Hexo 安装 在合适地方创建一个文件夹并命名，例如我在 E盘 下创建了hexo文件夹： 通过命令行进入该文件夹目录下： 123C:\\Users\\Jenson&gt;E:E:\\&gt;cd hexoE:\\hexo&gt; 执行 npm命令 安装hexo： 1npm install hexo-cli -g 期间cmd窗口会自动刷出一些信息，可能会有warn不过不要紧。待命令执行完毕，继续执行 1npm install hexo --save 这时又会有信息刷屏，信息滚动完毕，通过 1hexo -v 命令验证是否安装成功。 如果出现了下面字样，说明安装成功了： 初体验 窗口中继续执行 1hexo init 初始化 执行 1npm install 自动安装所需组件，直到完成 执行 1hexo g 执行 1hexo s 启动本地服务，在浏览器地址栏输入 1http://localhost:4000/ 看能否打开本地部署的网站，如果成功打开，恭喜你本地部署完成。 本地hexo关联到GitHub本地网站已经可以打开，接下来要把hexo部署到GitHub上，让别人也能访问。在hexo目录下找到_config.yml文件，按如下格式修改成你的：1234deploy: type: git repo: https://github.com/Jensonss/Jensonss.github.io.git branch: master 修改完成后，执行1hexo d -g 生成部署，这样就会根据刚才的GitHub地址commit到GitHub仓库，首次的话会弹窗让你输入你的GitHub登录的用户名和密码。登录成功后就会自动commit了。此时通过 xxx.github.io 应该是可以访问你的网站了。 个性域名绑定购买域名我的域名是在万网购买的，不过进入网站才发现万网成了阿里云的二级域名，不知道什么时候被阿里云收购了。购买通道猛戳,用淘宝账号直接登录，由于是个人使用所以我选了 .me 类型的，而且13元/首年价格比较便宜，以后续费价格好像是89元/年。 付款时会让选择持有者是个人还是企业，选择个人，然后创建一个个人使用的信息模板，可能由于我的是.me域名，所以没有进行身份证验证也能使用。 域名DNS解析购买后的域名不能直接使用，因为现在只是把域名颁发给你，但是还没有和IP地址绑定，还需要进行DNS解析。在你购买后，可以直接点击域名进入域名控制台，页面长这样： 点击左侧的菜单-云解析DNS，然后再点击你的域名： 进入了新手引导设置： 如果点击设置网站解析，进入的页面只能输入一个IP地址，由于GitHub有2个IP地址要绑定，所以我直接选择了高级设置，点击 添加解析，添加如下三条记录，其中xxx.github.io ，xxx为你得GitHub配置的名称： 注意：CNAME 必须大写这样过几分钟域名就会生效了， 域名绑定上一步DNS解析用到了CNAME ，现在在hexo/source目录下创建一个不带后缀的文件，名为CNAME，内容只填写你购买的域名： 然后执行hexo d -g部署到GitHub上。这样就能通过你的新域名访问你的网站了。 如果只是把hexo部署到GitHub上，半个小时是足够的，但是入果从找网站买域名、DNS解析、绑定。前前后后大概花了近1个小时。可能因为我有强迫症的缘故，填写一些信息时总是要想好久。 话不多说，看看完成后的网站吧：我的站点","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"使用Sublime text编译python3时中文打印异常问题","slug":"使用Sublime text编译python3时中文打印异常问题","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T10:57:08.000Z","comments":true,"path":"2017/04/22/使用Sublime text编译python3时中文打印异常问题/","link":"","permalink":"http://yoursite.com/2017/04/22/使用Sublime text编译python3时中文打印异常问题/","excerpt":"","text":"按照网上的一些方法改了几个地方都是没有效果，就又都给还原回来了。后来发现只要修改先前配置的环境即可1234&#123; &quot;cmd&quot;: [&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin/python3&quot;,&quot;-u&quot;,&quot;$file&quot;], &quot;env&quot;: &#123;&quot;LANG&quot;: &quot;en_US.UTF-8&quot;&#125;&#125; 加上一句env的配置就可以了。什么？不知道去哪里找配置文件了？ 打开Preferences -&gt; Browse Packages -&gt; 会自动打开一个新的窗口-打开user编辑之前的文件保存即可。 mark一下","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"pycharm黄线问题","slug":"pycharm黄线问题","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T10:55:32.000Z","comments":true,"path":"2017/04/22/pycharm黄线问题/","link":"","permalink":"http://yoursite.com/2017/04/22/pycharm黄线问题/","excerpt":"","text":"如下图打开文件时出现很多黄色波浪警告的线条让人眼花缭乱。 打开pycharm的设置然后找到Editor-&gt;Colors &amp; Fonts -&gt; General.在右边找到警告线类型，点击后会自动选中对应的文本提示。图中可以看到weak waring 去掉effects的勾选保存即可。搞定！","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"osx下pip3安装matplotlib时 The following required packages can not be built freetype","slug":"osx下pip3安装matplotlib时The following required packages can not be built freetype","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T11:16:04.000Z","comments":true,"path":"2017/04/22/osx下pip3安装matplotlib时The following required packages can not be built freetype/","link":"","permalink":"http://yoursite.com/2017/04/22/osx下pip3安装matplotlib时The following required packages can not be built freetype/","excerpt":"","text":"‘The following required packages can not be built: * freetype’出现这个提示，乍一看以为没有安装freetype的原因，后来找其安装方法。使用brew install freetype ，有提示already installed。然后又看了很多文章，照着改了很多都没有办法。后来胡乱一通查找看到了这个问答1234I think the other answers are on the right track, but I encountered this same problem and can attest that:brew install pkg-configbrew install freetypepip install matplotlib 上面意思说这哥们遇到过同样的问题，下面的能解决。所以试了下brew install pkg-config然后自动安装了，因为freetype已经提示安装了。最后又安装了一次pip3 install matplotlib成功了","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"osx如何安装Homrbrew","slug":"osx如何安装Homrbrew","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T10:56:12.000Z","comments":true,"path":"2017/04/22/osx如何安装Homrbrew/","link":"","permalink":"http://yoursite.com/2017/04/22/osx如何安装Homrbrew/","excerpt":"","text":"1.homebrew依赖于xcode，所以在终端先执行 xcode-select --install 期间弹窗一直确定即可，根据网络速度不同，可能稍有延迟 2.上一步完成了，终端继续输入ruby -e &quot;$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&quot;直到看到终端中显示install successful字样 3.执行执行brew help看是否有提示","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python入门系列(2):字符串、变量和简单数据类型的上手","slug":"Python入门系列(2) 字符串、变量和简单数据类型的上手","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T12:02:22.000Z","comments":true,"path":"2017/04/22/Python入门系列(2) 字符串、变量和简单数据类型的上手/","link":"","permalink":"http://yoursite.com/2017/04/22/Python入门系列(2) 字符串、变量和简单数据类型的上手/","excerpt":"","text":"说在前面的话java在声明变量时都要先指定数据类型 比如 int a=3 ; Stringt name = “jenson”;但是在python中可以直接使用变量python中的注释使用”#” 字符串的使用 直接声明变量 123print(&quot;jenson&quot;)name =&quot;jenson&quot;print(name) 打印如下 123jensonjenson[Finished in 0.0s] 字符串拼接直接使用+号 123print(&quot;hello jenson&quot;)name = &quot;hello&quot;+ &quot; jenson&quot;print(name) 打印结果一样一样的 123hello jensonhello jenson[Finished in 0.0s] 去除字符串的空白 1234name = &quot; jenson &quot;print(name.lstrip())print(name.rstrip())print(name.strip()) 结果如下 这里去除的空白分别是左边、右边和两边的空白，并不能去除中间空白 字符串的大小写 12345say = &quot;hello jenson&quot;print(say)print(say.upper())print(say.lower())print(say.title()) 结果如下： 12345hello jensonHELLO JENSONhello jensonHello Jenson[Finished in 0.0s] 可见三个函数的作用分别是使字符串大写、小写、单词首字母大写。 基本类型和运算 123456print(3+5)print(10-2)print(2*4)print(16/2)print(2+3*4)print(2**3) 输出如下： 12345678888.0148[Finished in 0.2s] 可以看出python对四则运算支持优先级，注意一下这里的幂用2个乘号表示 基本类型转为字符串基本类型和字符串混合使用时注意把基本类型先转换为字符串，使用str(基本类型值)，否则会引发异常。1234age = 25;print(str(age))say = &quot;I&apos;am &quot;+age print(say) 12345678925Traceback (most recent call last): File &quot;/Users/jenson/Desktop/python_work/str_text.py&quot;, line 15, in &lt;module&gt; say = &quot;I&apos;am &quot;+age TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly[Finished in 0.0s with exit code 1][cmd: [&apos;/Library/Frameworks/Python.framework/Versions/3.5/bin/python3&apos;, &apos;-u&apos;, &apos;/Users/jenson/Desktop/python_work/str_text.py&apos;]][dir: /Users/jenson/Desktop/python_work][path: /usr/bin:/bin:/usr/sbin:/sbin] 第一个print已经打印，第二个却报了异常，因为没有转换。 python2和python3整数除法比较 在python2下做除法运算3/2，得到结果是1 ，并不是1.5 而在python3下是正常的 这是因为python2中计算整数结果时不是采取四舍五入，而是将整数部分直接删除，所以在python2中如果要避免这种情况，要确保至少有一个操作数为浮点数，这样得到的结果也为浮点数 完毕。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python入门系列(1):如何使用Sublime text开发Python","slug":"Python入门系列(1) 如何使用Sublime text开发Python","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T12:01:28.000Z","comments":true,"path":"2017/04/22/Python入门系列(1) 如何使用Sublime text开发Python/","link":"","permalink":"http://yoursite.com/2017/04/22/Python入门系列(1) 如何使用Sublime text开发Python/","excerpt":"","text":"下载并安装Sublime text3点击下载osx版直接安装即可。如果需要其他系统版本请移步这里安装完成，在launcher启动Sublime 配置Python3的编译环境 找到Python3的安装路径终端中输入命令 -a python3 ```123456可以看到结果![屏幕快照 2017-01-06 下午8.37.07.png](http://upload-images.jianshu.io/upload_images/1796052-01e91620f87d697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)复制路径```/Library/Frameworks/Python.framework/Versions/3.5/bin/python3 配置Sublime打开Sublime-&gt;Tools-&gt;build system-&gt;new build system如下图可以看到列表里面已经有了Python编译环境，但这是针对Python2.x的版本的，需要我们手动添加3.x版本。 点击new build system 后的窗口如下图： 将其修改为123&#123;&quot;cmd&quot;: [&quot;之前得到的python3路径&quot;,&quot;-u&quot;,&quot;$file&quot;],&#125; 然后点击save as保存为1234567891011此时再次查看build system列表发现Python3已经出现了，至此Sublime的Python3编译环境已经完成。![屏幕快照 2017-01-06 下午8.51.22.png](http://upload-images.jianshu.io/upload_images/1796052-81e3e153c615759e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)# 开始我们的第一个程序hello Python！- 新建工作目录桌面新建一个名为python_work的文件夹，用来存放python文件- 新建文件使用Sublime--&gt;new file 新建一个空文件保存到刚才创建的python_work中，命名为hello_python.py 。(*这里命名时加了.py后缀是告诉Sublime说我这个文件是python程序，这样在编写时候会给出关键字的颜色标示，并且 编译时候会使用python编译环境*)- 打印hello python print(“hello python!”)``` 编写完代码保存，command+B执行编译 本节完成。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"osx下如何使用SublimeText阅读Android系统源码","slug":"osx下如何使用SublimeText阅读Android系统源码","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T10:50:58.000Z","comments":true,"path":"2017/04/22/osx下如何使用SublimeText阅读Android系统源码/","link":"","permalink":"http://yoursite.com/2017/04/22/osx下如何使用SublimeText阅读Android系统源码/","excerpt":"","text":"以前用win系统时使用sourceinsight阅读源码方便至极，但是自从换到mac下，尝试了很多方法很多工具，比如understand、比如vscode、比如wine下安装sourceinsight。总是有各种问题，所以这次尝试使用SublimeText 平时使用Sublimetext都是打开单个文件，这次要导入几万个文件，这在一些ide中称为project。同样在Sublime中也是如此。 1. 创建工程 Project &gt; Add Folder to Project 选择源码目录即可 这时在\b窗口左边栏中将出现刚刚添加的文件目录，如果还需要添加其他目录，则重复这一操作即可。 2. 保存工程 Project &gt; Save Project As 点击保存后Sublime Text将自动生成两个文件：project_name.sumlime-project：包含工程定义，该文件会被记录到版本控制里。project_name.sublim-workspace：包含了用户的工程数据，例如打开的文件和修改等，该文件不会被记录到版本控制里。 在.sublime-project文件中，你可以定义工程配置。例如你可以定义多个目录路径，或者哪些目录或文件需要排除在外。例如： 以上.sublime-project文件中定义了两个目录，而“name”标签是该目录在Sublime Text的\b左边栏中显示的名字。通过定义“name”，你可以将一些长路径或者名字很长的目录以更简洁的名称显示在\b左边栏中。 3、添加索引 安装Package Control插件1.打开控制台方法1：View-&gt;show console 方法2：ctrl+~ 2.输入代码：python2.x代码: 1import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) python3.x代码： 1import urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 安装CTags 首先 Preference -&gt; Browser Packages… 查看是否已经安装了CTags Package，如果没有则继续下面步骤 Preference -&gt; Package control, 输入“install package”，它会找出你可以安装的插件，在列表中选择ctag插件进行安装 3.创建索引 4、异常处理 期间出现Package Control:There are no packages available for installation弹窗提示选择Preference-&gt;Browser Packages打开文件夹后删除Package Control目录、删除User目录下相关Package Control名称文件等，再次安装。 ctag rebuild时弹窗异常如图： 这是因为我们还没有安装和配置ctags下载ctags-5.8.tar.gz解压并编译，依次执行如下命令：tar xzvf ctags-5.8.tar.gzcd ctags-5.8./configuremakesudo make install打开Preference -&gt;Package settings-&gt;ctags-&gt;settings-user和settings-default把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径/usr/local/bin/ctags（可以通过which ctags命令查看ctags路径） 5、快捷键 修改跳转默认函数跳转：Ctrl+shift+左键; 跳转返回：Ctrl+shift+右键。修改方法：Perference-&gt;Package Settings-&gt;CTags-&gt;Mouse Binding Default-&gt;复制到Mouse Binding User，把里面的”ctrl+shift”，修改为“command”，这样就可以用“command+左键”跳转了： 1234Command+P：查找文件Command+R：查找方法Command+左键：文件或函数跳转 Command+右键：返回文件或函数跳转的原始位置 至此Android源码项目创建完成并创建索引，代码跳转也反应迅速。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"Python入门系列(0):OSX系统下Python3的配置与安装","slug":"Python入门系列(0) OSX系统下Python3的配置与安装","date":"2017-04-22T10:55:54.000Z","updated":"2017-04-22T12:02:46.000Z","comments":true,"path":"2017/04/22/Python入门系列(0) OSX系统下Python3的配置与安装/","link":"","permalink":"http://yoursite.com/2017/04/22/Python入门系列(0) OSX系统下Python3的配置与安装/","excerpt":"","text":"关于Python默认安装的问题在Linux和osx中都默认集成了Python，这时我们要查看集成的版本是不是我们需要的3.x。如果是，那么恭喜你不用往下看了，如果不是请继续。如何查看Python版本呢？打开终端输入如下命令即可：1python --version 可以看到我的系统默认的版本是2.7.10，看来还是需要安装3.x的。咱门继续 Python3下载与安装先附上python3.6下载地址。下载完成直接点击安装即可，一直点击继续或者同意操作，直到出现如下界面： 关闭安装窗口，如果此时已经打开了terminal终端需要重新启动，来使刚才的安装生效(osx下Python安装后不需要配置类似jdk的环境变量)需要注意一点的是 2.x版本使用Python命令，在3.x下需要在后加上3 1python3 --version 查看输出结果，发现已经能识别出3.x版本，至此Python3安装完毕。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Mac版eclipse中每次重启电脑后字体自动变小","slug":"Mac版eclipse中每次重启电脑后字体自动变小","date":"2017-04-22T10:50:50.000Z","updated":"2017-04-22T10:44:28.000Z","comments":true,"path":"2017/04/22/Mac版eclipse中每次重启电脑后字体自动变小/","link":"","permalink":"http://yoursite.com/2017/04/22/Mac版eclipse中每次重启电脑后字体自动变小/","excerpt":"","text":"如题每次开机后打开eclipse时，发现上次调好的字体又变小了。每次都这样，比较影响心情。今天决定把这个问题解决掉。\b网友的做法是：打开 应用程序/Eclipse.app/Contents/Eclipse/eclipse.ini 文件中，把文中“-Dorg.eclipse.swt.internal.carbon.smallFonts”删掉。这样可以避免Eclipse里面的字体奇怪地自动变小。。 发现很久以前就存在这个问题，不过当时的fix方法和最新的不一样。传送通道 但是上面的2方法好像对我来说没有效果(我只试了第一种)。后来在偏好设置里发现Theme为mac时使用的是Reduced Palette这个选项，我好奇的把选项改为了Default。然后点了确认再调整好需要的字体并重启。然后真的没有再恢复小字体了。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"关于家庭网络宽带、路由及上网设备那些事---后续篇","slug":"关于家庭网络宽带、路由及上网设备那些事---后续篇","date":"2017-04-21T14:50:50.000Z","updated":"2017-04-22T10:42:20.000Z","comments":true,"path":"2017/04/21/关于家庭网络宽带、路由及上网设备那些事---后续篇/","link":"","permalink":"http://yoursite.com/2017/04/21/关于家庭网络宽带、路由及上网设备那些事---后续篇/","excerpt":"","text":"上一篇主要写了几点制约网速的可能原因，没有看过上一篇的请移步关于家庭网络宽带、路由及上网设备那些事。这一篇就分别介绍下宽带、路由和用网设备的一些知识。 家庭宽带的那些事网络出了问题都会打客服咨询，但是你知道你家的网络服务商是几级的吗？ ####1.宽带运营商分级 目前宽带运营商一般分为三级即可，三级··立马就邪恶了。一级服运营商是国家、省市、城域骨干网的建设者。主要有联通、电信、移动和广电，以前小的时候就有种说法叫南电信北联通。 电信在一级运营商里算是老前辈了。之所以就叫北联通是因为北方以前上网是通过电话线来拨号的，座机的电话那时候归属网通，后来联通收购了网通。移动以前只有无限上网的业务，宽带业务应该是合并了铁通后才有的，广电应该近些年发展起来的，据说广电是租用电信和自建都有的。二级运营商是租用了一级运营商的网络设备来发展的。如果一级运营商是厂家的话，二级运营商就相当于批发商了。主要有歌华宽带、长城宽带等。二级运营商的优势就是性价比较高和比较优质的售后。三级运营商是写字楼和办公楼这类，背靠房地产开发商和物业提供商发展的。比如有些写字楼只提供某一种宽带，网络 差但又不允许公司拉其他服务商的宽带，着实可恨。 看到这里相信大家对自家的网络提供商有了个大概了解，如果感兴趣请继续： 路由器的那些事先上一张图放松下，你们觉得这张图说明了什么问题？跟风！！中国人跟风习气太严重，一旦发现别人尝到了点甜头，马上就会有一大波人挤破头的往里钻。 1.互联网路由器兴起也是由于跟风，前两年物联网炒的热闹，家中万物互联，有人分析路由器是物联设备走向网络的首个大门，所以就纷纷研发所谓智能路由器。某米、某为、某极和某数字加入战斗，互联网行业经常是老大和老二掐架，老三莫名的死了。这次乱战虽然没有谁阵亡，但是其实用户还是受益的。最起码手机app管理路由器算是普及了不少，查看联网设备和拉黑蹭网设备也方便不少。 2.智能路由器个人觉得现在所谓的智能路由器其实就是互联网路由器后续发展的产物，而且其实在当不起“智能”二字，可能也是如此，所以目前对于智能路由器的定义也就是拥有独立的系统，可以扩展应用插件来实现不同的功能。目前区别路由器是否智能，比较直观的应该是看官方对该型号路由器是否有一个app来支持其手机端操作。 3. 双频路由器上一篇中简单介绍了双频路由器的优点，这里在详细说下：以前的无线路由器中只有一个频段就是2.4G，双频路由器中多了一个5G频段。两个频段是由802.11 工作组划分，每个频段又划分为若干信道2.4 GHz (802.11b/g/n)信道图如下： 有人可能会说中国有13个信道可用，可以的啦。其实每个信道的频宽有22MHz，所以这13个信道有很多重叠的区域，不信你看 这样一看刨去重叠的的那些，只有1、6和11三个信道可以互不影响。下面我们再看看5G: 发现中国地5G有5个信道可以使用，看起来也没有比2.4G的好到哪里，为什么传输速率会快呢?看下图5G信道间距有20MHz相比2.4G的5MHz大很多，如果使用一个信道时，不会受到其他信道的干扰，如果想提升速率，可以把多个信道合并为40MHz或者80MHz。相比之下速度就提升很多了。 所以综合得出结论：2.4G 信道虽然多，但是互不影响的只有三个，加上使用设备多，干扰大，所以传输速率2.4G低于5G但是由于 5G频率高，波长短，所以穿透性2.4G大于5G。举个例子理解下穿透性强弱：假如靠近路由器时都是100%信号，但是穿过一堵墙时，2.4G可能还有80%信号，而5G可能仅剩50%信号，就是说两个频段都能穿墙，但是5G穿墙过程自身损失的更严重，所以常说穿透性弱。 4.\b什么样的路由器才是好路由器？在我看来好的路由器首要因素就是是否稳定。上面说了穿墙后的信号会减弱。日常路由器放客厅，但是我们又不可能随时守在客厅，可能在卧室、可能在厕所、也可能在院子，远距离加穿墙后，信号可能只有一格了，很多路由器这时候网络是很差的，经常QQ和微信就可能提示网络无法连接，但是现在明明还有一格信号啊。这就是我所说的稳定。一个性能稳定的路由器就算信号只有微弱的一格，仍然能保持网络的流畅，这是我认为的好路由器。就这一点恰恰是很多市面路由都不具备的。其他就是参考路由器的性能指标了，如cpu、内存、flash等越大越好，但能耗能也愈大，发热也严重。一般来说家庭百兆宽带最好配上千兆路由，这里的千兆是wlan和lan口也要是千兆的。 用网设备那些事1.用有线网这里只想说一点如果你刚配的主机加上百兆光纤感觉还是网速不达标，那么你可能遇到假网线了。其实网线也是分类的，网线分为五类线、超五类线、六类线、七类线，可以通过网线外皮的Cat.5, Cat.5e,Cat.6等来判断,其中cat.6中间有十字的骨架把网线分开 如果家里是百兆光纤一般用超五类或者六类，当然六类最好，因为抗干扰更强。 2.无线设备暂时没啥想说的了，想起了再更。见谅~","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"关于家庭网络宽带、路由及上网设备那些事","slug":"关于家庭网络宽带、路由及上网设备那些事","date":"2017-04-21T14:40:50.000Z","updated":"2017-04-22T10:39:12.000Z","comments":true,"path":"2017/04/21/关于家庭网络宽带、路由及上网设备那些事/","link":"","permalink":"http://yoursite.com/2017/04/21/关于家庭网络宽带、路由及上网设备那些事/","excerpt":"","text":"看不见摸不着，但又对我们很重要的东西，你们觉得是什么？很多人一定会说是空气，但是肯定还有一部分心里会认为是WIFI~。 以前经常感慨每次回家最先欢迎我的不是别人，正是WIFI(~信号强没办法，一进小区就连接上了)。的确随着宽带的普及，我们的生活也愈来愈离不开网络，不管看电影玩游戏还是查资料。那你到底对它连接多少呢？ 1.你知道网络运营商所说的20M、50M和100M到底是什么意思吗?2.你知道运营商提供的50M和迅雷下载的速度2MB/s有什么区别联系吗？3.你知道为什么升级了宽带，然而下载速度为什么没有提升吗？如果都不清楚，那这篇文章就是为你准备的，请继续。 我们先来看下日常家庭网络图： 一般都是运营商把网线拉到家中，然后插到路由器上，然后通过无线路由功能为多台设备提供上网功能。如果是光纤用户会，则应该是网线接入光猫，再把光猫接入到路由器。看懂了这张图，下面的要讲的内容就很容易理解了。 运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？其实不管是运营商还是路由器厂家标称的xxM其实是Mbps的简称，而Mbps是Million bits per second的缩写，意思就是声称的20M是20兆位/秒。迅雷的下载速度5MB/s又是什么意思？这里的MB是指兆字节/秒要找出带宽和下载的关系要知道一个公式1字节=8比特位 即1Byte=8bit。所以声称的20M带宽实际下载速度为20/8=2.5MB/s，当然这是理论上的最大下载速度，线路的传输是有损耗的，所以一般下载速度会小于该理论值。 为什么升级了宽带，网速还是没有什么明显提升？上面知道了带宽和下载速度的关系，那么路由器带宽和其支持的最大传输速度关系也就明白了吧。哪些号称150M的路由器最大支持传输速率为150/8 =18.75MB/s ，加上路由器厂商的偷工减料，所以一般速率又严重小于18.75这个值(如果你的路由器能达到这个值，那一定是遇到良心厂家了)。假设光纤用户使用100兆时最大下载速度本可以达到12.5MB/s的，然而由于路由器偷工减料仅能达到18.75的一半即9MB/s时，这时你的家庭网络最大速度就只能被路由器所限制。 升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧~先来个问题：马路上能一次同时过5个人，家门口小路一次只能同时走3个人，但是我家大门一次只能同时1人过。那人员流动速率瓶颈在哪就很明显了吧，同样的，宽带、路由器都是网络的媒介，真正使用网络的是我们的手机电脑和平板。假设你的宽带和路由器的最大传输速率都达到了12.5MB/s，但是你的笔记本电脑的网卡还是54Mbps的老网卡o(╯□╰)o，结果可想而知了。 笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？县城的马路和北京的马路差不多宽，为什么北京每天堵车而县城基本不会？因为车少哇。同样的，目前大多数路由器的无线提供的都是2.4G无线，而电磁炉、无线键鼠等也有很多使用2.4G无线。在这个频段的设备多了也就难免发生堵塞。为了缓解堵塞，无线双频路由器也就诞生了，所谓双频就是2.4G和5G。5G频段使用设备少所以数据传输也就更稳定。5G高效的还有一个原因是无干扰信道数量比2.4G的更多。对于游戏玩家和高清影视爱好者，一台双频路由是必须的。但是还有一点要注意：使用5G频段需要路由器和网卡都支持802.11ac才可以。 上面说了这么多都是讲出你的网络中制约网速的瓶颈，至于具体的解决方法不用说了大家也心里有数了吧。","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"详解设计模式之单例模式","slug":"详解设计模式之单例模式","date":"2017-04-21T14:22:50.000Z","updated":"2017-04-22T10:32:30.000Z","comments":true,"path":"2017/04/21/详解设计模式之单例模式/","link":"","permalink":"http://yoursite.com/2017/04/21/详解设计模式之单例模式/","excerpt":"","text":"####1、什么是单例?单例顾名思义就是单个实例。日常工作都是自由的通过构造方法创建对象的，所以听到单例时，我们应该意识到其下是暗含了2层意思的，①构造方法不在为你所用，你不需要知道如何创建对象。②我会给你提供获取实例的方法，不需要你自己动手创建。 不清楚uml类关系的请移步UML–类图详解 ####2、\b什么情况下使用单例?当你需要内存中只有一个对象的时候。 ####3、为什么使用单例？单例保证了内存中数据的唯一性，同时也降低了内存的开销。 ####3、\b如何实现单例？在1中了解到两层含义后，对我们创建单例类是有帮助的，总结下就是：①私有化构造方法 ②对外提供获取实例方法 饿汉式所谓饿汉式，就是在类加载的时候就迫不及待的创建对象，等到调用获取实例方法直接拿到对象返回即可。看实现代码： 12345678910public class HungarySingleton &#123; private static HungarySingleton intance = new HungarySingleton(); private HungarySingleton()&#123; &#125; public static HungarySingleton getInstance()&#123; return intance; &#125;&#125; 懒汉式是最简单的单例模式，在类加载的时候就实例化，避免了多线程问题的同时保证了实例唯一性。缺点是即使不需要时候也会被实例，会占用内存。所以推荐在实例占用内存不多的情况下使用，否则请使用下面几种方式。 懒汉式懒汉式，就是在首次调用的时候才会创建实例，相比饿汉式，延迟了初始化。 12345678910111213public class LayzySingleton &#123; private static LayzySingleton instance = null; private LayzySingleton() &#123; &#125; public LayzySingleton getInstatnce() &#123; if (null == instance) &#123; instance = new LayzySingleton(); &#125; return instance; &#125;&#125; 上面代码有个问题，就是在多线程调用中会有产生多个实例的隐患，所以需要使用线程同步： 12345678910111213public class LayzySingleton &#123; private static LayzySingleton instance = null; private LayzySingleton() &#123; &#125; public synchronized LayzySingleton getInstatnce() &#123; if (null == instance) &#123; instance = new LayzySingleton(); &#125; return instance; &#125;&#125; synchronized的加入虽然解决了多实例的隐患，但是又带来了性能低下的问题，因为我们只需要在首次创建对象时让同步产生作用即可，其后的调用无需同步，现在只要是调用该方法就同步，看来还需要改进下面使用双重校验加锁(DCL)： 1234567891011121314151617public class LayzySingleton &#123; private static LayzySingleton instance = null; private LayzySingleton() &#123; &#125; public LayzySingleton getInstatnce() &#123; if (null == instance) &#123; synchronized(LayzySingleton.class)&#123; if (null == instance) &#123; instance = new LayzySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 现在多线程问题解决了，性能也得到优化了是不是双重校验加锁就完美了呢？NO~在Java并发编程中的指令重排序中有讲到双重校验加锁失效问题。要禁止指令重排序需要使用volatile修饰变量 1private volatile static LayzySingleton instance = null; 静态内部类如果觉得饿汉式占内存，懒汉式又要考虑多线程问题，那么可以使用静态内部类可能是你想要的： 123456789101112public class Singleton &#123; private Singleton()&#123; &#125; public Singleton getInstance()&#123; return Holder.instance; &#125; private class Holder&#123; private static final Singleton instance = new Singleton(); &#125;&#125; 静态内部类避免了加载Singleton类时就初始化问题，只有在调用getInstance时才会致使Holder类被加载并初始化，同时也避免了线程安全问题和性能问题，推荐使用此方法。 枚举式如果觉得上面的还是麻烦，可以使用枚举单例，代码实现： 1234567891011public enum EnumSingleton &#123; INSTANCE ; int num = 33; String config = &quot;jenson&quot;; public void doSomething()&#123; &#125;&#125; 枚举单例也可以有属性可以有方法，重要的是枚举默认就是线程安全的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"详解设计模式之简单工厂模式","slug":"详解设计模式之简单工厂模式","date":"2017-04-21T14:22:50.000Z","updated":"2017-04-22T10:34:14.000Z","comments":true,"path":"2017/04/21/详解设计模式之简单工厂模式/","link":"","permalink":"http://yoursite.com/2017/04/21/详解设计模式之简单工厂模式/","excerpt":"","text":"####1、什么是简单工厂模式？把一些相关类的对象的创建封装在另一个类中，这样在上层的客户端不需要明白相关类对象是如何创建的，只需要调用另一个类的相关方法获取实例即可。另一个类就是所说的工厂类。为了避免每次使用工厂时都创建工厂实例，获取相关类实例的方法一般使用静态方法，所以简单工厂一般也叫静态工厂。 ####2、\b什么时候使用工厂模式？当你要对上层隐藏一些对象从而达到解耦的效果时可以使用简单工厂。 ####3、\b如何使用工厂模式？ 先看下不使用模式如何创建接口实例 汽车接口代码：123public interface CarApi &#123; public void run();&#125; 起亚汽车实现代码： 123456789public class KiaImpl implements CarApi &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;起亚跑起来&quot;); &#125;&#125; 客户端代码： 123456789101112public class Client &#123; public static void main(String[] args) &#123; CarApi carApi = new KiaImpl(); carApi.run(); &#125;&#125;``` 如上，不使用模式的时候，客户端不仅依赖接口，更知道了接口的实现类是KiaImpl。要知道Java面向接口编程就是为了封装隔离，达到解耦模块的目的。这里虽然使用了接口，但是充其量只用到了其多态，至于封装隔离还是没影的事儿。- 看下使用简单工厂是如何实现的![使用模式.png](http://upload-images.jianshu.io/upload_images/1796052-cc51abbba4547d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)汽车接口和起亚实现代码如上不变，宝马实现代码如下： public class BmwImpl implements CarApi { @Override public void run() { // TODO Auto-generated method stub System.out.println(&quot;宝马跑起来&quot;); } }1汽车工厂代码如下： public class CarFactory { public static CarApi getCar(int type) { CarApi car; if (type == 0) { car = new KiaImpl(); } else { car = new BmwImpl(); } return car; }}1客户端代码如下： public class Client { public static void main(String[] args) {// CarApi carApi = new KiaImpl();// carApi.run(); CarApi kia = CarFactory.getCar(0); kia.run(); CarApi bmw = CarFactory.getCar(1); bmw.run(); }}``` 通过客户端代码可知，把实现类封装在工厂后，客户端只需要调用工厂静态方法就能拿到实现类实例，而不需要知道这些实现类是如何创建实现的，达到了解耦的目的。 有一点要注意：如果接口有多个实现类，在工厂中如何确定想要获取哪个实例？这时就要在静态方法中传入参数，这时客户端就要知道参数类型代表的意思。所以此时底层要向上层暴露一些信息以供使用。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"UML--类图详解","slug":"UML--类图详解","date":"2017-04-21T13:22:50.000Z","updated":"2017-05-10T09:25:33.000Z","comments":true,"path":"2017/04/21/UML--类图详解/","link":"","permalink":"http://yoursite.com/2017/04/21/UML--类图详解/","excerpt":"","text":"类图是面向对象系统建模中很常用也很重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口间关系的一种模型。类之间的关系主要有泛化、实现、聚合、组合、依赖、关联6种关系。 泛化关系(generalization)uml中的泛化关系也就是继承关系。继承关系的2个类可以使用 is-a来表示。继承关系使用实线空心箭头来表示，箭头从子类指向父类。 PS：泛化关系中的父类为非抽象类,泛化关系为面向对象中耦合度最大的一种关系 实现关系(Realization)实现关系使用空心三角箭头的虚线表示，箭头从实现类指向接口。 不知道为什么在我的osx版的startuml中实现关系只是一条线，不晓得是不是bug 聚合关系(Aggregation)聚合关系表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,如果没有了整体,局部仍然可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形的实线表示，菱形从局部指向整体。 组合关系(Composition)组合关系表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了。在类图使用实心菱形的实线表示，菱形从局部指向整体。 依赖关系(Dependency)依赖关系是对象关系最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。 关联关系(Association)关联关系是对象之间一种引用关系，比如吃饭时\b客户与餐具类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。 聚合和组合如何区别？直白点的理解就是聚合关系的两个类，局部类的生命周期不受整体类的影响，能够剥离整体单独存在。而组合关系的两个类，局部类的生命周期受限于整体类，整体类不存在时，局部类也将消亡。举个栗子：学生去学校上学被分配到x年级：其中学生和学校属于聚合关系，学生可以脱离学校独立存在，县里学校不好可以去市里学校。而学校和班级是组合关系，就是说班级存在的前提是要有个学校。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Android性能优化之耗电优化","slug":"Android性能优化之耗电优化","date":"2017-04-21T12:55:54.000Z","updated":"2017-04-22T10:24:00.000Z","comments":true,"path":"2017/04/21/Android性能优化之耗电优化/","link":"","permalink":"http://yoursite.com/2017/04/21/Android性能优化之耗电优化/","excerpt":"","text":"作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。 ####1、为什么耗电 通过上图先把用户-电量这一流程抽象出来，设备的耗电根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。用户对app频繁使用说明了你用户黏性做的好，我们不能左右，所以我们要在app对硬件调用上做优化来达到节省电量的目的。 先看下移动设备元件耗电大户有哪些： ####2、屏幕屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。 在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。 LCD概述LCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。 LED概述LED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。 优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。 ####3、无线网络无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。 移动网络移动网络数据传输有3种状态：Full power：高功率状态，网络激活，允许设备以最大传输速率进行传输。Low power：低功率状态，传输速率低于15kbps，耗电是Full Power状态的一半，一般不能直接从程序中进入该状态，而是由Full Power状态降级进入。Standby：\b空闲状态，没有数据连接需要传输，耗电最少。 这三种状态有一个转换流程： 可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态需要2s，从低功率状态转换到高功率状态需要1.5s。应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。 WIFI网络WIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。当从低(高)功率状态传输数据时，WIFI会暂时进入相应地低(高)传输状态，一旦数据传输完毕就回到初始状态。 WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。 通过上面了解网络连接过程，应该心里有了大概的优化建议。 网络优化方案： 减少网络高功率保持时间： - 1.文本和文件压缩传输。 不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样是无线所处的高功率状态时间更短，从而减少了耗电。 - 2.精简文本文件。所谓精简就是去掉文本中空行、空格、注释等无意义内容。 1234567&lt;html&gt; &lt;title&gt; A Sample Page&lt;/title&gt; &lt;body&gt; with some sample text &lt;--do more here--&gt; &lt;/body&gt; &lt;/html&gt; 精简后 1&lt;html&gt; &lt;title&gt; A Sample Page&lt;/title&gt; &lt;body&gt; with some sample text &lt;--do more here--&gt; &lt;/body&gt; &lt;/html&gt; - 3.根据显示大小从服务器获取图片 ①请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。也可以使用Android端使用Bitmap.Option自行获取缩放的图片②使用webp图片。 减少网络请求次数 - 1.使用缓存。 把经常使用的文件缓存到本地，如头像icon、好友信息等。以后很多时间都可以直接从本地读取缓存减少网络请求次数。 - 2.移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，从而减少频繁间隔请求导致状态转换消耗更多电量。 ####4、CPU cpu利用率高和cpu的频率高没有必然关系，这取决于cpu调频策略。高利用率和高频率的cpu都会导致高耗电。 浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，例如使用位移代替除法。 避免wakelock不正确使用wakelock可以唤醒设备也可以阻止设备休眠。在PowerManager类中谷歌已经声明了：这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。wankelock有几种类型，在使用时注意选择正确地类型。 使用JobScheduler很多时候为了满足我们的需求而没有考虑cpu的感受，为了执行1s中的数据区唤醒cpu，但实际却消耗了约两分钟的电量。为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。耗电大德任务，如备份在充电时执行。 Doze模式 Doze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。但是为了不影响应用正常工作，系统还会周期性退出Doze，在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。 ####5、其他优化 传感器每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。 后面的章节会写一些关于电量检测分析工具的使用。 为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"如何知道下载好的aosp版本？","slug":"如何知道下载好的aosp版本","date":"2017-04-21T12:55:54.000Z","updated":"2017-04-22T10:00:58.000Z","comments":true,"path":"2017/04/21/如何知道下载好的aosp版本/","link":"","permalink":"http://yoursite.com/2017/04/21/如何知道下载好的aosp版本/","excerpt":"","text":"下载源码时执行的是 1repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest 没有写上分支然后就直接同步了，下载完了不知道版本是多少。在 1234找到 build/make/core/version_defaults.mk文件打开搜索 PLATFORM_SDK_VERSION找到了 PLATFORM_SDK_VERSION := 25sdk版本知道了晓得原来是最新的7.1","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android性能优化之内存优化","slug":"Android性能优化之内存优化","date":"2017-04-21T12:55:54.000Z","updated":"2017-04-22T12:23:06.000Z","comments":true,"path":"2017/04/21/Android性能优化之内存优化/","link":"","permalink":"http://yoursite.com/2017/04/21/Android性能优化之内存优化/","excerpt":"","text":"上一章讲了Android性能优化之耗电优化 ，感兴趣的可以看下。这一章来说说Android内存方面如何优化，虽说是讲内存优化但是并不涉及虚拟机底层原理，力求通俗易懂。 养成好习惯先上图。内存从状态上来说只有已使用和未使用两种。本章内存优化也从这两方面下手：已使用的内存如何保证虚拟机的顺利回收、未使用的内存如何在满足需求的情况下尽量小的申请。 如何保证已使用内存顺利被回收？ Java对象生命周期 创建阶段申请内存空间，构造对象并初始化相关属性值 使用阶段根据对象应用调用相关方法完成业务逻辑。对象至少被一个强引用持有，除非对象创建时显示声明使用软引用、弱引用和虚引用。 不可见阶段当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，当然对象还是存在着的。 不可达阶段对象处于不可达阶段是指该对象不再被任何强引用所持有。GC会发现对象已不可达 收集阶段当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。 终结阶段当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段，等待垃圾回收器对该对象空间进行回收。 对象空间重新分配阶段若垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，则该对象彻底消失，这个阶段称之为“对象空间重新分配阶段”。 以上是Java对象生命周期的简要介绍，要保证内存顺利回收，正确使用Java对象生命周期很重要，如果不能及时回收，我们就称之为“发生了内存泄露”。 在不可见阶段，程序本身不再持有对象强引用，但对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。 图中灰色的孤立无援的对象对于GC Roots来说不可达，会被回收。知道了内存泄露会影响回收，下面说下哪些方面会导致内存泄露 引起内存泄露的情况 资源没有适时关闭sqlite的cursor、读写文件使用的File文件流等在使用完后没有及时关闭。虽然cursor会在系统回收时自动关闭，但是这样效率较低。对于资源对象使用还是应该养成良好习惯，使用完毕close并置空。 注册对象未注销在Android中主要是指注册的广播在Activity销毁时反注销。在Activity中如果有使用的观察者模式在生命周期发生变化时根据需求注销。在Activity中使用的各类传感器(光线、重力等)在页面销毁时及时注销，否则不光导致内存泄露还会因为传感器频繁的采样导致耗电及cpu的占用。 使用static修饰变量这里只说一点，被static修饰的变量可以认为是直接被GC Roots引用了，那你就知道其生命周期有多长了。这时候你如果用static 修饰Bitmap、View、Context和Activity等后果有多严重了吧。 非静态内部类的静态实例 先看几行代码： 12345678910111213public class MainActivity extends AppCompatActivity &#123;public static People people; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); people = new People(); &#125; class People&#123; int age ; String name ; &#125;&#125; 非静态内部类People持有外部类即当前Activity的引用，而该非静态内部类实例又是static修饰 的，导致Activity一直被持有而不得释放，最终导致Activity所包含的view不能释放，如果view tree中包含多图片，那泄露的内存是很大的。 Handler 众所周知handler用来发送和处理消息回调的。handler导致泄露主要是handler实例是作为非静态匿名内部类方式创建，并且MessageQueue队列中有未处理消息，这时如果退出Activity，MessageQueue中还有Message，而Message持有handler实例，handler实例作为非静态内部类持有Activity引用，最终的连锁反应导致Activity泄露。 handler引起的内存泄露一般是临时性的，因为消息队列里的Message在延时到时间或者某一情况激活后还是会执行的，除非你是故意搞事情。创建handler时最好使用静态内部类，同时在Activity退出时执行 handler.removeCallbacksAndMessages(null);清空队列消息 Webview webview的使用总是会莫名的出现各种问题或泄露。最好的办法就是把web页面放在一个独立的进程，如果需要交互使用aidl。 容器中的对象未清理对象 Android中使用的容器最多的就是List和Map。用来存储对象集合，如果对象集合和页面相关，那么在退出页面时注意清空集合。同时不要使用static修饰集合。 如何尽量小的申请内存？上面说完了如何保证GC顺利回收，现在来讲讲要最小使用内存应该怎么做： 慎用自动封装 来几行代码尝尝： 1234Integer num=0;for (int i=0;i&lt;100;i++) &#123; num+=i;&#125; Java基本数据类型是有自动装箱机制的。每次执行循环都会发生一次装箱操作创建一个Integer对象，造成内存消耗。包括其他基本数据类型都有可能造成这种情况。 内存复用 视图复用 在ListView中使用ViewHolder复用item组件，一方面节省内存，一方面提高滑动流畅性。都用过不多介绍。 使用对象池 看过Handler、Looper、Message、MessageQueue这一套消息循环源码的同志应该知道里面的Message使用了对象池模式。 对象池类似线程池， 首先初始化一个固定大小池子，每次创建对象时候先去池子中找有没有，如果有直接取出，如果没有new出来使用后还到池子里。这样便可达到对象复用的目的。对象池模式适用于那些频繁使用创建的对象，比如一个聊天app，里面对象最多的恐怕就是聊天信息(每条聊天信息对应一个信息对象)。都知道对象的创建是很耗费时间和内存的，没事不要new着玩。如果每条消息都创建一个对象，那可想而知该APP的性能。 对象池的使用也很简单，少量代码即可完成： 1234567891011121314public class People &#123; private static final Pools.SynchronizedPool&lt;People&gt; sPool = new Pools.SynchronizedPool&lt;People&gt;( 20);//需要维持对象的数量 int age; String name; public static People obtain() &#123; People instance = sPool.acquire(); return (instance != null) ? instance : new People(); &#125; public void recycle() &#123; sPool.release(this); &#125; &#125; &gt;注意：对象申请(obtain)和释放(recycle)成对出现，使用一个对象后一定要释放还给对象池。 - Bitmap复用 如果设置了options.inBitmap属性，以后再使用带有该options参数的decode方法加载图片资源时 ，decode会尝试重用已存在的位图内存，这样节省了加载和分配的时间，同时也节省了内存空间 &gt;该属性从3.0开始引进，低版本不支持inBitmap，4.4系统之前只能重用大小相同的内存区域，4.4以后可以重用任何比所需内存小的区域。具体使用可参考[官网](https://developer.android.com/topic/performance/graphics/manage-memory.html)。 纯色规则形状背景用Color Res代替图片 经常遇到一些按钮背景是纯色显示，比如选中状态背景变为纯灰，但是设计已经发来了切图用还是不用？大声say NO！如果背景使用图片来显示，那背景每个像素都要绘制。 假设一个分辨率为100x100的图片，占用4通道。那该图片内存占用就是100x100x4 =4万Byte≈40KB；但是如果使用123456789101112131415161718- 选择合适数据类型 - 使用ArrayMap替换HashMap 先看一下HashMap模型和ArrayMap模型：![hashmap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-3e3049cb811341c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![arraymap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-0d979501c5d1358f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt;HashMap是一个散列链表，稀疏阵列导致内存稍大，而ArrayMap提供了和HashMap一样的功能，但是避免了内存过度开销。在执行插入或删除操作时，从性能上看ArrayMap比HashMap稍差，但是如果对象数很小，比如1000以内不用担心性能问题。如果想深入了解这2个的原理请自行搜索，这里不过多阐述。 - 枚举替身来了 JDK1.5就支持了枚举类型，使用Enum关键字定义。使用枚举类型很多时候出于参数类型安全迫不得已作出的选择。 public String getValue(int type){ switch (type) { case 1: break; case 2: break; case 3: break; default: throw new IllegalArgumentException(&quot;不合法参数&quot;); } return “”;} 1234 试想一下如果一个函数的参数为int type，函数处理时只用到了1，2，3三种值，如果是其他值就抛出异常，这无疑增加了程序的不稳定性，按以前此时最好的解决办法就是参数改为枚举类型，增加了限定也就提高了稳定性。但是枚举类型就是一把双刃剑，增加安全同时也大大增加了内存占用,尤其是在移动设备上，资源有限更应该注意内存节省。谷歌或许考虑到了这些问题，在提供的注解包里添加了注解方式检查类型安全，目前支持int和String两种，看下使用方式： //1、先声明需要的类型常量值public static final int TYPE_1 = 1;public static final int TYPE_2 = 2;//2、创建注解接口同时把上一步声明的常量囊括到这里@IntDef({TYPE_1,TYPE_2})@Retention(RetentionPolicy.SOURCE)public @interface _TYPE{ }//3、在函数参数中增加 注解接口名称public String getValue(@_TYPE int type){ switch (type) { case 1: break; case 2: break; } return &quot;&quot;; }``` 经过上面的步骤，再调用getValue()函数时如果传入其他int则报错编译不通过，这样通过注解就增加了安全性： 结语：基本上APP大部分内存还是被图片占用，处理好图片尤为重要，但是关于图片三级缓存及缩放，目前都使用第三方框架如ImageLoader，所以这里一笔带过。以上就是日常内存优化需要注意的地方，自己做个总结，也希望能对各位看官有所帮助。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android源码下载","slug":"Android源码下载","date":"2017-04-21T12:55:54.000Z","updated":"2017-04-22T11:48:00.000Z","comments":true,"path":"2017/04/21/Android源码下载/","link":"","permalink":"http://yoursite.com/2017/04/21/Android源码下载/","excerpt":"","text":"说在前面的话win系统的笔记本过年回来就没有带回北京。最近打算看看Android源码，所以需要在mac中从新下载。 从官网下载下载Android源码首先想到的就是官网按照指示要先安装repo。但是在执行1curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo 时候就出现异常 12345curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:01:14 --:--:-- 0curl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out 搜索了下异常发现很早就有这个问题，比如这里但是好像没什么好的解决方法。网传有其他地址可以使用，但是没有继续浪费时间了，不能一条路走到黑。 使用国内资源国外太麻烦，毕竟只是想看源码，不想在下载方面浪费太多精力。所以把想法转战到国内的源上。分享2个源，科大源和清大源其中我选择使用的是科大源，打开页面看到初始同步有两个方法，方法1毕竟简单，下载一个打好的包，自己repo sync。方法2还是要下载repo，而且如果中途断掉还要从头下载，所以果断选了方法1，直接使用迅雷下载tar包还是很快的。不到一个小时下载完成，解压后打开aosp文件夹发现没有文件，因为是.开头的，都是隐藏文件，显示后如图：执行1/Users/jenson/Downloads/aosp/.repo/repo/repo sync 同步 如何修改已经init的repo如果想下载其他版本的源码，但是repo已经初始化过，如果再次执行repo init xxx会提示 :123Your identity is: jenson &lt;xxx@foxmail.com&gt;If you want to change this, please re-run &apos;repo init&apos; with --config-namerepo has been initialized in /Users/jenson/Downloads/aosp 上面意思是如果要修改init，需要重新运行repo init +新的url +config这时会自动修改配置并初始化: 1/Users/jenson/Downloads/aosp/.repo/repo/repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r58 --config","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"番茄工作法使用说明书","slug":"番茄工作法使用说明书","date":"2017-04-21T12:55:54.000Z","updated":"2017-04-22T12:17:14.000Z","comments":true,"path":"2017/04/21/番茄工作法使用说明书/","link":"","permalink":"http://yoursite.com/2017/04/21/番茄工作法使用说明书/","excerpt":"","text":"今天花了点时间把番茄工作法这本书看完了，和以前上学时45分钟每节课的感觉差不多，只是这个时间更短，流程也更细化，容易让人集中注意力。 先来几个问题看看中刀的人有多少：1.有拖延症，上午的工作要拖到下午，下午的工作要拖到明天或者有反正周六要加班，那就周五多玩玩，刷刷微博这样的思想。2.经常我们想看一本书，看了一点后就厌烦抛诸脑后，等过一段时间兴致又来了想继续读，发现前面的内容已经忘了不得已要从头开始，如此往复，一年到头一本书还在原地徘徊，年终总结时才悔恨不已。3.上班就开始干活，但是手头的事情刚干了一点，又一摊新的工作挤进来，然后倒手又去忙新的事情，经常下班了感觉忙了一天却没有一件拿得出手的已完成的活来交差。如果你有上面的一种或者几种那么番茄工作法适合你。 番茄工作法的历史番茄工作法是由弗朗西斯科·西里洛在1992年创建的，但其实在更早的时候西里洛就已经使用了。20世纪80年代西里洛还在大学时，由于学习效率低下作业完不成，就在想怎么让自己踏实的学一会，哪怕十分钟也行。如果有人监督帮忙掐表，会不会很好，后来西里洛找到了厨房定时器，形状酷似番茄，就这样他邂逅了番茄钟。 什么是番茄工作法？简单的说就是列出要做的事，标记当天要完成的，设置闹钟为25分钟，然后从第一件事情开始做。还要有每日回顾、每日承诺、中断和预估等。 1番茄工作法是一套简单的流程，它可以让我们提高时间观念、提升注意力、加强自我决策意识、改善目前不好的工作流程从而提高工作效率，当然这一切好处的前提是正确并长期的执行了番茄法。 番茄工作法需要哪些工具？一个番茄钟铅笔/橡皮三张表格(活动清单、今日待办、记录) 番茄工作法流程详解将近期要完成的活动/任务加入到活动清单把近几天准备工作的内容填写到活动清单中，活动清单内容力求简洁，不要求别人看懂，只需要自己几个月后仍能看懂即可。如果某件事明确了必须在某时间之前完成，则可以在活动末尾加上最后期限作为提醒。 从活动清单中选择今日要完成的几项抄入到今日待办中今日待办的任务一定是要从活动清单抄入过来的，如果是自己又单独创建的那活动清单有何意义？填写今日待办时要注意划分优先级(事情的重要程度)，然后给每个待办预估需要多少番茄钟来完成，在待办后面用方格表示出来。 1从开始的活动清单列举，到今日待办的筛选，有没有觉得原本杂乱无章的事情，现在有了头绪而且当天\b目标已经明确只需要放手去做了。无形中注意力已经转移到所选活动了。 准备好工作后，启动番茄钟时间设定为25分钟。注意每个番茄钟都是原子性的，即不能再分割，一旦番茄钟启动，25分钟必须从一而终。可能有人会有疑问：如果番茄钟期间渴了怎么办？有人打电话或者有同事来询问怎么办？别急，这些都是中断，参见步骤4。 开始工作，直到番茄钟响铃结束工作期间可能会受到中断，在日常工作中，中断是不可完全避免的，需要自己处理好中断。中断有两种形式：内部中断和外部中断。是自己造成的，是直觉向大脑发出信号，告诉我让我去专注当下活动以外的事情。```123456比如工作了一会，突然想打开qq去群里扯皮几句，想起有个电话没有回复，水杯没水了要去续杯等，这些都是来自自身内部的本能，其实是想拖延，这时该怎么办？接受、记录然后继续番茄钟。首先看引起中断原因，如果是突然想起没有做的事情，那么可以在今日待办(如果想起的事情不紧急可以直接加入到活动清单中，并在左边加一个“U”表示计划外事件“unplanned”)下方添加一个“计划外紧急”栏目，记录中断原因(下图中的③)，并在今日待办的当前活动后面添加一个 撇号 &apos; (下图中的①)，表示当下活动产生一个内部中断，记录完成继续番茄钟。 至于说要聊天扯皮和续杯，等到番茄钟结束后再去，当然如果只是喝水那你想喝多少喝多少。如果作为初学者感觉内部中断太多，可以尝试缩小番茄钟为5、10、15分钟。当然番茄钟的每次更改至少要保持两个星期再次更改。```外部中断 是别人造成的，有人向你询问请你帮忙，等你答复，外部中断往往具有互动性。但是我们不能因为保护番茄钟就拒绝帮忙同事，毕竟低头不见抬头见的。 可以在番茄钟期间手机、邮件静音，同事来面谈，如果比较急可以商量稍后推迟下，用下一个番茄钟来解决中断事件，而不是在当前活动直接中断处理；如果不着急可以添加到计划外事件，同时在当前活动后添加一个减号 -(下图中的②)，表示受到一次外部中断；如果非常着急，那么不得已只有废弃当前的番茄钟，先帮同事解决问题，过后休息一会然后开启新的番茄钟开始专注起来。 每个番茄钟结束都要在今日待办的当下活动方格中画×。如果当下活动已经完成则可以给活动内容划一条横线表示完成状态(下图中的③)。 休息小休时间一般为3-5分钟，每隔4个番茄钟就大休一次，大休一般15-30分钟。注意休息期间要站起来走动一下，让自己能消除对上一个番茄钟的思考，完全抽身出来放松下。可以泡杯茶或咖啡，去个厕所，窗台发呆等，总之拒绝任何用脑的活动。以下说明了休息时箭头所指从最佳到最差休息方式： 开始下一个番茄钟，重复3-5步下班前记录记录什么内容？记录当天完成的番茄钟数、被打断数、今日待办完成数等，通过记录可以知晓自己承诺完成了多少，相差多少，如果差距很大，就要寻找原因。经过一段时间的记录，数据可视化，看自己的承诺和已完成是否越来越接近。通过记录发现总结不足，在以后的清单中持续改善。 以上只介绍了番茄工作法流程和一些需要注意的点，其他一些边缘内容或者没有get到的点欢迎探讨。","categories":[{"name":"职场杂谈","slug":"职场杂谈","permalink":"http://yoursite.com/categories/职场杂谈/"}],"tags":[{"name":"职场杂谈","slug":"职场杂谈","permalink":"http://yoursite.com/tags/职场杂谈/"}]},{"title":"为什么我在工作线程刷新UI没报错？","slug":"为什么我在工作线程刷新UI没报错","date":"2017-04-21T12:55:54.000Z","updated":"2017-04-22T10:11:56.000Z","comments":true,"path":"2017/04/21/为什么我在工作线程刷新UI没报错/","link":"","permalink":"http://yoursite.com/2017/04/21/为什么我在工作线程刷新UI没报错/","excerpt":"","text":"从做Android开发以来就一直被灌输“只能在主线程刷新UI”的思想，但是这两天发现个问题，在onCreate中创建工作线程并刷新UI没有报错。代码是这样的： 123456789101112@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final TextView tv = (TextView) findViewById(R.id.sample_text); new Thread(new Runnable() &#123; @Override public void run() &#123; tv.setText(&quot;来自&quot;+Thread.currentThread().getName()+&quot;线程的更新&quot;); &#125; &#125;).start();&#125; 期待已久的crash没有出现，反而页面是这样显示的： 不禁让人陷入深思··· 第一步，分析问题原因。以前工作线程刷新UI会出现异常并提示只能在UI线程刷新UI。所以假设有个地方(函数)会在刷新UI前判断当前线程是不是主线程，那么现在问题就是验证下是否真的存在这么个地方。问题是从setText引起的，那就从这里出发看看。点进去看下发现又调用了其重载函数：1234@android.view.RemotableViewMethodpublic final void setText(CharSequence text) &#123; setText(text, mBufferType);&#125; 继续深入发现这个方法代码挺多的，但是不用过于关注细节，粗略浏览下不难发现前面大部分代码大多是对text文本格式的一些处理判断，无关刷新UI，直到 checkForRelayout()方法执行，从名字看是“从新布局”，根据view绘制流程测量、布局、绘制，那布局完了不是就绘制刷新了吗？所以决定去checkForRelayout方法看看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150private void setText(CharSequence text, BufferType type, boolean notifyBefore, int oldlen) &#123; if (text == null) &#123; text = &quot;&quot;; &#125; // If suggestions are not enabled, remove the suggestion spans from the text if (!isSuggestionsEnabled()) &#123; text = removeSuggestionSpans(text); &#125; if (!mUserSetTextScaleX) mTextPaint.setTextScaleX(1.0f); if (text instanceof Spanned &amp;&amp; ((Spanned) text).getSpanStart(TextUtils.TruncateAt.MARQUEE) &gt;= 0) &#123; if (ViewConfiguration.get(mContext).isFadingMarqueeEnabled()) &#123; setHorizontalFadingEdgeEnabled(true); mMarqueeFadeMode = MARQUEE_FADE_NORMAL; &#125; else &#123; setHorizontalFadingEdgeEnabled(false); mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS; &#125; setEllipsize(TextUtils.TruncateAt.MARQUEE); &#125; int n = mFilters.length; for (int i = 0; i &lt; n; i++) &#123; CharSequence out = mFilters[i].filter(text, 0, text.length(), EMPTY_SPANNED, 0, 0); if (out != null) &#123; text = out; &#125; &#125; if (notifyBefore) &#123; if (mText != null) &#123; oldlen = mText.length(); sendBeforeTextChanged(mText, 0, oldlen, text.length()); &#125; else &#123; sendBeforeTextChanged(&quot;&quot;, 0, 0, text.length()); &#125; &#125; boolean needEditableForNotification = false; if (mListeners != null &amp;&amp; mListeners.size() != 0) &#123; needEditableForNotification = true; &#125; if (type == BufferType.EDITABLE || getKeyListener() != null || needEditableForNotification) &#123; createEditorIfNeeded(); Editable t = mEditableFactory.newEditable(text); text = t; setFilters(t, mFilters); InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null) imm.restartInput(this); &#125; else if (type == BufferType.SPANNABLE || mMovement != null) &#123; text = mSpannableFactory.newSpannable(text); &#125; else if (!(text instanceof CharWrapper)) &#123; text = TextUtils.stringOrSpannedString(text); &#125; if (mAutoLinkMask != 0) &#123; Spannable s2; if (type == BufferType.EDITABLE || text instanceof Spannable) &#123; s2 = (Spannable) text; &#125; else &#123; s2 = mSpannableFactory.newSpannable(text); &#125; if (Linkify.addLinks(s2, mAutoLinkMask)) &#123; text = s2; type = (type == BufferType.EDITABLE) ? BufferType.EDITABLE : BufferType.SPANNABLE; /* * We must go ahead and set the text before changing the * movement method, because setMovementMethod() may call * setText() again to try to upgrade the buffer type. */ mText = text; // Do not change the movement method for text that support text selection as it // would prevent an arbitrary cursor displacement. if (mLinksClickable &amp;&amp; !textCanBeSelected()) &#123; setMovementMethod(LinkMovementMethod.getInstance()); &#125; &#125; &#125; mBufferType = type; mText = text; if (mTransformation == null) &#123; mTransformed = text; &#125; else &#123; mTransformed = mTransformation.getTransformation(text, this); &#125; final int textLength = text.length(); if (text instanceof Spannable &amp;&amp; !mAllowTransformationLengthChange) &#123; Spannable sp = (Spannable) text; // Remove any ChangeWatchers that might have come from other TextViews. final ChangeWatcher[] watchers = sp.getSpans(0, sp.length(), ChangeWatcher.class); final int count = watchers.length; for (int i = 0; i &lt; count; i++) &#123; sp.removeSpan(watchers[i]); &#125; if (mChangeWatcher == null) mChangeWatcher = new ChangeWatcher(); sp.setSpan(mChangeWatcher, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE | (CHANGE_WATCHER_PRIORITY &lt;&lt; Spanned.SPAN_PRIORITY_SHIFT)); if (mEditor != null) mEditor.addSpanWatchers(sp); if (mTransformation != null) &#123; sp.setSpan(mTransformation, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE); &#125; if (mMovement != null) &#123; mMovement.initialize(this, (Spannable) text); /* * Initializing the movement method will have set the * selection, so reset mSelectionMoved to keep that from * interfering with the normal on-focus selection-setting. */ if (mEditor != null) mEditor.mSelectionMoved = false; &#125; &#125; if (mLayout != null) &#123; checkForRelayout(); &#125; sendOnTextChanged(text, 0, oldlen, textLength); onTextChanged(text, 0, oldlen, textLength); notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT); if (needEditableForNotification) &#123; sendAfterTextChanged((Editable) text); &#125; // SelectionModifierCursorController depends on textCanBeSelected, which depends on text if (mEditor != null) mEditor.prepareCursorControllers();&#125; 找到checkForRelayout方法查看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void checkForRelayout() &#123; // If we have a fixed width, we can just swap in a new text layout // if the text height stays the same or if the view height is fixed. if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth)) &amp;&amp; (mHint == null || mHintLayout != null) &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; 0)) &#123; // Static width, so try making a new text layout. int oldht = mLayout.getHeight(); int want = mLayout.getWidth(); int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth(); /* * No need to bring the text into view, since the size is not * changing (unless we do the requestLayout(), in which case it * will happen at measure). */ makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING, mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(), false); if (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123; // In a fixed-height view, so use our new text layout. if (mLayoutParams.height != LayoutParams.WRAP_CONTENT &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123; invalidate(); return; &#125; // Dynamic height, but height has stayed the same, // so use our new text layout. if (mLayout.getHeight() == oldht &amp;&amp; (mHintLayout == null || mHintLayout.getHeight() == oldht)) &#123; invalidate(); return; &#125; &#125; // We lose: the height has changed and we have a dynamic height. // Request a new view layout using our new text layout. requestLayout(); invalidate(); &#125; else &#123; // Dynamic width, so we have no choice but to request a new // view layout with a new text layout. nullLayouts(); requestLayout(); invalidate(); &#125;&#125; 发现不管是if还是else，都要执行invalidate()，那就进去看看，一路进展比较顺利，好像离真理更进一步了。经过连续的三连调跳转到了invalidateInternal方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public void invalidate() &#123; invalidate(true); &#125; /** * This is where the invalidate() work actually happens. A full invalidate() * causes the drawing cache to be invalidated, but this function can be * called with invalidateCache set to false to skip that invalidation step * for cases that do not need it (for example, a component that remains at * the same dimensions with the same content). * * @param invalidateCache Whether the drawing cache for this view should be * invalidated as well. This is usually true for a full * invalidate, but may be set to false if the View&apos;s contents or * dimensions have not changed. */ void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true); &#125; void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; if (mGhostView != null) &#123; mGhostView.invalidate(true); return; &#125; if (skipInvalidate()) &#123; return; &#125; if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123; if (fullInvalidate) &#123; mLastIsOpaque = isOpaque(); mPrivateFlags &amp;= ~PFLAG_DRAWN; &#125; mPrivateFlags |= PFLAG_DIRTY; if (invalidateCache) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; &#125; // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; // Damage the entire projection receiver, if necessary. if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123; final View receiver = getProjectionReceiver(); if (receiver != null) &#123; receiver.damageInParent(); &#125; &#125; // Damage the entire IsolatedZVolume receiving this view&apos;s shadow. if (isHardwareAccelerated() &amp;&amp; getZ() != 0) &#123; damageShadowReceiver(); &#125; &#125; &#125; 重点看invalidateChild()这个方法，方法里面有do while循环，每次循环出当前view的parent，最后一次循环返回的parent时ViewRootImpl类实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; // If the child is drawing an animation, we want to copy this flag onto // ourselves and the parent to make sure the invalidate request goes // through final boolean drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION; // Check whether the child that requests the invalidate is fully opaque // Views being animated or transformed are not considered opaque because we may // be invalidating their old position and need the parent to paint behind them. Matrix childMatrix = child.getMatrix(); final boolean isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp; child.getAnimation() == null &amp;&amp; childMatrix.isIdentity(); // Mark the child as dirty, using the appropriate flag // Make sure we do not set both flags at the same time int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY; if (child.mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; &#125; final int[] location = attachInfo.mInvalidateChildLocation; location[CHILD_LEFT_INDEX] = child.mLeft; location[CHILD_TOP_INDEX] = child.mTop; if (!childMatrix.isIdentity() || (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); Matrix transformMatrix; if ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123; Transformation t = attachInfo.mTmpTransformation; boolean transformed = getChildStaticTransformation(child, t); if (transformed) &#123; transformMatrix = attachInfo.mTmpMatrix; transformMatrix.set(t.getMatrix()); if (!childMatrix.isIdentity()) &#123; transformMatrix.preConcat(childMatrix); &#125; &#125; else &#123; transformMatrix = childMatrix; &#125; &#125; else &#123; transformMatrix = childMatrix; &#125; transformMatrix.mapRect(boundingRect); dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f)); &#125; do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; if (drawAnimation) &#123; if (view != null) &#123; view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; &#125; else if (parent instanceof ViewRootImpl) &#123; ((ViewRootImpl) parent).mIsAnimating = true; &#125; &#125; // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate if (view != null) &#123; if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp; view.getSolidColor() == 0) &#123; opaqueFlag = PFLAG_DIRTY; &#125; if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123; view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag; &#125; &#125; parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f)); &#125; &#125; &#125; while (parent != null); &#125; &#125; 现在查看ViewRootImpl类的invalidateChildInParent()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (DEBUG_DRAW) Log.v(TAG, &quot;Invalidate child: &quot; + dirty); if (dirty == null) &#123; invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123; return null; &#125; if (mCurScrollY != 0 || mTranslator != null) &#123; mTempRect.set(dirty); dirty = mTempRect; if (mCurScrollY != 0) &#123; dirty.offset(0, -mCurScrollY); &#125; if (mTranslator != null) &#123; mTranslator.translateRectInAppWindowToScreen(dirty); &#125; if (mAttachInfo.mScalingRequired) &#123; dirty.inset(-1, -1); &#125; &#125; final Rect localDirty = mDirty; if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123; mAttachInfo.mSetIgnoreDirtyState = true; mAttachInfo.mIgnoreDirtyState = true; &#125; // Add the new dirty rect to the current one localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom); // Intersect with the bounds of the window to skip // updates that lie outside of the visible region final float appScale = mAttachInfo.mApplicationScale; final boolean intersected = localDirty.intersect(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); if (!intersected) &#123; localDirty.setEmpty(); &#125; if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123; scheduleTraversals(); &#125; return null;&#125; 方法块的第一行好像就是我们要找的验证线程的地方checkThread()，而该方法内容也很简单，看到抛出的异常就很熟悉了： 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125;&#125; 第二步，验证线程地方已经找到了，假设得到了证实，那么为什么该有的异常没有出现呢？现在再次假设是不是因为某些原因导致checkThread()没有执行呢？ 有人可能会问会不会是mThread == Thread.currentThread()？其实这是不可能的 ，先看下mThread赋值： 123456789public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mBasePackageName = context.getBasePackageName(); mDisplayAdjustments = display.getDisplayAdjustments(); mThread = Thread.currentThread(); ViewRootImpl类实例化是在Activity启动时的主线程创建的，所以mThread是主线程实例，而checkThread()中的Thread.currentThread()，最初是由textView.setText()调用的一系列方法栈，并且setText是在子线程调用。 继续刚才的假设，不过现在要逆推回去，checkThread()方法没有执行，可以认为ViewRootImpl的invalidateChildInParent()方法没有执行，它又是在ViewGroup中invalidateChild()方法里的do while中调用，要使do while不被调用，继续往上看，如果attachInfo为null，进不去if语句块也就不会执行checkThread()了，这是第一个可能的原因。记录下，继续逆推。 View中的invalidateInternal()方法： 12345678// Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; 根据判断条件，如果p即mParent或者ai即mAttachInfo 任一为null，都不会执行invalidateChild，这是第二个可能原因，这里的ai和第一个原因的attachInfo是一样的，所以第一个原因可能忽略，精力关注在第二个原因上。 现在的关注点是实例p和ai是什么时候创建的，有没有为null的现象？ 1final AttachInfo ai = mAttachInfo; 而mAttachInfo是在View的dispatchAttachedToWindow()方法中赋值的： 1234 void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; //System.out.println(&quot;Attached! &quot; + this); mAttachInfo = info;&#125; View的dispatchAttachedToWindow()方法是在ViewRootImpl中的performTraversals()方法调用，这个方法是遍历View Tree 12345private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView; ······· host.dispatchAttachedToWindow(mAttachInfo, 0); 可见View中的mAttachInfo来自ViewrootImpl的mAttachInfo，而ViewrootImpl的mAttachInfo是在其构造方法中被赋值的： 12345678910111213141516171819202122232425262728public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mBasePackageName = context.getBasePackageName(); mDisplayAdjustments = display.getDisplayAdjustments(); mThread = Thread.currentThread(); mLocation = new WindowLeaked(null); mLocation.fillInStackTrace(); mWidth = -1; mHeight = -1; mDirty = new Rect(); mTempRect = new Rect(); mVisRect = new Rect(); mWinFrame = new Rect(); mWindow = new W(this); mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion; mViewVisibility = View.GONE; mTransparentRegion = new Region(); mPreviousTransparentRegion = new Region(); mFirst = true; // true for the first time the view is added mAdded = false; mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); &#125; 之前说了ViewRootImpl实例是在Activity启动时创建的，现在看看具体是启动的什么时候:在向window添加view的时候即：WindowManagerGlobal的addView方法中创建ViewrootImpl实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(&quot;view must not be null&quot;); &#125; if (display == null) &#123; throw new IllegalArgumentException(&quot;display must not be null&quot;); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there&apos;s no parent and we&apos;re running on L or above (or in the // system context), assume we want hardware acceleration. final Context context = view.getContext(); if (context != null &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; &#125; 而调用addView()方法是在ActivityThread类的handleResumeActivity()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) &#123; final Activity a = r.activity; if (localLOGV) Slog.v( TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn&apos;t yet been added to the window manager, // and this guy didn&apos;t finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; // If the window has already been added, but during resume // we started another activity, then don&apos;t yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; &#125; // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; if (r.newConfig != null) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.newConfig); performConfigurationChanged(r.activity, r.newConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig)); r.newConfig = null; &#125; if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; if (!r.onlyLocalRequest) &#123; r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); &#125; r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) &#123; try &#123; ActivityManagerNative.getDefault().activityResumed(token); &#125; catch (RemoteException ex) &#123; &#125; &#125; &#125; else &#123; // If an exception was thrown when trying to resume, then // just end this activity. try &#123; ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, false); &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; 看到上面的方法有些人心里可能有底儿了，handleResumeActivity()方法是不是让Activity回调onResume？如果是的话一切就都明了了，因为ViewrootImpl是在onReume期间创建，而AttachInfo是在ViewRootImpl实例化时创建，我们的工作线程是在onCreate时刷新UI的，那时候还没有实例化AttachInfo，导致mAttachInfo为null，最终if条件判断失败没有进入。然而这一切都是在YY，实践才是检验真理的唯一标准，动起来： 看到这一行代码12ActivityClientRecord r = performResumeActivity(token, clearHide);```微微一笑，点进去看看， public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) { ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r + &quot; finished=&quot; + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) { if (clearHide) { r.hideForNow = false; r.activity.mStartedActivity = false; } try { r.activity.mFragments.noteStateNotSaved(); if (r.pendingIntents != null) { deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; } if (r.pendingResults != null) { deliverResults(r, r.pendingResults); r.pendingResults = null; } r.activity.performResume(); EventLog.writeEvent(LOG_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName()); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to resume activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } } return r; } 1代码很短，很容易提取有用信息：``` r.activity.performResume();```在进去看看： final void performResume() { performRestart(); mFragments.execPendingActions(); mLastNonConfigurationInstances = null; mCalled = false; // mResumed is set by the instrumentation mInstrumentation.callActivityOnResume(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onResume()&quot;); } // Now really resume, and install the current status bar and menu. mCalled = false; mFragments.dispatchResume(); mFragments.execPendingActions(); onPostResume(); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onPostResume()&quot;); } } 1看到```mInstrumentation```这个属性就能感觉到越来越接近SDK API层了，看看它的```callActivityOnResume()```方法做了什么： public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); } } } } 123一行```activity.onResume();```已经水落石出。回到handleResumeActivity代码中，我精简下： final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { //这里是最终回调Activity的onResume()方法 ActivityClientRecord r = performResumeActivity(token, clearHide);//省略若干 if (r != null) { final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; boolean willBeVisible = !a.mStartedActivity; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; //这里是调用WindowManagerGlobal的addView()方法最终实例化ViewRootImpl，进而实例化AttachInfo wm.addView(decor, l); } } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } } } ``` 另外关于阅读源码问题，win下当然使用SourceInsight不二选，如果是在mac下可以参考我的osx下如何使用SublimeText阅读Android系统源码.。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼","slug":"搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼","date":"2017-04-21T12:55:54.000Z","updated":"2017-04-22T09:55:54.000Z","comments":true,"path":"2017/04/21/搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼/","link":"","permalink":"http://yoursite.com/2017/04/21/搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼/","excerpt":"","text":"一直以来对这几个SDK版本概念都有点模糊不清，对于API的使用又会产生什么样的影响。所以今天花点时间来记录下。 minSDKVersion顾名思义是设置sdk最低版本的。作用就是操作系统会拒绝低于该标准的APP的安装。 例如，minSDKVersion设置为16(Jelly Bean 4.1系统)，那么该APP将只能运行在4.1系统以上的设备中，想要在2.3系统上安装是不被允许的。 minSDKVersion比较容易理解，经常让我混淆的时其他两个版本设置会对API产生的影响。 targetSDKVersiontargetSDKVersion就是设置SDK目标版本，目标版本的设置就是为了告诉Android系统：本APP是设计计划给哪个API级别运行的。 一般情况下目标版本设置为当前Android最新版本即可。既然是一般那也就有特殊情况，什么情况下需要修改目标版本呢？ 如果新发布的SDK版本会对UI显示甚至操作系统运行机制产生影响，而你的APP又没有做好应对措施，为了保证你的APP正常运行，那你需要降低目标版本。因为你的目标版本仍然是旧的SDK，所以在新版系统中那些新的变化会在你的APP中被忽略，继而保证其正常运行。 例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。 compileSDKVersioncompileSDKVersion是设置编译版本。 一般来说编译目标版本是选择最新的SDK，这样可以及时使用体验到新的API提供的新功能。 值得注意的是，如果minSDKVersion和compileSDKVersion版本差距比较大的话，可能会造成API的不兼容。例如，你的最低版本是2.3 ，但是编译版本是5.0，API中使用了4.0SDK提供的一些新API，这样的后果是在2.3系统中运行到该处代码时会发生异常崩溃。这是因为代码的不兼容造成的。如图： 如何解决这种API的不兼容呢？一种办法是提升minSDKVersion到新API使用的SDK版本，但是这种方法只是回避兼容性，并没有确实解决问题，而且还要放弃低版本部分市场。比较好的做法是在使用新API地方做设备版本的检查。Build.VERSION_SDK_INT常量表示当前Android设备的版本号。可以将该常量同新API版本进行比较，如果版本大于等于新版API版本号，则正常使用新API功能，否则使用旧的调用。兼容设置如下： 注意：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]}