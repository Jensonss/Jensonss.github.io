{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/image/weixin.png","path":"image/weixin.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/slider.096dc6.js","path":"slider.096dc6.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.266c1c.js","path":"main.266c1c.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.266c1c.css","path":"main.266c1c.css","modified":0,"renderable":1},{"_id":"source/image/alipay.jpg","path":"image/alipay.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/mobile.906508.js","path":"mobile.906508.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"source/image/avatar.jpg","path":"image/avatar.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"89652fd7b8ccbe7b66dde151db11bb0abac19c93","modified":1502781848000},{"_id":"source/CNAME","hash":"4d6ad5941eb82092c055b8495d5fad1ea792e578","modified":1500877232000},{"_id":"source/about/index.md","hash":"9c3ed2eb1797f7da82161b45116322d4476c2fa5","modified":1501673706000},{"_id":"source/_posts/2015圆明园荷花节.md","hash":"1bfc7a4bd3ee55c1ab24309d4f7ce4df617fb79e","modified":1493111849000},{"_id":"source/_posts/.DS_Store","hash":"3c13382bdfcb6822a704600e2f5dea3b94203af3","modified":1502293914000},{"_id":"source/categories/index.md","hash":"3c5ec6d1300cd36a0804d8fc87dc12b2c6fddf89","modified":1500877232000},{"_id":"source/_posts/30分钟搭建自己的网站.md","hash":"da25e80c1827d55cf58e540f3c32fbfbcfd2772a","modified":1500877232000},{"_id":"source/_posts/Android关于Activity生命周期误解.md","hash":"c6d5fd46788830e67d66a469ec3bb95174b7e7c3","modified":1494138484000},{"_id":"source/_posts/2016圆明园荷花节.md","hash":"c9a89b6cf915239fb18efa46707fb604f027b863","modified":1493112792000},{"_id":"source/_posts/Android内存分析工具之MAT详解.md","hash":"71aa589c3fc1a352fa6b2513f4337a31a54be275","modified":1493279043000},{"_id":"source/_posts/Android屏幕适配.md","hash":"59a3c1fafeb39dfac6b1ee233bfc90b6200eadfe","modified":1501575272000},{"_id":"source/_posts/Android开发之JNI深入解析.md","hash":"f397d89e67a8d58518a8023cbdb26d0b705adea0","modified":1493104632000},{"_id":"source/_posts/Android性能优化之内存优化.md","hash":"477f10656bb236512c44a45a9ad859da230d9fc7","modified":1500877232000},{"_id":"source/_posts/Android性能优化之耗电优化.md","hash":"cf30816f5a16cd6fed05b05efc7285be2c2d4ef9","modified":1500877232000},{"_id":"source/_posts/Android各版本新功能及区别.md","hash":"bcfb516c894dc55aa5a1b44bdb585a3e80a0b0db","modified":1501067448000},{"_id":"source/_posts/2016公司清明节坝上草原.md","hash":"13a029d458c82a899e749c59e7f954caecb84987","modified":1493114450000},{"_id":"source/_posts/Android性能优化之UI优化.md","hash":"ebfea595f94ae95930d4a496dcffe0def5fc5097","modified":1493893416000},{"_id":"source/_posts/Android源码下载.md","hash":"f54c57d6f2b861a358057bd9ab6d8586bdfc0466","modified":1500877232000},{"_id":"source/_posts/Gradle和Gradle-Plugin之间对应关系.md","hash":"f0f43239e9a07f17f32e7b97aa9c95582b48aae9","modified":1501753414000},{"_id":"source/_posts/Django创建数据表时syncdb提示Unknown-command：‘syncdb.md","hash":"ccbee079b86580a30207f7db69c2601617081e4a","modified":1498552565000},{"_id":"source/_posts/Java-wait，notify和notifyAll使用分析.md","hash":"9d2404af1da7095063439f7f4e1aba15fb3f4a3f","modified":1500876487000},{"_id":"source/_posts/Java字符串压缩去重.md","hash":"718cd297d2d399a6e2d493fd8f1e85b6bbc4b8c0","modified":1493805866000},{"_id":"source/_posts/Java参数到底是值传递还是引用传递.md","hash":"7495cc2fd5671f2e67569131cf4f19283f14660b","modified":1502348426000},{"_id":"source/_posts/Android进程和线程.md","hash":"f35bf1484a09873f01d59b27881e418fad5bf082","modified":1493297965000},{"_id":"source/_posts/Mac版eclipse中每次重启电脑后字体自动变小.md","hash":"e190ffe2601170a9f1d9624594de3c4bdc5cd322","modified":1500877232000},{"_id":"source/_posts/Java知识点.md","hash":"605d3405c83fae72dff04d2bfd34050ad8f8d8de","modified":1498822084000},{"_id":"source/_posts/Mac下配置adb.md","hash":"db67213430c7bb2e2cd5da360797d39a8480279d","modified":1499952641000},{"_id":"source/_posts/Mac系统下载文本都是打开都是乱码.md","hash":"921d12465890beef98bb0d75e894f8f5827b4ecf","modified":1501672254000},{"_id":"source/_posts/Android网络框架执行流程分析.md","hash":"5dc90783a119e2ad65275c7d6c94e55a624c82c0","modified":1494349851000},{"_id":"source/_posts/Mac终端光标变成粗体.md","hash":"99df80e4ecd82abc2ff9f4d0bd2fdb9a8daef5bd","modified":1500443385000},{"_id":"source/_posts/Mac系统中希捷移动硬盘NTFS格式只能读.md","hash":"e4e97b28b0c672d2a693bed1345581e380edbb06","modified":1501693642000},{"_id":"source/_posts/No-resource-identifier-found-for-attribute-roundIcon-in-package-android.md","hash":"2dc17f40fc149e13193096b241c8aa48dd7e96ae","modified":1502171555000},{"_id":"source/_posts/Python中-和-有什么意义.md","hash":"657e559ac941eca034aa748bb01132929271855e","modified":1502206945000},{"_id":"source/_posts/Python入门系列(0) OSX系统下Python3的配置与安装.md","hash":"30cec5c142146cd597e528112a82545842a393f6","modified":1500877232000},{"_id":"source/_posts/Python入门系列(1) 如何使用Sublime text开发Python.md","hash":"34eebf3ee5630646ff6a0a2b2a6482129205561c","modified":1500877232000},{"_id":"source/_posts/Python入门系列(2) 字符串、变量和简单数据类型的上手.md","hash":"aa0044c9b3fd3291c6b7febf3a5e518a4f1e2ff2","modified":1500877232000},{"_id":"source/_posts/Python入门系列(4)文件IO.md","hash":"6206c2416cd54a6d0d8b5850181a7446cdc9031a","modified":1502171580000},{"_id":"source/_posts/Python爬虫应该掌握哪些知识.md","hash":"5259d5c60da31f434a4fef9227e2e8211cebd504","modified":1501560958000},{"_id":"source/_posts/Python入门系列-3-元组、列表和字典.md","hash":"20a7bc985311b5acb73c2c6bdab1c5b9cc3aafc9","modified":1499965501000},{"_id":"source/_posts/Python用qq邮箱发邮件.md","hash":"0d6e281870681bc7e5b93c5a5a79b42da714dbcb","modified":1502293890000},{"_id":"source/_posts/Python入门系列(5)：进程、线程和协程.md","hash":"5724e9e512d772e0ab637eefc027d4b94aa0a055","modified":1502181990000},{"_id":"source/_posts/Python第三方库没有代码快捷提示.md","hash":"fabbc59cfe1d35750f3a2ad741ee1caf21312384","modified":1501520635000},{"_id":"source/_posts/Python爬虫爬取简书首页文章-一.md","hash":"9c589bd5d35cbd6cdb11edcc94d3af0ae11e6661","modified":1501650393000},{"_id":"source/_posts/Python爬虫爬取简书首页文章-二.md","hash":"8a7e95c42b3e6ae74f5941850b7a2b1d158a529f","modified":1501666379000},{"_id":"source/_posts/UML--类图详解.md","hash":"4be21817592db5347e0bbc46140027732ebbfdc9","modified":1500877232000},{"_id":"source/_posts/Selenium-ChromeDriver安装.md","hash":"2c8260e049efd493c66a3c4c909de9a5cacf1e7f","modified":1501614198000},{"_id":"source/_posts/WireShark-the-capture-session-could-not-be-initiated-you-don-t-have-permission-to-capture-on-that-device-异常.md","hash":"fb24f981572e8f2acc06ae5f16d4789cb927d5f7","modified":1501758602000},{"_id":"source/_posts/WordCloud不显示中文只显示方框问题.md","hash":"c38b03f97bf4eda585325467b8ecce5512c72ca1","modified":1501671965000},{"_id":"source/_posts/hexo博客换电脑后怎么办.md","hash":"cbea4e876c2923a173e9791172f526c1a49c2380","modified":1493726087000},{"_id":"source/_posts/hexo更换主题及配置.md","hash":"01d867c68a8adaf4708b017dbabfb6655d495a3f","modified":1500011845000},{"_id":"source/_posts/Python自动化之hexo自动发布和提交源码.md","hash":"b1331b982ee6f4f5362ae5dd1b2fbf4cebc9de99","modified":1501061938000},{"_id":"source/_posts/hexo文章tags添加多标签.md","hash":"804d7f53b7cca30c6c0d344a8c95aa15cde91533","modified":1500443704000},{"_id":"source/_posts/osx下pip3安装matplotlib时The following required packages can not be built freetype.md","hash":"c07fa80299a0f444cb97601ed72ed779754fdc5f","modified":1500877232000},{"_id":"source/_posts/osx下如何使用SublimeText阅读Android系统源码.md","hash":"43b436019977125515415286835b7676bdfdf1d3","modified":1500877232000},{"_id":"source/_posts/hexo添加网易云音乐播放器.md","hash":"9673496b97a4fe87d480e3610902214ca874ce19","modified":1500016209000},{"_id":"source/_posts/hexo本地图片发布后不能显示的问题.md","hash":"63c9969d407f219666f39a3b9de47552b504d055","modified":1493108291000},{"_id":"source/_posts/Python读取文件出现UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte异常.md","hash":"1c9e9c7659ff6a49c0c37afac0aea75e2e9c01cf","modified":1501672448000},{"_id":"source/_posts/osx如何安装Homrbrew.md","hash":"892b22d2789de7eb2c5b5518165cd40729cf3082","modified":1500877232000},{"_id":"source/_posts/pycharm黄线问题.md","hash":"4b5c68fb4fdc38882e45224d792c434c0449c2d9","modified":1500877232000},{"_id":"source/_posts/为什么我在工作线程刷新UI没报错.md","hash":"27a72e63dd0f90546170ed97bb53f4724e51ef4b","modified":1500877232000},{"_id":"source/_posts/typeerror-module-init-takes-at-most-2-arguments-3-given.md","hash":"e033fafc246bdc73e420f9a157e31ef7ddc9a67f","modified":1501504231000},{"_id":"source/_posts/使用Sublime text编译python3时中文打印异常问题.md","hash":"c9b8b67a852a458e7e70f20f64187a514c967397","modified":1500877232000},{"_id":"source/_posts/两个栈实现队列功能.md","hash":"c640b5dcc4051d9ae492c8bb5570270d801b6fd7","modified":1495103781000},{"_id":"source/_posts/使用sychronized注意事项.md","hash":"7151e7e2d08e67913e62489c1b91385a4a84c883","modified":1502382705000},{"_id":"source/_posts/为什么每一个IT人员应该有一把人体工学电脑椅.md","hash":"8dd75cfc78c5acb449e2d70a4c228391d984f7b1","modified":1494848579000},{"_id":"source/_posts/为什么Android中很多int常量使用十六进制表示.md","hash":"6e6a5c5a04b21997dc3d63d501fe353f58ed7f35","modified":1500442737000},{"_id":"source/_posts/关于家庭网络宽带、路由及上网设备那些事---后续篇.md","hash":"dfe7b33713e0cc3777be37b0bfea63b7b1fa3919","modified":1500877232000},{"_id":"source/_posts/关于Intent那些事.md","hash":"e127fcd979e4c42ae7d78ad0712b8d0b63819c9e","modified":1500442127000},{"_id":"source/_posts/关于家庭网络宽带、路由及上网设备那些事.md","hash":"f457ca1bb8b578846981952339e8a7847f9b7e3d","modified":1500877232000},{"_id":"source/_posts/关于Canvas的一些概念.md","hash":"1ade8cf30540507c84d2b36b93da90aa018de6f6","modified":1501748987000},{"_id":"source/_posts/为什么相对布局比线性布局性能低.md","hash":"94501d6f02b1ec4bbdea54090bdb0c56ebe64f80","modified":1500460586000},{"_id":"source/_posts/农夫带着狼、羊和白菜过河问题.md","hash":"f6ddffce0b0316f04dd5c899a68dc8a2f7ba43b1","modified":1494433180000},{"_id":"source/_posts/四个人过桥问题.md","hash":"da3addb3fd1bd6facc5a4331687fe17a45eac1d8","modified":1494503431000},{"_id":"source/_posts/如何知道下载好的aosp版本.md","hash":"7b2bbfc62a038aa2c493aa5196ffca207bc0ffee","modified":1500877232000},{"_id":"source/_posts/搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼.md","hash":"fddef626692da6e21ccb91efab47d21be14b2a04","modified":1500877232000},{"_id":"source/_posts/垃圾回收机制-关于GC.md","hash":"a27ecaca6a3d3ef60b0ffc3d50fbd31fb2431bd0","modified":1501130707000},{"_id":"source/_posts/反转字符串.md","hash":"15e8fd6941c4b14eb965ff4e52dc0debe29c7ffc","modified":1501144972000},{"_id":"source/_posts/浅谈Android事件传递机制.md","hash":"5bc7c7fe4cad6a27f3862c82ca68c2ab1db6bc11","modified":1501003875000},{"_id":"source/_posts/求解1到n中1的个数.md","hash":"d3aa1d028bd9797ad4229f5771c6f01474cf6167","modified":1501171910000},{"_id":"source/_posts/浅谈Android性能优化系列-0-之为什么需要性能优化.md","hash":"fe2f12b60548f529eccac8cc8aba5a3d79c5c4ae","modified":1500477933000},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化.md","hash":"c1529ae7c2ff865c0e47a9e8592d9a911089edc8","modified":1500886932000},{"_id":"source/_posts/番茄工作法使用说明书.md","hash":"e968d4d30ec369a6dcde23dd1e8327c735452f3b","modified":1500877232000},{"_id":"source/_posts/字符串前的r和u.md","hash":"d1cc943ecbcf9a441de4e00ce6f960ba17bd78dd","modified":1502171570000},{"_id":"source/_posts/数学归纳法.md","hash":"cef3dc5c30405bef196d6e6cbb33eb3c49f8687d","modified":1494992326000},{"_id":"source/_posts/用Python提取excel中有用数据.md","hash":"9cfadcf79f585dd97645a743733cd95d9eb3ca1b","modified":1500606511000},{"_id":"source/_posts/算法排序之交换排序.md","hash":"780c025a7eab0528e5fc2b14cdd9d51034e85e5a","modified":1493821647000},{"_id":"source/_posts/算法查找之二分查找.md","hash":"2b24c0967c08b25a1df308c5fdab9b2c6271d29c","modified":1493828078000},{"_id":"source/_posts/算法排序之快速排序.md","hash":"592651801d21174e58b431145d4691a1e0e0f144","modified":1494949170000},{"_id":"source/_posts/详解设计模式之建造者模式.md","hash":"b41b7269995129353377657721fb7b518214dd4f","modified":1494401051000},{"_id":"source/_posts/详解设计模式之单例模式.md","hash":"66e8a3096cc82e44a429f73abf2bf8e311104a78","modified":1500877232000},{"_id":"source/_posts/详解设计模式之简单工厂模式.md","hash":"d9f0298c546f057fd19a17e3f792af53108adb74","modified":1500877232000},{"_id":"source/tags/index.md","hash":"cd323cee16538256e9d43471a8f82dffb8eb9ae1","modified":1500877232000},{"_id":"source/_posts/详解设计模式之责任链模式.md","hash":"a9797e56e0947e73b3bce30eb22744b5bf84a7dc","modified":1494407908000},{"_id":"themes/yilia/.DS_Store","hash":"91353449236cec6c06e9c34bcf3c1279282a5c6d","modified":1500478334000},{"_id":"source/_posts/算法之朴素模式匹配.md","hash":"d0882f77585197326899947dfa768d15b1ad7647","modified":1495705671000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1500447214000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1500447214000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1500447214000},{"_id":"source/_posts/设计一个有获取元素最小值getMin的栈.md","hash":"a4e69d3779d0e31dc838a97bccbc734777a780e9","modified":1495096109000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1500447214000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1500447214000},{"_id":"themes/yilia/README.md","hash":"86757b00d393bd4956a252d92a469f11f2ae8914","modified":1500447214000},{"_id":"themes/yilia/.gitignore 下午4.03.39","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1500451828000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1500447214000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1500447214000},{"_id":"themes/yilia/_config.yml","hash":"fc32144c20c8f2c9ec948444f2c825816979442d","modified":1501561210000},{"_id":"source/image/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1500473979000},{"_id":"source/image/weixin.png","hash":"8b79c4caf0cb7c2cee0f034c77e772021cb030ef","modified":1499961665000},{"_id":"source/_posts/2016公司清明节坝上草原/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1493113484000},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112396013.jpg","hash":"9c5244967054cafe06bc2c664121cd6168779993","modified":1493112484000},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112393720.jpg","hash":"b1c2c8a583fc699b06538430993c80390125c446","modified":1493112484000},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112398170.jpg","hash":"96c4b59cffff416f920a82ca6b2e2b2e79cd3621","modified":1493112484000},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112405316.jpg","hash":"80d99017a1536f5ebe650057bd03d7378070f78b","modified":1493112483000},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112402523.jpg","hash":"0d5f3956b59608b523bbe1f0c90570f01cd211d6","modified":1493112482000},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112400267.jpg","hash":"1963b1b85ed7ca762f5c1e4f4761a70b63830436","modified":1493112484000},{"_id":"source/_posts/2015圆明园荷花节/.DS_Store","hash":"9d37a7d6a1c665163d7ee02c6be11c651d6214e4","modified":1493111795000},{"_id":"source/_posts/Android内存分析工具之MAT详解/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1493271714000},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.11.33.png","hash":"d3c407d21cca28dd6efe53c3c49c3b49636704ff","modified":1493277096000},{"_id":"source/_posts/Android内存分析工具之MAT详解/0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png","hash":"23d4d41ee705d2a53d8823da0008b1a5cb49ef1c","modified":1493271838000},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.21.48.png","hash":"f6005c31a725e55955a612e075c980b638b3c801","modified":1493274119000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.57.46.png","hash":"9b4989e0bb92980672882b05ccf49e48c91fea9b","modified":1493049473000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.14.36.png","hash":"68d7e653a1005d1e73024cb8ea8fbc2731777a79","modified":1493046883000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 上午12.26.47.png","hash":"41789b81c2fa5e7d6654d0a299aa844e4e3091d4","modified":1493051217000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 上午9.49.56.png","hash":"5a279dc5923c44e761031e95002e9a29bdbf0a9a","modified":1493085003000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午9.57.43.png","hash":"3ca00b29315f30e0a6d715ed11aec4577b8ed4a7","modified":1493042270000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午2.54.18.png","hash":"c238b16f19b4ebf921d74c2580755f38eb69ac35","modified":1493103266000},{"_id":"source/_posts/Mac终端光标变成粗体/设置光标.png","hash":"d9f678998217524e28f4b4e10fc1e1631fe30bce","modified":1500443274000},{"_id":"source/_posts/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.33.13.png","hash":"36238ae43e26397f774c65c9ce10a5f83be59215","modified":1493105599000},{"_id":"source/_posts/Android网络框架执行流程分析/流程.png","hash":"6d4d1136ff206a04c1b74d6e30aae272a19eafa5","modified":1494345617000},{"_id":"source/_posts/hexo更换主题及配置/menu配置.png","hash":"84040ec3c162cf7afc540db55dc939cc0a7d1d71","modified":1500002861000},{"_id":"source/_posts/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.34.46.png","hash":"f74cf134edf54b4e55d8df0e6c9b5d3630006665","modified":1493105695000},{"_id":"source/_posts/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.45.37.png","hash":"8e07868047b036caacf006f004a3de013cb11c19","modified":1493106344000},{"_id":"source/_posts/hexo更换主题及配置/换主题.png","hash":"ec78501ea132e8e0d1f509b9268fe4262920fa57","modified":1500001404000},{"_id":"source/_posts/hexo更换主题及配置/打赏效果图.png","hash":"a69b43e4388a4431d63a1b0bc677ed6596c92283","modified":1500003928000},{"_id":"source/_posts/关于Intent那些事/请求流程.png","hash":"4a4430ccabff6a5384fb3ae9bab09074c6f7161d","modified":1500291495000},{"_id":"source/_posts/用Python提取excel中有用数据/项目结果.png","hash":"3b8f5f092ba987271637276b530139d475fd48a0","modified":1500605743000},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1500615721000},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化/lint.png","hash":"9a73d022691f76e3470f412cb3d3cebd8887fcee","modified":1500615354000},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化/lint_result.png","hash":"cd1b100b0d2900caea67a2c0f6d0d6f4119cece7","modified":1500615763000},{"_id":"source/_posts/用Python提取excel中有用数据/doc文档内容.png","hash":"e1c13632c462af66e5b304cfb46a6efa5dca4e09","modified":1500605887000},{"_id":"source/_posts/用Python提取excel中有用数据/创建项目.png","hash":"8527258d0cb28748ae005e669726e7ee9084f823","modified":1500604609000},{"_id":"source/_posts/离职出行/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1493114941000},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化/安装包构成.png","hash":"4debd2c5045d54dbcc217729e6297bb24de35aa7","modified":1500610965000},{"_id":"source/_posts/浅谈Android事件传递机制/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1500893079000},{"_id":"themes/yilia/.git/COMMIT_EDITMSG","hash":"212a755da5a77da60c37cec6375f8305cd188782","modified":1500621501000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1500447214000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1500447155000},{"_id":"themes/yilia/.git/packed-refs","hash":"4dc64835d90ebd62d3df9c760251d3ee4fe50711","modified":1500447214000},{"_id":"themes/yilia/.git/index","hash":"f7d9e99de01c3d45e9542a8000ef5f56205cec70","modified":1500621497000},{"_id":"themes/yilia/.git/config","hash":"45d92bcfc359558933d85245fc7e2affac28e5e2","modified":1500451946000},{"_id":"themes/yilia/languages/.DS_Store","hash":"af650f35cbffd8c5627394c646e4bccd7eefebd5","modified":1500446133000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1499958683000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1499958683000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1499958683000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1499958683000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1499958683000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1499958683000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1499958683000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1499958683000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1499958683000},{"_id":"source/_posts/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午5.17.19.png","hash":"a00d2b50faeaf760c57b3ea66651b1d7193c1d39","modified":1494407844000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1499958683000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1499958683000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1499958683000},{"_id":"source/_posts/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午4.21.27.png","hash":"9dbdbd65bab90c5352370e5d36acfd07273f4145","modified":1494404493000},{"_id":"themes/yilia/layout/.DS_Store","hash":"285abf9412a95867a7d573c6c16bacd01a7ffcf6","modified":1500478322000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1499958683000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1499958683000},{"_id":"themes/yilia/source/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1499958683000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1499958683000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1499958683000},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112391191.jpg","hash":"2b68aeaac0f687cfa8368184faec7fdec3f97b94","modified":1493112485000},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午1.49.26.png","hash":"d2d08200b0aba19179903417a9bc338d421accc6","modified":1493272169000},{"_id":"source/_posts/Android内存分析工具之MAT详解/1A94CD89-1BE9-46BC-9449-8B55EE34D741.png","hash":"2286365e7cffc5a42624d41ed0ff862d120a0780","modified":1493271980000},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.08.27.png","hash":"3cbadb4dfedf23cf807dad7061666894d3d321ca","modified":1493273312000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.04.06.png","hash":"cdd90a2769b98ac3a51eb0c2167448bdc2c04ead","modified":1493046250000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午10.29.17.png","hash":"bfc2e17ce7ec253dbb876f6f5f7b37541edfd893","modified":1493044162000},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午12.56.36.png","hash":"7547cac237c52b5a55c883117a4731e5fcc9a21c","modified":1493096201000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1499958683000},{"_id":"themes/yilia/source/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1499958683000},{"_id":"themes/yilia/source/main.266c1c.css","hash":"a274acf63e17d906582eec3c0e3c00375ede5d3f","modified":1500479530000},{"_id":"source/image/alipay.jpg","hash":"d9c8084299f79c67cecc01242f83554dab75f9e4","modified":1499961630000},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.19.06.png","hash":"b346dd2a664e6b306369fd760fd150df576f7404","modified":1493277552000},{"_id":"source/_posts/hexo更换主题及配置/模块缺失.png","hash":"bb4aa7054a8956bb67986ee2d9e151c1894c8fe1","modified":1500004831000},{"_id":"source/_posts/hexo更换主题及配置/关于我.png","hash":"2faad470f45d51d919d5e66c4fdb0bd8a0be0a76","modified":1500004418000},{"_id":"source/_posts/hexo添加网易云音乐播放器/音乐界面.png","hash":"c1baed64e509ea400a9b8b040a0489902ae9e83e","modified":1500015299000},{"_id":"themes/yilia/source/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1499958683000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1500447155000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1500447155000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1500447155000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"b75e8fff732292fa26b5a0b47cd253d4281e321a","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"9bfcbd9e71401b6da6b2bbbe61e97625ca247b7a","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"51db1cecdd6d456c4a14b2ae1df489e2d566b190","modified":1500013799000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1499958683000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1499958683000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1499958683000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1499958683000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1499958683000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1499958683000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1499958683000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1499958683000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1499958683000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1499958683000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"41e7646916cf1926f8430f40ee88201461a259e9","modified":1500621497000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1499958683000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1499958683000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1499958683000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1499958683000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1499958683000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1499958683000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1499958683000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1499958683000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1499958683000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1499958683000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1499958683000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1499958683000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1499958683000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1499958683000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1499958683000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1499958683000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1499958683000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1499958683000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1499958683000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1499958683000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1499958683000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1499958683000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1499958683000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1499958683000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1499958683000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1499958683000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1499958683000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1499958683000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1499958683000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1499958683000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9bb1a4918c1b1ee62ce0a71381990a1978c51b2a","modified":1499958683000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1499958683000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1499958683000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1499958683000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1499958683000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1499958683000},{"_id":"source/image/avatar.jpg","hash":"23e19c88c7a3a432c3b6c77a4e3598af11baeece","modified":1500474150000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1499958683000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1499958683000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1499958683000},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.22.23.png","hash":"50622ee73aff94b566796ec4f45a0d4fdb8b4405","modified":1493277745000},{"_id":"source/_posts/为什么每一个IT人员应该有一把人体工学电脑椅/58f074a8N70fcfb6a.jpg","hash":"52a75130e228a32d037ec4dbec556c01c26e5fa9","modified":1494848421000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"171b130d25c36f496e4b43e3808707a8f1897729","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1499958683000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1499958683000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"fe7daf0b3651cbd11c1412a322d246658383b4e8","modified":1500621497000},{"_id":"themes/yilia/.git/objects/0d/d61be53e3e660bce0a1801c27337f3f4200b99","hash":"22961b6d609aa58f2ff8a8b173e9d59abb5d5b9a","modified":1500621497000},{"_id":"themes/yilia/.git/objects/49/9c90271d9e5e7aa24eaeb49425f68c86491d06","hash":"24307762ee2ba0d970c16342a4889e3c6a876792","modified":1500621497000},{"_id":"themes/yilia/.git/objects/86/ef34ac7459cd727260d770ef222e07c0814040","hash":"2ceeb2d5b5b00f7ee8355857bb2368c1108763ae","modified":1500621497000},{"_id":"themes/yilia/.git/objects/01/7eb8cfc9a59fcfea9056159a1037c845053825","hash":"c48945f46c8e7bf8e20361bb9bf916f63a188253","modified":1500621489000},{"_id":"themes/yilia/.git/objects/d6/7643c57cdac8b808862dfbe429da4ec8d999d9","hash":"ff9065b6afce67ed2dd896923403cfbbadd3e844","modified":1500621497000},{"_id":"themes/yilia/.git/objects/27/8b68222bab57c2e74d244595a081892157e62b","hash":"68c51b17cea6c81eab0a37e642eaa19058d2113e","modified":1500621489000},{"_id":"themes/yilia/.git/objects/c1/a83655f90dfad26911450eb3195f1ed7d1fc16","hash":"7498d6756527fcd7500aea10979c52638836e9ea","modified":1500621489000},{"_id":"themes/yilia/.git/objects/61/14bde8e4c8c780a7c32d7ab6afe33918f8bc1a","hash":"b9c551e9eb55ceb3c578c70a894ac853b0c3a72b","modified":1500447708000},{"_id":"themes/yilia/.git/objects/26/c18b0826ab3538d7ca5809db8214a88cdd640f","hash":"9751c386ab0421466eb7a9b919a1bda3559f4087","modified":1500447708000},{"_id":"themes/yilia/.git/objects/df/0a26095226209a22918020da0c9fb30269eab9","hash":"7127284bd358bf390222fda991f70f61ac48ed70","modified":1500447708000},{"_id":"themes/yilia/.git/objects/e3/e1d24d42b3f65f8f73cacfa8e5f964c7d9d6b1","hash":"13ba0abc0825370caf9cd15a971e8f9416ac5ac1","modified":1500447708000},{"_id":"themes/yilia/.git/objects/b1/7ec9cfc7cc7c440c3d1e5670b9e2af73b59eee","hash":"e41f3f76d58f92d47be1ecd3933fc5088c169853","modified":1500447708000},{"_id":"themes/yilia/.git/objects/34/8725f1f342a74fec239a0bc882fde5444c40a7","hash":"4d931a6d26c8ced0427006afa45d03d26be3c17f","modified":1500447699000},{"_id":"themes/yilia/.git/objects/a1/add7f9eef00944c6757cfc3cfdc916d83496ae","hash":"34fc0a9f9d9a49124777e37fb2709faf0f7e7125","modified":1500447699000},{"_id":"themes/yilia/.git/objects/ed/068a77d694cb9c07c61872a46c1be3f5d3a7a7","hash":"177f8d1708e6a2f1f7312ad73dfa5b171678504b","modified":1500621497000},{"_id":"themes/yilia/.git/objects/e9/c04f35e325de9b8be02b215348a05b19828da7","hash":"23eaca8eb3860e8dc1160be1df12d25a3fd84c9b","modified":1500447699000},{"_id":"themes/yilia/.git/objects/pack/pack-4a69d2b0ca35f096f2341bc051ec83a248aca039.idx","hash":"aa9dfee43bbb960f6511e54f43a6712f1e81866a","modified":1500447214000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1499958683000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1499958683000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1499958683000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1499958683000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1499958683000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1499958683000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1499958683000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1499958683000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1499958683000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1499958683000},{"_id":"themes/yilia/.git/objects/b2/5ec5e95cade7564362a4ef0f09e391968a6e64","hash":"a263c14a4e2c64832bbf7dbdcc9b7b48c3c53736","modified":1500621489000},{"_id":"themes/yilia/.git/objects/e5/67ac4c14d5dc10966d0d180d9298558387d273","hash":"ed80984ca234396e3e1accdafa24a6266aa05d64","modified":1500621489000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1499958683000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1499958683000},{"_id":"source/_posts/2015圆明园荷花节/psb1.jpeg","hash":"d80b5ed042dacf934c5ad1b9affbb56ba0ae7fb5","modified":1493108200000},{"_id":"themes/yilia/.git/refs/remotes/origin/master","hash":"fe7daf0b3651cbd11c1412a322d246658383b4e8","modified":1500621519000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1500447214000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"41e7646916cf1926f8430f40ee88201461a259e9","modified":1500621497000},{"_id":"source/_posts/离职出行/20160925152825_IMG_6947.JPG","hash":"e663186274e4c407629afd14c5bd4af0d888f6f8","modified":1493114712000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610081259_IMG_6245.JPG","hash":"be8e8a8a757928733830cff4537802921ad2091f","modified":1493113410000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"408922f40a87d85fb117f3350056b184fb088a20","modified":1500447214000},{"_id":"source/_posts/离职出行/20160924145228_IMG_6849.JPG","hash":"e9a703a6e58b14876405a3b37403831d0d335ea3","modified":1493114713000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610091441_IMG_6323.JPG","hash":"cc389e61386b83f5ce18246b594478e423274d5c","modified":1493113411000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/master","hash":"eff4927a3b83170b89f61125baf6b002ae365151","modified":1500621519000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610075842_IMG_6219.JPG","hash":"ae26053b2b8f4dee67bab69acbe225a80d8076fd","modified":1493113410000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610080912_IMG_6235.JPG","hash":"fbeb762f3541d0954ad578558492f48a7abba4d2","modified":1493113408000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610082906_IMG_6261.JPG","hash":"e6e7e11f4f6de850ddf925d24896cfcd5944d14c","modified":1493113410000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610102213_IMG_6353.JPG","hash":"a2f14eb6fbfcf1fbcc084bd90a8d614030e39311","modified":1493113408000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610110010_IMG_6396.JPG","hash":"148a5f5bdb7ace4ade1791da2dba67db50122792","modified":1493113409000},{"_id":"source/_posts/2015圆明园荷花节/psb4.jpeg","hash":"2c5af6e38cd60180eb8ac7fa98a2a83f44758942","modified":1493108216000},{"_id":"source/_posts/离职出行/20160922125643_IMG_6744.JPG","hash":"738851571a28e4937d0735f9cc680557346d7676","modified":1493114713000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610083541_IMG_6276.JPG","hash":"b9d92e6e71c5984caa23d897fb5669c8981cf33d","modified":1493113410000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610095757_IMG_6325.JPG","hash":"c579d0733c4491c8fb0fa1301a0100fe1e67d07b","modified":1493113412000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610101355_IMG_6343.JPG","hash":"772d9ac49f90f8dd67738d41ab7b72ebd9c9015d","modified":1493113411000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610104345_IMG_6371.JPG","hash":"7d6673579bc361052e2118c0515af3c1ece7f055","modified":1493113411000},{"_id":"source/_posts/2015圆明园荷花节/psb5.jpeg","hash":"7010bd8e83d1fa3fd1e7a246ab83d55540b5fcf4","modified":1493108220000},{"_id":"source/_posts/离职出行/20160922120143_IMG_6706.JPG","hash":"294bb67485e89b5cee6091cdf3352a1bb719a6b5","modified":1493114713000},{"_id":"source/_posts/离职出行/20160922124759_IMG_6741.JPG","hash":"00469dd829d541504ca3debc57fa56ae6c80e8b1","modified":1493114714000},{"_id":"source/_posts/离职出行/20160925170135_IMG_6970.JPG","hash":"96962932e3cb18e1639cce9df43728cb3c07ffd2","modified":1493114711000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610075354_IMG_6200.JPG","hash":"c81a26d766979f0203d1c91427134fc9c315adbb","modified":1493113410000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610100357_IMG_6326.JPG","hash":"b677c649cb3266d7fc355ae80f99e3d714c8446f","modified":1493113412000},{"_id":"source/_posts/离职出行/20160922112951_IMG_6692.JPG","hash":"ec1d1491a43959fecc40b90c2222f77e24239966","modified":1493114714000},{"_id":"source/_posts/离职出行/20160922124730_IMG_6740.JPG","hash":"883d7adf7b2fc2cd0f3b2f1927616ab5a89cbe86","modified":1493114714000},{"_id":"source/_posts/离职出行/20160924141958_IMG_6827.JPG","hash":"7164082cdc1c5bdb3cfb5dcef4902353df4bfde5","modified":1493114713000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610075557_IMG_6209.JPG","hash":"43e703a6c743a380d7060f11fb001a9b85edeffe","modified":1493113412000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610084538_IMG_6283.JPG","hash":"ccdb0d7a49b927a0a557ed2882d3e67127280c8e","modified":1493113411000},{"_id":"source/_posts/离职出行/20160922132332_IMG_6762.JPG","hash":"6899f4ac278cce136048554d395fbc447860d1e4","modified":1493114714000},{"_id":"source/_posts/离职出行/20160925140452_IMG_6864.JPG","hash":"2c7e99b3e05bc8c038c7386a859170af81db1b0f","modified":1493114715000},{"_id":"source/_posts/离职出行/20160922124939_IMG_6743.JPG","hash":"a9473be092dcf78510bd9d926143a44b2f18b959","modified":1493114713000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610101211_IMG_6337.JPG","hash":"7230d86300f9c0499507ac88aca12025b26274f2","modified":1493113408000},{"_id":"source/_posts/离职出行/20160924155639_IMG_6859.JPG","hash":"5a773e00d48fe86d3b2af11206b5c6727c8063cd","modified":1493114712000},{"_id":"source/_posts/为什么每一个IT人员应该有一把人体工学电脑椅/1918606_151944_1.gif","hash":"0a558cb121714b05daf2673edf86b45609cb890c","modified":1494844142000},{"_id":"source/_posts/2016公司清明节坝上草原/20160610101300_IMG_6342.JPG","hash":"fc39fea0b5ea8172840713b5cd3430b9da2a48bf","modified":1493113408000},{"_id":"source/_posts/离职出行/20160922185501_IMG_6785.JPG","hash":"53bef96b2565169f1d6723580b6a70edc8af1fde","modified":1493114715000},{"_id":"source/_posts/离职出行/20160925185719_IMG_6996(1).JPG","hash":"0ae7baafaf3ed3a9d34378eb61a3d555b117403c","modified":1493114711000},{"_id":"source/_posts/2015圆明园荷花节/psb3.jpeg","hash":"bbd0d8d23cea5c6136454a6b94239cf932a09dc8","modified":1493108211000},{"_id":"source/_posts/2015圆明园荷花节/psb2.jpeg","hash":"9f4b48a3f872e86bb604fd09f38fba40cf25cd09","modified":1493108206000},{"_id":"source/_posts/2015圆明园荷花节/psb6.jpeg","hash":"33d745b867503d31865b00e6e237d74b508b3cc0","modified":1493108224000},{"_id":"source/_posts/2015圆明园荷花节/psb.jpeg","hash":"f6f6edd5fb92833d845b4d938ea3b956c3239d24","modified":1493108174000},{"_id":"source/_posts/2015圆明园荷花节/psb7.jpeg","hash":"e5cd925b599ea52b1fc723908c425e237a357bc0","modified":1493108228000},{"_id":"themes/yilia/.git/objects/pack/pack-4a69d2b0ca35f096f2341bc051ec83a248aca039.pack","hash":"2b1e7912340fd292f00d20d26276ce28840fd79c","modified":1500621489000},{"_id":"public/content.json","hash":"f3d2fb70a247cc9af5e6b93dbe50453260f62709","modified":1502778454499},{"_id":"public/about/index.html","hash":"7a7c071522e2f3cdaada2a58eac6fe7cdcef9a5c","modified":1502382767009},{"_id":"public/categories/index.html","hash":"8abfece963a008c7175dcc355150a7e74d880cf6","modified":1502382768644},{"_id":"public/tags/index.html","hash":"3ce9813ffd82201789a59bb5532c4315a59dd84d","modified":1502382768832},{"_id":"public/2017/04/21/番茄工作法使用说明书/index.html","hash":"6f35fb1a20440a3eaef701a0b5375b8e4dcb38be","modified":1502778461277},{"_id":"public/2017/04/21/如何知道下载好的aosp版本/index.html","hash":"00f3cfc4fc3bcbd377460f5bb06451354933a3fc","modified":1502778461279},{"_id":"public/2017/04/21/搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼/index.html","hash":"e5dc3860ebee8089bbef3be3146b5595e2ee5124","modified":1502778461279},{"_id":"public/2017/04/21/为什么我在工作线程刷新UI没报错/index.html","hash":"5696ff1a661d9de7b16a88f1075b2b07b1e9147d","modified":1502778461268},{"_id":"public/2017/04/21/Android性能优化之内存优化/index.html","hash":"6008b8fed42c0e31831fb6f086ae659ef3a9b4fe","modified":1502778461279},{"_id":"public/2017/04/21/Android源码下载/index.html","hash":"58ce997ef6cfd016ef3db926440fe1da0a110e6a","modified":1502778461281},{"_id":"public/2017/04/21/Android性能优化之耗电优化/index.html","hash":"7bbf63b7781507be1783e8c67ca5331d87651747","modified":1502778461180},{"_id":"public/2017/04/21/UML--类图详解/index.html","hash":"ccc8e24db22de3b4ffbc09f35484ea20e0e767ad","modified":1502778461282},{"_id":"public/2017/04/21/详解设计模式之简单工厂模式/index.html","hash":"f83979fc9ec8e470f815297b34090d8570b7783d","modified":1502778461283},{"_id":"public/2017/04/21/详解设计模式之单例模式/index.html","hash":"3e48983cff0d0bd6e1bc3b03b5772793114b32cf","modified":1502778461283},{"_id":"public/2017/04/21/关于家庭网络宽带、路由及上网设备那些事/index.html","hash":"51483c0e5583be6e0b2ffc4ed2abf3d2f8a965fc","modified":1502778461283},{"_id":"public/2017/04/21/关于家庭网络宽带、路由及上网设备那些事---后续篇/index.html","hash":"95d2b5a31e0a0eaa1b7efcfed62229193b349e20","modified":1502382768836},{"_id":"public/2017/04/22/Mac版eclipse中每次重启电脑后字体自动变小/index.html","hash":"5da31d3eb90acd5d25c1a2fcd86e3bb18c880650","modified":1502778461284},{"_id":"public/2017/04/22/osx如何安装Homrbrew/index.html","hash":"f340ae7a40789cf777027996777b9c3dfd14a856","modified":1502778461284},{"_id":"public/2017/04/22/osx下如何使用SublimeText阅读Android系统源码/index.html","hash":"e89e332bf561cc084b195616cb3565d225f2281b","modified":1502778461283},{"_id":"public/2017/04/22/osx下pip3安装matplotlib时The following required packages can not be built freetype/index.html","hash":"ea60b6efcca197eb5ef1e128398295ae31a05a1a","modified":1502778461284},{"_id":"public/2017/04/22/Python入门系列(0) OSX系统下Python3的配置与安装/index.html","hash":"50871cfea4a7ca2dd81de14095a939204d985551","modified":1502778461286},{"_id":"public/2017/04/22/pycharm黄线问题/index.html","hash":"6e19a8a9ea850cfb39a256fea2fe14351fdfd747","modified":1502778461285},{"_id":"public/2017/04/22/Python入门系列(1) 如何使用Sublime text开发Python/index.html","hash":"627d3e630da6a15722f5ae52aa002c7ee29ee23e","modified":1502778461284},{"_id":"public/2017/04/22/Python入门系列(2) 字符串、变量和简单数据类型的上手/index.html","hash":"fdc5446cd11516c938af29e6f8dd3f05bb9de634","modified":1502778461283},{"_id":"public/2017/04/22/使用Sublime text编译python3时中文打印异常问题/index.html","hash":"52faa3e0a109cdc2f49457470bd2ce1933fd8d0e","modified":1502778461285},{"_id":"public/2017/04/23/30分钟搭建自己的网站/index.html","hash":"dfe6586d8d3f8ad56c01b1183b3e36319cef0dab","modified":1502778461285},{"_id":"public/2017/04/25/Android开发之JNI深入解析/index.html","hash":"57344902d0a76a8c2146e8bbe947a3cbff9416ff","modified":1502382768839},{"_id":"public/2017/04/25/hexo本地图片发布后不能显示的问题/index.html","hash":"6c2edfa93bce65e5df77eada1b767c1479443df8","modified":1502382768839},{"_id":"public/2017/04/25/2015圆明园荷花节/index.html","hash":"ce5f13803f1aa4167e9e929d365f39142156aff3","modified":1502382768840},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/index.html","hash":"1ec1acd2138816bce4c085ce45b85f40457875de","modified":1502382768840},{"_id":"public/2017/04/27/Android进程和线程/index.html","hash":"55aa7840c3ada5933a1c2f2676f780e8289e38f0","modified":1502382768840},{"_id":"public/2017/05/03/Java字符串压缩去重/index.html","hash":"2677b8283f57a4c844434771b467a7f020802d15","modified":1502382768904},{"_id":"public/2017/04/25/2016公司清明节坝上草原/index.html","hash":"3ca2182d465a05f87bb936bc2d3677d097e32cd7","modified":1502382768916},{"_id":"public/2017/05/03/算法查找之二分查找/index.html","hash":"6f4bdbba469a7ef2a707441d5130df906615cfde","modified":1502382768918},{"_id":"public/2017/05/04/Android性能优化之UI优化/index.html","hash":"b55ca5ed651c8f5c0b0e6c1055716d872042494e","modified":1502382768918},{"_id":"public/2017/05/05/Android关于Activity生命周期误解/index.html","hash":"5e7b90ab8b9f11a0cbe09ca6468a65b8b79ad313","modified":1502382768918},{"_id":"public/2017/05/10/Android网络框架执行流程分析/index.html","hash":"ad35c22284637977e75d3ccb1faefea210672616","modified":1502382768918},{"_id":"public/2017/05/10/详解设计模式之建造者模式/index.html","hash":"058b1c25779681746e4a053b0966ae22fb91d561","modified":1502382768919},{"_id":"public/2017/05/10/详解设计模式之责任链模式/index.html","hash":"ec36b2d36bf9904e9283035bf9f3628a76e17192","modified":1502382768919},{"_id":"public/2017/05/10/农夫带着狼、羊和白菜过河问题/index.html","hash":"426e6446e4b75ca951a473cffef9ef3277f3055b","modified":1502382768919},{"_id":"public/2017/05/11/四个人过桥问题/index.html","hash":"6d626ef18545994871b20ff42cedf7e8f27e71b4","modified":1502382768919},{"_id":"public/2017/04/25/2016圆明园荷花节/index.html","hash":"27e378557650acd5ce88aaca890e68baac8add48","modified":1502382768919},{"_id":"public/2017/05/03/算法排序之交换排序/index.html","hash":"ef2380e76c3f9ea94dbf6b85e374df59dfb9f2fc","modified":1502382768919},{"_id":"public/2017/05/16/算法排序之快速排序/index.html","hash":"c68ebd9f1e2f138728a0b2ed1af6c5fd91c6f77e","modified":1502382768919},{"_id":"public/2017/05/17/设计一个有获取元素最小值getMin的栈/index.html","hash":"d86db50d8e9718289a63e0d84b79c6e39776107f","modified":1502382768920},{"_id":"public/2017/05/18/两个栈实现队列功能/index.html","hash":"6902f5c020d10ace9386f429c32a9de36f63a31d","modified":1502382768920},{"_id":"public/2017/05/02/hexo博客换电脑后怎么办/index.html","hash":"34ebb6bd43e4b5c23e9fbd879e5ed8ea4cdd623c","modified":1502382768920},{"_id":"public/2017/05/25/算法之朴素模式匹配/index.html","hash":"4d24a933663bbdcbf5bb492c084a234c9386d4e5","modified":1502382768921},{"_id":"public/2017/06/26/Python入门系列-3-元组、列表和字典/index.html","hash":"c9fdb40568a7b3c7ab0d000fc7be68ba42dfe777","modified":1502382768921},{"_id":"public/2017/06/30/Java知识点/index.html","hash":"e9f9b1c85f0a9232e2d44712aa9a97b5a6764521","modified":1502382768921},{"_id":"public/2017/07/01/Mac终端光标变成粗体/index.html","hash":"993a1d0da3f78b56fe2d0aecd05e24d6a336b97f","modified":1502382768921},{"_id":"public/2017/07/01/hexo文章tags添加多标签/index.html","hash":"40e490fc89644e4695f669bf3f725acb715ce7c7","modified":1502382768922},{"_id":"public/2017/07/13/Mac下配置adb/index.html","hash":"d8a980ca1c0bf128877d47252d0bdd058d78c1f4","modified":1502382768922},{"_id":"public/2017/07/14/hexo更换主题及配置/index.html","hash":"e5e08d5dd32b2d29781ef654cb81ff48d6c70ced","modified":1502382768922},{"_id":"public/2017/06/27/Django创建数据表时syncdb提示Unknown-command：‘syncdb/index.html","hash":"2b1acbc9e8b62e931690e4f129539d1fd979e17a","modified":1502382768922},{"_id":"public/2017/07/17/关于Intent那些事/index.html","hash":"9b97bdae046344316b73305e83386c652ba1ebd4","modified":1502382768922},{"_id":"public/2017/07/19/为什么Android中很多int常量使用十六进制表示/index.html","hash":"dab0b9a17c3f0016701b4da0d0f070715e6d87b0","modified":1502382768922},{"_id":"public/2017/07/19/为什么相对布局比线性布局性能低/index.html","hash":"4711d667b13ee945d51c861ff920fad3e6af8ce3","modified":1502382768922},{"_id":"public/2017/07/19/浅谈Android性能优化系列-0-之为什么需要性能优化/index.html","hash":"e06b65919949a1735a16f7bc439e1dd3f4a184bb","modified":1502382768923},{"_id":"public/2017/07/21/用Python提取excel中有用数据/index.html","hash":"0bf1fbc5ab58b0301f3b1c3ee8bde9b54e9a720c","modified":1502382768923},{"_id":"public/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/index.html","hash":"553634dcf154898dd21c19107e193e2d4ef5488a","modified":1502382768923},{"_id":"public/2017/07/21/Java-wait，notify和notifyAll使用分析/index.html","hash":"b5b3ee272711851cdb761f05fca1bbd06ea91fc7","modified":1502382768923},{"_id":"public/2017/07/24/浅谈Android事件传递机制/index.html","hash":"5cff1286260186042608f0e740397d29fd149b34","modified":1502382768923},{"_id":"public/2017/07/26/Android各版本新功能及区别/index.html","hash":"5463dd157482b3b18ac82b0fcae1e728543fc11a","modified":1502382768923},{"_id":"public/2017/07/26/Python自动化之hexo自动发布和提交源码/index.html","hash":"f6a1c89126acde39b499264f7027cee9d90e7b0f","modified":1502382768923},{"_id":"public/2017/07/26/垃圾回收机制-关于GC/index.html","hash":"24a91e9b06e9966d7da1a10ea0458aae34d8dfbf","modified":1502382768924},{"_id":"public/2017/07/27/反转字符串/index.html","hash":"c1a5564c59a5cc8481ab92c13c043ed467b01f88","modified":1502382768924},{"_id":"public/2017/07/28/求解1到n中1的个数/index.html","hash":"6c2fc8e4838b9e58decf23a6b60c1fd80bbf7ee7","modified":1502382768924},{"_id":"public/2017/07/29/Mac系统下载文本都是打开都是乱码/index.html","hash":"0d587bd231c2368cea43fb93ada3feb63a0f9cea","modified":1502382768924},{"_id":"public/2017/07/14/hexo添加网易云音乐播放器/index.html","hash":"88a284a7faca94126c230c162c301290a637ab9d","modified":1502382768924},{"_id":"public/2017/07/29/Python读取文件出现UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte异常/index.html","hash":"6ab70cdbe0d68f60b56e6ab04b7cb1f1133c00c2","modified":1502382768924},{"_id":"public/2017/07/31/typeerror-module-init-takes-at-most-2-arguments-3-given/index.html","hash":"d09ed31b345ac5bd53a2501d5e3db94a56c7520a","modified":1502382768924},{"_id":"public/2017/07/29/WordCloud不显示中文只显示方框问题/index.html","hash":"4e72c465798f66b318ce1f27a4afaac8f8f909c6","modified":1502382768925},{"_id":"public/2017/08/01/Mac系统中希捷移动硬盘NTFS格式只能读/index.html","hash":"7502ff288b9b92e7577c59c2043daace6fdb2288","modified":1502382768925},{"_id":"public/2017/08/01/Python爬虫应该掌握哪些知识/index.html","hash":"45e90e9c0f759381fda024998bfaf7adb9c3c6df","modified":1502382768925},{"_id":"public/2017/08/01/Android屏幕适配/index.html","hash":"0e99c45654a1228adb012ea1c7b38426b67af14d","modified":1502382768925},{"_id":"public/2017/08/02/Selenium-ChromeDriver安装/index.html","hash":"771dacdb57fa689a1543364a62ce7f03573302bc","modified":1502382768925},{"_id":"public/2017/08/02/Python爬虫爬取简书首页文章-一/index.html","hash":"b0dfca2c43bcb99a74306b7e1f07839d4d8fe5a9","modified":1502382768925},{"_id":"public/2017/05/16/数学归纳法/index.html","hash":"db0425aad61cf3b3c4b996db0d68e0f7463474d5","modified":1502382768925},{"_id":"public/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/index.html","hash":"a9ad956eb513d3f7f2c88df7d9a1362b2f242f90","modified":1502382768925},{"_id":"public/2017/08/03/Gradle和Gradle-Plugin之间对应关系/index.html","hash":"e4819a09633b705ba4e0ee942e913986f64c1705","modified":1502382768926},{"_id":"public/2017/08/03/关于Canvas的一些概念/index.html","hash":"3121695f147ac52244ce07f6bcf1d50ba8a845eb","modified":1502382768926},{"_id":"public/2017/08/03/WireShark-the-capture-session-could-not-be-initiated-you-don-t-have-permission-to-capture-on-that-device-异常/index.html","hash":"bb58701f74e9e9857fc336ba12e42a1a8ef3a4fa","modified":1502382768926},{"_id":"public/2017/08/04/No-resource-identifier-found-for-attribute-roundIcon-in-package-android/index.html","hash":"9117b0a62683556de2991e70e1dbcd41ed485fc2","modified":1502382768926},{"_id":"public/2017/08/06/字符串前的r和u/index.html","hash":"b014471112e21625b78e90bda6ceea9c070b0f4c","modified":1502382768926},{"_id":"public/2017/08/06/Python入门系列(4)文件IO/index.html","hash":"dfa0b454816139d4ec7611dd8bd121397aa4d813","modified":1502382768926},{"_id":"public/2017/08/07/Python入门系列(5)：进程、线程和协程/index.html","hash":"8a8d89460c0431da81fd120ac7a5d2d18456166d","modified":1502382768927},{"_id":"public/2017/08/09/Python用qq邮箱发邮件/index.html","hash":"88d6fd86aba1d591b95e1dcb13c5ab7898c8454a","modified":1502382768927},{"_id":"public/2017/08/10/Java参数到底是值传递还是引用传递/index.html","hash":"a68ecfae8c7f05ecb3ab2c3acd1a56d34cb1a34a","modified":1502382768927},{"_id":"public/2017/08/01/Python第三方库没有代码快捷提示/index.html","hash":"e348ae9daf05f8125eb5fc436082837e455b5bc8","modified":1502382768927},{"_id":"public/archives/index.html","hash":"1fcfe1abfca4925f3f1787bc6a45fc0afb4bb74a","modified":1502778461286},{"_id":"public/archives/page/2/index.html","hash":"2c03abc35567a232b1048a20e1a5e867ac26a5ec","modified":1502778461286},{"_id":"public/2017/08/08/Python中-和-有什么意义/index.html","hash":"76777507a44688630117fe16c14a37039af62479","modified":1502382768928},{"_id":"public/archives/page/4/index.html","hash":"fe21ec70dfa50f7ab00e558107a987b1ab574027","modified":1502778461286},{"_id":"public/archives/page/5/index.html","hash":"b94208a7492d1743855c6573e4237100d8894dc9","modified":1502778461286},{"_id":"public/archives/page/6/index.html","hash":"27039a89d3248c9978f6722824a0600136ce5051","modified":1502778461287},{"_id":"public/archives/page/7/index.html","hash":"d7697d88c653c1170c769d94db7819fc58d97d38","modified":1502778461289},{"_id":"public/archives/page/8/index.html","hash":"05a3c9288bb84d2b579dc594d8aeb9aed9d81529","modified":1502778461290},{"_id":"public/archives/page/9/index.html","hash":"230e32af713ff2250e25d9abb070ca33a9284272","modified":1502778461290},{"_id":"public/archives/2017/index.html","hash":"8e3728ee0502cce841dbb34c5ac75b677c1bf7b8","modified":1502778461290},{"_id":"public/archives/2017/page/2/index.html","hash":"412352ac703fea6df5eead78c52ba125c7e8a912","modified":1502778461293},{"_id":"public/archives/2017/page/3/index.html","hash":"320a1a623a13b4fe8a603ba7fa43fdcf6df7e60c","modified":1502778461292},{"_id":"public/archives/2017/page/4/index.html","hash":"7100836fa15043dd596f55092f8e61fc99f1c26d","modified":1502778461290},{"_id":"public/archives/2017/page/5/index.html","hash":"d2245f7151a66a3bb9c81bac977659fcbeb48a25","modified":1502778461291},{"_id":"public/archives/2017/page/6/index.html","hash":"a8fb9cc6972267a3d8b4614ee3487efde7e39347","modified":1502778461291},{"_id":"public/archives/2017/page/7/index.html","hash":"ffd6b7077fcd04504d9f854e8b330ff0f49c5e68","modified":1502778461291},{"_id":"public/archives/2017/page/8/index.html","hash":"355a94eea9652932a3b2994f374e59c92dca76ef","modified":1502778461292},{"_id":"public/archives/2017/page/9/index.html","hash":"f1c5e7c263b343530b60bfa7e9f1aa43262f4442","modified":1502778461292},{"_id":"public/archives/2017/04/index.html","hash":"cf6d83b4ed0e5af48ba6864c53f47df4f615dca3","modified":1502778461292},{"_id":"public/archives/2017/04/page/2/index.html","hash":"e402ffa899e76de2b3a82d0763f245b0ec76b876","modified":1502778461293},{"_id":"public/archives/2017/04/page/3/index.html","hash":"395c725b89d37e02c73cf3a25a5dc8ce1a5ea1ef","modified":1502778461293},{"_id":"public/archives/2017/05/index.html","hash":"75dde1adae3e6accc8670e1289cc2225be942818","modified":1502382768932},{"_id":"public/archives/2017/05/page/2/index.html","hash":"359baa5a7ce3890357a69579e30a70d9223c180b","modified":1502382768932},{"_id":"public/archives/2017/06/index.html","hash":"c4c7ac15fbaf52040f88760259c8e07e37caaedf","modified":1502382768932},{"_id":"public/archives/2017/07/index.html","hash":"ce655b7075376b5a315d6b71385ba0ddd41baf85","modified":1502382768932},{"_id":"public/archives/2017/07/page/2/index.html","hash":"ceba5c794e906fb9fb109496213f8f624e2a7bb5","modified":1502382768932},{"_id":"public/archives/2017/07/page/3/index.html","hash":"eca505c1f99b4678963f0b73f931eabe007e16fa","modified":1502382768934},{"_id":"public/archives/2017/08/index.html","hash":"34e43ee3085d428587e4815b3c308ffa22dace17","modified":1502778461294},{"_id":"public/archives/2017/08/page/2/index.html","hash":"bbb077a1effe2bd422cf158f5abb6219d319f50c","modified":1502778461294},{"_id":"public/categories/生活/index.html","hash":"b12e290b5d8a66ba71c4183a88bbba1fbf92805d","modified":1502382768935},{"_id":"public/categories/网络/index.html","hash":"cefd8a812961a49404089fc292ae9a1a9e38d1ec","modified":1502382768935},{"_id":"public/categories/Android/index.html","hash":"c5c591d3dffd2c3db91ef79914cf4af0caf66553","modified":1502382768935},{"_id":"public/categories/Android/page/2/index.html","hash":"50a43796f00df7b2b55bf329aa5ef11b787254cb","modified":1502382768935},{"_id":"public/categories/Android/page/3/index.html","hash":"2bac081a394ad07273f2e8afec6d883673f50c21","modified":1502382768936},{"_id":"public/categories/Python/index.html","hash":"3d5deb741c13595e4da7289da9b531bc9a15e7e6","modified":1502778461298},{"_id":"public/categories/Python/page/2/index.html","hash":"712eafa95268591aa01325055739d4ce2709887f","modified":1502778461298},{"_id":"public/categories/Python/page/3/index.html","hash":"852c0382eda991cf6d521054f31510e620bda032","modified":1502778461298},{"_id":"public/categories/Java/index.html","hash":"e6949f5426ff3e0dff64cead98c062e13bdcecdf","modified":1502382768936},{"_id":"public/categories/工具/index.html","hash":"e65b51446e1ce5bfb70203d70daca0ba6a19a84f","modified":1502382768936},{"_id":"public/categories/Java/多线程/index.html","hash":"87cee160bb9656c9b63190e839762538b3aa4576","modified":1502382768936},{"_id":"public/categories/MAC/index.html","hash":"5cf50447014c4cf1bee612779d43cd1658c428f0","modified":1502382768936},{"_id":"public/categories/Mac/index.html","hash":"44997cd11b338769aa40299ab2fb7aace7400657","modified":1502382768937},{"_id":"public/categories/Mac/工具/index.html","hash":"3a2bda45896456375e07dcc4d7389df450ec8051","modified":1502382768937},{"_id":"public/categories/Python/自己写爬虫/index.html","hash":"536895fda78ebe87b396aea3f868af097d893c0c","modified":1502382768938},{"_id":"public/categories/设计模式/index.html","hash":"1db714543b5a1398d1c541f5467f320e999b0e04","modified":1502382768938},{"_id":"public/categories/Python/自动化/index.html","hash":"8e6ea289e1f3f59c78cc7f236d8a81f4a48d35b8","modified":1502382768938},{"_id":"public/categories/WireShakr/index.html","hash":"ac43c126661d82f9eb38b76c1282ab454149da29","modified":1502382768938},{"_id":"public/categories/Python/WordCloud/index.html","hash":"a66fa1eb825df24d23d8673bc8ca2c8eb5df64a5","modified":1502382768938},{"_id":"public/categories/WireShakr/网络/index.html","hash":"1c21ad0c093c640aeb283ca94ae49e65b66776d4","modified":1502382768939},{"_id":"public/categories/算法/index.html","hash":"712fa703a2be211f30ee46462a7e1942159447ec","modified":1502382768939},{"_id":"public/categories/职场杂谈/index.html","hash":"fc553e408938f63046955fc691067ce32e281643","modified":1502382768939},{"_id":"public/categories/Android/Java/index.html","hash":"5c99f578cc3e0c1cf7167a851e7e322cd4451d56","modified":1502382768939},{"_id":"public/categories/趣题/index.html","hash":"8928ef443b17ee5083446b9efe1a1c09572cbd1e","modified":1502382768939},{"_id":"public/categories/GC/index.html","hash":"acfff2ff36c16e05e9d473a97b47fe8eab6b7276","modified":1502382768939},{"_id":"public/categories/Android/源码解析/index.html","hash":"1207538b24ccb423759083555267d27101363f19","modified":1502382768939},{"_id":"public/categories/Java/算法/index.html","hash":"ebd07f4192f5276e32218780431decde47121f17","modified":1502382768939},{"_id":"public/categories/GC/Java/index.html","hash":"49a3de0eff1de6bfb8633e85a141908eaabead62","modified":1502382768939},{"_id":"public/categories/Android/性能优化/index.html","hash":"6be1aa4571d76a694f71b816e2137de803a1fdcb","modified":1502382768939},{"_id":"public/categories/程序员的数学/index.html","hash":"b9db411b506913f7ff6a8786f71374732fbb8622","modified":1502382768940},{"_id":"public/categories/Java/算法/趣题/index.html","hash":"ff39065b74b91aad8bcf552ea25ab5ca1e79171d","modified":1502382768940},{"_id":"public/categories/Python/excel/index.html","hash":"18fa8099fe2ef56119181558ec0ff4c030fac9e8","modified":1502382768940},{"_id":"public/categories/Python/excel/xlrd/index.html","hash":"84805b87e4720a053fc06785a2ed587b1363c876","modified":1502382768940},{"_id":"public/index.html","hash":"3e7ec8dac5a596646bd5d85d9db52ad4d4293dab","modified":1502786778334},{"_id":"public/page/2/index.html","hash":"73fbfe21473fb8a508335bd288a5eaac30cf1d52","modified":1502778461295},{"_id":"public/page/3/index.html","hash":"9b1ffbd2b7b40a40d8bf99bca9cb974238e82ff4","modified":1502778461296},{"_id":"public/archives/page/3/index.html","hash":"002c68b0d4ce712dd4a2239b4445bc998069763f","modified":1502778461286},{"_id":"public/2017/08/02/Python爬虫爬取简书首页文章-二/index.html","hash":"21da8daa8d2a16bb9132f913263dc0df6ef6c7ea","modified":1502382768940},{"_id":"public/page/6/index.html","hash":"fa05ff0fa2ef2ba5196c61bab68b1755cafa760d","modified":1502778461296},{"_id":"public/page/7/index.html","hash":"6dc5a938a71a4727ab514932e18d8994dbbb1b07","modified":1502778461296},{"_id":"public/page/8/index.html","hash":"eabc34f4b76dd6a5e14ad44580b3bf4342ba4c0c","modified":1502778461296},{"_id":"public/page/9/index.html","hash":"9bf37fdc2b16a048d167e61e9e8eb05877907693","modified":1502778461297},{"_id":"public/tags/生活/index.html","hash":"6194591a1644cd3520d932af784098ce93778f24","modified":1502382768941},{"_id":"public/tags/网络/index.html","hash":"b667726ce258668fc5981df2b3f2cae3d81a6153","modified":1502382768941},{"_id":"public/tags/Android/index.html","hash":"ce9ef9e0ec97692173f0af28d25724aaf29523cb","modified":1502382768941},{"_id":"public/tags/Android/page/2/index.html","hash":"ef982a00eba9bc64deecb5cc1e6e3edbea9ad78b","modified":1502382768942},{"_id":"public/tags/Android/page/3/index.html","hash":"0b96ca234c2f2b1122721ec8e9b67c50c5cf6ddf","modified":1502382768942},{"_id":"public/tags/Python/index.html","hash":"4b4ed5affe38990146257ab5bb4f9c299c191098","modified":1502778461297},{"_id":"public/tags/Python/page/2/index.html","hash":"08936930a51114d650bea4239961037c8a6f0840","modified":1502778461298},{"_id":"public/tags/Python/page/3/index.html","hash":"8cd0538762f017b172e06f9ef520720bba33becf","modified":1502778461297},{"_id":"public/tags/Java/index.html","hash":"959431d8a842e0a607eb2defd1db29fdaf977007","modified":1502382768942},{"_id":"public/tags/多线程/index.html","hash":"16b3ae129c1857d5ea3fe0dcf258754388871ac9","modified":1502382768942},{"_id":"public/tags/工具/index.html","hash":"62eb2211577bcdfb3eca988218b83eb9fea8dfcf","modified":1502382768942},{"_id":"public/tags/MAC/index.html","hash":"5f41ab450258e48ac95059eb7b8b45ebd6b07a9b","modified":1502382768951},{"_id":"public/tags/Mac/index.html","hash":"9416c438114b647d6a67664320beb2fe869ea572","modified":1502382768951},{"_id":"public/tags/自己写爬虫/index.html","hash":"0540df42322e0d3d898dc4191ca219992278e66c","modified":1502382768951},{"_id":"public/tags/设计模式/index.html","hash":"3cf8fa9e79a1e3d87aeb1e086af0f8d9bb7054e2","modified":1502382768951},{"_id":"public/tags/自动化/index.html","hash":"983878fba4b77e742c9709eefb9f711719d2400c","modified":1502382768951},{"_id":"public/tags/WireShakr/index.html","hash":"9a4212025543834d017399864370ff4d1373b621","modified":1502382768951},{"_id":"public/tags/WordCloud/index.html","hash":"d74e4f0b9b273678c1844ef9ea9ade800d733a4e","modified":1502382768952},{"_id":"public/tags/算法/index.html","hash":"0a36f74b6544ab5349a68f595d9ddcfdb253916f","modified":1502382768952},{"_id":"public/tags/职场杂谈/index.html","hash":"583946e72f887f9d7a00dda478544976d7bac051","modified":1502382768952},{"_id":"public/tags/趣题/index.html","hash":"9915d0e745ecc28d0fbe386674b61da7d8c04344","modified":1502382768952},{"_id":"public/tags/GC/index.html","hash":"96f83690ef559aa98bd04a8958c58b555498ce18","modified":1502382768952},{"_id":"public/tags/源码解析/index.html","hash":"513136c8bf05c7bfbc0b1b9a06d09d3f29886f1b","modified":1502382768952},{"_id":"public/tags/性能优化/index.html","hash":"371f077305e3380cafa92debca1256fea05e4b3b","modified":1502382768952},{"_id":"public/tags/程序员的数学/index.html","hash":"50f2ab51ab854a415395083b010c412532ce1f91","modified":1502382768952},{"_id":"public/tags/excel/index.html","hash":"fb6cfc63f8efe13a633a7319f2e5834438ee0875","modified":1502382768952},{"_id":"public/tags/xlrd/index.html","hash":"ad4bebab1a86e6767231f96315545d647034dfa8","modified":1502382768952},{"_id":"public/page/5/index.html","hash":"24a5c6991a7c6c95d675530858f34f04d00a06df","modified":1502778461295},{"_id":"public/page/4/index.html","hash":"9202f01e509f7384083b8888c2dc17600da7e315","modified":1502778461295},{"_id":"public/2017/08/10/使用sychronized注意事项/index.html","hash":"216201a6b9c7eff7bb3d226674da7b747f0f1835","modified":1502778461290},{"_id":"public/CNAME","hash":"4d6ad5941eb82092c055b8495d5fad1ea792e578","modified":1502382768958},{"_id":"public/image/weixin.png","hash":"8b79c4caf0cb7c2cee0f034c77e772021cb030ef","modified":1502382768958},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1502382768958},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1502382768958},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1502382768958},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1502382768958},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1502382768958},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1502382768958},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502382768958},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1502382768958},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502382768958},{"_id":"public/2017/04/25/2016圆明园荷花节/mmexport1493112393720.jpg","hash":"b1c2c8a583fc699b06538430993c80390125c446","modified":1502382768958},{"_id":"public/2017/04/25/2016圆明园荷花节/mmexport1493112396013.jpg","hash":"9c5244967054cafe06bc2c664121cd6168779993","modified":1502382768958},{"_id":"public/2017/05/10/Android网络框架执行流程分析/流程.png","hash":"6d4d1136ff206a04c1b74d6e30aae272a19eafa5","modified":1502382768958},{"_id":"public/2017/07/01/Mac终端光标变成粗体/设置光标.png","hash":"d9f678998217524e28f4b4e10fc1e1631fe30bce","modified":1502382768958},{"_id":"public/2017/04/25/2016圆明园荷花节/mmexport1493112402523.jpg","hash":"0d5f3956b59608b523bbe1f0c90570f01cd211d6","modified":1502382768958},{"_id":"public/2017/04/25/2016圆明园荷花节/mmexport1493112405316.jpg","hash":"80d99017a1536f5ebe650057bd03d7378070f78b","modified":1502382768958},{"_id":"public/2017/04/25/2016圆明园荷花节/mmexport1493112398170.jpg","hash":"96c4b59cffff416f920a82ca6b2e2b2e79cd3621","modified":1502382768958},{"_id":"public/2017/04/25/2016圆明园荷花节/mmexport1493112400267.jpg","hash":"1963b1b85ed7ca762f5c1e4f4761a70b63830436","modified":1502382768958},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png","hash":"23d4d41ee705d2a53d8823da0008b1a5cb49ef1c","modified":1502382769048},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.21.48.png","hash":"f6005c31a725e55955a612e075c980b638b3c801","modified":1502382769048},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.11.33.png","hash":"d3c407d21cca28dd6efe53c3c49c3b49636704ff","modified":1502382769048},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午9.57.43.png","hash":"3ca00b29315f30e0a6d715ed11aec4577b8ed4a7","modified":1502382769098},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 上午9.49.56.png","hash":"5a279dc5923c44e761031e95002e9a29bdbf0a9a","modified":1502382769098},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 上午12.26.47.png","hash":"41789b81c2fa5e7d6654d0a299aa844e4e3091d4","modified":1502382769098},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.57.46.png","hash":"9b4989e0bb92980672882b05ccf49e48c91fea9b","modified":1502382769098},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.14.36.png","hash":"68d7e653a1005d1e73024cb8ea8fbc2731777a79","modified":1502382769098},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午2.54.18.png","hash":"c238b16f19b4ebf921d74c2580755f38eb69ac35","modified":1502382769098},{"_id":"public/2017/07/17/关于Intent那些事/请求流程.png","hash":"4a4430ccabff6a5384fb3ae9bab09074c6f7161d","modified":1502382769301},{"_id":"public/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.34.46.png","hash":"f74cf134edf54b4e55d8df0e6c9b5d3630006665","modified":1502382769301},{"_id":"public/2017/05/10/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午5.17.19.png","hash":"a00d2b50faeaf760c57b3ea66651b1d7193c1d39","modified":1502382769301},{"_id":"public/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.45.37.png","hash":"8e07868047b036caacf006f004a3de013cb11c19","modified":1502382769301},{"_id":"public/2017/05/10/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午4.21.27.png","hash":"9dbdbd65bab90c5352370e5d36acfd07273f4145","modified":1502382769301},{"_id":"public/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/lint_result.png","hash":"cd1b100b0d2900caea67a2c0f6d0d6f4119cece7","modified":1502382769301},{"_id":"public/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/lint.png","hash":"9a73d022691f76e3470f412cb3d3cebd8887fcee","modified":1502382769301},{"_id":"public/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.33.13.png","hash":"36238ae43e26397f774c65c9ce10a5f83be59215","modified":1502382769302},{"_id":"public/2017/07/21/用Python提取excel中有用数据/创建项目.png","hash":"8527258d0cb28748ae005e669726e7ee9084f823","modified":1502382769302},{"_id":"public/2017/07/21/用Python提取excel中有用数据/doc文档内容.png","hash":"e1c13632c462af66e5b304cfb46a6efa5dca4e09","modified":1502382769302},{"_id":"public/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/安装包构成.png","hash":"4debd2c5045d54dbcc217729e6297bb24de35aa7","modified":1502382769302},{"_id":"public/2017/07/14/hexo更换主题及配置/打赏效果图.png","hash":"a69b43e4388a4431d63a1b0bc677ed6596c92283","modified":1502382769302},{"_id":"public/2017/07/21/用Python提取excel中有用数据/项目结果.png","hash":"3b8f5f092ba987271637276b530139d475fd48a0","modified":1502382769302},{"_id":"public/2017/07/14/hexo更换主题及配置/换主题.png","hash":"ec78501ea132e8e0d1f509b9268fe4262920fa57","modified":1502382769312},{"_id":"public/2017/07/14/hexo更换主题及配置/menu配置.png","hash":"84040ec3c162cf7afc540db55dc939cc0a7d1d71","modified":1502382769327},{"_id":"public/slider.096dc6.js","hash":"a8b66ef85d96616086ea6256e7288d0b5a2df56d","modified":1502382769455},{"_id":"public/2017/04/25/2016圆明园荷花节/mmexport1493112391191.jpg","hash":"2b68aeaac0f687cfa8368184faec7fdec3f97b94","modified":1502382769455},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午1.49.26.png","hash":"d2d08200b0aba19179903417a9bc338d421accc6","modified":1502382769457},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/1A94CD89-1BE9-46BC-9449-8B55EE34D741.png","hash":"2286365e7cffc5a42624d41ed0ff862d120a0780","modified":1502382769457},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.08.27.png","hash":"3cbadb4dfedf23cf807dad7061666894d3d321ca","modified":1502382769457},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.04.06.png","hash":"cdd90a2769b98ac3a51eb0c2167448bdc2c04ead","modified":1502382769457},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午10.29.17.png","hash":"bfc2e17ce7ec253dbb876f6f5f7b37541edfd893","modified":1502382769457},{"_id":"public/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午12.56.36.png","hash":"7547cac237c52b5a55c883117a4731e5fcc9a21c","modified":1502382769457},{"_id":"public/main.266c1c.css","hash":"a274acf63e17d906582eec3c0e3c00375ede5d3f","modified":1502382769458},{"_id":"public/mobile.906508.js","hash":"86e50eecba93644d6cf4f78fd4f9ff54a0ea82d5","modified":1502382769458},{"_id":"public/image/alipay.jpg","hash":"d9c8084299f79c67cecc01242f83554dab75f9e4","modified":1502382769864},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.19.06.png","hash":"b346dd2a664e6b306369fd760fd150df576f7404","modified":1502382769869},{"_id":"public/2017/07/14/hexo添加网易云音乐播放器/音乐界面.png","hash":"c1baed64e509ea400a9b8b040a0489902ae9e83e","modified":1502382769878},{"_id":"public/2017/07/14/hexo更换主题及配置/模块缺失.png","hash":"bb4aa7054a8956bb67986ee2d9e151c1894c8fe1","modified":1502382769878},{"_id":"public/2017/07/14/hexo更换主题及配置/关于我.png","hash":"2faad470f45d51d919d5e66c4fdb0bd8a0be0a76","modified":1502382769878},{"_id":"public/main.266c1c.js","hash":"59ccafbd45d28c397a8a901152ef5e196077e4f4","modified":1502382769880},{"_id":"public/image/avatar.jpg","hash":"23e19c88c7a3a432c3b6c77a4e3598af11baeece","modified":1502382769921},{"_id":"public/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.22.23.png","hash":"50622ee73aff94b566796ec4f45a0d4fdb8b4405","modified":1502382769921},{"_id":"public/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/58f074a8N70fcfb6a.jpg","hash":"52a75130e228a32d037ec4dbec556c01c26e5fa9","modified":1502382769922},{"_id":"public/2017/04/25/2015圆明园荷花节/psb1.jpeg","hash":"d80b5ed042dacf934c5ad1b9affbb56ba0ae7fb5","modified":1502382770355},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610081259_IMG_6245.JPG","hash":"be8e8a8a757928733830cff4537802921ad2091f","modified":1502382770382},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610091441_IMG_6323.JPG","hash":"cc389e61386b83f5ce18246b594478e423274d5c","modified":1502382770395},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610080912_IMG_6235.JPG","hash":"fbeb762f3541d0954ad578558492f48a7abba4d2","modified":1502382770399},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610075842_IMG_6219.JPG","hash":"ae26053b2b8f4dee67bab69acbe225a80d8076fd","modified":1502382770399},{"_id":"public/2017/04/25/2015圆明园荷花节/psb4.jpeg","hash":"2c5af6e38cd60180eb8ac7fa98a2a83f44758942","modified":1502382770403},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610082906_IMG_6261.JPG","hash":"e6e7e11f4f6de850ddf925d24896cfcd5944d14c","modified":1502382770403},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610102213_IMG_6353.JPG","hash":"a2f14eb6fbfcf1fbcc084bd90a8d614030e39311","modified":1502382770404},{"_id":"public/2017/04/25/2015圆明园荷花节/psb5.jpeg","hash":"7010bd8e83d1fa3fd1e7a246ab83d55540b5fcf4","modified":1502382770432},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610083541_IMG_6276.JPG","hash":"b9d92e6e71c5984caa23d897fb5669c8981cf33d","modified":1502382770432},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610110010_IMG_6396.JPG","hash":"148a5f5bdb7ace4ade1791da2dba67db50122792","modified":1502382770433},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610104345_IMG_6371.JPG","hash":"7d6673579bc361052e2118c0515af3c1ece7f055","modified":1502382770434},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610095757_IMG_6325.JPG","hash":"c579d0733c4491c8fb0fa1301a0100fe1e67d07b","modified":1502382770436},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610101355_IMG_6343.JPG","hash":"772d9ac49f90f8dd67738d41ab7b72ebd9c9015d","modified":1502382770437},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610100357_IMG_6326.JPG","hash":"b677c649cb3266d7fc355ae80f99e3d714c8446f","modified":1502382770442},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610075354_IMG_6200.JPG","hash":"c81a26d766979f0203d1c91427134fc9c315adbb","modified":1502382770445},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610075557_IMG_6209.JPG","hash":"43e703a6c743a380d7060f11fb001a9b85edeffe","modified":1502382770445},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610084538_IMG_6283.JPG","hash":"ccdb0d7a49b927a0a557ed2882d3e67127280c8e","modified":1502382770615},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610101211_IMG_6337.JPG","hash":"7230d86300f9c0499507ac88aca12025b26274f2","modified":1502382770639},{"_id":"public/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/1918606_151944_1.gif","hash":"0a558cb121714b05daf2673edf86b45609cb890c","modified":1502382770656},{"_id":"public/2017/04/25/2016公司清明节坝上草原/20160610101300_IMG_6342.JPG","hash":"fc39fea0b5ea8172840713b5cd3430b9da2a48bf","modified":1502382770660},{"_id":"public/2017/04/25/2015圆明园荷花节/psb2.jpeg","hash":"9f4b48a3f872e86bb604fd09f38fba40cf25cd09","modified":1502382770782},{"_id":"public/2017/04/25/2015圆明园荷花节/psb3.jpeg","hash":"bbd0d8d23cea5c6136454a6b94239cf932a09dc8","modified":1502382770782},{"_id":"public/2017/04/25/2015圆明园荷花节/psb6.jpeg","hash":"33d745b867503d31865b00e6e237d74b508b3cc0","modified":1502382770787},{"_id":"public/2017/04/25/2015圆明园荷花节/psb7.jpeg","hash":"e5cd925b599ea52b1fc723908c425e237a357bc0","modified":1502382770796},{"_id":"public/2017/04/25/2015圆明园荷花节/psb.jpeg","hash":"f6f6edd5fb92833d845b4d938ea3b956c3239d24","modified":1502382771166},{"_id":"source/_posts/Python操作xml.md","hash":"4864504b4995603342ef0753186f48b77d26930f","modified":1502786746000},{"_id":"source/_posts/Python使用MD5.md","hash":"6128e8a1f6072d110df578a4d8b162d32f463ff7","modified":1502616508000},{"_id":"source/_posts/bytes和str转换.md","hash":"4d78563283b61039ab375941595d4ae4d6023f22","modified":1502615762000},{"_id":"public/2017/08/13/bytes和str转换/index.html","hash":"a1812c184044ad9fbd7de1b47f747132764d7332","modified":1502778461312},{"_id":"public/2017/08/13/Python操作xml/index.html","hash":"8b1861101aae70e779a3ca30ab8b5da329eef421","modified":1502786778291},{"_id":"public/2017/08/13/Python使用MD5/index.html","hash":"701d7945a7e997a7205fd72703b9d906ffc60a62","modified":1502778461312},{"_id":"public/archives/page/10/index.html","hash":"22fc243b1717d38e4951692721279811f0a7cca8","modified":1502778461313},{"_id":"public/archives/2017/page/10/index.html","hash":"993a3ed4297d796776547dcc2c0009d7855e7d53","modified":1502778461313},{"_id":"public/archives/2017/08/page/3/index.html","hash":"1373e23e30e3c75099fd26c3d18e7b376ae937be","modified":1502778461313},{"_id":"public/page/10/index.html","hash":"620fe44bb5564f14be758b68c8c3c82b08cdacfd","modified":1502778461313}],"Category":[{"name":"生活","_id":"cj66nwj7q0004wh9ci2ncsbuj"},{"name":"网络","_id":"cj66nwj9r000awh9c2ijq2i1e"},{"name":"Android","_id":"cj66nwjbo000hwh9c21q3l849"},{"name":"Python","_id":"cj66nwjci001ewh9cu9m4idgk"},{"name":"Java","_id":"cj66nwjcs001pwh9ceqcv46lv"},{"name":"工具","_id":"cj66nwjdm002dwh9csy08ys7q"},{"name":"多线程","parent":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjdv002lwh9cx8dx0ssr"},{"name":"MAC","_id":"cj66nwje0002twh9c36i7kck7"},{"name":"Mac","_id":"cj66nwjec0034wh9cqbtqbz36"},{"name":"工具","parent":"cj66nwjec0034wh9cqbtqbz36","_id":"cj66nwjes003gwh9ct40r00y1"},{"name":"自己写爬虫","parent":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjfd003ywh9c1aa12h36"},{"name":"设计模式","_id":"cj66nwjga004ewh9cb7uwghww"},{"name":"自动化","parent":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjgh004mwh9c8snxv8p3"},{"name":"WireShakr","_id":"cj66nwjgt004uwh9ck50nng15"},{"name":"WordCloud","parent":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjh40055wh9cdsbpb9p4"},{"name":"网络","parent":"cj66nwjgt004uwh9ck50nng15","_id":"cj66nwjhp005kwh9cdll8q344"},{"name":"算法","_id":"cj66nwjhy005xwh9c0fhxenhk"},{"name":"职场杂谈","_id":"cj66nwji90068wh9cto2f4g3f"},{"name":"Java","parent":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjig006gwh9cq5aidrqm"},{"name":"趣题","_id":"cj66nwjjb006twh9cxih4ju1y"},{"name":"GC","_id":"cj66nwjjr007cwh9ctachpdfp"},{"name":"源码解析","parent":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjjx007kwh9cdrteifcp"},{"name":"算法","parent":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjk4007swh9cpupajgjl"},{"name":"Java","parent":"cj66nwjjr007cwh9ctachpdfp","_id":"cj66nwjku0088wh9ci75p3gef"},{"name":"性能优化","parent":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjl2008jwh9ctn6u85us"},{"name":"程序员的数学","_id":"cj66nwjl9008rwh9ccdmvrgi4"},{"name":"趣题","parent":"cj66nwjk4007swh9cpupajgjl","_id":"cj66nwjlf008ywh9cgcb8vdof"},{"name":"excel","parent":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjli0093wh9c53ga0s23"},{"name":"xlrd","parent":"cj66nwjli0093wh9c53ga0s23","_id":"cj66nwjlk009fwh9cd3iefjvt"}],"Data":[],"Page":[{"title":"关于我","date":"2017-04-22T09:00:42.000Z","_content":"\n>一个从运维转战开发的程序猿。2012年因为兴趣自学Android。\n\n#### 我的经历\n- 2010年专科毕业\n- 2011年，财政局做了一年的数据维护\n- 2013年，做了一年的IPTV Android机顶盒开发\n- 2014年3-6月，做了三个月政府审查上报类项目Android客户端，负责框架搭建\n- 2014年9月到2016年10月，做了两年Android IM即时通讯APP聊天功能开发及维护并各种性能优化。\n- 自学了一段时间的Python，发现Python代码简洁，功能强大，有点爱不释手的感觉\n\n#### 自我评价\n- 热爱编程，喜欢看书自我驱动型学习，\n- 热爱户外，喜欢和驴友徒步穿越\n- 喜欢摄影，喜欢用镜头留住精彩的瞬间\n\n#### 联系我\n\nQQ:\t840418528\nEmail:\tsongjlforever@foxmail.com\n\n#### 我的词云\n\n![我的词云](http://othg5ggzi.bkt.clouddn.com/%E6%88%91%E7%9A%84%E8%AF%8D%E4%BA%91.png)\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-04-22 17:00:42\n---\n\n>一个从运维转战开发的程序猿。2012年因为兴趣自学Android。\n\n#### 我的经历\n- 2010年专科毕业\n- 2011年，财政局做了一年的数据维护\n- 2013年，做了一年的IPTV Android机顶盒开发\n- 2014年3-6月，做了三个月政府审查上报类项目Android客户端，负责框架搭建\n- 2014年9月到2016年10月，做了两年Android IM即时通讯APP聊天功能开发及维护并各种性能优化。\n- 自学了一段时间的Python，发现Python代码简洁，功能强大，有点爱不释手的感觉\n\n#### 自我评价\n- 热爱编程，喜欢看书自我驱动型学习，\n- 热爱户外，喜欢和驴友徒步穿越\n- 喜欢摄影，喜欢用镜头留住精彩的瞬间\n\n#### 联系我\n\nQQ:\t840418528\nEmail:\tsongjlforever@foxmail.com\n\n#### 我的词云\n\n![我的词云](http://othg5ggzi.bkt.clouddn.com/%E6%88%91%E7%9A%84%E8%AF%8D%E4%BA%91.png)\n\n","updated":"2017-08-02T11:35:06.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj66nwj640000wh9c1u95rrsy","content":"<blockquote>\n<p>一个从运维转战开发的程序猿。2012年因为兴趣自学Android。</p>\n</blockquote>\n<h4 id=\"我的经历\"><a href=\"#我的经历\" class=\"headerlink\" title=\"我的经历\"></a>我的经历</h4><ul>\n<li>2010年专科毕业</li>\n<li>2011年，财政局做了一年的数据维护</li>\n<li>2013年，做了一年的IPTV Android机顶盒开发</li>\n<li>2014年3-6月，做了三个月政府审查上报类项目Android客户端，负责框架搭建</li>\n<li>2014年9月到2016年10月，做了两年Android IM即时通讯APP聊天功能开发及维护并各种性能优化。</li>\n<li>自学了一段时间的Python，发现Python代码简洁，功能强大，有点爱不释手的感觉</li>\n</ul>\n<h4 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h4><ul>\n<li>热爱编程，喜欢看书自我驱动型学习，</li>\n<li>热爱户外，喜欢和驴友徒步穿越</li>\n<li>喜欢摄影，喜欢用镜头留住精彩的瞬间</li>\n</ul>\n<h4 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h4><p>QQ:    840418528<br>Email:    songjlforever@foxmail.com</p>\n<h4 id=\"我的词云\"><a href=\"#我的词云\" class=\"headerlink\" title=\"我的词云\"></a>我的词云</h4><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%88%91%E7%9A%84%E8%AF%8D%E4%BA%91.png\" alt=\"我的词云\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一个从运维转战开发的程序猿。2012年因为兴趣自学Android。</p>\n</blockquote>\n<h4 id=\"我的经历\"><a href=\"#我的经历\" class=\"headerlink\" title=\"我的经历\"></a>我的经历</h4><ul>\n<li>2010年专科毕业</li>\n<li>2011年，财政局做了一年的数据维护</li>\n<li>2013年，做了一年的IPTV Android机顶盒开发</li>\n<li>2014年3-6月，做了三个月政府审查上报类项目Android客户端，负责框架搭建</li>\n<li>2014年9月到2016年10月，做了两年Android IM即时通讯APP聊天功能开发及维护并各种性能优化。</li>\n<li>自学了一段时间的Python，发现Python代码简洁，功能强大，有点爱不释手的感觉</li>\n</ul>\n<h4 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h4><ul>\n<li>热爱编程，喜欢看书自我驱动型学习，</li>\n<li>热爱户外，喜欢和驴友徒步穿越</li>\n<li>喜欢摄影，喜欢用镜头留住精彩的瞬间</li>\n</ul>\n<h4 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h4><p>QQ:    840418528<br>Email:    songjlforever@foxmail.com</p>\n<h4 id=\"我的词云\"><a href=\"#我的词云\" class=\"headerlink\" title=\"我的词云\"></a>我的词云</h4><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%88%91%E7%9A%84%E8%AF%8D%E4%BA%91.png\" alt=\"我的词云\"></p>\n"},{"title":"分类","date":"2017-04-22T09:16:26.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-04-22 17:16:26\ntype: \"categories\"\n---\n","updated":"2017-07-24T06:20:32.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj66nwj7g0002wh9cso22q2zs","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-04-22T09:16:02.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-04-22 17:16:02\ntype: \"tags\"\n---\n","updated":"2017-07-24T06:20:32.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj66nwj7x0006wh9c0s2i46sh","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2015圆明园荷花节","date":"2017-04-25T08:15:01.000Z","_content":"\n# 说在前面的话\n\n圆明园每年夏季荷花盛开时都会有荷花节。而我也已经2015、2016两年都去参观了，当然今年也不会例外。每年参观人很多，如果天气比较热，最好早点去，如果去的太晚可能拍不到状态好的荷花。盛开又饱满的荷花一般都距离岸边比较远，最好用长焦拍摄。\n\n# 直接上图\n\n![psb (2)](2015圆明园荷花节/psb2.jpeg)\n\n\n\n\n\n\n\n\n\n![psb (3)](2015圆明园荷花节/psb3.jpeg)\n\n\n\n\n\n\n\n![psb (4)](2015圆明园荷花节/psb4.jpeg)\n\n\n\n\n\n\n\n![psb (5)](2015圆明园荷花节/psb5.jpeg)\n\n\n\n\n\n\n\n\n\n![psb (6)](2015圆明园荷花节/psb6.jpeg)\n\n\n\n\n\n\n\n\n\n![psb (7)](2015圆明园荷花节/psb7.jpeg)\n\n\n\n这个小孩和猫德照片说下：当时是已经拍完荷花在出来的路上，到大门口了，看到路边土坡上有一只猫咪，我个人比较喜欢猫狗，就上前逗了几下，这时一个小孩也上来，好像他也很喜欢的样子，摸着猫咪竟没注意到他左手的雪糕其实已经化了。孩子妈在旁边站着看着。小孩摸着猫咪，猫咪竟也不怕眼生，自顾的舔舐腿毛~~画面好不温馨，赶紧后退几步(镜头最近对焦距离1.2米)拍下这一幕。\n\n\n\n\n\n\n\n![psb](2015圆明园荷花节/psb.jpeg)\n\n\n\n\n\n\n\n\n\n\n\n![psb (1)](2015圆明园荷花节/psb1.jpeg)\n\n\n\n再说下这个蜻蜓的图片：这个蜻蜓是在圆明园的黑天鹅区？名字好像忘了，但是那个区确实有个很大的石雕还是金属的天鹅塑像。在那部分水域也有些荷花。拿镜头扫射时发现的蜻蜓正落在荷叶杆上休憩。其实那片区域是有围栏的，不能靠近。幸亏长焦镜头直接拉到最远才看得清。换个角度把荷叶作为背景。咔嚓按下快门~~\n\n\n\n\n\n\n\n","source":"_posts/2015圆明园荷花节.md","raw":"---\ntitle: 2015圆明园荷花节\ndate: 2017-04-25 16:15:01\ntags: 生活\ncategories: 生活\n---\n\n# 说在前面的话\n\n圆明园每年夏季荷花盛开时都会有荷花节。而我也已经2015、2016两年都去参观了，当然今年也不会例外。每年参观人很多，如果天气比较热，最好早点去，如果去的太晚可能拍不到状态好的荷花。盛开又饱满的荷花一般都距离岸边比较远，最好用长焦拍摄。\n\n# 直接上图\n\n![psb (2)](2015圆明园荷花节/psb2.jpeg)\n\n\n\n\n\n\n\n\n\n![psb (3)](2015圆明园荷花节/psb3.jpeg)\n\n\n\n\n\n\n\n![psb (4)](2015圆明园荷花节/psb4.jpeg)\n\n\n\n\n\n\n\n![psb (5)](2015圆明园荷花节/psb5.jpeg)\n\n\n\n\n\n\n\n\n\n![psb (6)](2015圆明园荷花节/psb6.jpeg)\n\n\n\n\n\n\n\n\n\n![psb (7)](2015圆明园荷花节/psb7.jpeg)\n\n\n\n这个小孩和猫德照片说下：当时是已经拍完荷花在出来的路上，到大门口了，看到路边土坡上有一只猫咪，我个人比较喜欢猫狗，就上前逗了几下，这时一个小孩也上来，好像他也很喜欢的样子，摸着猫咪竟没注意到他左手的雪糕其实已经化了。孩子妈在旁边站着看着。小孩摸着猫咪，猫咪竟也不怕眼生，自顾的舔舐腿毛~~画面好不温馨，赶紧后退几步(镜头最近对焦距离1.2米)拍下这一幕。\n\n\n\n\n\n\n\n![psb](2015圆明园荷花节/psb.jpeg)\n\n\n\n\n\n\n\n\n\n\n\n![psb (1)](2015圆明园荷花节/psb1.jpeg)\n\n\n\n再说下这个蜻蜓的图片：这个蜻蜓是在圆明园的黑天鹅区？名字好像忘了，但是那个区确实有个很大的石雕还是金属的天鹅塑像。在那部分水域也有些荷花。拿镜头扫射时发现的蜻蜓正落在荷叶杆上休憩。其实那片区域是有围栏的，不能靠近。幸亏长焦镜头直接拉到最远才看得清。换个角度把荷叶作为背景。咔嚓按下快门~~\n\n\n\n\n\n\n\n","slug":"2015圆明园荷花节","published":1,"updated":"2017-04-25T09:17:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwj780001wh9cdlsi9d46","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>圆明园每年夏季荷花盛开时都会有荷花节。而我也已经2015、2016两年都去参观了，当然今年也不会例外。每年参观人很多，如果天气比较热，最好早点去，如果去的太晚可能拍不到状态好的荷花。盛开又饱满的荷花一般都距离岸边比较远，最好用长焦拍摄。</p>\n<h1 id=\"直接上图\"><a href=\"#直接上图\" class=\"headerlink\" title=\"直接上图\"></a>直接上图</h1><p><img src=\"/2017/04/25/2015圆明园荷花节/psb2.jpeg\" alt=\"psb (2)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb3.jpeg\" alt=\"psb (3)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb4.jpeg\" alt=\"psb (4)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb5.jpeg\" alt=\"psb (5)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb6.jpeg\" alt=\"psb (6)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb7.jpeg\" alt=\"psb (7)\"></p>\n<p>这个小孩和猫德照片说下：当时是已经拍完荷花在出来的路上，到大门口了，看到路边土坡上有一只猫咪，我个人比较喜欢猫狗，就上前逗了几下，这时一个小孩也上来，好像他也很喜欢的样子，摸着猫咪竟没注意到他左手的雪糕其实已经化了。孩子妈在旁边站着看着。小孩摸着猫咪，猫咪竟也不怕眼生，自顾的舔舐腿毛~~画面好不温馨，赶紧后退几步(镜头最近对焦距离1.2米)拍下这一幕。</p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb.jpeg\" alt=\"psb\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb1.jpeg\" alt=\"psb (1)\"></p>\n<p>再说下这个蜻蜓的图片：这个蜻蜓是在圆明园的黑天鹅区？名字好像忘了，但是那个区确实有个很大的石雕还是金属的天鹅塑像。在那部分水域也有些荷花。拿镜头扫射时发现的蜻蜓正落在荷叶杆上休憩。其实那片区域是有围栏的，不能靠近。幸亏长焦镜头直接拉到最远才看得清。换个角度把荷叶作为背景。咔嚓按下快门~~</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>圆明园每年夏季荷花盛开时都会有荷花节。而我也已经2015、2016两年都去参观了，当然今年也不会例外。每年参观人很多，如果天气比较热，最好早点去，如果去的太晚可能拍不到状态好的荷花。盛开又饱满的荷花一般都距离岸边比较远，最好用长焦拍摄。</p>\n<h1 id=\"直接上图\"><a href=\"#直接上图\" class=\"headerlink\" title=\"直接上图\"></a>直接上图</h1><p><img src=\"/2017/04/25/2015圆明园荷花节/psb2.jpeg\" alt=\"psb (2)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb3.jpeg\" alt=\"psb (3)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb4.jpeg\" alt=\"psb (4)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb5.jpeg\" alt=\"psb (5)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb6.jpeg\" alt=\"psb (6)\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb7.jpeg\" alt=\"psb (7)\"></p>\n<p>这个小孩和猫德照片说下：当时是已经拍完荷花在出来的路上，到大门口了，看到路边土坡上有一只猫咪，我个人比较喜欢猫狗，就上前逗了几下，这时一个小孩也上来，好像他也很喜欢的样子，摸着猫咪竟没注意到他左手的雪糕其实已经化了。孩子妈在旁边站着看着。小孩摸着猫咪，猫咪竟也不怕眼生，自顾的舔舐腿毛~~画面好不温馨，赶紧后退几步(镜头最近对焦距离1.2米)拍下这一幕。</p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb.jpeg\" alt=\"psb\"></p>\n<p><img src=\"/2017/04/25/2015圆明园荷花节/psb1.jpeg\" alt=\"psb (1)\"></p>\n<p>再说下这个蜻蜓的图片：这个蜻蜓是在圆明园的黑天鹅区？名字好像忘了，但是那个区确实有个很大的石雕还是金属的天鹅塑像。在那部分水域也有些荷花。拿镜头扫射时发现的蜻蜓正落在荷叶杆上休憩。其实那片区域是有围栏的，不能靠近。幸亏长焦镜头直接拉到最远才看得清。换个角度把荷叶作为背景。咔嚓按下快门~~</p>\n"},{"title":"Hexo+GitHub 30分钟拥有属于自己的网站","date":"2017-04-23T04:57:00.000Z","_content":"# 说在前面的话\n\n>很多ITer都想拥有一个个人网站，记录自己工作经验和生活。哪怕已经有了简书这样好的一个平台，但是那种情节并没有就此打消。下面给大家分享下我个人网站创建流程及中途遇到的坑，希望对那些想建站却又嫌麻烦的朋友有所帮助。\n\n# 准备工作\n在开始前要做好系列准备工作，如环境搭建、GitHub账号注册等。下面分别来看下要做哪些：\n\n## GitHub官网\n- 账号注册\n\t如果你还没有GitHub账号，请前往[官网注册](https://github.com/)。如果已经注册过，请登录\n\t\n- 创建仓库\n\t登录后，点击左上角+号创建仓库：\n  ![index.png](http://upload-images.jianshu.io/upload_images/1796052-076ccee5f6f8713c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n 在新的创建页面，写上   yourname.github.io ，然后下方选框勾上(我当时没有勾后来本地文件向git提交时出了点小问题)。yourname最好就是你的GitHub的名字，\n\n![index1.png](http://upload-images.jianshu.io/upload_images/1796052-68a0ed4e1dd8fc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Git客户端安装\n\n- 安装\n\tGit可以直接从[官网下载](https://git-scm.com/downloads) 系统版本自行选择。\nGit安装基本也可以认为一路next点过来，如果你的 on the Desktop没有勾选的话，为了方便可以勾选上\n\n![index3.png](http://upload-images.jianshu.io/upload_images/1796052-1b1909354d7db0bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 验证\n\t同样为了查看是否正确安装，需要从命令行查看能否正确显示版本信息：\n\t```\n\tgit --version\n\t```\n如果显示了版本信息，则说明正确安装：\n```\ngit version 2.12.2.windows.2\n```\n- 配置git\n\t- 配置Git的user name和email：\n\t```\n\tgit config --global user.name \"你的名字\"\n\tgit config --global user.email \"你的git使用的邮箱\"\n\t```\n\t- 生成密钥：\n\t\t使用ssh-keygen -t rsa -C 你的git使用的邮箱 命令生成密钥，输入命令后连续点击好像三四次回车就行，出现的一些设置提示不用管，全部默认就行。执行完成后会生成密钥文件如图：\n\n![index4.png](http://upload-images.jianshu.io/upload_images/1796052-6a752a526843a255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 密钥和GitHub关联\n\t编辑器打开id_rsa.pub复制所有内容。\n\t打开GitHub Setting如图：\n\n  ![index5.png](http://upload-images.jianshu.io/upload_images/1796052-fbd7fecb18c1669f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n 找到SSH key，点击new SSH key，把内容粘贴到key文本框中，title随意起，保存，如下图：\n![index6.png](http://upload-images.jianshu.io/upload_images/1796052-091de6d5aa8682a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Node.js\n- 安装\n\t我笔记本是win系统，所以关于Node.js下载：\n [32位下载](https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi) \n [64位下载](https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi)\n 如果是其他系统，需要自行去官网下载。\n 关于安装没有什么注意的，反正我是一路next，如图：\n\n![index7.png](http://upload-images.jianshu.io/upload_images/1796052-c67fd55dd0a8089a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 验证\n\t安装完成后，可以像JDK一样，使用命令行验证是否正确安装，在cmd命令窗口执行以下：\n\t```\n\tnode -v\n\tnpm -v\n\t```\n\t如果正确显示了当前版本号，则说明安装成功：\n\n\t```\n\tv4.2.3\n\t2.14.7\n\t```\n\t否则，请根据具体异常信息搜索下。\n\n## Hexo\n- 安装\n\t在合适地方创建一个文件夹并命名，例如我在 E盘 下创建了hexo文件夹：\n\t通过命令行进入该文件夹目录下：\n\t```\n\tC:\\Users\\Jenson>E:\n\tE:\\>cd hexo\n\tE:\\hexo>\n\t```\n\t执行 npm命令 安装hexo：\n\t```\n\tnpm install hexo-cli -g\n\t```\n\t期间cmd窗口会自动刷出一些信息，可能会有warn不过不要紧。待命令执行完毕，继续执行\n\t```\n\tnpm install hexo --save\n\t```\n\t这时又会有信息刷屏，信息滚动完毕，通过\n\n\t```\n\thexo -v\n\t```\n\t命令验证是否安装成功。\n\t如果出现了下面字样，说明安装成功了：\n![index12.png](http://upload-images.jianshu.io/upload_images/1796052-89811acc016bd532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 初体验\n\t- 窗口中继续执行\n\t``` \n\thexo init \n\t```\n\t初始化\n\t- 执行\n\t```\n\tnpm install\n\t```\n\t自动安装所需组件，直到完成\n\t- 执行\n\t```\n\thexo g\n\t```\n\t- 执行\n\t```\n\thexo s\n\t```\n\t启动本地服务，在浏览器地址栏输入\n\t```\n\thttp://localhost:4000/\n\t```\n\t看能否打开本地部署的网站，如果成功打开，恭喜你本地部署完成。\n\n# 本地hexo关联到GitHub\n\n本地网站已经可以打开，接下来要把hexo部署到GitHub上，让别人也能访问。\n在hexo目录下找到_config.yml文件，按如下格式修改成你的：\n```\ndeploy:\n  type: git\n  repo: https://github.com/Jensonss/Jensonss.github.io.git\n  branch: master\n```\n修改完成后，执行\n```\nhexo d -g\n```\n生成部署，这样就会根据刚才的GitHub地址commit到GitHub仓库，首次的话会弹窗让你输入你的GitHub登录的用户名和密码。登录成功后就会自动commit了。\n此时通过 ```xxx.github.io``` 应该是可以访问你的网站了。\n\n# 个性域名绑定\n\n\n## 购买域名\n\n我的域名是在万网购买的，不过进入网站才发现万网成了阿里云的二级域名，不知道什么时候被阿里云收购了。购买通道[猛戳](https://wanwang.aliyun.com/),用淘宝账号直接登录，由于是个人使用所以我选了 .me 类型的，而且13元/首年价格比较便宜，以后续费价格好像是89元/年。\n\n付款时会让选择持有者是个人还是企业，选择个人，然后创建一个个人使用的信息模板，可能由于我的是.me域名，所以没有进行身份证验证也能使用。\n\n## 域名DNS解析\n购买后的域名不能直接使用，因为现在只是把域名颁发给你，但是还没有和IP地址绑定，还需要进行DNS解析。\n在你购买后，可以直接点击域名进入域名控制台，页面长这样：\n![index8.png](http://upload-images.jianshu.io/upload_images/1796052-d32c7d57b43b7559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击左侧的菜单-云解析DNS，然后再点击你的域名：\n\n![index9.png](http://upload-images.jianshu.io/upload_images/1796052-bbca539b61e74602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n进入了新手引导设置：\n\n![index10.png](http://upload-images.jianshu.io/upload_images/1796052-97f979d9b478abb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果点击设置网站解析，进入的页面只能输入一个IP地址，由于GitHub有2个IP地址要绑定，所以我直接选择了高级设置，点击 添加解析，添加如下三条记录，其中xxx.github.io  ，xxx为你得GitHub配置的名称：\n\n![index11.png](http://upload-images.jianshu.io/upload_images/1796052-15f930f4842f9ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意：CNAME 必须大写\n这样过几分钟域名就会生效了，\n\n\n\n## 域名绑定\n上一步DNS解析用到了CNAME ，现在在hexo/source目录下创建一个不带后缀的文件，名为CNAME，内容只填写你购买的域名：\n\n![图片.png](http://upload-images.jianshu.io/upload_images/1796052-617ebc06eda88723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后执行```hexo d -g```部署到GitHub上。这样就能通过你的新域名访问你的网站了。\n\n如果只是把hexo部署到GitHub上，半个小时是足够的，但是入果从找网站买域名、DNS解析、绑定。前前后后大概花了近1个小时。可能因为我有强迫症的缘故，填写一些信息时总是要想好久。\n\n话不多说，看看完成后的网站吧：[我的站点](www.jensondev.me)","source":"_posts/30分钟搭建自己的网站.md","raw":"---\ntitle: Hexo+GitHub 30分钟拥有属于自己的网站\ndate: 2017-04-23 12:57:00\ntags: 网络\ncategories: 网络\n---\n# 说在前面的话\n\n>很多ITer都想拥有一个个人网站，记录自己工作经验和生活。哪怕已经有了简书这样好的一个平台，但是那种情节并没有就此打消。下面给大家分享下我个人网站创建流程及中途遇到的坑，希望对那些想建站却又嫌麻烦的朋友有所帮助。\n\n# 准备工作\n在开始前要做好系列准备工作，如环境搭建、GitHub账号注册等。下面分别来看下要做哪些：\n\n## GitHub官网\n- 账号注册\n\t如果你还没有GitHub账号，请前往[官网注册](https://github.com/)。如果已经注册过，请登录\n\t\n- 创建仓库\n\t登录后，点击左上角+号创建仓库：\n  ![index.png](http://upload-images.jianshu.io/upload_images/1796052-076ccee5f6f8713c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n 在新的创建页面，写上   yourname.github.io ，然后下方选框勾上(我当时没有勾后来本地文件向git提交时出了点小问题)。yourname最好就是你的GitHub的名字，\n\n![index1.png](http://upload-images.jianshu.io/upload_images/1796052-68a0ed4e1dd8fc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Git客户端安装\n\n- 安装\n\tGit可以直接从[官网下载](https://git-scm.com/downloads) 系统版本自行选择。\nGit安装基本也可以认为一路next点过来，如果你的 on the Desktop没有勾选的话，为了方便可以勾选上\n\n![index3.png](http://upload-images.jianshu.io/upload_images/1796052-1b1909354d7db0bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 验证\n\t同样为了查看是否正确安装，需要从命令行查看能否正确显示版本信息：\n\t```\n\tgit --version\n\t```\n如果显示了版本信息，则说明正确安装：\n```\ngit version 2.12.2.windows.2\n```\n- 配置git\n\t- 配置Git的user name和email：\n\t```\n\tgit config --global user.name \"你的名字\"\n\tgit config --global user.email \"你的git使用的邮箱\"\n\t```\n\t- 生成密钥：\n\t\t使用ssh-keygen -t rsa -C 你的git使用的邮箱 命令生成密钥，输入命令后连续点击好像三四次回车就行，出现的一些设置提示不用管，全部默认就行。执行完成后会生成密钥文件如图：\n\n![index4.png](http://upload-images.jianshu.io/upload_images/1796052-6a752a526843a255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 密钥和GitHub关联\n\t编辑器打开id_rsa.pub复制所有内容。\n\t打开GitHub Setting如图：\n\n  ![index5.png](http://upload-images.jianshu.io/upload_images/1796052-fbd7fecb18c1669f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n 找到SSH key，点击new SSH key，把内容粘贴到key文本框中，title随意起，保存，如下图：\n![index6.png](http://upload-images.jianshu.io/upload_images/1796052-091de6d5aa8682a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Node.js\n- 安装\n\t我笔记本是win系统，所以关于Node.js下载：\n [32位下载](https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi) \n [64位下载](https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi)\n 如果是其他系统，需要自行去官网下载。\n 关于安装没有什么注意的，反正我是一路next，如图：\n\n![index7.png](http://upload-images.jianshu.io/upload_images/1796052-c67fd55dd0a8089a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 验证\n\t安装完成后，可以像JDK一样，使用命令行验证是否正确安装，在cmd命令窗口执行以下：\n\t```\n\tnode -v\n\tnpm -v\n\t```\n\t如果正确显示了当前版本号，则说明安装成功：\n\n\t```\n\tv4.2.3\n\t2.14.7\n\t```\n\t否则，请根据具体异常信息搜索下。\n\n## Hexo\n- 安装\n\t在合适地方创建一个文件夹并命名，例如我在 E盘 下创建了hexo文件夹：\n\t通过命令行进入该文件夹目录下：\n\t```\n\tC:\\Users\\Jenson>E:\n\tE:\\>cd hexo\n\tE:\\hexo>\n\t```\n\t执行 npm命令 安装hexo：\n\t```\n\tnpm install hexo-cli -g\n\t```\n\t期间cmd窗口会自动刷出一些信息，可能会有warn不过不要紧。待命令执行完毕，继续执行\n\t```\n\tnpm install hexo --save\n\t```\n\t这时又会有信息刷屏，信息滚动完毕，通过\n\n\t```\n\thexo -v\n\t```\n\t命令验证是否安装成功。\n\t如果出现了下面字样，说明安装成功了：\n![index12.png](http://upload-images.jianshu.io/upload_images/1796052-89811acc016bd532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 初体验\n\t- 窗口中继续执行\n\t``` \n\thexo init \n\t```\n\t初始化\n\t- 执行\n\t```\n\tnpm install\n\t```\n\t自动安装所需组件，直到完成\n\t- 执行\n\t```\n\thexo g\n\t```\n\t- 执行\n\t```\n\thexo s\n\t```\n\t启动本地服务，在浏览器地址栏输入\n\t```\n\thttp://localhost:4000/\n\t```\n\t看能否打开本地部署的网站，如果成功打开，恭喜你本地部署完成。\n\n# 本地hexo关联到GitHub\n\n本地网站已经可以打开，接下来要把hexo部署到GitHub上，让别人也能访问。\n在hexo目录下找到_config.yml文件，按如下格式修改成你的：\n```\ndeploy:\n  type: git\n  repo: https://github.com/Jensonss/Jensonss.github.io.git\n  branch: master\n```\n修改完成后，执行\n```\nhexo d -g\n```\n生成部署，这样就会根据刚才的GitHub地址commit到GitHub仓库，首次的话会弹窗让你输入你的GitHub登录的用户名和密码。登录成功后就会自动commit了。\n此时通过 ```xxx.github.io``` 应该是可以访问你的网站了。\n\n# 个性域名绑定\n\n\n## 购买域名\n\n我的域名是在万网购买的，不过进入网站才发现万网成了阿里云的二级域名，不知道什么时候被阿里云收购了。购买通道[猛戳](https://wanwang.aliyun.com/),用淘宝账号直接登录，由于是个人使用所以我选了 .me 类型的，而且13元/首年价格比较便宜，以后续费价格好像是89元/年。\n\n付款时会让选择持有者是个人还是企业，选择个人，然后创建一个个人使用的信息模板，可能由于我的是.me域名，所以没有进行身份证验证也能使用。\n\n## 域名DNS解析\n购买后的域名不能直接使用，因为现在只是把域名颁发给你，但是还没有和IP地址绑定，还需要进行DNS解析。\n在你购买后，可以直接点击域名进入域名控制台，页面长这样：\n![index8.png](http://upload-images.jianshu.io/upload_images/1796052-d32c7d57b43b7559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击左侧的菜单-云解析DNS，然后再点击你的域名：\n\n![index9.png](http://upload-images.jianshu.io/upload_images/1796052-bbca539b61e74602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n进入了新手引导设置：\n\n![index10.png](http://upload-images.jianshu.io/upload_images/1796052-97f979d9b478abb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果点击设置网站解析，进入的页面只能输入一个IP地址，由于GitHub有2个IP地址要绑定，所以我直接选择了高级设置，点击 添加解析，添加如下三条记录，其中xxx.github.io  ，xxx为你得GitHub配置的名称：\n\n![index11.png](http://upload-images.jianshu.io/upload_images/1796052-15f930f4842f9ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意：CNAME 必须大写\n这样过几分钟域名就会生效了，\n\n\n\n## 域名绑定\n上一步DNS解析用到了CNAME ，现在在hexo/source目录下创建一个不带后缀的文件，名为CNAME，内容只填写你购买的域名：\n\n![图片.png](http://upload-images.jianshu.io/upload_images/1796052-617ebc06eda88723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后执行```hexo d -g```部署到GitHub上。这样就能通过你的新域名访问你的网站了。\n\n如果只是把hexo部署到GitHub上，半个小时是足够的，但是入果从找网站买域名、DNS解析、绑定。前前后后大概花了近1个小时。可能因为我有强迫症的缘故，填写一些信息时总是要想好久。\n\n话不多说，看看完成后的网站吧：[我的站点](www.jensondev.me)","slug":"30分钟搭建自己的网站","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwj7i0003wh9cfwbzn0mv","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><blockquote>\n<p>很多ITer都想拥有一个个人网站，记录自己工作经验和生活。哪怕已经有了简书这样好的一个平台，但是那种情节并没有就此打消。下面给大家分享下我个人网站创建流程及中途遇到的坑，希望对那些想建站却又嫌麻烦的朋友有所帮助。</p>\n</blockquote>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>在开始前要做好系列准备工作，如环境搭建、GitHub账号注册等。下面分别来看下要做哪些：</p>\n<h2 id=\"GitHub官网\"><a href=\"#GitHub官网\" class=\"headerlink\" title=\"GitHub官网\"></a>GitHub官网</h2><ul>\n<li><p>账号注册<br>  如果你还没有GitHub账号，请前往<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">官网注册</a>。如果已经注册过，请登录</p>\n</li>\n<li><p>创建仓库<br>  登录后，点击左上角+号创建仓库：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-076ccee5f6f8713c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index.png\"><br>在新的创建页面，写上   yourname.github.io ，然后下方选框勾上(我当时没有勾后来本地文件向git提交时出了点小问题)。yourname最好就是你的GitHub的名字，</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-68a0ed4e1dd8fc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index1.png\"></p>\n<h2 id=\"Git客户端安装\"><a href=\"#Git客户端安装\" class=\"headerlink\" title=\"Git客户端安装\"></a>Git客户端安装</h2><ul>\n<li>安装<br>  Git可以直接从<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">官网下载</a> 系统版本自行选择。<br>Git安装基本也可以认为一路next点过来，如果你的 on the Desktop没有勾选的话，为了方便可以勾选上</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-1b1909354d7db0bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index3.png\"></p>\n<ul>\n<li>验证<br>  同样为了查看是否正确安装，需要从命令行查看能否正确显示版本信息：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git --version</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果显示了版本信息，则说明正确安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git version 2.12.2.windows.2</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>配置git</p>\n<ul>\n<li><p>配置Git的user name和email：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name &quot;你的名字&quot;</div><div class=\"line\">git config --global user.email &quot;你的git使用的邮箱&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>生成密钥：<br>  使用ssh-keygen -t rsa -C 你的git使用的邮箱 命令生成密钥，输入命令后连续点击好像三四次回车就行，出现的一些设置提示不用管，全部默认就行。执行完成后会生成密钥文件如图：</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6a752a526843a255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index4.png\"></p>\n<ul>\n<li><p>密钥和GitHub关联<br>  编辑器打开id_rsa.pub复制所有内容。<br>  打开GitHub Setting如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-fbd7fecb18c1669f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index5.png\"><br>找到SSH key，点击new SSH key，把内容粘贴到key文本框中，title随意起，保存，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-091de6d5aa8682a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index6.png\"></p>\n</li>\n</ul>\n<h2 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h2><ul>\n<li>安装<br>  我笔记本是win系统，所以关于Node.js下载：<br><a href=\"https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi\" target=\"_blank\" rel=\"external\">32位下载</a><br><a href=\"https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi\" target=\"_blank\" rel=\"external\">64位下载</a><br>如果是其他系统，需要自行去官网下载。<br>关于安装没有什么注意的，反正我是一路next，如图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c67fd55dd0a8089a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index7.png\"></p>\n<ul>\n<li><p>验证<br>  安装完成后，可以像JDK一样，使用命令行验证是否正确安装，在cmd命令窗口执行以下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v</div><div class=\"line\">npm -v</div></pre></td></tr></table></figure>\n<p>  如果正确显示了当前版本号，则说明安装成功：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">v4.2.3</div><div class=\"line\">2.14.7</div></pre></td></tr></table></figure>\n<p>  否则，请根据具体异常信息搜索下。</p>\n</li>\n</ul>\n<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><ul>\n<li><p>安装<br>  在合适地方创建一个文件夹并命名，例如我在 E盘 下创建了hexo文件夹：<br>  通过命令行进入该文件夹目录下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\Jenson&gt;E:</div><div class=\"line\">E:\\&gt;cd hexo</div><div class=\"line\">E:\\hexo&gt;</div></pre></td></tr></table></figure>\n<p>  执行 npm命令 安装hexo：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<p>  期间cmd窗口会自动刷出一些信息，可能会有warn不过不要紧。待命令执行完毕，继续执行</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo --save</div></pre></td></tr></table></figure>\n<p>  这时又会有信息刷屏，信息滚动完毕，通过</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo -v</div></pre></td></tr></table></figure>\n<p>  命令验证是否安装成功。<br>  如果出现了下面字样，说明安装成功了：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-89811acc016bd532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index12.png\"></p>\n</li>\n<li><p>初体验</p>\n<ul>\n<li><p>窗口中继续执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure>\n<p>初始化</p>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>自动安装所需组件，直到完成</p>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo s</div></pre></td></tr></table></figure>\n<p>启动本地服务，在浏览器地址栏输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:4000/</div></pre></td></tr></table></figure>\n<p>看能否打开本地部署的网站，如果成功打开，恭喜你本地部署完成。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"本地hexo关联到GitHub\"><a href=\"#本地hexo关联到GitHub\" class=\"headerlink\" title=\"本地hexo关联到GitHub\"></a>本地hexo关联到GitHub</h1><p>本地网站已经可以打开，接下来要把hexo部署到GitHub上，让别人也能访问。<br>在hexo目录下找到_config.yml文件，按如下格式修改成你的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo: https://github.com/Jensonss/Jensonss.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure></p>\n<p>修改完成后，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -g</div></pre></td></tr></table></figure></p>\n<p>生成部署，这样就会根据刚才的GitHub地址commit到GitHub仓库，首次的话会弹窗让你输入你的GitHub登录的用户名和密码。登录成功后就会自动commit了。<br>此时通过 <code>xxx.github.io</code> 应该是可以访问你的网站了。</p>\n<h1 id=\"个性域名绑定\"><a href=\"#个性域名绑定\" class=\"headerlink\" title=\"个性域名绑定\"></a>个性域名绑定</h1><h2 id=\"购买域名\"><a href=\"#购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名</h2><p>我的域名是在万网购买的，不过进入网站才发现万网成了阿里云的二级域名，不知道什么时候被阿里云收购了。购买通道<a href=\"https://wanwang.aliyun.com/\" target=\"_blank\" rel=\"external\">猛戳</a>,用淘宝账号直接登录，由于是个人使用所以我选了 .me 类型的，而且13元/首年价格比较便宜，以后续费价格好像是89元/年。</p>\n<p>付款时会让选择持有者是个人还是企业，选择个人，然后创建一个个人使用的信息模板，可能由于我的是.me域名，所以没有进行身份证验证也能使用。</p>\n<h2 id=\"域名DNS解析\"><a href=\"#域名DNS解析\" class=\"headerlink\" title=\"域名DNS解析\"></a>域名DNS解析</h2><p>购买后的域名不能直接使用，因为现在只是把域名颁发给你，但是还没有和IP地址绑定，还需要进行DNS解析。<br>在你购买后，可以直接点击域名进入域名控制台，页面长这样：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-d32c7d57b43b7559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index8.png\"></p>\n<p>点击左侧的菜单-云解析DNS，然后再点击你的域名：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-bbca539b61e74602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index9.png\"></p>\n<p>进入了新手引导设置：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-97f979d9b478abb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index10.png\"></p>\n<p>如果点击设置网站解析，进入的页面只能输入一个IP地址，由于GitHub有2个IP地址要绑定，所以我直接选择了高级设置，点击 添加解析，添加如下三条记录，其中xxx.github.io  ，xxx为你得GitHub配置的名称：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-15f930f4842f9ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index11.png\"></p>\n<p>注意：CNAME 必须大写<br>这样过几分钟域名就会生效了，</p>\n<h2 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h2><p>上一步DNS解析用到了CNAME ，现在在hexo/source目录下创建一个不带后缀的文件，名为CNAME，内容只填写你购买的域名：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-617ebc06eda88723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片.png\"></p>\n<p>然后执行<code>hexo d -g</code>部署到GitHub上。这样就能通过你的新域名访问你的网站了。</p>\n<p>如果只是把hexo部署到GitHub上，半个小时是足够的，但是入果从找网站买域名、DNS解析、绑定。前前后后大概花了近1个小时。可能因为我有强迫症的缘故，填写一些信息时总是要想好久。</p>\n<p>话不多说，看看完成后的网站吧：<a href=\"www.jensondev.me\">我的站点</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><blockquote>\n<p>很多ITer都想拥有一个个人网站，记录自己工作经验和生活。哪怕已经有了简书这样好的一个平台，但是那种情节并没有就此打消。下面给大家分享下我个人网站创建流程及中途遇到的坑，希望对那些想建站却又嫌麻烦的朋友有所帮助。</p>\n</blockquote>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>在开始前要做好系列准备工作，如环境搭建、GitHub账号注册等。下面分别来看下要做哪些：</p>\n<h2 id=\"GitHub官网\"><a href=\"#GitHub官网\" class=\"headerlink\" title=\"GitHub官网\"></a>GitHub官网</h2><ul>\n<li><p>账号注册<br>  如果你还没有GitHub账号，请前往<a href=\"https://github.com/\">官网注册</a>。如果已经注册过，请登录</p>\n</li>\n<li><p>创建仓库<br>  登录后，点击左上角+号创建仓库：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-076ccee5f6f8713c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index.png\"><br>在新的创建页面，写上   yourname.github.io ，然后下方选框勾上(我当时没有勾后来本地文件向git提交时出了点小问题)。yourname最好就是你的GitHub的名字，</p>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-68a0ed4e1dd8fc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index1.png\"></p>\n<h2 id=\"Git客户端安装\"><a href=\"#Git客户端安装\" class=\"headerlink\" title=\"Git客户端安装\"></a>Git客户端安装</h2><ul>\n<li>安装<br>  Git可以直接从<a href=\"https://git-scm.com/downloads\">官网下载</a> 系统版本自行选择。<br>Git安装基本也可以认为一路next点过来，如果你的 on the Desktop没有勾选的话，为了方便可以勾选上</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-1b1909354d7db0bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index3.png\"></p>\n<ul>\n<li>验证<br>  同样为了查看是否正确安装，需要从命令行查看能否正确显示版本信息：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git --version</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果显示了版本信息，则说明正确安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git version 2.12.2.windows.2</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>配置git</p>\n<ul>\n<li><p>配置Git的user name和email：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name &quot;你的名字&quot;</div><div class=\"line\">git config --global user.email &quot;你的git使用的邮箱&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>生成密钥：<br>  使用ssh-keygen -t rsa -C 你的git使用的邮箱 命令生成密钥，输入命令后连续点击好像三四次回车就行，出现的一些设置提示不用管，全部默认就行。执行完成后会生成密钥文件如图：</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6a752a526843a255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index4.png\"></p>\n<ul>\n<li><p>密钥和GitHub关联<br>  编辑器打开id_rsa.pub复制所有内容。<br>  打开GitHub Setting如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-fbd7fecb18c1669f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index5.png\"><br>找到SSH key，点击new SSH key，把内容粘贴到key文本框中，title随意起，保存，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-091de6d5aa8682a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index6.png\"></p>\n</li>\n</ul>\n<h2 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h2><ul>\n<li>安装<br>  我笔记本是win系统，所以关于Node.js下载：<br><a href=\"https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi\">32位下载</a><br><a href=\"https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi\">64位下载</a><br>如果是其他系统，需要自行去官网下载。<br>关于安装没有什么注意的，反正我是一路next，如图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c67fd55dd0a8089a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index7.png\"></p>\n<ul>\n<li><p>验证<br>  安装完成后，可以像JDK一样，使用命令行验证是否正确安装，在cmd命令窗口执行以下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">node -v</div><div class=\"line\">npm -v</div></pre></td></tr></table></figure>\n<p>  如果正确显示了当前版本号，则说明安装成功：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">v4.2.3</div><div class=\"line\">2.14.7</div></pre></td></tr></table></figure>\n<p>  否则，请根据具体异常信息搜索下。</p>\n</li>\n</ul>\n<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><ul>\n<li><p>安装<br>  在合适地方创建一个文件夹并命名，例如我在 E盘 下创建了hexo文件夹：<br>  通过命令行进入该文件夹目录下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\Users\\Jenson&gt;E:</div><div class=\"line\">E:\\&gt;cd hexo</div><div class=\"line\">E:\\hexo&gt;</div></pre></td></tr></table></figure>\n<p>  执行 npm命令 安装hexo：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<p>  期间cmd窗口会自动刷出一些信息，可能会有warn不过不要紧。待命令执行完毕，继续执行</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo --save</div></pre></td></tr></table></figure>\n<p>  这时又会有信息刷屏，信息滚动完毕，通过</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo -v</div></pre></td></tr></table></figure>\n<p>  命令验证是否安装成功。<br>  如果出现了下面字样，说明安装成功了：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-89811acc016bd532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index12.png\"></p>\n</li>\n<li><p>初体验</p>\n<ul>\n<li><p>窗口中继续执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure>\n<p>初始化</p>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>自动安装所需组件，直到完成</p>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div></pre></td></tr></table></figure>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo s</div></pre></td></tr></table></figure>\n<p>启动本地服务，在浏览器地址栏输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:4000/</div></pre></td></tr></table></figure>\n<p>看能否打开本地部署的网站，如果成功打开，恭喜你本地部署完成。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"本地hexo关联到GitHub\"><a href=\"#本地hexo关联到GitHub\" class=\"headerlink\" title=\"本地hexo关联到GitHub\"></a>本地hexo关联到GitHub</h1><p>本地网站已经可以打开，接下来要把hexo部署到GitHub上，让别人也能访问。<br>在hexo目录下找到_config.yml文件，按如下格式修改成你的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo: https://github.com/Jensonss/Jensonss.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure></p>\n<p>修改完成后，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -g</div></pre></td></tr></table></figure></p>\n<p>生成部署，这样就会根据刚才的GitHub地址commit到GitHub仓库，首次的话会弹窗让你输入你的GitHub登录的用户名和密码。登录成功后就会自动commit了。<br>此时通过 <code>xxx.github.io</code> 应该是可以访问你的网站了。</p>\n<h1 id=\"个性域名绑定\"><a href=\"#个性域名绑定\" class=\"headerlink\" title=\"个性域名绑定\"></a>个性域名绑定</h1><h2 id=\"购买域名\"><a href=\"#购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名</h2><p>我的域名是在万网购买的，不过进入网站才发现万网成了阿里云的二级域名，不知道什么时候被阿里云收购了。购买通道<a href=\"https://wanwang.aliyun.com/\">猛戳</a>,用淘宝账号直接登录，由于是个人使用所以我选了 .me 类型的，而且13元/首年价格比较便宜，以后续费价格好像是89元/年。</p>\n<p>付款时会让选择持有者是个人还是企业，选择个人，然后创建一个个人使用的信息模板，可能由于我的是.me域名，所以没有进行身份证验证也能使用。</p>\n<h2 id=\"域名DNS解析\"><a href=\"#域名DNS解析\" class=\"headerlink\" title=\"域名DNS解析\"></a>域名DNS解析</h2><p>购买后的域名不能直接使用，因为现在只是把域名颁发给你，但是还没有和IP地址绑定，还需要进行DNS解析。<br>在你购买后，可以直接点击域名进入域名控制台，页面长这样：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-d32c7d57b43b7559.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index8.png\"></p>\n<p>点击左侧的菜单-云解析DNS，然后再点击你的域名：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-bbca539b61e74602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index9.png\"></p>\n<p>进入了新手引导设置：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-97f979d9b478abb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index10.png\"></p>\n<p>如果点击设置网站解析，进入的页面只能输入一个IP地址，由于GitHub有2个IP地址要绑定，所以我直接选择了高级设置，点击 添加解析，添加如下三条记录，其中xxx.github.io  ，xxx为你得GitHub配置的名称：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-15f930f4842f9ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"index11.png\"></p>\n<p>注意：CNAME 必须大写<br>这样过几分钟域名就会生效了，</p>\n<h2 id=\"域名绑定\"><a href=\"#域名绑定\" class=\"headerlink\" title=\"域名绑定\"></a>域名绑定</h2><p>上一步DNS解析用到了CNAME ，现在在hexo/source目录下创建一个不带后缀的文件，名为CNAME，内容只填写你购买的域名：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-617ebc06eda88723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片.png\"></p>\n<p>然后执行<code>hexo d -g</code>部署到GitHub上。这样就能通过你的新域名访问你的网站了。</p>\n<p>如果只是把hexo部署到GitHub上，半个小时是足够的，但是入果从找网站买域名、DNS解析、绑定。前前后后大概花了近1个小时。可能因为我有强迫症的缘故，填写一些信息时总是要想好久。</p>\n<p>话不多说，看看完成后的网站吧：<a href=\"www.jensondev.me\">我的站点</a></p>\n"},{"title":"Android关于Activity生命周期误解","date":"2017-05-05T03:03:36.000Z","_content":"\n两个Activity  A和B，先启动A，通过A打开B，在关闭B，这时候两个Activity的生命周期分别是如何执行的？\n\n我的答案是：\n\nA启动时\n\n`A onCreate onStart onResume`\n\n点击启动B之后\n\n`\tA onPause onStop, B onCreate onStart onResume`\n\nB关闭之后\n\n` B onPause onStop onDestory ,A onRestart onStart onResume`\n\n但是想的太简单了，我以为的并不是我以为的。下面是打印的生命周期执行：\n\n```\n05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onCreate\n05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart\n05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume\n05-05 11:01:33.861 5494-5542/com.example.jenson.myapplication I/OpenGLRenderer: Initialized EGL, version 1.4\n05-05 11:01:46.391 5494-5494/com.example.jenson.myapplication I/MainActivity: onPause\n05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onCreate\n05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStart\n05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onResume\n05-05 11:01:46.691 5494-5494/com.example.jenson.myapplication I/MainActivity: onStop\n05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 0\n05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 1\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/FirstActivity: onPause\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onRestart\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume\n05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStop\n05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onDestroy\n```\n\n> 记住一点：启动一个新Activity，先把自己onPause，然后等新Activity启动成功即onResume后再onStop，关闭当前Activity时，还是先把自己onPause，下一帧的Activity(相对于Activity栈来说)执行恢复onResume，然后自己再执行onStop、onDestory\n\n虽然知道了真相，但是现在还不清楚为什么要这样设计，，有时间还要看看这里的源码，mark下。\n\n","source":"_posts/Android关于Activity生命周期误解.md","raw":"---\ntitle: Android关于Activity生命周期误解\ndate: 2017-05-05 11:03:36\ntags: Android\ncategories: Android\n---\n\n两个Activity  A和B，先启动A，通过A打开B，在关闭B，这时候两个Activity的生命周期分别是如何执行的？\n\n我的答案是：\n\nA启动时\n\n`A onCreate onStart onResume`\n\n点击启动B之后\n\n`\tA onPause onStop, B onCreate onStart onResume`\n\nB关闭之后\n\n` B onPause onStop onDestory ,A onRestart onStart onResume`\n\n但是想的太简单了，我以为的并不是我以为的。下面是打印的生命周期执行：\n\n```\n05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onCreate\n05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart\n05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume\n05-05 11:01:33.861 5494-5542/com.example.jenson.myapplication I/OpenGLRenderer: Initialized EGL, version 1.4\n05-05 11:01:46.391 5494-5494/com.example.jenson.myapplication I/MainActivity: onPause\n05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onCreate\n05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStart\n05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onResume\n05-05 11:01:46.691 5494-5494/com.example.jenson.myapplication I/MainActivity: onStop\n05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 0\n05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 1\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/FirstActivity: onPause\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onRestart\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart\n05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume\n05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStop\n05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onDestroy\n```\n\n> 记住一点：启动一个新Activity，先把自己onPause，然后等新Activity启动成功即onResume后再onStop，关闭当前Activity时，还是先把自己onPause，下一帧的Activity(相对于Activity栈来说)执行恢复onResume，然后自己再执行onStop、onDestory\n\n虽然知道了真相，但是现在还不清楚为什么要这样设计，，有时间还要看看这里的源码，mark下。\n\n","slug":"Android关于Activity生命周期误解","published":1,"updated":"2017-05-07T06:28:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwj810007wh9ca1yxr937","content":"<p>两个Activity  A和B，先启动A，通过A打开B，在关闭B，这时候两个Activity的生命周期分别是如何执行的？</p>\n<p>我的答案是：</p>\n<p>A启动时</p>\n<p><code>A onCreate onStart onResume</code></p>\n<p>点击启动B之后</p>\n<p><code>A onPause onStop, B onCreate onStart onResume</code></p>\n<p>B关闭之后</p>\n<p><code>B onPause onStop onDestory ,A onRestart onStart onResume</code></p>\n<p>但是想的太简单了，我以为的并不是我以为的。下面是打印的生命周期执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onCreate</div><div class=\"line\">05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart</div><div class=\"line\">05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume</div><div class=\"line\">05-05 11:01:33.861 5494-5542/com.example.jenson.myapplication I/OpenGLRenderer: Initialized EGL, version 1.4</div><div class=\"line\">05-05 11:01:46.391 5494-5494/com.example.jenson.myapplication I/MainActivity: onPause</div><div class=\"line\">05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onCreate</div><div class=\"line\">05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStart</div><div class=\"line\">05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onResume</div><div class=\"line\">05-05 11:01:46.691 5494-5494/com.example.jenson.myapplication I/MainActivity: onStop</div><div class=\"line\">05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 0</div><div class=\"line\">05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 1</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/FirstActivity: onPause</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onRestart</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume</div><div class=\"line\">05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStop</div><div class=\"line\">05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onDestroy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>记住一点：启动一个新Activity，先把自己onPause，然后等新Activity启动成功即onResume后再onStop，关闭当前Activity时，还是先把自己onPause，下一帧的Activity(相对于Activity栈来说)执行恢复onResume，然后自己再执行onStop、onDestory</p>\n</blockquote>\n<p>虽然知道了真相，但是现在还不清楚为什么要这样设计，，有时间还要看看这里的源码，mark下。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>两个Activity  A和B，先启动A，通过A打开B，在关闭B，这时候两个Activity的生命周期分别是如何执行的？</p>\n<p>我的答案是：</p>\n<p>A启动时</p>\n<p><code>A onCreate onStart onResume</code></p>\n<p>点击启动B之后</p>\n<p><code>A onPause onStop, B onCreate onStart onResume</code></p>\n<p>B关闭之后</p>\n<p><code>B onPause onStop onDestory ,A onRestart onStart onResume</code></p>\n<p>但是想的太简单了，我以为的并不是我以为的。下面是打印的生命周期执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onCreate</div><div class=\"line\">05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart</div><div class=\"line\">05-05 11:01:33.801 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume</div><div class=\"line\">05-05 11:01:33.861 5494-5542/com.example.jenson.myapplication I/OpenGLRenderer: Initialized EGL, version 1.4</div><div class=\"line\">05-05 11:01:46.391 5494-5494/com.example.jenson.myapplication I/MainActivity: onPause</div><div class=\"line\">05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onCreate</div><div class=\"line\">05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStart</div><div class=\"line\">05-05 11:01:46.411 5494-5494/com.example.jenson.myapplication I/FirstActivity: onResume</div><div class=\"line\">05-05 11:01:46.691 5494-5494/com.example.jenson.myapplication I/MainActivity: onStop</div><div class=\"line\">05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 0</div><div class=\"line\">05-05 11:02:20.641 5494-5494/com.example.jenson.myapplication I/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 1</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/FirstActivity: onPause</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onRestart</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onStart</div><div class=\"line\">05-05 11:02:20.651 5494-5494/com.example.jenson.myapplication I/MainActivity: onResume</div><div class=\"line\">05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onStop</div><div class=\"line\">05-05 11:02:20.871 5494-5494/com.example.jenson.myapplication I/FirstActivity: onDestroy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>记住一点：启动一个新Activity，先把自己onPause，然后等新Activity启动成功即onResume后再onStop，关闭当前Activity时，还是先把自己onPause，下一帧的Activity(相对于Activity栈来说)执行恢复onResume，然后自己再执行onStop、onDestory</p>\n</blockquote>\n<p>虽然知道了真相，但是现在还不清楚为什么要这样设计，，有时间还要看看这里的源码，mark下。</p>\n"},{"title":"2016圆明园荷花节","date":"2017-04-25T09:27:35.000Z","_content":"\n# 说在前面的话\n\n2016年的圆明园荷花节热闹不亚于往年，但是这次拍照片却没有多少可观的。感觉好照片也要讲缘分，比如这次就没有遇到蜻蜓，更没有遇到小孩和猫咪。只能干巴巴的拍荷花。\n\n# 上图\n\n![mmexport1493112391191](2016圆明园荷花节/mmexport1493112391191.jpg)\n\n\n\n\n\n\n\n![mmexport1493112393720](2016圆明园荷花节/mmexport1493112393720.jpg)\n\n\n\n\n\n![mmexport1493112396013](2016圆明园荷花节/mmexport1493112396013.jpg)\n\n\n\n\n\n\n\n![mmexport1493112398170](2016圆明园荷花节/mmexport1493112398170.jpg)\n\n\n\n\n\n\n\n![mmexport1493112400267](2016圆明园荷花节/mmexport1493112400267.jpg)\n\n\n\n\n\n\n\n\n\n![mmexport1493112402523](2016圆明园荷花节/mmexport1493112402523.jpg)\n\n\n\n\n\n![mmexport1493112405316](2016圆明园荷花节/mmexport1493112405316.jpg)\n\n\n\n\n\n","source":"_posts/2016圆明园荷花节.md","raw":"---\ntitle: 2016圆明园荷花节\ndate: 2017-04-25 17:27:35\ntags: 生活\ncategories: 生活\n---\n\n# 说在前面的话\n\n2016年的圆明园荷花节热闹不亚于往年，但是这次拍照片却没有多少可观的。感觉好照片也要讲缘分，比如这次就没有遇到蜻蜓，更没有遇到小孩和猫咪。只能干巴巴的拍荷花。\n\n# 上图\n\n![mmexport1493112391191](2016圆明园荷花节/mmexport1493112391191.jpg)\n\n\n\n\n\n\n\n![mmexport1493112393720](2016圆明园荷花节/mmexport1493112393720.jpg)\n\n\n\n\n\n![mmexport1493112396013](2016圆明园荷花节/mmexport1493112396013.jpg)\n\n\n\n\n\n\n\n![mmexport1493112398170](2016圆明园荷花节/mmexport1493112398170.jpg)\n\n\n\n\n\n\n\n![mmexport1493112400267](2016圆明园荷花节/mmexport1493112400267.jpg)\n\n\n\n\n\n\n\n\n\n![mmexport1493112402523](2016圆明园荷花节/mmexport1493112402523.jpg)\n\n\n\n\n\n![mmexport1493112405316](2016圆明园荷花节/mmexport1493112405316.jpg)\n\n\n\n\n\n","slug":"2016圆明园荷花节","published":1,"updated":"2017-04-25T09:33:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwj9d0008wh9cd1h3hylv","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>2016年的圆明园荷花节热闹不亚于往年，但是这次拍照片却没有多少可观的。感觉好照片也要讲缘分，比如这次就没有遇到蜻蜓，更没有遇到小孩和猫咪。只能干巴巴的拍荷花。</p>\n<h1 id=\"上图\"><a href=\"#上图\" class=\"headerlink\" title=\"上图\"></a>上图</h1><p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112391191.jpg\" alt=\"mmexport1493112391191\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112393720.jpg\" alt=\"mmexport1493112393720\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112396013.jpg\" alt=\"mmexport1493112396013\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112398170.jpg\" alt=\"mmexport1493112398170\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112400267.jpg\" alt=\"mmexport1493112400267\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112402523.jpg\" alt=\"mmexport1493112402523\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112405316.jpg\" alt=\"mmexport1493112405316\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>2016年的圆明园荷花节热闹不亚于往年，但是这次拍照片却没有多少可观的。感觉好照片也要讲缘分，比如这次就没有遇到蜻蜓，更没有遇到小孩和猫咪。只能干巴巴的拍荷花。</p>\n<h1 id=\"上图\"><a href=\"#上图\" class=\"headerlink\" title=\"上图\"></a>上图</h1><p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112391191.jpg\" alt=\"mmexport1493112391191\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112393720.jpg\" alt=\"mmexport1493112393720\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112396013.jpg\" alt=\"mmexport1493112396013\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112398170.jpg\" alt=\"mmexport1493112398170\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112400267.jpg\" alt=\"mmexport1493112400267\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112402523.jpg\" alt=\"mmexport1493112402523\"></p>\n<p><img src=\"/2017/04/25/2016圆明园荷花节/mmexport1493112405316.jpg\" alt=\"mmexport1493112405316\"></p>\n"},{"title":"Android内存分析工具之MAT详解","date":"2017-04-27T05:07:09.000Z","_content":"\n# 说在前面的话\n\n关于Android内存优化可参见我的另一篇文章[[Android性能优化之内存优化](http://www.jensondev.me/2017/04/21/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/)]。Android性能优化中内存优化可谓重中之重，而内存泄露又是Android内存优化的重灾区。重灾区就要重拳出击，整治内存泄露，Mat是必备的利器。\n\n# 关于Mat\n\n\n\nMat，全面Memory Analyzer Tool，Java内存分析工具。注意一点，Mat是由eclipse社区维护，所以如果使用Android studio开发的话，需要单独下载，[官方通道](http://www.eclipse.org/mat/downloads.php)。我用的是mac版，后面也会使用mac版来分析。\n\n# Mat使用\n\n注意：我的测试app包名为：com.example.jenson.myapplication\n\n在eclipse中集成了Mat，可以直接拿来使用，而使用Android studio时。这两个是分开的，所以我们要先导出dump文件。\n\n## Android studio导出dump文件\n\n打开Android Monitor窗口，![0B8D42B7-E5A5-431D-9658-2A99C923CF4E](Android内存分析工具之MAT详解/0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png)\n\n点击圆圈中的按钮，过几秒中会自动生成一个dump文件，然后自动打开如下图的窗口：![1A94CD89-1BE9-46BC-9449-8B55EE34D741](Android内存分析工具之MAT详解/1A94CD89-1BE9-46BC-9449-8B55EE34D741.png)\n\n在Heap Snapshot下的几个文件就是自动生成的dump文件，但是这不是标准的dump文件，所以需要选择文件右键导出标准dump文件，保存到一个目录下：\n\n![屏幕快照 2017-04-27 下午1.49.26](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午1.49.26.png)\n\n\n\n## Mat打开标准dump文件\n\n使用Mat，菜单open File选择刚才导出的dump文件，经过分析后回显示如下所示的项目：\n\n![屏幕快照 2017-04-27 下午2.08.27](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.08.27.png)\n\n\n\nMat从多角度提供了内存分析，其中包括Histogram、Dominator Tree、Leak Suspects和Top consumers等。\n\noverview是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在Inspector栏目显示这块区域的相关信息。\n\nLeak Suspectss是一个关于内存泄露猜想的饼图，Problem Suspect 1是泄露猜想的描述。看我这里说的像是字节数组，这么大的数组难不成是图片，要知道图片在内存中就是以字节数组形式存在的。\n\n平常内存分析比较常用的还是Histogram、Dominator Tree。\n\n## 开始分析内存\n\n这里我们使用Histogram进行分析，切换到Histogram页面。这个页面主要有4个列，Class Name、Objects、Shallow Heap和Retained Heap。其中Class Name是全类名，Objects是这个类的对象实例个数。Shallow Heap是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。Retained Heap指当前对象大小和当前对象能直接或间接引用的对象大小的总和。这个栏目是分析重点。\n\n内存分析是分析的整个系统的内存泄露，而我们只要查找我们APP的内存泄露情况。这无疑增加了很多工作，不过幸亏Histogram支持正则表达式查找，在Regex中输入我们的包名进行过滤，直奔和我们APP有关的内存泄露：\n\n![屏幕快照 2017-04-27 下午3.11.33](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.11.33.png)\n\n过滤后就显示了我们APP相关内存信息，按Retained Heap大小排列下，发现Student和MainActivity这两个类问题比较大。但是MainActivity的Objects数量为1，而Student的为130，看起来Student问题更严重，所以先从Student入手：\n\n首先看下是哪里的引用导致了Student不能被GC回收。![屏幕快照 2017-04-27 下午3.19.06](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.19.06.png)\n\n右键使用Merge Shortest Paths to GC Roots显示距GC Root最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。进入结果页查看：\n\n![屏幕快照 2017-04-27 下午3.22.23](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.22.23.png)\n\n啧啧，原来Student不能被回收竟然就是这个MainActivity搞的鬼，可以看到这个类里面有个students集合里面存放的正式不能回收的Student对象。\n\n看代码：\n\n```\n    static List<Student> students=new ArrayList<>();\n    static final String tag=\"MainActivity\";\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        sample_text = (TextView) findViewById(R.id.sample_text);\n        TestNative testNative = new TestNative();\n        sample_text.setText(testNative.stringFromJNI());\n        for (int i = 0; i < 10; i++) {\n\n            Student student = new Student(\"jenson\" + i, i);\n            students.add(student);\n        }\n    }\n```\n\n原来不能被回收是因为用static修饰了students集合。这导致其生命周期边长，在Activity销毁时，仍然存在。问题找到了，去掉static完成内存泄露修复。\n\n","source":"_posts/Android内存分析工具之MAT详解.md","raw":"---\ntitle: Android内存分析工具之MAT详解\ndate: 2017-04-27 13:07:09\ntags: Android\ncategories: Android\n---\n\n# 说在前面的话\n\n关于Android内存优化可参见我的另一篇文章[[Android性能优化之内存优化](http://www.jensondev.me/2017/04/21/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/)]。Android性能优化中内存优化可谓重中之重，而内存泄露又是Android内存优化的重灾区。重灾区就要重拳出击，整治内存泄露，Mat是必备的利器。\n\n# 关于Mat\n\n\n\nMat，全面Memory Analyzer Tool，Java内存分析工具。注意一点，Mat是由eclipse社区维护，所以如果使用Android studio开发的话，需要单独下载，[官方通道](http://www.eclipse.org/mat/downloads.php)。我用的是mac版，后面也会使用mac版来分析。\n\n# Mat使用\n\n注意：我的测试app包名为：com.example.jenson.myapplication\n\n在eclipse中集成了Mat，可以直接拿来使用，而使用Android studio时。这两个是分开的，所以我们要先导出dump文件。\n\n## Android studio导出dump文件\n\n打开Android Monitor窗口，![0B8D42B7-E5A5-431D-9658-2A99C923CF4E](Android内存分析工具之MAT详解/0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png)\n\n点击圆圈中的按钮，过几秒中会自动生成一个dump文件，然后自动打开如下图的窗口：![1A94CD89-1BE9-46BC-9449-8B55EE34D741](Android内存分析工具之MAT详解/1A94CD89-1BE9-46BC-9449-8B55EE34D741.png)\n\n在Heap Snapshot下的几个文件就是自动生成的dump文件，但是这不是标准的dump文件，所以需要选择文件右键导出标准dump文件，保存到一个目录下：\n\n![屏幕快照 2017-04-27 下午1.49.26](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午1.49.26.png)\n\n\n\n## Mat打开标准dump文件\n\n使用Mat，菜单open File选择刚才导出的dump文件，经过分析后回显示如下所示的项目：\n\n![屏幕快照 2017-04-27 下午2.08.27](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.08.27.png)\n\n\n\nMat从多角度提供了内存分析，其中包括Histogram、Dominator Tree、Leak Suspects和Top consumers等。\n\noverview是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在Inspector栏目显示这块区域的相关信息。\n\nLeak Suspectss是一个关于内存泄露猜想的饼图，Problem Suspect 1是泄露猜想的描述。看我这里说的像是字节数组，这么大的数组难不成是图片，要知道图片在内存中就是以字节数组形式存在的。\n\n平常内存分析比较常用的还是Histogram、Dominator Tree。\n\n## 开始分析内存\n\n这里我们使用Histogram进行分析，切换到Histogram页面。这个页面主要有4个列，Class Name、Objects、Shallow Heap和Retained Heap。其中Class Name是全类名，Objects是这个类的对象实例个数。Shallow Heap是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。Retained Heap指当前对象大小和当前对象能直接或间接引用的对象大小的总和。这个栏目是分析重点。\n\n内存分析是分析的整个系统的内存泄露，而我们只要查找我们APP的内存泄露情况。这无疑增加了很多工作，不过幸亏Histogram支持正则表达式查找，在Regex中输入我们的包名进行过滤，直奔和我们APP有关的内存泄露：\n\n![屏幕快照 2017-04-27 下午3.11.33](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.11.33.png)\n\n过滤后就显示了我们APP相关内存信息，按Retained Heap大小排列下，发现Student和MainActivity这两个类问题比较大。但是MainActivity的Objects数量为1，而Student的为130，看起来Student问题更严重，所以先从Student入手：\n\n首先看下是哪里的引用导致了Student不能被GC回收。![屏幕快照 2017-04-27 下午3.19.06](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.19.06.png)\n\n右键使用Merge Shortest Paths to GC Roots显示距GC Root最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。进入结果页查看：\n\n![屏幕快照 2017-04-27 下午3.22.23](Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.22.23.png)\n\n啧啧，原来Student不能被回收竟然就是这个MainActivity搞的鬼，可以看到这个类里面有个students集合里面存放的正式不能回收的Student对象。\n\n看代码：\n\n```\n    static List<Student> students=new ArrayList<>();\n    static final String tag=\"MainActivity\";\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        sample_text = (TextView) findViewById(R.id.sample_text);\n        TestNative testNative = new TestNative();\n        sample_text.setText(testNative.stringFromJNI());\n        for (int i = 0; i < 10; i++) {\n\n            Student student = new Student(\"jenson\" + i, i);\n            students.add(student);\n        }\n    }\n```\n\n原来不能被回收是因为用static修饰了students集合。这导致其生命周期边长，在Activity销毁时，仍然存在。问题找到了，去掉static完成内存泄露修复。\n\n","slug":"Android内存分析工具之MAT详解","published":1,"updated":"2017-04-27T07:44:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwj9p0009wh9ce9kc2y61","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>关于Android内存优化可参见我的另一篇文章[<a href=\"http://www.jensondev.me/2017/04/21/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"external\">Android性能优化之内存优化</a>]。Android性能优化中内存优化可谓重中之重，而内存泄露又是Android内存优化的重灾区。重灾区就要重拳出击，整治内存泄露，Mat是必备的利器。</p>\n<h1 id=\"关于Mat\"><a href=\"#关于Mat\" class=\"headerlink\" title=\"关于Mat\"></a>关于Mat</h1><p>Mat，全面Memory Analyzer Tool，Java内存分析工具。注意一点，Mat是由eclipse社区维护，所以如果使用Android studio开发的话，需要单独下载，<a href=\"http://www.eclipse.org/mat/downloads.php\" target=\"_blank\" rel=\"external\">官方通道</a>。我用的是mac版，后面也会使用mac版来分析。</p>\n<h1 id=\"Mat使用\"><a href=\"#Mat使用\" class=\"headerlink\" title=\"Mat使用\"></a>Mat使用</h1><p>注意：我的测试app包名为：com.example.jenson.myapplication</p>\n<p>在eclipse中集成了Mat，可以直接拿来使用，而使用Android studio时。这两个是分开的，所以我们要先导出dump文件。</p>\n<h2 id=\"Android-studio导出dump文件\"><a href=\"#Android-studio导出dump文件\" class=\"headerlink\" title=\"Android studio导出dump文件\"></a>Android studio导出dump文件</h2><p>打开Android Monitor窗口，<img src=\"/2017/04/27/Android内存分析工具之MAT详解/0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png\" alt=\"0B8D42B7-E5A5-431D-9658-2A99C923CF4E\"></p>\n<p>点击圆圈中的按钮，过几秒中会自动生成一个dump文件，然后自动打开如下图的窗口：<img src=\"/2017/04/27/Android内存分析工具之MAT详解/1A94CD89-1BE9-46BC-9449-8B55EE34D741.png\" alt=\"1A94CD89-1BE9-46BC-9449-8B55EE34D741\"></p>\n<p>在Heap Snapshot下的几个文件就是自动生成的dump文件，但是这不是标准的dump文件，所以需要选择文件右键导出标准dump文件，保存到一个目录下：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午1.49.26.png\" alt=\"屏幕快照 2017-04-27 下午1.49.26\"></p>\n<h2 id=\"Mat打开标准dump文件\"><a href=\"#Mat打开标准dump文件\" class=\"headerlink\" title=\"Mat打开标准dump文件\"></a>Mat打开标准dump文件</h2><p>使用Mat，菜单open File选择刚才导出的dump文件，经过分析后回显示如下所示的项目：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.08.27.png\" alt=\"屏幕快照 2017-04-27 下午2.08.27\"></p>\n<p>Mat从多角度提供了内存分析，其中包括Histogram、Dominator Tree、Leak Suspects和Top consumers等。</p>\n<p>overview是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在Inspector栏目显示这块区域的相关信息。</p>\n<p>Leak Suspectss是一个关于内存泄露猜想的饼图，Problem Suspect 1是泄露猜想的描述。看我这里说的像是字节数组，这么大的数组难不成是图片，要知道图片在内存中就是以字节数组形式存在的。</p>\n<p>平常内存分析比较常用的还是Histogram、Dominator Tree。</p>\n<h2 id=\"开始分析内存\"><a href=\"#开始分析内存\" class=\"headerlink\" title=\"开始分析内存\"></a>开始分析内存</h2><p>这里我们使用Histogram进行分析，切换到Histogram页面。这个页面主要有4个列，Class Name、Objects、Shallow Heap和Retained Heap。其中Class Name是全类名，Objects是这个类的对象实例个数。Shallow Heap是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。Retained Heap指当前对象大小和当前对象能直接或间接引用的对象大小的总和。这个栏目是分析重点。</p>\n<p>内存分析是分析的整个系统的内存泄露，而我们只要查找我们APP的内存泄露情况。这无疑增加了很多工作，不过幸亏Histogram支持正则表达式查找，在Regex中输入我们的包名进行过滤，直奔和我们APP有关的内存泄露：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.11.33.png\" alt=\"屏幕快照 2017-04-27 下午3.11.33\"></p>\n<p>过滤后就显示了我们APP相关内存信息，按Retained Heap大小排列下，发现Student和MainActivity这两个类问题比较大。但是MainActivity的Objects数量为1，而Student的为130，看起来Student问题更严重，所以先从Student入手：</p>\n<p>首先看下是哪里的引用导致了Student不能被GC回收。<img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.19.06.png\" alt=\"屏幕快照 2017-04-27 下午3.19.06\"></p>\n<p>右键使用Merge Shortest Paths to GC Roots显示距GC Root最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。进入结果页查看：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.22.23.png\" alt=\"屏幕快照 2017-04-27 下午3.22.23\"></p>\n<p>啧啧，原来Student不能被回收竟然就是这个MainActivity搞的鬼，可以看到这个类里面有个students集合里面存放的正式不能回收的Student对象。</p>\n<p>看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">static List&lt;Student&gt; students=new ArrayList&lt;&gt;();</div><div class=\"line\">static final String tag=&quot;MainActivity&quot;;</div><div class=\"line\">@Override</div><div class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">    super.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.activity_main);</div><div class=\"line\">    sample_text = (TextView) findViewById(R.id.sample_text);</div><div class=\"line\">    TestNative testNative = new TestNative();</div><div class=\"line\">    sample_text.setText(testNative.stringFromJNI());</div><div class=\"line\">    for (int i = 0; i &lt; 10; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">        Student student = new Student(&quot;jenson&quot; + i, i);</div><div class=\"line\">        students.add(student);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原来不能被回收是因为用static修饰了students集合。这导致其生命周期边长，在Activity销毁时，仍然存在。问题找到了，去掉static完成内存泄露修复。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>关于Android内存优化可参见我的另一篇文章[<a href=\"http://www.jensondev.me/2017/04/21/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/\">Android性能优化之内存优化</a>]。Android性能优化中内存优化可谓重中之重，而内存泄露又是Android内存优化的重灾区。重灾区就要重拳出击，整治内存泄露，Mat是必备的利器。</p>\n<h1 id=\"关于Mat\"><a href=\"#关于Mat\" class=\"headerlink\" title=\"关于Mat\"></a>关于Mat</h1><p>Mat，全面Memory Analyzer Tool，Java内存分析工具。注意一点，Mat是由eclipse社区维护，所以如果使用Android studio开发的话，需要单独下载，<a href=\"http://www.eclipse.org/mat/downloads.php\">官方通道</a>。我用的是mac版，后面也会使用mac版来分析。</p>\n<h1 id=\"Mat使用\"><a href=\"#Mat使用\" class=\"headerlink\" title=\"Mat使用\"></a>Mat使用</h1><p>注意：我的测试app包名为：com.example.jenson.myapplication</p>\n<p>在eclipse中集成了Mat，可以直接拿来使用，而使用Android studio时。这两个是分开的，所以我们要先导出dump文件。</p>\n<h2 id=\"Android-studio导出dump文件\"><a href=\"#Android-studio导出dump文件\" class=\"headerlink\" title=\"Android studio导出dump文件\"></a>Android studio导出dump文件</h2><p>打开Android Monitor窗口，<img src=\"/2017/04/27/Android内存分析工具之MAT详解/0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png\" alt=\"0B8D42B7-E5A5-431D-9658-2A99C923CF4E\"></p>\n<p>点击圆圈中的按钮，过几秒中会自动生成一个dump文件，然后自动打开如下图的窗口：<img src=\"/2017/04/27/Android内存分析工具之MAT详解/1A94CD89-1BE9-46BC-9449-8B55EE34D741.png\" alt=\"1A94CD89-1BE9-46BC-9449-8B55EE34D741\"></p>\n<p>在Heap Snapshot下的几个文件就是自动生成的dump文件，但是这不是标准的dump文件，所以需要选择文件右键导出标准dump文件，保存到一个目录下：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午1.49.26.png\" alt=\"屏幕快照 2017-04-27 下午1.49.26\"></p>\n<h2 id=\"Mat打开标准dump文件\"><a href=\"#Mat打开标准dump文件\" class=\"headerlink\" title=\"Mat打开标准dump文件\"></a>Mat打开标准dump文件</h2><p>使用Mat，菜单open File选择刚才导出的dump文件，经过分析后回显示如下所示的项目：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.08.27.png\" alt=\"屏幕快照 2017-04-27 下午2.08.27\"></p>\n<p>Mat从多角度提供了内存分析，其中包括Histogram、Dominator Tree、Leak Suspects和Top consumers等。</p>\n<p>overview是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在Inspector栏目显示这块区域的相关信息。</p>\n<p>Leak Suspectss是一个关于内存泄露猜想的饼图，Problem Suspect 1是泄露猜想的描述。看我这里说的像是字节数组，这么大的数组难不成是图片，要知道图片在内存中就是以字节数组形式存在的。</p>\n<p>平常内存分析比较常用的还是Histogram、Dominator Tree。</p>\n<h2 id=\"开始分析内存\"><a href=\"#开始分析内存\" class=\"headerlink\" title=\"开始分析内存\"></a>开始分析内存</h2><p>这里我们使用Histogram进行分析，切换到Histogram页面。这个页面主要有4个列，Class Name、Objects、Shallow Heap和Retained Heap。其中Class Name是全类名，Objects是这个类的对象实例个数。Shallow Heap是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。Retained Heap指当前对象大小和当前对象能直接或间接引用的对象大小的总和。这个栏目是分析重点。</p>\n<p>内存分析是分析的整个系统的内存泄露，而我们只要查找我们APP的内存泄露情况。这无疑增加了很多工作，不过幸亏Histogram支持正则表达式查找，在Regex中输入我们的包名进行过滤，直奔和我们APP有关的内存泄露：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.11.33.png\" alt=\"屏幕快照 2017-04-27 下午3.11.33\"></p>\n<p>过滤后就显示了我们APP相关内存信息，按Retained Heap大小排列下，发现Student和MainActivity这两个类问题比较大。但是MainActivity的Objects数量为1，而Student的为130，看起来Student问题更严重，所以先从Student入手：</p>\n<p>首先看下是哪里的引用导致了Student不能被GC回收。<img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.19.06.png\" alt=\"屏幕快照 2017-04-27 下午3.19.06\"></p>\n<p>右键使用Merge Shortest Paths to GC Roots显示距GC Root最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。进入结果页查看：</p>\n<p><img src=\"/2017/04/27/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.22.23.png\" alt=\"屏幕快照 2017-04-27 下午3.22.23\"></p>\n<p>啧啧，原来Student不能被回收竟然就是这个MainActivity搞的鬼，可以看到这个类里面有个students集合里面存放的正式不能回收的Student对象。</p>\n<p>看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">static List&lt;Student&gt; students=new ArrayList&lt;&gt;();</div><div class=\"line\">static final String tag=&quot;MainActivity&quot;;</div><div class=\"line\">@Override</div><div class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">    super.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.activity_main);</div><div class=\"line\">    sample_text = (TextView) findViewById(R.id.sample_text);</div><div class=\"line\">    TestNative testNative = new TestNative();</div><div class=\"line\">    sample_text.setText(testNative.stringFromJNI());</div><div class=\"line\">    for (int i = 0; i &lt; 10; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">        Student student = new Student(&quot;jenson&quot; + i, i);</div><div class=\"line\">        students.add(student);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原来不能被回收是因为用static修饰了students集合。这导致其生命周期边长，在Activity销毁时，仍然存在。问题找到了，去掉static完成内存泄露修复。</p>\n"},{"title":"Android屏幕适配","date":"2017-08-01T05:23:03.000Z","_content":"\n# 前言\n\n由于Android手机尺寸、分辨率碎片化严重，在Android应用开发中屏幕适配需求也变得越来越重要。\n\n#  概念理解\n\n**屏幕尺寸**指屏幕对角线的长度，以英寸为单位，1英寸=2.54厘米。\n**屏幕分辨率**指在横纵向上的像素点数，单位是px，1px=1像素点，一般是纵向像素x横向像素，如1280×720。\n**屏幕像素密度**是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写，像素密度和屏幕尺寸和屏幕分辨率有关，像素密度也叫dpi。\n\n**dp，也是dip：**Density Independent Pixels的缩写。以**160dpi**为基准，1dp=1px，密度无关像素\n**dpi：**屏幕像素密度的单位，“dot per inch”的缩写\n\n**px：**像素，物理上的绝对单位\n\n**sp：**Scale-Independent Pixels的缩写，可以根据系统自动进行缩放。通常可以使用12sp，14sp，18sp，22sp，为了避免精度失真一般不使用奇数和小数。\n\n不同密度区分：\n\n| 名称      | 密度范围        | 图片大小      | 比例   |\n| ------- | ----------- | --------- | ---- |\n| mdpi    | 120dp~160dp | 48×48px   | 2    |\n| hdpi    | 160dp~240dp | 72×72px   | 3    |\n| xhdpi   | 240dp~320dp | 96×96px   | 4    |\n| xxhdpi  | 320dp~480dp | 144×144px | 6    |\n| xxxhdpi | 480dp~640dp | 192×192px | 8    |\n|         |             |           | 12   |\n\n**如果只想出一套图片优先出xxhdpi，这样在低于这个密度下的系统会压缩图片进行显示，不至于会模糊，同时由于xxxhdpi还没有流行起来，用户数量少。**\n\n\n\n# 适配方法\n\n## 适配尺寸\n\n- 优先使用wrap_content，matc_parent，weight\n\n- 使用相对布局，禁止使用绝对布局\n\n- 使用限定符\n\n  - 尺寸限定符，如layout-large\n\n    3.2系统以前有用，\n\n    3.2版本后又退出了最小宽度限定符如layout-sw600dp\n\n    sw=small width 最小宽度。\n\n    如果要维护全系统版本，需要维护的布局太多，应该抽取共同布局\n\n    创建`res/layout/main.xml`布局文件。\n\n    默认布局`res/values/layout.xml`。内容为：\n\n    ```xml\n    <resource>\n    \t<item name=\"main\"type=\"layout\">\n          @layout/main\n        </item>\n      </resource>\n    ```\n\n    创建`res/layout/main_twopanels.xml`布局文件。\n\n    给3.2之前版本创建`res/values-large/layout.xml`文件，内容为：\n\n    ```xml\n    <resource>\n    \t<item name=\"main\"type=\"layout\">\n          @layout/main_twopanels\n        </item>\n      </resource>\n    ```\n\n    给3.2之后的版本创建`res/values-sw600dp/layout.xml`文件，内容为：\n\n    ```xml\n    <resource>\n    \t<item name=\"main\"type=\"layout\">\n          @layout/main_twopanels\n        </item>\n      </resource>\n    ```\n\n    ​\n\n  - 屏幕方向限定符：-land，-port\n\n- 使用点九位图\n\n  左上控制拉伸区域，右下控制间隔区域\n\n\n\n## 适配密度\n\n- 使用非密度制约像素  如dp，sp\n\n  ​\n\n- 多种位图\n\n  **如果只提供一种高分辨率图，将其放在对应的密度drawable下没有问题。但是如果将其放入低于当前密度的drawable下，会造成图片按比例放大，导致内存倍数增加**\n\n  比如把一个1920x1080的xxhdpi的图片放在mdpi下，内存占用会增加9倍。\n\n  按照图片比例的2：3：4：6：8计算出来。\n\n  ​","source":"_posts/Android屏幕适配.md","raw":"---\ntitle: Android屏幕适配\ndate: 2017-08-01 13:23:03\ntags: Android\ncategories: Android\n---\n\n# 前言\n\n由于Android手机尺寸、分辨率碎片化严重，在Android应用开发中屏幕适配需求也变得越来越重要。\n\n#  概念理解\n\n**屏幕尺寸**指屏幕对角线的长度，以英寸为单位，1英寸=2.54厘米。\n**屏幕分辨率**指在横纵向上的像素点数，单位是px，1px=1像素点，一般是纵向像素x横向像素，如1280×720。\n**屏幕像素密度**是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写，像素密度和屏幕尺寸和屏幕分辨率有关，像素密度也叫dpi。\n\n**dp，也是dip：**Density Independent Pixels的缩写。以**160dpi**为基准，1dp=1px，密度无关像素\n**dpi：**屏幕像素密度的单位，“dot per inch”的缩写\n\n**px：**像素，物理上的绝对单位\n\n**sp：**Scale-Independent Pixels的缩写，可以根据系统自动进行缩放。通常可以使用12sp，14sp，18sp，22sp，为了避免精度失真一般不使用奇数和小数。\n\n不同密度区分：\n\n| 名称      | 密度范围        | 图片大小      | 比例   |\n| ------- | ----------- | --------- | ---- |\n| mdpi    | 120dp~160dp | 48×48px   | 2    |\n| hdpi    | 160dp~240dp | 72×72px   | 3    |\n| xhdpi   | 240dp~320dp | 96×96px   | 4    |\n| xxhdpi  | 320dp~480dp | 144×144px | 6    |\n| xxxhdpi | 480dp~640dp | 192×192px | 8    |\n|         |             |           | 12   |\n\n**如果只想出一套图片优先出xxhdpi，这样在低于这个密度下的系统会压缩图片进行显示，不至于会模糊，同时由于xxxhdpi还没有流行起来，用户数量少。**\n\n\n\n# 适配方法\n\n## 适配尺寸\n\n- 优先使用wrap_content，matc_parent，weight\n\n- 使用相对布局，禁止使用绝对布局\n\n- 使用限定符\n\n  - 尺寸限定符，如layout-large\n\n    3.2系统以前有用，\n\n    3.2版本后又退出了最小宽度限定符如layout-sw600dp\n\n    sw=small width 最小宽度。\n\n    如果要维护全系统版本，需要维护的布局太多，应该抽取共同布局\n\n    创建`res/layout/main.xml`布局文件。\n\n    默认布局`res/values/layout.xml`。内容为：\n\n    ```xml\n    <resource>\n    \t<item name=\"main\"type=\"layout\">\n          @layout/main\n        </item>\n      </resource>\n    ```\n\n    创建`res/layout/main_twopanels.xml`布局文件。\n\n    给3.2之前版本创建`res/values-large/layout.xml`文件，内容为：\n\n    ```xml\n    <resource>\n    \t<item name=\"main\"type=\"layout\">\n          @layout/main_twopanels\n        </item>\n      </resource>\n    ```\n\n    给3.2之后的版本创建`res/values-sw600dp/layout.xml`文件，内容为：\n\n    ```xml\n    <resource>\n    \t<item name=\"main\"type=\"layout\">\n          @layout/main_twopanels\n        </item>\n      </resource>\n    ```\n\n    ​\n\n  - 屏幕方向限定符：-land，-port\n\n- 使用点九位图\n\n  左上控制拉伸区域，右下控制间隔区域\n\n\n\n## 适配密度\n\n- 使用非密度制约像素  如dp，sp\n\n  ​\n\n- 多种位图\n\n  **如果只提供一种高分辨率图，将其放在对应的密度drawable下没有问题。但是如果将其放入低于当前密度的drawable下，会造成图片按比例放大，导致内存倍数增加**\n\n  比如把一个1920x1080的xxhdpi的图片放在mdpi下，内存占用会增加9倍。\n\n  按照图片比例的2：3：4：6：8计算出来。\n\n  ​","slug":"Android屏幕适配","published":1,"updated":"2017-08-01T08:14:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwja5000dwh9cog2t6xju","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>由于Android手机尺寸、分辨率碎片化严重，在Android应用开发中屏幕适配需求也变得越来越重要。</p>\n<h1 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h1><p><strong>屏幕尺寸</strong>指屏幕对角线的长度，以英寸为单位，1英寸=2.54厘米。<br><strong>屏幕分辨率</strong>指在横纵向上的像素点数，单位是px，1px=1像素点，一般是纵向像素x横向像素，如1280×720。<br><strong>屏幕像素密度</strong>是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写，像素密度和屏幕尺寸和屏幕分辨率有关，像素密度也叫dpi。</p>\n<p><strong>dp，也是dip：</strong>Density Independent Pixels的缩写。以<strong>160dpi</strong>为基准，1dp=1px，密度无关像素<br><strong>dpi：</strong>屏幕像素密度的单位，“dot per inch”的缩写</p>\n<p><strong>px：</strong>像素，物理上的绝对单位</p>\n<p><strong>sp：</strong>Scale-Independent Pixels的缩写，可以根据系统自动进行缩放。通常可以使用12sp，14sp，18sp，22sp，为了避免精度失真一般不使用奇数和小数。</p>\n<p>不同密度区分：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>密度范围</th>\n<th>图片大小</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mdpi</td>\n<td>120dp~160dp</td>\n<td>48×48px</td>\n<td>2</td>\n</tr>\n<tr>\n<td>hdpi</td>\n<td>160dp~240dp</td>\n<td>72×72px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>xhdpi</td>\n<td>240dp~320dp</td>\n<td>96×96px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>xxhdpi</td>\n<td>320dp~480dp</td>\n<td>144×144px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>xxxhdpi</td>\n<td>480dp~640dp</td>\n<td>192×192px</td>\n<td>8</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p><strong>如果只想出一套图片优先出xxhdpi，这样在低于这个密度下的系统会压缩图片进行显示，不至于会模糊，同时由于xxxhdpi还没有流行起来，用户数量少。</strong></p>\n<h1 id=\"适配方法\"><a href=\"#适配方法\" class=\"headerlink\" title=\"适配方法\"></a>适配方法</h1><h2 id=\"适配尺寸\"><a href=\"#适配尺寸\" class=\"headerlink\" title=\"适配尺寸\"></a>适配尺寸</h2><ul>\n<li><p>优先使用wrap_content，matc_parent，weight</p>\n</li>\n<li><p>使用相对布局，禁止使用绝对布局</p>\n</li>\n<li><p>使用限定符</p>\n<ul>\n<li><p>尺寸限定符，如layout-large</p>\n<p>3.2系统以前有用，</p>\n<p>3.2版本后又退出了最小宽度限定符如layout-sw600dp</p>\n<p>sw=small width 最小宽度。</p>\n<p>如果要维护全系统版本，需要维护的布局太多，应该抽取共同布局</p>\n<p>创建<code>res/layout/main.xml</code>布局文件。</p>\n<p>默认布局<code>res/values/layout.xml</code>。内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span><span class=\"attr\">type</span>=<span class=\"string\">\"layout\"</span>&gt;</span></div><div class=\"line\">      @layout/main</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>创建<code>res/layout/main_twopanels.xml</code>布局文件。</p>\n<p>给3.2之前版本创建<code>res/values-large/layout.xml</code>文件，内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span><span class=\"attr\">type</span>=<span class=\"string\">\"layout\"</span>&gt;</span></div><div class=\"line\">      @layout/main_twopanels</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>给3.2之后的版本创建<code>res/values-sw600dp/layout.xml</code>文件，内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span><span class=\"attr\">type</span>=<span class=\"string\">\"layout\"</span>&gt;</span></div><div class=\"line\">      @layout/main_twopanels</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>屏幕方向限定符：-land，-port</p>\n</li>\n</ul>\n</li>\n<li><p>使用点九位图</p>\n<p>左上控制拉伸区域，右下控制间隔区域</p>\n</li>\n</ul>\n<h2 id=\"适配密度\"><a href=\"#适配密度\" class=\"headerlink\" title=\"适配密度\"></a>适配密度</h2><ul>\n<li><p>使用非密度制约像素  如dp，sp</p>\n<p>​</p>\n</li>\n<li><p>多种位图</p>\n<p><strong>如果只提供一种高分辨率图，将其放在对应的密度drawable下没有问题。但是如果将其放入低于当前密度的drawable下，会造成图片按比例放大，导致内存倍数增加</strong></p>\n<p>比如把一个1920x1080的xxhdpi的图片放在mdpi下，内存占用会增加9倍。</p>\n<p>按照图片比例的2：3：4：6：8计算出来。</p>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>由于Android手机尺寸、分辨率碎片化严重，在Android应用开发中屏幕适配需求也变得越来越重要。</p>\n<h1 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h1><p><strong>屏幕尺寸</strong>指屏幕对角线的长度，以英寸为单位，1英寸=2.54厘米。<br><strong>屏幕分辨率</strong>指在横纵向上的像素点数，单位是px，1px=1像素点，一般是纵向像素x横向像素，如1280×720。<br><strong>屏幕像素密度</strong>是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写，像素密度和屏幕尺寸和屏幕分辨率有关，像素密度也叫dpi。</p>\n<p><strong>dp，也是dip：</strong>Density Independent Pixels的缩写。以<strong>160dpi</strong>为基准，1dp=1px，密度无关像素<br><strong>dpi：</strong>屏幕像素密度的单位，“dot per inch”的缩写</p>\n<p><strong>px：</strong>像素，物理上的绝对单位</p>\n<p><strong>sp：</strong>Scale-Independent Pixels的缩写，可以根据系统自动进行缩放。通常可以使用12sp，14sp，18sp，22sp，为了避免精度失真一般不使用奇数和小数。</p>\n<p>不同密度区分：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>密度范围</th>\n<th>图片大小</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mdpi</td>\n<td>120dp~160dp</td>\n<td>48×48px</td>\n<td>2</td>\n</tr>\n<tr>\n<td>hdpi</td>\n<td>160dp~240dp</td>\n<td>72×72px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>xhdpi</td>\n<td>240dp~320dp</td>\n<td>96×96px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>xxhdpi</td>\n<td>320dp~480dp</td>\n<td>144×144px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>xxxhdpi</td>\n<td>480dp~640dp</td>\n<td>192×192px</td>\n<td>8</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p><strong>如果只想出一套图片优先出xxhdpi，这样在低于这个密度下的系统会压缩图片进行显示，不至于会模糊，同时由于xxxhdpi还没有流行起来，用户数量少。</strong></p>\n<h1 id=\"适配方法\"><a href=\"#适配方法\" class=\"headerlink\" title=\"适配方法\"></a>适配方法</h1><h2 id=\"适配尺寸\"><a href=\"#适配尺寸\" class=\"headerlink\" title=\"适配尺寸\"></a>适配尺寸</h2><ul>\n<li><p>优先使用wrap_content，matc_parent，weight</p>\n</li>\n<li><p>使用相对布局，禁止使用绝对布局</p>\n</li>\n<li><p>使用限定符</p>\n<ul>\n<li><p>尺寸限定符，如layout-large</p>\n<p>3.2系统以前有用，</p>\n<p>3.2版本后又退出了最小宽度限定符如layout-sw600dp</p>\n<p>sw=small width 最小宽度。</p>\n<p>如果要维护全系统版本，需要维护的布局太多，应该抽取共同布局</p>\n<p>创建<code>res/layout/main.xml</code>布局文件。</p>\n<p>默认布局<code>res/values/layout.xml</code>。内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span><span class=\"attr\">type</span>=<span class=\"string\">\"layout\"</span>&gt;</span></div><div class=\"line\">      @layout/main</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>创建<code>res/layout/main_twopanels.xml</code>布局文件。</p>\n<p>给3.2之前版本创建<code>res/values-large/layout.xml</code>文件，内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span><span class=\"attr\">type</span>=<span class=\"string\">\"layout\"</span>&gt;</span></div><div class=\"line\">      @layout/main_twopanels</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>给3.2之后的版本创建<code>res/values-sw600dp/layout.xml</code>文件，内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span><span class=\"attr\">type</span>=<span class=\"string\">\"layout\"</span>&gt;</span></div><div class=\"line\">      @layout/main_twopanels</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>屏幕方向限定符：-land，-port</p>\n</li>\n</ul>\n</li>\n<li><p>使用点九位图</p>\n<p>左上控制拉伸区域，右下控制间隔区域</p>\n</li>\n</ul>\n<h2 id=\"适配密度\"><a href=\"#适配密度\" class=\"headerlink\" title=\"适配密度\"></a>适配密度</h2><ul>\n<li><p>使用非密度制约像素  如dp，sp</p>\n<p>​</p>\n</li>\n<li><p>多种位图</p>\n<p><strong>如果只提供一种高分辨率图，将其放在对应的密度drawable下没有问题。但是如果将其放入低于当前密度的drawable下，会造成图片按比例放大，导致内存倍数增加</strong></p>\n<p>比如把一个1920x1080的xxhdpi的图片放在mdpi下，内存占用会增加9倍。</p>\n<p>按照图片比例的2：3：4：6：8计算出来。</p>\n<p>​</p>\n</li>\n</ul>\n"},{"title":"Android性能优化之内存优化","date":"2017-04-21T12:55:54.000Z","_content":">上一章讲了[Android性能优化之耗电优化\n](http://www.jianshu.com/p/bd3d673aa979)，感兴趣的可以看下。这一章来说说Android内存方面如何优化，虽说是讲内存优化但是并不涉及虚拟机底层原理，力求通俗易懂。\n\n\n![屏幕快照 2017-03-29 下午2.58.41.png](http://upload-images.jianshu.io/upload_images/1796052-0956f76fd0a3e36b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n养成好习惯先上图。内存从状态上来说只有已使用和未使用两种。本章内存优化也从这两方面下手：已使用的内存如何保证虚拟机的顺利回收、未使用的内存如何在满足需求的情况下尽量小的申请。\n\n#### 如何保证已使用内存顺利被回收？\n- Java对象生命周期\n  - 创建阶段\n申请内存空间，构造对象并初始化相关属性值\n  - 使用阶段\n根据对象应用调用相关方法完成业务逻辑。对象至少被一个强引用持有，除非对象创建时显示声明使用软引用、弱引用和虚引用。\n  - 不可见阶段\n当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，当然对象还是存在着的。\n  - 不可达阶段\n对象处于不可达阶段是指该对象不再被任何强引用所持有。GC会发现对象已不可达\n\n  - 收集阶段\n当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。\n  - 终结阶段\n当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段，等待垃圾回收器对该对象空间进行回收。\n\n  - 对象空间重新分配阶段\n若垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，则该对象彻底消失，这个阶段称之为“对象空间重新分配阶段”。\n\n\t以上是Java对象生命周期的简要介绍，要保证内存顺利回收，正确使用Java对象生命周期很重要，如果不能及时回收，我们就称之为“发生了内存泄露”。\n\n>在不可见阶段，程序本身不再持有对象强引用，但对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。\n\n\n![垃圾回收.jpeg](http://upload-images.jianshu.io/upload_images/1796052-ef7e7496b8a9cd2e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n图中灰色的孤立无援的对象对于GC Roots来说不可达，会被回收。知道了内存泄露会影响回收，下面说下哪些方面会导致内存泄露\n\n- 引起内存泄露的情况\n   - 资源没有适时关闭\nsqlite的cursor、读写文件使用的File文件流等在使用完后没有及时关闭。虽然cursor会在系统回收时自动关闭，但是这样效率较低。对于资源对象使用还是应该养成良好习惯，使用完毕close并置空。\n   - 注册对象未注销\n在Android中主要是指注册的广播在Activity销毁时反注销。\n在Activity中如果有使用的观察者模式在生命周期发生变化时根据需求注销。\n在Activity中使用的各类传感器(光线、重力等)在页面销毁时及时注销，否则不光导致内存泄露还会因为传感器频繁的采样导致耗电及cpu的占用。\n   - 使用static修饰变量\n这里只说一点，被static修饰的变量可以认为是直接被GC Roots引用了，那你就知道其生命周期有多长了。这时候你如果用static 修饰Bitmap、View、Context和Activity等后果有多严重了吧。\n\n   - 非静态内部类的静态实例\n\n\t\t先看几行代码：\n\n\t\t```\n\t\tpublic class MainActivity extends AppCompatActivity {\n\t\tpublic static People people;\n   \t\t @Override\n    \t\tprotected void onCreate(Bundle savedInstanceState) {\n       \t\t super.onCreate(savedInstanceState);\n       \t\t setContentView(R.layout.activity_main);\n       \t\t people = new People();\n    \t\t}\n   \t\t class  People{\n       \t\t int age ;\n       \t\t String name ;\n    \t\t}\n\t\t}\n\t\t```\n\n\t\t非静态内部类People持有外部类即当前Activity的引用，而该非静态内部类实例又是static修饰\t\t的，导致Activity一直被持有而不得释放，最终导致Activity所包含的view不能释放，如果view \t\ttree中包含多图片，那泄露的内存是很大的。\n\n   - Handler\n\n\t\t众所周知handler用来发送和处理消息回调的。\nhandler导致泄露主要是handler实例是作为非静态匿名内部类方式创建，并且MessageQueue队列中有未处理消息，这时如果退出Activity，MessageQueue中还有Message，而Message持有handler实例，handler实例作为非静态内部类持有Activity引用，最终的连锁反应导致Activity泄露。\n\n\t\t>handler引起的内存泄露一般是临时性的，因为消息队列里的Message在延时到时间或者某一情况激活后还是会执行的，除非你是故意搞事情。创建handler时最好使用静态内部类，同时在Activity退出时执行 handler.removeCallbacksAndMessages(null);清空队列消息\n\n   - Webview\n\n\t\twebview的使用总是会莫名的出现各种问题或泄露。最好的办法就是把web页面放在一个独立的进程，如果需要交互使用aidl。\n\n  - 容器中的对象未清理对象\n\n\t\tAndroid中使用的容器最多的就是List和Map。用来存储对象集合，如果对象集合和页面相关，那么在退出页面时注意清空集合。同时不要使用static修饰集合。\n\n#### 如何尽量小的申请内存？\n上面说完了如何保证GC顺利回收，现在来讲讲要最小使用内存应该怎么做：\n\n- 慎用自动封装\n\n\t来几行代码尝尝：\n\n\t```\n        Integer num=0;\n        for (int i=0;i<100;i++) {\n            num+=i;\n        }\n\t```\n\n\tJava基本数据类型是有自动装箱机制的。每次执行循环都会发生一次装箱操作创建一个Integer对象，造成内存消耗。包括其他基本数据类型都有可能造成这种情况。\n\n- 内存复用\n  - 视图复用\n\n\t\t在ListView中使用ViewHolder复用item组件，一方面节省内存，一方面提高滑动流畅性。都用过不多介绍。\n  - 使用对象池\n\n\t\t看过Handler、Looper、Message、MessageQueue这一套消息循环源码的同志应该知道里面的Message使用了对象池模式。\n>对象池类似线程池， 首先初始化一个固定大小池子，每次创建对象时候先去池子中找有没有，如果有直接取出，如果没有new出来使用后还到池子里。这样便可达到对象复用的目的。\n对象池模式适用于那些频繁使用创建的对象，比如一个聊天app，里面对象最多的恐怕就是聊天信息(每条聊天信息对应一个信息对象)。都知道对象的创建是很耗费时间和内存的，没事不要new着玩。如果每条消息都创建一个对象，那可想而知该APP的性能。\n\n\t\t对象池的使用也很简单，少量代码即可完成：\n\n\t\t```\n\t\t\tpublic class People {\n        \t\t\tprivate static final Pools.SynchronizedPool<People> sPool = new Pools.SynchronizedPool<People>(\n           \t\t   \t  20);//需要维持对象的数量\n        \t\t\tint age;\n       \t\t\tString name;\n      \n        \t\t\tpublic static People obtain() {\n          \t\t\t  People instance = sPool.acquire();\n          \t\t\t  return (instance != null) ? instance : new People();\n        \t\t\t}\n        \t\t\tpublic void recycle() {\n          \t\t\t  sPool.release(this);\n       \t\t \t}\n    \t\t\t}\n\n\t\t```\n\n\t\t>注意：对象申请(obtain)和释放(recycle)成对出现，使用一个对象后一定要释放还给对象池。\n\n\n\n\t- Bitmap复用\n\n\t\t如果设置了options.inBitmap属性，以后再使用带有该options参数的decode方法加载图片资源时\t\t，decode会尝试重用已存在的位图内存，这样节省了加载和分配的时间，同时也节省了内存空间\n\n\t\t>该属性从3.0开始引进，低版本不支持inBitmap，4.4系统之前只能重用大小相同的内存区域，4.4以后可以重用任何比所需内存小的区域。具体使用可参考[官网](https://developer.android.com/topic/performance/graphics/manage-memory.html)。\n\n  - 纯色规则形状背景用Color Res代替图片\n\n\t\t经常遇到一些按钮背景是纯色显示，比如选中状态背景变为纯灰，但是设计已经发来了切图用还是不用？大声say NO！如果背景使用图片来显示，那背景每个像素都要绘制。\n\n    \t假设一个分辨率为100x100的图片，占用4通道。那该图片内存占用就是100x100x4 =4万Byte≈40KB；但是如果使用```        android:background=\"@color/colorAccent\"```引用color值的方式，由于是纯色，只需渲染一个像素而其他像素复用这个像素值即可。这样只需要4Byte即完成了背景设置。\n\n\n\n- 选择合适数据类型\n\n   - 使用ArrayMap替换HashMap\n\n\t\t先看一下HashMap模型和ArrayMap模型：\n![hashmap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-3e3049cb811341c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![arraymap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-0d979501c5d1358f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>HashMap是一个散列链表，稀疏阵列导致内存稍大，而ArrayMap提供了和HashMap一样的功能，但是避免了内存过度开销。在执行插入或删除操作时，从性能上看ArrayMap比HashMap稍差，但是如果对象数很小，比如1000以内不用担心性能问题。如果想深入了解这2个的原理请自行搜索，这里不过多阐述。\n\n\n  - 枚举替身来了\n      JDK1.5就支持了枚举类型，使用Enum关键字定义。使用枚举类型很多时候出于参数类型安全迫不得已作出的选择。\n\n   ```\n  public String  getValue(int type){\n            switch (type) {\n                case 1:\n                    break;\n                case 2:\n                    break;\n                case 3:\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"不合法参数\");\n            }\n    return \"\";\n    }\n```\n\n      试想一下如果一个函数的参数为int type，函数处理时只用到了1，2，3三种值，如果是其他值就抛出异常，这无疑增加了程序的不稳定性，按以前此时最好的解决办法就是参数改为枚举类型，增加了限定也就提高了稳定性。但是枚举类型就是一把双刃剑，增加安全同时也大大增加了内存占用,尤其是在移动设备上，资源有限更应该注意内存节省。\n\n     谷歌或许考虑到了这些问题，在提供的注解包里添加了注解方式检查类型安全，目前支持int和String两种，看下使用方式：\n\n    ```\n    //1、先声明需要的类型常量值\n    public static final int TYPE_1 = 1;\n    public static final int TYPE_2 = 2;\n    //2、创建注解接口同时把上一步声明的常量囊括到这里\n    @IntDef({TYPE_1,TYPE_2})\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface _TYPE{\n        \n    }\n    //3、在函数参数中增加 注解接口名称\n    public String getValue(@_TYPE int type){\n        switch (type) {\n            case 1:\n                break;\n            case 2:\n                break;\n        }\n        return \"\";\n    }\n```\n\n       经过上面的步骤，再调用getValue()函数时如果传入其他int则报错编译不通过，这样通过注解就增加了安全性：\n\n\t![屏幕快照 2017-03-29 下午7.13.32.png](http://upload-images.jianshu.io/upload_images/1796052-62fa91a5486d42cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n结语：基本上APP大部分内存还是被图片占用，处理好图片尤为重要，但是关于图片三级缓存及缩放，目前都使用第三方框架如ImageLoader，所以这里一笔带过。以上就是日常内存优化需要注意的地方，自己做个总结，也希望能对各位看官有所帮助。","source":"_posts/Android性能优化之内存优化.md","raw":"---\ntitle: Android性能优化之内存优化\ndate: 2017-04-21 20:55:54\ntags: Android\ncategories: Android\n---\n>上一章讲了[Android性能优化之耗电优化\n](http://www.jianshu.com/p/bd3d673aa979)，感兴趣的可以看下。这一章来说说Android内存方面如何优化，虽说是讲内存优化但是并不涉及虚拟机底层原理，力求通俗易懂。\n\n\n![屏幕快照 2017-03-29 下午2.58.41.png](http://upload-images.jianshu.io/upload_images/1796052-0956f76fd0a3e36b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n养成好习惯先上图。内存从状态上来说只有已使用和未使用两种。本章内存优化也从这两方面下手：已使用的内存如何保证虚拟机的顺利回收、未使用的内存如何在满足需求的情况下尽量小的申请。\n\n#### 如何保证已使用内存顺利被回收？\n- Java对象生命周期\n  - 创建阶段\n申请内存空间，构造对象并初始化相关属性值\n  - 使用阶段\n根据对象应用调用相关方法完成业务逻辑。对象至少被一个强引用持有，除非对象创建时显示声明使用软引用、弱引用和虚引用。\n  - 不可见阶段\n当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，当然对象还是存在着的。\n  - 不可达阶段\n对象处于不可达阶段是指该对象不再被任何强引用所持有。GC会发现对象已不可达\n\n  - 收集阶段\n当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。\n  - 终结阶段\n当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段，等待垃圾回收器对该对象空间进行回收。\n\n  - 对象空间重新分配阶段\n若垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，则该对象彻底消失，这个阶段称之为“对象空间重新分配阶段”。\n\n\t以上是Java对象生命周期的简要介绍，要保证内存顺利回收，正确使用Java对象生命周期很重要，如果不能及时回收，我们就称之为“发生了内存泄露”。\n\n>在不可见阶段，程序本身不再持有对象强引用，但对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。\n\n\n![垃圾回收.jpeg](http://upload-images.jianshu.io/upload_images/1796052-ef7e7496b8a9cd2e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n图中灰色的孤立无援的对象对于GC Roots来说不可达，会被回收。知道了内存泄露会影响回收，下面说下哪些方面会导致内存泄露\n\n- 引起内存泄露的情况\n   - 资源没有适时关闭\nsqlite的cursor、读写文件使用的File文件流等在使用完后没有及时关闭。虽然cursor会在系统回收时自动关闭，但是这样效率较低。对于资源对象使用还是应该养成良好习惯，使用完毕close并置空。\n   - 注册对象未注销\n在Android中主要是指注册的广播在Activity销毁时反注销。\n在Activity中如果有使用的观察者模式在生命周期发生变化时根据需求注销。\n在Activity中使用的各类传感器(光线、重力等)在页面销毁时及时注销，否则不光导致内存泄露还会因为传感器频繁的采样导致耗电及cpu的占用。\n   - 使用static修饰变量\n这里只说一点，被static修饰的变量可以认为是直接被GC Roots引用了，那你就知道其生命周期有多长了。这时候你如果用static 修饰Bitmap、View、Context和Activity等后果有多严重了吧。\n\n   - 非静态内部类的静态实例\n\n\t\t先看几行代码：\n\n\t\t```\n\t\tpublic class MainActivity extends AppCompatActivity {\n\t\tpublic static People people;\n   \t\t @Override\n    \t\tprotected void onCreate(Bundle savedInstanceState) {\n       \t\t super.onCreate(savedInstanceState);\n       \t\t setContentView(R.layout.activity_main);\n       \t\t people = new People();\n    \t\t}\n   \t\t class  People{\n       \t\t int age ;\n       \t\t String name ;\n    \t\t}\n\t\t}\n\t\t```\n\n\t\t非静态内部类People持有外部类即当前Activity的引用，而该非静态内部类实例又是static修饰\t\t的，导致Activity一直被持有而不得释放，最终导致Activity所包含的view不能释放，如果view \t\ttree中包含多图片，那泄露的内存是很大的。\n\n   - Handler\n\n\t\t众所周知handler用来发送和处理消息回调的。\nhandler导致泄露主要是handler实例是作为非静态匿名内部类方式创建，并且MessageQueue队列中有未处理消息，这时如果退出Activity，MessageQueue中还有Message，而Message持有handler实例，handler实例作为非静态内部类持有Activity引用，最终的连锁反应导致Activity泄露。\n\n\t\t>handler引起的内存泄露一般是临时性的，因为消息队列里的Message在延时到时间或者某一情况激活后还是会执行的，除非你是故意搞事情。创建handler时最好使用静态内部类，同时在Activity退出时执行 handler.removeCallbacksAndMessages(null);清空队列消息\n\n   - Webview\n\n\t\twebview的使用总是会莫名的出现各种问题或泄露。最好的办法就是把web页面放在一个独立的进程，如果需要交互使用aidl。\n\n  - 容器中的对象未清理对象\n\n\t\tAndroid中使用的容器最多的就是List和Map。用来存储对象集合，如果对象集合和页面相关，那么在退出页面时注意清空集合。同时不要使用static修饰集合。\n\n#### 如何尽量小的申请内存？\n上面说完了如何保证GC顺利回收，现在来讲讲要最小使用内存应该怎么做：\n\n- 慎用自动封装\n\n\t来几行代码尝尝：\n\n\t```\n        Integer num=0;\n        for (int i=0;i<100;i++) {\n            num+=i;\n        }\n\t```\n\n\tJava基本数据类型是有自动装箱机制的。每次执行循环都会发生一次装箱操作创建一个Integer对象，造成内存消耗。包括其他基本数据类型都有可能造成这种情况。\n\n- 内存复用\n  - 视图复用\n\n\t\t在ListView中使用ViewHolder复用item组件，一方面节省内存，一方面提高滑动流畅性。都用过不多介绍。\n  - 使用对象池\n\n\t\t看过Handler、Looper、Message、MessageQueue这一套消息循环源码的同志应该知道里面的Message使用了对象池模式。\n>对象池类似线程池， 首先初始化一个固定大小池子，每次创建对象时候先去池子中找有没有，如果有直接取出，如果没有new出来使用后还到池子里。这样便可达到对象复用的目的。\n对象池模式适用于那些频繁使用创建的对象，比如一个聊天app，里面对象最多的恐怕就是聊天信息(每条聊天信息对应一个信息对象)。都知道对象的创建是很耗费时间和内存的，没事不要new着玩。如果每条消息都创建一个对象，那可想而知该APP的性能。\n\n\t\t对象池的使用也很简单，少量代码即可完成：\n\n\t\t```\n\t\t\tpublic class People {\n        \t\t\tprivate static final Pools.SynchronizedPool<People> sPool = new Pools.SynchronizedPool<People>(\n           \t\t   \t  20);//需要维持对象的数量\n        \t\t\tint age;\n       \t\t\tString name;\n      \n        \t\t\tpublic static People obtain() {\n          \t\t\t  People instance = sPool.acquire();\n          \t\t\t  return (instance != null) ? instance : new People();\n        \t\t\t}\n        \t\t\tpublic void recycle() {\n          \t\t\t  sPool.release(this);\n       \t\t \t}\n    \t\t\t}\n\n\t\t```\n\n\t\t>注意：对象申请(obtain)和释放(recycle)成对出现，使用一个对象后一定要释放还给对象池。\n\n\n\n\t- Bitmap复用\n\n\t\t如果设置了options.inBitmap属性，以后再使用带有该options参数的decode方法加载图片资源时\t\t，decode会尝试重用已存在的位图内存，这样节省了加载和分配的时间，同时也节省了内存空间\n\n\t\t>该属性从3.0开始引进，低版本不支持inBitmap，4.4系统之前只能重用大小相同的内存区域，4.4以后可以重用任何比所需内存小的区域。具体使用可参考[官网](https://developer.android.com/topic/performance/graphics/manage-memory.html)。\n\n  - 纯色规则形状背景用Color Res代替图片\n\n\t\t经常遇到一些按钮背景是纯色显示，比如选中状态背景变为纯灰，但是设计已经发来了切图用还是不用？大声say NO！如果背景使用图片来显示，那背景每个像素都要绘制。\n\n    \t假设一个分辨率为100x100的图片，占用4通道。那该图片内存占用就是100x100x4 =4万Byte≈40KB；但是如果使用```        android:background=\"@color/colorAccent\"```引用color值的方式，由于是纯色，只需渲染一个像素而其他像素复用这个像素值即可。这样只需要4Byte即完成了背景设置。\n\n\n\n- 选择合适数据类型\n\n   - 使用ArrayMap替换HashMap\n\n\t\t先看一下HashMap模型和ArrayMap模型：\n![hashmap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-3e3049cb811341c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![arraymap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-0d979501c5d1358f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>HashMap是一个散列链表，稀疏阵列导致内存稍大，而ArrayMap提供了和HashMap一样的功能，但是避免了内存过度开销。在执行插入或删除操作时，从性能上看ArrayMap比HashMap稍差，但是如果对象数很小，比如1000以内不用担心性能问题。如果想深入了解这2个的原理请自行搜索，这里不过多阐述。\n\n\n  - 枚举替身来了\n      JDK1.5就支持了枚举类型，使用Enum关键字定义。使用枚举类型很多时候出于参数类型安全迫不得已作出的选择。\n\n   ```\n  public String  getValue(int type){\n            switch (type) {\n                case 1:\n                    break;\n                case 2:\n                    break;\n                case 3:\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"不合法参数\");\n            }\n    return \"\";\n    }\n```\n\n      试想一下如果一个函数的参数为int type，函数处理时只用到了1，2，3三种值，如果是其他值就抛出异常，这无疑增加了程序的不稳定性，按以前此时最好的解决办法就是参数改为枚举类型，增加了限定也就提高了稳定性。但是枚举类型就是一把双刃剑，增加安全同时也大大增加了内存占用,尤其是在移动设备上，资源有限更应该注意内存节省。\n\n     谷歌或许考虑到了这些问题，在提供的注解包里添加了注解方式检查类型安全，目前支持int和String两种，看下使用方式：\n\n    ```\n    //1、先声明需要的类型常量值\n    public static final int TYPE_1 = 1;\n    public static final int TYPE_2 = 2;\n    //2、创建注解接口同时把上一步声明的常量囊括到这里\n    @IntDef({TYPE_1,TYPE_2})\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface _TYPE{\n        \n    }\n    //3、在函数参数中增加 注解接口名称\n    public String getValue(@_TYPE int type){\n        switch (type) {\n            case 1:\n                break;\n            case 2:\n                break;\n        }\n        return \"\";\n    }\n```\n\n       经过上面的步骤，再调用getValue()函数时如果传入其他int则报错编译不通过，这样通过注解就增加了安全性：\n\n\t![屏幕快照 2017-03-29 下午7.13.32.png](http://upload-images.jianshu.io/upload_images/1796052-62fa91a5486d42cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n结语：基本上APP大部分内存还是被图片占用，处理好图片尤为重要，但是关于图片三级缓存及缩放，目前都使用第三方框架如ImageLoader，所以这里一笔带过。以上就是日常内存优化需要注意的地方，自己做个总结，也希望能对各位看官有所帮助。","slug":"Android性能优化之内存优化","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjbm000gwh9cjmkaes7g","content":"<blockquote>\n<p>上一章讲了<a href=\"http://www.jianshu.com/p/bd3d673aa979\" target=\"_blank\" rel=\"external\">Android性能优化之耗电优化\n</a>，感兴趣的可以看下。这一章来说说Android内存方面如何优化，虽说是讲内存优化但是并不涉及虚拟机底层原理，力求通俗易懂。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-0956f76fd0a3e36b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-29 下午2.58.41.png\"></p>\n<p>养成好习惯先上图。内存从状态上来说只有已使用和未使用两种。本章内存优化也从这两方面下手：已使用的内存如何保证虚拟机的顺利回收、未使用的内存如何在满足需求的情况下尽量小的申请。</p>\n<h4 id=\"如何保证已使用内存顺利被回收？\"><a href=\"#如何保证已使用内存顺利被回收？\" class=\"headerlink\" title=\"如何保证已使用内存顺利被回收？\"></a>如何保证已使用内存顺利被回收？</h4><ul>\n<li><p>Java对象生命周期</p>\n<ul>\n<li>创建阶段<br>申请内存空间，构造对象并初始化相关属性值</li>\n<li>使用阶段<br>根据对象应用调用相关方法完成业务逻辑。对象至少被一个强引用持有，除非对象创建时显示声明使用软引用、弱引用和虚引用。</li>\n<li>不可见阶段<br>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，当然对象还是存在着的。</li>\n<li><p>不可达阶段<br>对象处于不可达阶段是指该对象不再被任何强引用所持有。GC会发现对象已不可达</p>\n</li>\n<li><p>收集阶段<br>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。</p>\n</li>\n<li><p>终结阶段<br>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段，等待垃圾回收器对该对象空间进行回收。</p>\n</li>\n<li><p>对象空间重新分配阶段<br>若垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，则该对象彻底消失，这个阶段称之为“对象空间重新分配阶段”。</p>\n<p>以上是Java对象生命周期的简要介绍，要保证内存顺利回收，正确使用Java对象生命周期很重要，如果不能及时回收，我们就称之为“发生了内存泄露”。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在不可见阶段，程序本身不再持有对象强引用，但对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-ef7e7496b8a9cd2e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"垃圾回收.jpeg\"></p>\n<p>图中灰色的孤立无援的对象对于GC Roots来说不可达，会被回收。知道了内存泄露会影响回收，下面说下哪些方面会导致内存泄露</p>\n<ul>\n<li><p>引起内存泄露的情况</p>\n<ul>\n<li>资源没有适时关闭<br>sqlite的cursor、读写文件使用的File文件流等在使用完后没有及时关闭。虽然cursor会在系统回收时自动关闭，但是这样效率较低。对于资源对象使用还是应该养成良好习惯，使用完毕close并置空。</li>\n<li>注册对象未注销<br>在Android中主要是指注册的广播在Activity销毁时反注销。<br>在Activity中如果有使用的观察者模式在生命周期发生变化时根据需求注销。<br>在Activity中使用的各类传感器(光线、重力等)在页面销毁时及时注销，否则不光导致内存泄露还会因为传感器频繁的采样导致耗电及cpu的占用。</li>\n<li><p>使用static修饰变量<br>这里只说一点，被static修饰的变量可以认为是直接被GC Roots引用了，那你就知道其生命周期有多长了。这时候你如果用static 修饰Bitmap、View、Context和Activity等后果有多严重了吧。</p>\n</li>\n<li><p>非静态内部类的静态实例</p>\n<p>   先看几行代码：</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends AppCompatActivity &#123;</div><div class=\"line\">public static People people;</div><div class=\"line\"> \t\t @Override</div><div class=\"line\">  \t\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">     \t\t super.onCreate(savedInstanceState);</div><div class=\"line\">     \t\t setContentView(R.layout.activity_main);</div><div class=\"line\">     \t\t people = new People();</div><div class=\"line\">  \t\t&#125;</div><div class=\"line\"> \t\t class  People&#123;</div><div class=\"line\">     \t\t int age ;</div><div class=\"line\">     \t\t String name ;</div><div class=\"line\">  \t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>   非静态内部类People持有外部类即当前Activity的引用，而该非静态内部类实例又是static修饰        的，导致Activity一直被持有而不得释放，最终导致Activity所包含的view不能释放，如果view         tree中包含多图片，那泄露的内存是很大的。</p>\n</li>\n<li><p>Handler</p>\n<p>   众所周知handler用来发送和处理消息回调的。<br>handler导致泄露主要是handler实例是作为非静态匿名内部类方式创建，并且MessageQueue队列中有未处理消息，这时如果退出Activity，MessageQueue中还有Message，而Message持有handler实例，handler实例作为非静态内部类持有Activity引用，最终的连锁反应导致Activity泄露。</p>\n<blockquote>\n<p>handler引起的内存泄露一般是临时性的，因为消息队列里的Message在延时到时间或者某一情况激活后还是会执行的，除非你是故意搞事情。创建handler时最好使用静态内部类，同时在Activity退出时执行 handler.removeCallbacksAndMessages(null);清空队列消息</p>\n</blockquote>\n</li>\n<li><p>Webview</p>\n<p>   webview的使用总是会莫名的出现各种问题或泄露。最好的办法就是把web页面放在一个独立的进程，如果需要交互使用aidl。</p>\n</li>\n</ul>\n<ul>\n<li><p>容器中的对象未清理对象</p>\n<pre><code>Android中使用的容器最多的就是List和Map。用来存储对象集合，如果对象集合和页面相关，那么在退出页面时注意清空集合。同时不要使用static修饰集合。\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"如何尽量小的申请内存？\"><a href=\"#如何尽量小的申请内存？\" class=\"headerlink\" title=\"如何尽量小的申请内存？\"></a>如何尽量小的申请内存？</h4><p>上面说完了如何保证GC顺利回收，现在来讲讲要最小使用内存应该怎么做：</p>\n<ul>\n<li><p>慎用自动封装</p>\n<p>  来几行代码尝尝：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer num=0;</div><div class=\"line\">for (int i=0;i&lt;100;i++) &#123;</div><div class=\"line\">    num+=i;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  Java基本数据类型是有自动装箱机制的。每次执行循环都会发生一次装箱操作创建一个Integer对象，造成内存消耗。包括其他基本数据类型都有可能造成这种情况。</p>\n</li>\n<li><p>内存复用</p>\n<ul>\n<li><p>视图复用</p>\n<pre><code>在ListView中使用ViewHolder复用item组件，一方面节省内存，一方面提高滑动流畅性。都用过不多介绍。\n</code></pre></li>\n<li><p>使用对象池</p>\n<pre><code>看过Handler、Looper、Message、MessageQueue这一套消息循环源码的同志应该知道里面的Message使用了对象池模式。\n</code></pre><blockquote>\n<p>对象池类似线程池， 首先初始化一个固定大小池子，每次创建对象时候先去池子中找有没有，如果有直接取出，如果没有new出来使用后还到池子里。这样便可达到对象复用的目的。<br>对象池模式适用于那些频繁使用创建的对象，比如一个聊天app，里面对象最多的恐怕就是聊天信息(每条聊天信息对应一个信息对象)。都知道对象的创建是很耗费时间和内存的，没事不要new着玩。如果每条消息都创建一个对象，那可想而知该APP的性能。</p>\n</blockquote>\n<pre><code>对象池的使用也很简单，少量代码即可完成：\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class People &#123;</div><div class=\"line\">     \t\t\tprivate static final Pools.SynchronizedPool&lt;People&gt; sPool = new Pools.SynchronizedPool&lt;People&gt;(</div><div class=\"line\">        \t\t   \t  20);//需要维持对象的数量</div><div class=\"line\">     \t\t\tint age;</div><div class=\"line\">    \t\t\tString name;</div><div class=\"line\">   </div><div class=\"line\">     \t\t\tpublic static People obtain() &#123;</div><div class=\"line\">       \t\t\t  People instance = sPool.acquire();</div><div class=\"line\">       \t\t\t  return (instance != null) ? instance : new People();</div><div class=\"line\">     \t\t\t&#125;</div><div class=\"line\">     \t\t\tpublic void recycle() &#123;</div><div class=\"line\">       \t\t\t  sPool.release(this);</div><div class=\"line\">    \t\t \t&#125;</div><div class=\"line\"> \t\t\t&#125;</div></pre></td></tr></table></figure>\n\n&gt;注意：对象申请(obtain)和释放(recycle)成对出现，使用一个对象后一定要释放还给对象池。\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<pre><code>- Bitmap复用\n\n    如果设置了options.inBitmap属性，以后再使用带有该options参数的decode方法加载图片资源时        ，decode会尝试重用已存在的位图内存，这样节省了加载和分配的时间，同时也节省了内存空间\n\n    &gt;该属性从3.0开始引进，低版本不支持inBitmap，4.4系统之前只能重用大小相同的内存区域，4.4以后可以重用任何比所需内存小的区域。具体使用可参考[官网](https://developer.android.com/topic/performance/graphics/manage-memory.html)。\n</code></pre><ul>\n<li><p>纯色规则形状背景用Color Res代替图片</p>\n<pre><code>经常遇到一些按钮背景是纯色显示，比如选中状态背景变为纯灰，但是设计已经发来了切图用还是不用？大声say NO！如果背景使用图片来显示，那背景每个像素都要绘制。\n\n假设一个分辨率为100x100的图片，占用4通道。那该图片内存占用就是100x100x4 =4万Byte≈40KB；但是如果使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- 选择合适数据类型</div><div class=\"line\"></div><div class=\"line\">   - 使用ArrayMap替换HashMap</div><div class=\"line\"></div><div class=\"line\">\t\t先看一下HashMap模型和ArrayMap模型：</div><div class=\"line\">![hashmap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-3e3049cb811341c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\">![arraymap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-0d979501c5d1358f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&gt;HashMap是一个散列链表，稀疏阵列导致内存稍大，而ArrayMap提供了和HashMap一样的功能，但是避免了内存过度开销。在执行插入或删除操作时，从性能上看ArrayMap比HashMap稍差，但是如果对象数很小，比如1000以内不用担心性能问题。如果想深入了解这2个的原理请自行搜索，这里不过多阐述。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  - 枚举替身来了</div><div class=\"line\">      JDK1.5就支持了枚举类型，使用Enum关键字定义。使用枚举类型很多时候出于参数类型安全迫不得已作出的选择。</div></pre></td></tr></table></figure>\n</code></pre><p>public String  getValue(int type){</p>\n<pre><code>switch (type) {\n    case 1:\n        break;\n    case 2:\n        break;\n    case 3:\n        break;\n    default:\n        throw new IllegalArgumentException(&quot;不合法参数&quot;);\n}\n</code></pre><p>return “”;<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> 试想一下如果一个函数的参数为int type，函数处理时只用到了1，2，3三种值，如果是其他值就抛出异常，这无疑增加了程序的不稳定性，按以前此时最好的解决办法就是参数改为枚举类型，增加了限定也就提高了稳定性。但是枚举类型就是一把双刃剑，增加安全同时也大大增加了内存占用,尤其是在移动设备上，资源有限更应该注意内存节省。</div><div class=\"line\"></div><div class=\"line\">谷歌或许考虑到了这些问题，在提供的注解包里添加了注解方式检查类型安全，目前支持int和String两种，看下使用方式：</div></pre></td></tr></table></figure>\n<p>//1、先声明需要的类型常量值<br>public static final int TYPE_1 = 1;<br>public static final int TYPE_2 = 2;<br>//2、创建注解接口同时把上一步声明的常量囊括到这里<br>@IntDef({TYPE_1,TYPE_2})<br>@Retention(RetentionPolicy.SOURCE)<br>public @interface _TYPE{</p>\n<p>}<br>//3、在函数参数中增加 注解接口名称<br>public String getValue(@_TYPE int type){</p>\n<pre><code>switch (type) {\n    case 1:\n        break;\n    case 2:\n        break;\n}\nreturn &quot;&quot;;\n</code></pre><p>}<br>```</p>\n<p>   经过上面的步骤，再调用getValue()函数时如果传入其他int则报错编译不通过，这样通过注解就增加了安全性：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-62fa91a5486d42cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-29 下午7.13.32.png\"></p>\n</li>\n</ul>\n<p>结语：基本上APP大部分内存还是被图片占用，处理好图片尤为重要，但是关于图片三级缓存及缩放，目前都使用第三方框架如ImageLoader，所以这里一笔带过。以上就是日常内存优化需要注意的地方，自己做个总结，也希望能对各位看官有所帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>上一章讲了<a href=\"http://www.jianshu.com/p/bd3d673aa979\">Android性能优化之耗电优化\n</a>，感兴趣的可以看下。这一章来说说Android内存方面如何优化，虽说是讲内存优化但是并不涉及虚拟机底层原理，力求通俗易懂。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-0956f76fd0a3e36b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-29 下午2.58.41.png\"></p>\n<p>养成好习惯先上图。内存从状态上来说只有已使用和未使用两种。本章内存优化也从这两方面下手：已使用的内存如何保证虚拟机的顺利回收、未使用的内存如何在满足需求的情况下尽量小的申请。</p>\n<h4 id=\"如何保证已使用内存顺利被回收？\"><a href=\"#如何保证已使用内存顺利被回收？\" class=\"headerlink\" title=\"如何保证已使用内存顺利被回收？\"></a>如何保证已使用内存顺利被回收？</h4><ul>\n<li><p>Java对象生命周期</p>\n<ul>\n<li>创建阶段<br>申请内存空间，构造对象并初始化相关属性值</li>\n<li>使用阶段<br>根据对象应用调用相关方法完成业务逻辑。对象至少被一个强引用持有，除非对象创建时显示声明使用软引用、弱引用和虚引用。</li>\n<li>不可见阶段<br>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，当然对象还是存在着的。</li>\n<li><p>不可达阶段<br>对象处于不可达阶段是指该对象不再被任何强引用所持有。GC会发现对象已不可达</p>\n</li>\n<li><p>收集阶段<br>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。</p>\n</li>\n<li><p>终结阶段<br>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段，等待垃圾回收器对该对象空间进行回收。</p>\n</li>\n<li><p>对象空间重新分配阶段<br>若垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，则该对象彻底消失，这个阶段称之为“对象空间重新分配阶段”。</p>\n<p>以上是Java对象生命周期的简要介绍，要保证内存顺利回收，正确使用Java对象生命周期很重要，如果不能及时回收，我们就称之为“发生了内存泄露”。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在不可见阶段，程序本身不再持有对象强引用，但对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-ef7e7496b8a9cd2e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"垃圾回收.jpeg\"></p>\n<p>图中灰色的孤立无援的对象对于GC Roots来说不可达，会被回收。知道了内存泄露会影响回收，下面说下哪些方面会导致内存泄露</p>\n<ul>\n<li><p>引起内存泄露的情况</p>\n<ul>\n<li>资源没有适时关闭<br>sqlite的cursor、读写文件使用的File文件流等在使用完后没有及时关闭。虽然cursor会在系统回收时自动关闭，但是这样效率较低。对于资源对象使用还是应该养成良好习惯，使用完毕close并置空。</li>\n<li>注册对象未注销<br>在Android中主要是指注册的广播在Activity销毁时反注销。<br>在Activity中如果有使用的观察者模式在生命周期发生变化时根据需求注销。<br>在Activity中使用的各类传感器(光线、重力等)在页面销毁时及时注销，否则不光导致内存泄露还会因为传感器频繁的采样导致耗电及cpu的占用。</li>\n<li><p>使用static修饰变量<br>这里只说一点，被static修饰的变量可以认为是直接被GC Roots引用了，那你就知道其生命周期有多长了。这时候你如果用static 修饰Bitmap、View、Context和Activity等后果有多严重了吧。</p>\n</li>\n<li><p>非静态内部类的静态实例</p>\n<p>   先看几行代码：</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends AppCompatActivity &#123;</div><div class=\"line\">public static People people;</div><div class=\"line\"> \t\t @Override</div><div class=\"line\">  \t\tprotected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">     \t\t super.onCreate(savedInstanceState);</div><div class=\"line\">     \t\t setContentView(R.layout.activity_main);</div><div class=\"line\">     \t\t people = new People();</div><div class=\"line\">  \t\t&#125;</div><div class=\"line\"> \t\t class  People&#123;</div><div class=\"line\">     \t\t int age ;</div><div class=\"line\">     \t\t String name ;</div><div class=\"line\">  \t\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>   非静态内部类People持有外部类即当前Activity的引用，而该非静态内部类实例又是static修饰        的，导致Activity一直被持有而不得释放，最终导致Activity所包含的view不能释放，如果view         tree中包含多图片，那泄露的内存是很大的。</p>\n</li>\n<li><p>Handler</p>\n<p>   众所周知handler用来发送和处理消息回调的。<br>handler导致泄露主要是handler实例是作为非静态匿名内部类方式创建，并且MessageQueue队列中有未处理消息，这时如果退出Activity，MessageQueue中还有Message，而Message持有handler实例，handler实例作为非静态内部类持有Activity引用，最终的连锁反应导致Activity泄露。</p>\n<blockquote>\n<p>handler引起的内存泄露一般是临时性的，因为消息队列里的Message在延时到时间或者某一情况激活后还是会执行的，除非你是故意搞事情。创建handler时最好使用静态内部类，同时在Activity退出时执行 handler.removeCallbacksAndMessages(null);清空队列消息</p>\n</blockquote>\n</li>\n<li><p>Webview</p>\n<p>   webview的使用总是会莫名的出现各种问题或泄露。最好的办法就是把web页面放在一个独立的进程，如果需要交互使用aidl。</p>\n</li>\n</ul>\n<ul>\n<li><p>容器中的对象未清理对象</p>\n<pre><code>Android中使用的容器最多的就是List和Map。用来存储对象集合，如果对象集合和页面相关，那么在退出页面时注意清空集合。同时不要使用static修饰集合。\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"如何尽量小的申请内存？\"><a href=\"#如何尽量小的申请内存？\" class=\"headerlink\" title=\"如何尽量小的申请内存？\"></a>如何尽量小的申请内存？</h4><p>上面说完了如何保证GC顺利回收，现在来讲讲要最小使用内存应该怎么做：</p>\n<ul>\n<li><p>慎用自动封装</p>\n<p>  来几行代码尝尝：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Integer num=0;</div><div class=\"line\">for (int i=0;i&lt;100;i++) &#123;</div><div class=\"line\">    num+=i;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  Java基本数据类型是有自动装箱机制的。每次执行循环都会发生一次装箱操作创建一个Integer对象，造成内存消耗。包括其他基本数据类型都有可能造成这种情况。</p>\n</li>\n<li><p>内存复用</p>\n<ul>\n<li><p>视图复用</p>\n<pre><code>在ListView中使用ViewHolder复用item组件，一方面节省内存，一方面提高滑动流畅性。都用过不多介绍。\n</code></pre></li>\n<li><p>使用对象池</p>\n<pre><code>看过Handler、Looper、Message、MessageQueue这一套消息循环源码的同志应该知道里面的Message使用了对象池模式。\n</code></pre><blockquote>\n<p>对象池类似线程池， 首先初始化一个固定大小池子，每次创建对象时候先去池子中找有没有，如果有直接取出，如果没有new出来使用后还到池子里。这样便可达到对象复用的目的。<br>对象池模式适用于那些频繁使用创建的对象，比如一个聊天app，里面对象最多的恐怕就是聊天信息(每条聊天信息对应一个信息对象)。都知道对象的创建是很耗费时间和内存的，没事不要new着玩。如果每条消息都创建一个对象，那可想而知该APP的性能。</p>\n</blockquote>\n<pre><code>对象池的使用也很简单，少量代码即可完成：\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class People &#123;</div><div class=\"line\">     \t\t\tprivate static final Pools.SynchronizedPool&lt;People&gt; sPool = new Pools.SynchronizedPool&lt;People&gt;(</div><div class=\"line\">        \t\t   \t  20);//需要维持对象的数量</div><div class=\"line\">     \t\t\tint age;</div><div class=\"line\">    \t\t\tString name;</div><div class=\"line\">   </div><div class=\"line\">     \t\t\tpublic static People obtain() &#123;</div><div class=\"line\">       \t\t\t  People instance = sPool.acquire();</div><div class=\"line\">       \t\t\t  return (instance != null) ? instance : new People();</div><div class=\"line\">     \t\t\t&#125;</div><div class=\"line\">     \t\t\tpublic void recycle() &#123;</div><div class=\"line\">       \t\t\t  sPool.release(this);</div><div class=\"line\">    \t\t \t&#125;</div><div class=\"line\"> \t\t\t&#125;</div></pre></td></tr></table></figure>\n\n&gt;注意：对象申请(obtain)和释放(recycle)成对出现，使用一个对象后一定要释放还给对象池。\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<pre><code>- Bitmap复用\n\n    如果设置了options.inBitmap属性，以后再使用带有该options参数的decode方法加载图片资源时        ，decode会尝试重用已存在的位图内存，这样节省了加载和分配的时间，同时也节省了内存空间\n\n    &gt;该属性从3.0开始引进，低版本不支持inBitmap，4.4系统之前只能重用大小相同的内存区域，4.4以后可以重用任何比所需内存小的区域。具体使用可参考[官网](https://developer.android.com/topic/performance/graphics/manage-memory.html)。\n</code></pre><ul>\n<li><p>纯色规则形状背景用Color Res代替图片</p>\n<pre><code>经常遇到一些按钮背景是纯色显示，比如选中状态背景变为纯灰，但是设计已经发来了切图用还是不用？大声say NO！如果背景使用图片来显示，那背景每个像素都要绘制。\n\n假设一个分辨率为100x100的图片，占用4通道。那该图片内存占用就是100x100x4 =4万Byte≈40KB；但是如果使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- 选择合适数据类型</div><div class=\"line\"></div><div class=\"line\">   - 使用ArrayMap替换HashMap</div><div class=\"line\"></div><div class=\"line\">\t\t先看一下HashMap模型和ArrayMap模型：</div><div class=\"line\">![hashmap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-3e3049cb811341c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\">![arraymap模型.jpg](http://upload-images.jianshu.io/upload_images/1796052-0d979501c5d1358f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&gt;HashMap是一个散列链表，稀疏阵列导致内存稍大，而ArrayMap提供了和HashMap一样的功能，但是避免了内存过度开销。在执行插入或删除操作时，从性能上看ArrayMap比HashMap稍差，但是如果对象数很小，比如1000以内不用担心性能问题。如果想深入了解这2个的原理请自行搜索，这里不过多阐述。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  - 枚举替身来了</div><div class=\"line\">      JDK1.5就支持了枚举类型，使用Enum关键字定义。使用枚举类型很多时候出于参数类型安全迫不得已作出的选择。</div></pre></td></tr></table></figure>\n</code></pre><p>public String  getValue(int type){</p>\n<pre><code>switch (type) {\n    case 1:\n        break;\n    case 2:\n        break;\n    case 3:\n        break;\n    default:\n        throw new IllegalArgumentException(&quot;不合法参数&quot;);\n}\n</code></pre><p>return “”;<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"> 试想一下如果一个函数的参数为int type，函数处理时只用到了1，2，3三种值，如果是其他值就抛出异常，这无疑增加了程序的不稳定性，按以前此时最好的解决办法就是参数改为枚举类型，增加了限定也就提高了稳定性。但是枚举类型就是一把双刃剑，增加安全同时也大大增加了内存占用,尤其是在移动设备上，资源有限更应该注意内存节省。</div><div class=\"line\"></div><div class=\"line\">谷歌或许考虑到了这些问题，在提供的注解包里添加了注解方式检查类型安全，目前支持int和String两种，看下使用方式：</div></pre></td></tr></table></figure>\n<p>//1、先声明需要的类型常量值<br>public static final int TYPE_1 = 1;<br>public static final int TYPE_2 = 2;<br>//2、创建注解接口同时把上一步声明的常量囊括到这里<br>@IntDef({TYPE_1,TYPE_2})<br>@Retention(RetentionPolicy.SOURCE)<br>public @interface _TYPE{</p>\n<p>}<br>//3、在函数参数中增加 注解接口名称<br>public String getValue(@_TYPE int type){</p>\n<pre><code>switch (type) {\n    case 1:\n        break;\n    case 2:\n        break;\n}\nreturn &quot;&quot;;\n</code></pre><p>}<br>```</p>\n<p>   经过上面的步骤，再调用getValue()函数时如果传入其他int则报错编译不通过，这样通过注解就增加了安全性：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-62fa91a5486d42cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-29 下午7.13.32.png\"></p>\n</li>\n</ul>\n<p>结语：基本上APP大部分内存还是被图片占用，处理好图片尤为重要，但是关于图片三级缓存及缩放，目前都使用第三方框架如ImageLoader，所以这里一笔带过。以上就是日常内存优化需要注意的地方，自己做个总结，也希望能对各位看官有所帮助。</p>\n"},{"title":"Android开发之JNI深入解析","date":"2017-04-24T16:55:54.000Z","_content":"\n# 说在前面的话\n\n>本来是没有打算写JNI的，因为本来是在看Binder机制原理的，但是看着看着就跑偏看到了JNI。。。\n\n# 通过本章可以了解到这些：\n\n\n\n- jni介绍\n\n- 为什么要学习jni\n\n- jni使用流程是怎样的\n\n- 如何Java调用C\n\n- 如何C调用Java\n\n- 了解jni源码和机制\n\n  ​\n\n# 什么是jni、ndk\n\n\n\njni(java native interface)，Java本地接口。在Java中接口就是一套协议标准，同样这里也是如此，jni是一套让Java和C互通有无的一套标准。看到这脑子里应该有个大概情况：\n\n![屏幕快照 2017-04-21 下午12.17.32.png](http://upload-images.jianshu.io/upload_images/1796052-062e7ea6f0c17ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nndk,它只是一套开发工具集，如果再给它加个形容词，那就是本地开发工具集，即Native Development Kit。\n>注意区别ndk和jni，一个是一套软件，一个是套标准。\n\n\n\n# 为什么使用jni\n\n\n\n- 1、效率问题\n\n  C和C++效率比Java要高一些，虽然这种差距随着Java性能优化有越来越小的趋势，但是总归还是存在的。\n\n- 2、安全问题\n\n  虽然没有绝对的安全，但是相对来说C语言的反汇编比Java更不容易看懂\n\n- 3、代码复用\n\n  C语言年代久远，有很多现成的库，如果Java需要使用同样的功能，不需要自己从新实现，jni直接调用库即可。\n\n# jni步骤流程\n\n\n\n就像使用Java类要先加载类文件一样，要使用jni，首先要加载类库，然后通过Java层方法调用JNI层方法。调用流程如下：\n\n![屏幕快照 2017-04-21 下午1.29.01.png](http://upload-images.jianshu.io/upload_images/1796052-a4792879d689f210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面是调用流程，调用的前提是先完成开发，也就是说开发流程是要先完成Java层方法和Native层方法。\n\n基础介绍的差不多了，下面开始进入实际开发部分：\n\n\n\n#  Java调用C\n\n##  看看一般开发时Java如何调用C\n\nJava层和JNI层之间源码是有对应规律的。\n\nJNI实现文件命名为：Java全类名(下划线作分隔符)\n\nJNI实现方法命名为：Java_为前缀+全类名(下划线作分隔符)+方法名\n\n例如，现在Java定义native方法如下：\n\n```\npublic class TestNative {\n    // Used to load the 'native-lib' library on application startup.\n    public native int add(int a,int b);\n    public native String stringFromJNI();\n}\n```\n\n那么按照规范，jni实现方法名为：\n\n```\nJava_com_example_jenson_myapplication_TestNative_add(JNIEnv *env, jobject instance, jint a,\n                                                     jint b) {\n    return a+b;\n}\n```\n\nJava声明方法和jni实现方法都已经实现了，接下来就是调用实现库(.so文件，关于so的编译不在讲):\n\n```\n static {\n        System.loadLibrary(\"native-lib\");\n    }\n```\n\n上面是最普通也是最简单的jni开发流程三步走，但是其中有很多问题没有弄明白，比如JNIENV是什么，Java中参数int为什么变为jint了等等。\n\n学习最好的方法就是看代码，那么我们就看看系统jni使用示例：Log打印系统。\n\n## 看看Log打印系统Java如何调用C\n\n首先我们看下Log.java的源码才好下手。\n\n### 简单介绍Log.java源码\n\n看看Log.i()方法实现：\n\n    public static int i(String tag, String msg, Throwable tr) {\n        return println_native(LOG_ID_MAIN, INFO, tag, msg + '\\n' + getStackTraceString(tr));\n    }\n    \n    public static int w(String tag, String msg) {\n        return println_native(LOG_ID_MAIN, WARN, tag, msg);\n    }\n可以看出真正的打印是在 println_native 方法中，而这个方法是一个本地方法：\n\n```\npublic static native int println_native(int bufID,int priority, String tag, String msg);\npublic static native boolean isLoggable(String tag, int level);\n```\n\n\n\n> 原来JNI中Java层的实现这么简单，只需要声明一个native修饰的方法，传入必须的参数就行了。\n\n下面研究中心要转移到jni层实现了，源码那么多如何找到jni实现呢？\n\n### JNI层源码探究\n\n- 查找JNI层实现\n\n  按照上面说的规范，直接查找Java类Log的全类名。\n\n  例如 Log类全类名为android.util.Log，其对应的Native文件名称应该为android_util_Log。我们试下：\n\n  ![屏幕快照 2017-04-24 下午9.57.43](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午9.57.43.png)\n\n  果真找到了，下面开始探究源码：\n\n- JNI源码开扒\n\n  我们首先找到Java层println_native方法JNI层的实现，按照上面的命名规范，没有找到 Java_android_util_Log_println_native ，但是却找到了这个方法：android_util_Log_println_native ，看来Android系统级的JNI没有遵循规范啊。不过没关系，*只要记住JNI有两种方式：一种是遵守JNI命名规范的日常使用方法，另一种是是这种系统级JNI没有Java_前缀就行了* 。不影响我们看代码：\n\n  ![屏幕快照 2017-04-24 下午10.29.17](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午10.29.17.png)\n\n  可以看出该方法代码比较少，因为我们是研究JNI，而不是研究Log如何打印，所以方法中对于其他方法调用不再深入研究，但是现在Java声明方法和JNI实现方法都找到了，但是系统式如何把这两个给关联起来的呢？我们继续往下看：\n\n  ​\n\n- Java和JNI双方的方法如何对上眼的\n\n  在该文件中有这样一个方法 register_android_util_Log，我们看下实现：\n\n  ![屏幕快照 2017-04-24 下午11.04.06](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.04.06.png)\n\n  这个方法前面大部分代码给我的第一感觉就是：这么TM和Java的反射好像啊！难道是C++版反射？反正意思就是通过Java的Log类拿到该类的几个变量(C语言中习惯称为域)\n\n  看最后一行调用了AndroidRunTime的方法，顾名思义是注册本地方法，其中参数 gMethods  值得一看：\n\n  ![屏幕快照 2017-04-24 下午11.14.36](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.14.36.png)\n\n  这是一个静态结构体数组，这个比较有意思，看注释可以看出大括弧的三个元素分别是名称、签名和函数指针。而名称恰恰是Java里面声明的本地方法，签名是本地方法的签名，函数指针指向的是Native实现方法。一个数组就把Java方法和Native方法给关联起来了。因为Java支持方法重载，为了确保调用的唯一性，于是就有了方法签名，下面说说方法签名机制：\n\n  首先看下签名规则：\n\n  | Java类型  | 类型签名    |\n  | ------- | ------- |\n  | boolean | Z       |\n  | byte    | B       |\n  | char    | C       |\n  | long    | J       |\n  | float   | F       |\n  | double  | D       |\n  | short   | S       |\n  | int     | I       |\n  | 其他类     | L全类名;   |\n  | 数组      | [元素类型签名 |\n\n  > 注意：方法签名格式分为两部分：参数类型签名+返回值类型签名，类型签名之间没有空格，其中参数类型签名使用()括起来，有多少参数就有多少参数类型签名，格式为： *(参数1类型签名参数n类型签名)返回值类型签名* ,注意全类名用\"/\"分隔。\n\n  拿 boolean isLoggable(String tag, int level) 举例来说其方法签名为(Ljava/lang/String;I)Z 。\n\n  说完了方法签名规则，我们继续，在android_util_Log文件中有jni方法，所以有了 register_android_util_Log 来注册该文件的jni方法，那么在其他有jni方法的文件中是不是也有类似的register_xxx方法呢？怀着好奇心，打开Parcel看看：\n\n  ```\n  int register_android_os_Parcel(JNIEnv* env)\n  {\n      jclass clazz;\n\n      clazz = env->FindClass(kParcelPathName);\n      LOG_FATAL_IF(clazz == NULL, \"Unable to find class android.os.Parcel\");\n\n      gParcelOffsets.clazz = (jclass) env->NewGlobalRef(clazz);\n      gParcelOffsets.mNativePtr = env->GetFieldID(clazz, \"mNativePtr\", \"J\");\n      gParcelOffsets.obtain = env->GetStaticMethodID(clazz, \"obtain\",\n                                                     \"()Landroid/os/Parcel;\");\n      gParcelOffsets.recycle = env->GetMethodID(clazz, \"recycle\", \"()V\");\n\n      return AndroidRuntime::registerNativeMethods(\n          env, kParcelPathName,\n          gParcelMethods, NELEM(gParcelMethods));\n  }\n  ```\n\n  看到register_android_os_Parcel 方法证实了我的猜测，所以根据归纳法暂且可以认为系统的涉及jni方法的文件中都会有对应的注册方法而且最终都调用了AndroidRunTime::registerNativeMethods()。\n\n  其实registerNativeMethods方法的第二个参数是类文件路径：\n\n  ```\n  AndroidRuntime::registerNativeMethods(env, \"android/util/Log\", gMethods, NELEM(gMethods));\n  ```\n\n  而mMethods数组中又对应了JNI实现方法和Java方法，通过registerNativeMethods方法调用jniRegisterNativeMethods()然后调用RegisterNatives方法最终告诉了JVM Java类和JNI实现方法的映射关系，这样就完了Java调用C。\n\n  ​\n\n- Java类型和JNI类型如何对应的\n\n  首先看下基本类型的对应关系：\n\n  | Java类型  | JNI类型    | 字长   |\n  | ------- | -------- | ---- |\n  | boolean | jboolean | 8位   |\n  | byte    | jbyte    | 8位   |\n  | char    | jchar    | 16位  |\n  | short   | jshort   | 16位  |\n  | int     | jint     | 32位  |\n  | long    | jlong    | 64位  |\n  | float   | jfloat   | 32位  |\n  | double  | jdouble  | 64位  |\n  | void    | void     |      |\n\n  很好奇jboolean这些类型是怎么来的，既然是jni类型就先去jni.h头文件下看看有没有定义：\n\n  ![屏幕快照 2017-04-25 下午12.56.36](Android开发之JNI深入解析/屏幕快照 2017-04-25 下午12.56.36.png)\n\n  竟然找到了，本来以为jxx是jni新开发的类型，原来就是对C类型起了一个别名。简单理解就是把Java基本类型的值给到了占用同样字节大小的C类型上。\n\n  下面再看看引用类型对应关系：\n\n  | Java类型                                   | JNI类型                                    |\n  | ---------------------------------------- | ---------------------------------------- |\n  | java.lang.Class                          | class                                    |\n  | java.lang.String                         | string                                   |\n  | java.lang.Throwable                      | throwable                                |\n  | Object[]、boolean[]、byte[]、char[]、short[]、int[]、long[]、float[]、double[] | jobjectArray、jbooleanArray、jbyteArray、jcharArray、jshortArray、jintArray、jlongArray、jfloatArray、jdoubleArray |\n  | java.lang.Object                         | jobject                                  |\n\n  ​\n\n#  C调用Java\n\n上面介绍了Java如何调用C，本节讲下C如何调用Java：\n\nC调用Java按流程走也很简单，通过全类名找到类，找到类构造方法，根据构造方法构建对象，根据对象调用变量和方法。OK，我们通过一个示例来讲解下：\n\n示例流程是这样子，我们通过Java方法stringFromJNI调用JNI实现方法，但是在实现方法中并没有直接返回一个字符串，而是该方法中调用了一个Java方法，其实现如下：\n\n```\n    public String callByNative( ){\n        return \"callByNative\";\n    }\n```\n\n返回的字符串直接显示在TextView中：\n\n```\n    sample_text = (TextView) findViewById(R.id.sample_text);\n    TestNative testNative = new TestNative();\n    sample_text.setText(testNative.stringFromJNI());\n```\n\n接下来我们需要自己在stringFromJNI的实现方法中调用Java层的callByNative：\n\n首先通过全类名找到类，通过FindClass方法,参数为全类名：\n\n```\n    jclass clazz = env->FindClass(\"com/example/jenson/myapplication/TestNative\");\n```\n\n然后通过构造方法构建对象，要调用构造方法先找到构造方法的ID：\n\n```\njmethodID mid = env->GetMethodID(clazz,\"<init>\",\"()V\");\njobject  obj= env->NewObject(clazz,mid);\n```\n\n要注意的是：构造方法比较特殊，所以第二个参数的方法名要传”<init>“，第三个参数为方法签名，至于签名规则上面有介绍，根据参数自己填写签名。\n\n创建对象时使用NewObject，需要传入创建对象使用的类及构造方法对应的id。\n\n对象上面已经创建完成，接下来可以调用实例方法callByNative了：\n\n```\n mid = env->GetMethodID(clazz,\"callByNative\",\"()Ljava/lang/String;\");\n jstring js = (jstring) env->CallObjectMethod(obj, mid);\n```\n\n注意调用一个方法前要先获取方法ID，然后通过Call<Type>Method方法传入对象和方法ID，达到实例方法调用。\n\n因为callByNative方法返回的是String，所以按照上面说的应该调用CallStringMethod方法，但是jni没有这个方法，所以直接使用了CallObjectMethod，然后强制转换来得到String，比较Object是一切类基类。\n\n最终stringFromJNI实现代码如下：\n\n```\nJava_com_example_jenson_myapplication_TestNative_stringFromJNI(JNIEnv *env, jobject instance) {\n\n    // 这里通过C调用callByNative方法\n    jclass clazz = env->FindClass(\"com/example/jenson/myapplication/TestNative\");\n    jmethodID mid = env->GetMethodID(clazz,\"<init>\",\"()V\");\n    jobject  obj= env->NewObject(clazz,mid);\n    mid = env->GetMethodID(clazz,\"callByNative\",\"()Ljava/lang/String;\");\n    jstring js = (jstring) env->CallObjectMethod(obj, mid);\n    if (js ==NULL) {\n        js = (jstring) \"hello\";\n    }\n    return js;\n}\n```\n\n\n\n看下执行结果，达到了我们的要求：![屏幕快照 2017-04-25 下午2.54.18](Android开发之JNI深入解析/屏幕快照 2017-04-25 下午2.54.18.png)\n\n\n\njnienv提供了很多参数实现C调用Java，诸如：GetMethodID、FindClass、GetFieldID，还有静态方法和域：GetStaticMethodID、GetStaticFieldID等，感兴趣的可以去jni.h去研究下。\n\n\n\n# JNIENV是什么鬼\n\n\n\n\n\n# JNI异常处理\n\n","source":"_posts/Android开发之JNI深入解析.md","raw":"---\ntitle: Android开发之JNI深入解析\ndate: 2017-04-25 00:55:54\ntags: Android\ncategories: Android\n---\n\n# 说在前面的话\n\n>本来是没有打算写JNI的，因为本来是在看Binder机制原理的，但是看着看着就跑偏看到了JNI。。。\n\n# 通过本章可以了解到这些：\n\n\n\n- jni介绍\n\n- 为什么要学习jni\n\n- jni使用流程是怎样的\n\n- 如何Java调用C\n\n- 如何C调用Java\n\n- 了解jni源码和机制\n\n  ​\n\n# 什么是jni、ndk\n\n\n\njni(java native interface)，Java本地接口。在Java中接口就是一套协议标准，同样这里也是如此，jni是一套让Java和C互通有无的一套标准。看到这脑子里应该有个大概情况：\n\n![屏幕快照 2017-04-21 下午12.17.32.png](http://upload-images.jianshu.io/upload_images/1796052-062e7ea6f0c17ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nndk,它只是一套开发工具集，如果再给它加个形容词，那就是本地开发工具集，即Native Development Kit。\n>注意区别ndk和jni，一个是一套软件，一个是套标准。\n\n\n\n# 为什么使用jni\n\n\n\n- 1、效率问题\n\n  C和C++效率比Java要高一些，虽然这种差距随着Java性能优化有越来越小的趋势，但是总归还是存在的。\n\n- 2、安全问题\n\n  虽然没有绝对的安全，但是相对来说C语言的反汇编比Java更不容易看懂\n\n- 3、代码复用\n\n  C语言年代久远，有很多现成的库，如果Java需要使用同样的功能，不需要自己从新实现，jni直接调用库即可。\n\n# jni步骤流程\n\n\n\n就像使用Java类要先加载类文件一样，要使用jni，首先要加载类库，然后通过Java层方法调用JNI层方法。调用流程如下：\n\n![屏幕快照 2017-04-21 下午1.29.01.png](http://upload-images.jianshu.io/upload_images/1796052-a4792879d689f210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面是调用流程，调用的前提是先完成开发，也就是说开发流程是要先完成Java层方法和Native层方法。\n\n基础介绍的差不多了，下面开始进入实际开发部分：\n\n\n\n#  Java调用C\n\n##  看看一般开发时Java如何调用C\n\nJava层和JNI层之间源码是有对应规律的。\n\nJNI实现文件命名为：Java全类名(下划线作分隔符)\n\nJNI实现方法命名为：Java_为前缀+全类名(下划线作分隔符)+方法名\n\n例如，现在Java定义native方法如下：\n\n```\npublic class TestNative {\n    // Used to load the 'native-lib' library on application startup.\n    public native int add(int a,int b);\n    public native String stringFromJNI();\n}\n```\n\n那么按照规范，jni实现方法名为：\n\n```\nJava_com_example_jenson_myapplication_TestNative_add(JNIEnv *env, jobject instance, jint a,\n                                                     jint b) {\n    return a+b;\n}\n```\n\nJava声明方法和jni实现方法都已经实现了，接下来就是调用实现库(.so文件，关于so的编译不在讲):\n\n```\n static {\n        System.loadLibrary(\"native-lib\");\n    }\n```\n\n上面是最普通也是最简单的jni开发流程三步走，但是其中有很多问题没有弄明白，比如JNIENV是什么，Java中参数int为什么变为jint了等等。\n\n学习最好的方法就是看代码，那么我们就看看系统jni使用示例：Log打印系统。\n\n## 看看Log打印系统Java如何调用C\n\n首先我们看下Log.java的源码才好下手。\n\n### 简单介绍Log.java源码\n\n看看Log.i()方法实现：\n\n    public static int i(String tag, String msg, Throwable tr) {\n        return println_native(LOG_ID_MAIN, INFO, tag, msg + '\\n' + getStackTraceString(tr));\n    }\n    \n    public static int w(String tag, String msg) {\n        return println_native(LOG_ID_MAIN, WARN, tag, msg);\n    }\n可以看出真正的打印是在 println_native 方法中，而这个方法是一个本地方法：\n\n```\npublic static native int println_native(int bufID,int priority, String tag, String msg);\npublic static native boolean isLoggable(String tag, int level);\n```\n\n\n\n> 原来JNI中Java层的实现这么简单，只需要声明一个native修饰的方法，传入必须的参数就行了。\n\n下面研究中心要转移到jni层实现了，源码那么多如何找到jni实现呢？\n\n### JNI层源码探究\n\n- 查找JNI层实现\n\n  按照上面说的规范，直接查找Java类Log的全类名。\n\n  例如 Log类全类名为android.util.Log，其对应的Native文件名称应该为android_util_Log。我们试下：\n\n  ![屏幕快照 2017-04-24 下午9.57.43](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午9.57.43.png)\n\n  果真找到了，下面开始探究源码：\n\n- JNI源码开扒\n\n  我们首先找到Java层println_native方法JNI层的实现，按照上面的命名规范，没有找到 Java_android_util_Log_println_native ，但是却找到了这个方法：android_util_Log_println_native ，看来Android系统级的JNI没有遵循规范啊。不过没关系，*只要记住JNI有两种方式：一种是遵守JNI命名规范的日常使用方法，另一种是是这种系统级JNI没有Java_前缀就行了* 。不影响我们看代码：\n\n  ![屏幕快照 2017-04-24 下午10.29.17](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午10.29.17.png)\n\n  可以看出该方法代码比较少，因为我们是研究JNI，而不是研究Log如何打印，所以方法中对于其他方法调用不再深入研究，但是现在Java声明方法和JNI实现方法都找到了，但是系统式如何把这两个给关联起来的呢？我们继续往下看：\n\n  ​\n\n- Java和JNI双方的方法如何对上眼的\n\n  在该文件中有这样一个方法 register_android_util_Log，我们看下实现：\n\n  ![屏幕快照 2017-04-24 下午11.04.06](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.04.06.png)\n\n  这个方法前面大部分代码给我的第一感觉就是：这么TM和Java的反射好像啊！难道是C++版反射？反正意思就是通过Java的Log类拿到该类的几个变量(C语言中习惯称为域)\n\n  看最后一行调用了AndroidRunTime的方法，顾名思义是注册本地方法，其中参数 gMethods  值得一看：\n\n  ![屏幕快照 2017-04-24 下午11.14.36](Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.14.36.png)\n\n  这是一个静态结构体数组，这个比较有意思，看注释可以看出大括弧的三个元素分别是名称、签名和函数指针。而名称恰恰是Java里面声明的本地方法，签名是本地方法的签名，函数指针指向的是Native实现方法。一个数组就把Java方法和Native方法给关联起来了。因为Java支持方法重载，为了确保调用的唯一性，于是就有了方法签名，下面说说方法签名机制：\n\n  首先看下签名规则：\n\n  | Java类型  | 类型签名    |\n  | ------- | ------- |\n  | boolean | Z       |\n  | byte    | B       |\n  | char    | C       |\n  | long    | J       |\n  | float   | F       |\n  | double  | D       |\n  | short   | S       |\n  | int     | I       |\n  | 其他类     | L全类名;   |\n  | 数组      | [元素类型签名 |\n\n  > 注意：方法签名格式分为两部分：参数类型签名+返回值类型签名，类型签名之间没有空格，其中参数类型签名使用()括起来，有多少参数就有多少参数类型签名，格式为： *(参数1类型签名参数n类型签名)返回值类型签名* ,注意全类名用\"/\"分隔。\n\n  拿 boolean isLoggable(String tag, int level) 举例来说其方法签名为(Ljava/lang/String;I)Z 。\n\n  说完了方法签名规则，我们继续，在android_util_Log文件中有jni方法，所以有了 register_android_util_Log 来注册该文件的jni方法，那么在其他有jni方法的文件中是不是也有类似的register_xxx方法呢？怀着好奇心，打开Parcel看看：\n\n  ```\n  int register_android_os_Parcel(JNIEnv* env)\n  {\n      jclass clazz;\n\n      clazz = env->FindClass(kParcelPathName);\n      LOG_FATAL_IF(clazz == NULL, \"Unable to find class android.os.Parcel\");\n\n      gParcelOffsets.clazz = (jclass) env->NewGlobalRef(clazz);\n      gParcelOffsets.mNativePtr = env->GetFieldID(clazz, \"mNativePtr\", \"J\");\n      gParcelOffsets.obtain = env->GetStaticMethodID(clazz, \"obtain\",\n                                                     \"()Landroid/os/Parcel;\");\n      gParcelOffsets.recycle = env->GetMethodID(clazz, \"recycle\", \"()V\");\n\n      return AndroidRuntime::registerNativeMethods(\n          env, kParcelPathName,\n          gParcelMethods, NELEM(gParcelMethods));\n  }\n  ```\n\n  看到register_android_os_Parcel 方法证实了我的猜测，所以根据归纳法暂且可以认为系统的涉及jni方法的文件中都会有对应的注册方法而且最终都调用了AndroidRunTime::registerNativeMethods()。\n\n  其实registerNativeMethods方法的第二个参数是类文件路径：\n\n  ```\n  AndroidRuntime::registerNativeMethods(env, \"android/util/Log\", gMethods, NELEM(gMethods));\n  ```\n\n  而mMethods数组中又对应了JNI实现方法和Java方法，通过registerNativeMethods方法调用jniRegisterNativeMethods()然后调用RegisterNatives方法最终告诉了JVM Java类和JNI实现方法的映射关系，这样就完了Java调用C。\n\n  ​\n\n- Java类型和JNI类型如何对应的\n\n  首先看下基本类型的对应关系：\n\n  | Java类型  | JNI类型    | 字长   |\n  | ------- | -------- | ---- |\n  | boolean | jboolean | 8位   |\n  | byte    | jbyte    | 8位   |\n  | char    | jchar    | 16位  |\n  | short   | jshort   | 16位  |\n  | int     | jint     | 32位  |\n  | long    | jlong    | 64位  |\n  | float   | jfloat   | 32位  |\n  | double  | jdouble  | 64位  |\n  | void    | void     |      |\n\n  很好奇jboolean这些类型是怎么来的，既然是jni类型就先去jni.h头文件下看看有没有定义：\n\n  ![屏幕快照 2017-04-25 下午12.56.36](Android开发之JNI深入解析/屏幕快照 2017-04-25 下午12.56.36.png)\n\n  竟然找到了，本来以为jxx是jni新开发的类型，原来就是对C类型起了一个别名。简单理解就是把Java基本类型的值给到了占用同样字节大小的C类型上。\n\n  下面再看看引用类型对应关系：\n\n  | Java类型                                   | JNI类型                                    |\n  | ---------------------------------------- | ---------------------------------------- |\n  | java.lang.Class                          | class                                    |\n  | java.lang.String                         | string                                   |\n  | java.lang.Throwable                      | throwable                                |\n  | Object[]、boolean[]、byte[]、char[]、short[]、int[]、long[]、float[]、double[] | jobjectArray、jbooleanArray、jbyteArray、jcharArray、jshortArray、jintArray、jlongArray、jfloatArray、jdoubleArray |\n  | java.lang.Object                         | jobject                                  |\n\n  ​\n\n#  C调用Java\n\n上面介绍了Java如何调用C，本节讲下C如何调用Java：\n\nC调用Java按流程走也很简单，通过全类名找到类，找到类构造方法，根据构造方法构建对象，根据对象调用变量和方法。OK，我们通过一个示例来讲解下：\n\n示例流程是这样子，我们通过Java方法stringFromJNI调用JNI实现方法，但是在实现方法中并没有直接返回一个字符串，而是该方法中调用了一个Java方法，其实现如下：\n\n```\n    public String callByNative( ){\n        return \"callByNative\";\n    }\n```\n\n返回的字符串直接显示在TextView中：\n\n```\n    sample_text = (TextView) findViewById(R.id.sample_text);\n    TestNative testNative = new TestNative();\n    sample_text.setText(testNative.stringFromJNI());\n```\n\n接下来我们需要自己在stringFromJNI的实现方法中调用Java层的callByNative：\n\n首先通过全类名找到类，通过FindClass方法,参数为全类名：\n\n```\n    jclass clazz = env->FindClass(\"com/example/jenson/myapplication/TestNative\");\n```\n\n然后通过构造方法构建对象，要调用构造方法先找到构造方法的ID：\n\n```\njmethodID mid = env->GetMethodID(clazz,\"<init>\",\"()V\");\njobject  obj= env->NewObject(clazz,mid);\n```\n\n要注意的是：构造方法比较特殊，所以第二个参数的方法名要传”<init>“，第三个参数为方法签名，至于签名规则上面有介绍，根据参数自己填写签名。\n\n创建对象时使用NewObject，需要传入创建对象使用的类及构造方法对应的id。\n\n对象上面已经创建完成，接下来可以调用实例方法callByNative了：\n\n```\n mid = env->GetMethodID(clazz,\"callByNative\",\"()Ljava/lang/String;\");\n jstring js = (jstring) env->CallObjectMethod(obj, mid);\n```\n\n注意调用一个方法前要先获取方法ID，然后通过Call<Type>Method方法传入对象和方法ID，达到实例方法调用。\n\n因为callByNative方法返回的是String，所以按照上面说的应该调用CallStringMethod方法，但是jni没有这个方法，所以直接使用了CallObjectMethod，然后强制转换来得到String，比较Object是一切类基类。\n\n最终stringFromJNI实现代码如下：\n\n```\nJava_com_example_jenson_myapplication_TestNative_stringFromJNI(JNIEnv *env, jobject instance) {\n\n    // 这里通过C调用callByNative方法\n    jclass clazz = env->FindClass(\"com/example/jenson/myapplication/TestNative\");\n    jmethodID mid = env->GetMethodID(clazz,\"<init>\",\"()V\");\n    jobject  obj= env->NewObject(clazz,mid);\n    mid = env->GetMethodID(clazz,\"callByNative\",\"()Ljava/lang/String;\");\n    jstring js = (jstring) env->CallObjectMethod(obj, mid);\n    if (js ==NULL) {\n        js = (jstring) \"hello\";\n    }\n    return js;\n}\n```\n\n\n\n看下执行结果，达到了我们的要求：![屏幕快照 2017-04-25 下午2.54.18](Android开发之JNI深入解析/屏幕快照 2017-04-25 下午2.54.18.png)\n\n\n\njnienv提供了很多参数实现C调用Java，诸如：GetMethodID、FindClass、GetFieldID，还有静态方法和域：GetStaticMethodID、GetStaticFieldID等，感兴趣的可以去jni.h去研究下。\n\n\n\n# JNIENV是什么鬼\n\n\n\n\n\n# JNI异常处理\n\n","slug":"Android开发之JNI深入解析","published":1,"updated":"2017-04-25T07:17:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjbo000kwh9cpbkb80wu","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><blockquote>\n<p>本来是没有打算写JNI的，因为本来是在看Binder机制原理的，但是看着看着就跑偏看到了JNI。。。</p>\n</blockquote>\n<h1 id=\"通过本章可以了解到这些：\"><a href=\"#通过本章可以了解到这些：\" class=\"headerlink\" title=\"通过本章可以了解到这些：\"></a>通过本章可以了解到这些：</h1><ul>\n<li><p>jni介绍</p>\n</li>\n<li><p>为什么要学习jni</p>\n</li>\n<li><p>jni使用流程是怎样的</p>\n</li>\n<li><p>如何Java调用C</p>\n</li>\n<li><p>如何C调用Java</p>\n</li>\n<li><p>了解jni源码和机制</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"什么是jni、ndk\"><a href=\"#什么是jni、ndk\" class=\"headerlink\" title=\"什么是jni、ndk\"></a>什么是jni、ndk</h1><p>jni(java native interface)，Java本地接口。在Java中接口就是一套协议标准，同样这里也是如此，jni是一套让Java和C互通有无的一套标准。看到这脑子里应该有个大概情况：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-062e7ea6f0c17ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-21 下午12.17.32.png\"><br>ndk,它只是一套开发工具集，如果再给它加个形容词，那就是本地开发工具集，即Native Development Kit。</p>\n<blockquote>\n<p>注意区别ndk和jni，一个是一套软件，一个是套标准。</p>\n</blockquote>\n<h1 id=\"为什么使用jni\"><a href=\"#为什么使用jni\" class=\"headerlink\" title=\"为什么使用jni\"></a>为什么使用jni</h1><ul>\n<li><p>1、效率问题</p>\n<p>C和C++效率比Java要高一些，虽然这种差距随着Java性能优化有越来越小的趋势，但是总归还是存在的。</p>\n</li>\n<li><p>2、安全问题</p>\n<p>虽然没有绝对的安全，但是相对来说C语言的反汇编比Java更不容易看懂</p>\n</li>\n<li><p>3、代码复用</p>\n<p>C语言年代久远，有很多现成的库，如果Java需要使用同样的功能，不需要自己从新实现，jni直接调用库即可。</p>\n</li>\n</ul>\n<h1 id=\"jni步骤流程\"><a href=\"#jni步骤流程\" class=\"headerlink\" title=\"jni步骤流程\"></a>jni步骤流程</h1><p>就像使用Java类要先加载类文件一样，要使用jni，首先要加载类库，然后通过Java层方法调用JNI层方法。调用流程如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a4792879d689f210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-21 下午1.29.01.png\"></p>\n<p>上面是调用流程，调用的前提是先完成开发，也就是说开发流程是要先完成Java层方法和Native层方法。</p>\n<p>基础介绍的差不多了，下面开始进入实际开发部分：</p>\n<h1 id=\"Java调用C\"><a href=\"#Java调用C\" class=\"headerlink\" title=\"Java调用C\"></a>Java调用C</h1><h2 id=\"看看一般开发时Java如何调用C\"><a href=\"#看看一般开发时Java如何调用C\" class=\"headerlink\" title=\"看看一般开发时Java如何调用C\"></a>看看一般开发时Java如何调用C</h2><p>Java层和JNI层之间源码是有对应规律的。</p>\n<p>JNI实现文件命名为：Java全类名(下划线作分隔符)</p>\n<p>JNI实现方法命名为：Java_为前缀+全类名(下划线作分隔符)+方法名</p>\n<p>例如，现在Java定义native方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestNative &#123;</div><div class=\"line\">    // Used to load the &apos;native-lib&apos; library on application startup.</div><div class=\"line\">    public native int add(int a,int b);</div><div class=\"line\">    public native String stringFromJNI();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么按照规范，jni实现方法名为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Java_com_example_jenson_myapplication_TestNative_add(JNIEnv *env, jobject instance, jint a,</div><div class=\"line\">                                                     jint b) &#123;</div><div class=\"line\">    return a+b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java声明方法和jni实现方法都已经实现了，接下来就是调用实现库(.so文件，关于so的编译不在讲):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">static &#123;</div><div class=\"line\">       System.loadLibrary(&quot;native-lib&quot;);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>上面是最普通也是最简单的jni开发流程三步走，但是其中有很多问题没有弄明白，比如JNIENV是什么，Java中参数int为什么变为jint了等等。</p>\n<p>学习最好的方法就是看代码，那么我们就看看系统jni使用示例：Log打印系统。</p>\n<h2 id=\"看看Log打印系统Java如何调用C\"><a href=\"#看看Log打印系统Java如何调用C\" class=\"headerlink\" title=\"看看Log打印系统Java如何调用C\"></a>看看Log打印系统Java如何调用C</h2><p>首先我们看下Log.java的源码才好下手。</p>\n<h3 id=\"简单介绍Log-java源码\"><a href=\"#简单介绍Log-java源码\" class=\"headerlink\" title=\"简单介绍Log.java源码\"></a>简单介绍Log.java源码</h3><p>看看Log.i()方法实现：</p>\n<pre><code>public static int i(String tag, String msg, Throwable tr) {\n    return println_native(LOG_ID_MAIN, INFO, tag, msg + &apos;\\n&apos; + getStackTraceString(tr));\n}\n\npublic static int w(String tag, String msg) {\n    return println_native(LOG_ID_MAIN, WARN, tag, msg);\n}\n</code></pre><p>可以看出真正的打印是在 println_native 方法中，而这个方法是一个本地方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static native int println_native(int bufID,int priority, String tag, String msg);</div><div class=\"line\">public static native boolean isLoggable(String tag, int level);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>原来JNI中Java层的实现这么简单，只需要声明一个native修饰的方法，传入必须的参数就行了。</p>\n</blockquote>\n<p>下面研究中心要转移到jni层实现了，源码那么多如何找到jni实现呢？</p>\n<h3 id=\"JNI层源码探究\"><a href=\"#JNI层源码探究\" class=\"headerlink\" title=\"JNI层源码探究\"></a>JNI层源码探究</h3><ul>\n<li><p>查找JNI层实现</p>\n<p>按照上面说的规范，直接查找Java类Log的全类名。</p>\n<p>例如 Log类全类名为android.util.Log，其对应的Native文件名称应该为android_util_Log。我们试下：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午9.57.43.png\" alt=\"屏幕快照 2017-04-24 下午9.57.43\"></p>\n<p>果真找到了，下面开始探究源码：</p>\n</li>\n<li><p>JNI源码开扒</p>\n<p>我们首先找到Java层println_native方法JNI层的实现，按照上面的命名规范，没有找到 Java_android_util_Log_println_native ，但是却找到了这个方法：android_util_Log_println<em>native ，看来Android系统级的JNI没有遵循规范啊。不过没关系，*只要记住JNI有两种方式：一种是遵守JNI命名规范的日常使用方法，另一种是是这种系统级JNI没有Java</em>前缀就行了* 。不影响我们看代码：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午10.29.17.png\" alt=\"屏幕快照 2017-04-24 下午10.29.17\"></p>\n<p>可以看出该方法代码比较少，因为我们是研究JNI，而不是研究Log如何打印，所以方法中对于其他方法调用不再深入研究，但是现在Java声明方法和JNI实现方法都找到了，但是系统式如何把这两个给关联起来的呢？我们继续往下看：</p>\n<p>​</p>\n</li>\n<li><p>Java和JNI双方的方法如何对上眼的</p>\n<p>在该文件中有这样一个方法 register_android_util_Log，我们看下实现：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.04.06.png\" alt=\"屏幕快照 2017-04-24 下午11.04.06\"></p>\n<p>这个方法前面大部分代码给我的第一感觉就是：这么TM和Java的反射好像啊！难道是C++版反射？反正意思就是通过Java的Log类拿到该类的几个变量(C语言中习惯称为域)</p>\n<p>看最后一行调用了AndroidRunTime的方法，顾名思义是注册本地方法，其中参数 gMethods  值得一看：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.14.36.png\" alt=\"屏幕快照 2017-04-24 下午11.14.36\"></p>\n<p>这是一个静态结构体数组，这个比较有意思，看注释可以看出大括弧的三个元素分别是名称、签名和函数指针。而名称恰恰是Java里面声明的本地方法，签名是本地方法的签名，函数指针指向的是Native实现方法。一个数组就把Java方法和Native方法给关联起来了。因为Java支持方法重载，为了确保调用的唯一性，于是就有了方法签名，下面说说方法签名机制：</p>\n<p>首先看下签名规则：</p>\n<p>| Java类型  | 类型签名    |<br>| ——- | ——- |<br>| boolean | Z       |<br>| byte    | B       |<br>| char    | C       |<br>| long    | J       |<br>| float   | F       |<br>| double  | D       |<br>| short   | S       |<br>| int     | I       |<br>| 其他类     | L全类名;   |<br>| 数组      | [元素类型签名 |</p>\n<blockquote>\n<p>注意：方法签名格式分为两部分：参数类型签名+返回值类型签名，类型签名之间没有空格，其中参数类型签名使用()括起来，有多少参数就有多少参数类型签名，格式为： <em>(参数1类型签名参数n类型签名)返回值类型签名</em> ,注意全类名用”/“分隔。</p>\n</blockquote>\n<p>拿 boolean isLoggable(String tag, int level) 举例来说其方法签名为(Ljava/lang/String;I)Z 。</p>\n<p>说完了方法签名规则，我们继续，在android_util_Log文件中有jni方法，所以有了 register_android_util_Log 来注册该文件的jni方法，那么在其他有jni方法的文件中是不是也有类似的register_xxx方法呢？怀着好奇心，打开Parcel看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">int register_android_os_Parcel(JNIEnv* env)</div><div class=\"line\">&#123;</div><div class=\"line\">    jclass clazz;</div><div class=\"line\"></div><div class=\"line\">    clazz = env-&gt;FindClass(kParcelPathName);</div><div class=\"line\">    LOG_FATAL_IF(clazz == NULL, &quot;Unable to find class android.os.Parcel&quot;);</div><div class=\"line\"></div><div class=\"line\">    gParcelOffsets.clazz = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class=\"line\">    gParcelOffsets.mNativePtr = env-&gt;GetFieldID(clazz, &quot;mNativePtr&quot;, &quot;J&quot;);</div><div class=\"line\">    gParcelOffsets.obtain = env-&gt;GetStaticMethodID(clazz, &quot;obtain&quot;,</div><div class=\"line\">                                                   &quot;()Landroid/os/Parcel;&quot;);</div><div class=\"line\">    gParcelOffsets.recycle = env-&gt;GetMethodID(clazz, &quot;recycle&quot;, &quot;()V&quot;);</div><div class=\"line\"></div><div class=\"line\">    return AndroidRuntime::registerNativeMethods(</div><div class=\"line\">        env, kParcelPathName,</div><div class=\"line\">        gParcelMethods, NELEM(gParcelMethods));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看到register_android_os_Parcel 方法证实了我的猜测，所以根据归纳法暂且可以认为系统的涉及jni方法的文件中都会有对应的注册方法而且最终都调用了AndroidRunTime::registerNativeMethods()。</p>\n<p>其实registerNativeMethods方法的第二个参数是类文件路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidRuntime::registerNativeMethods(env, &quot;android/util/Log&quot;, gMethods, NELEM(gMethods));</div></pre></td></tr></table></figure>\n<p>而mMethods数组中又对应了JNI实现方法和Java方法，通过registerNativeMethods方法调用jniRegisterNativeMethods()然后调用RegisterNatives方法最终告诉了JVM Java类和JNI实现方法的映射关系，这样就完了Java调用C。</p>\n<p>​</p>\n</li>\n<li><p>Java类型和JNI类型如何对应的</p>\n<p>首先看下基本类型的对应关系：</p>\n<p>| Java类型  | JNI类型    | 字长   |<br>| ——- | ——– | —- |<br>| boolean | jboolean | 8位   |<br>| byte    | jbyte    | 8位   |<br>| char    | jchar    | 16位  |<br>| short   | jshort   | 16位  |<br>| int     | jint     | 32位  |<br>| long    | jlong    | 64位  |<br>| float   | jfloat   | 32位  |<br>| double  | jdouble  | 64位  |<br>| void    | void     |      |</p>\n<p>很好奇jboolean这些类型是怎么来的，既然是jni类型就先去jni.h头文件下看看有没有定义：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午12.56.36.png\" alt=\"屏幕快照 2017-04-25 下午12.56.36\"></p>\n<p>竟然找到了，本来以为jxx是jni新开发的类型，原来就是对C类型起了一个别名。简单理解就是把Java基本类型的值给到了占用同样字节大小的C类型上。</p>\n<p>下面再看看引用类型对应关系：</p>\n<p>| Java类型                                   | JNI类型                                    |<br>| —————————————- | —————————————- |<br>| java.lang.Class                          | class                                    |<br>| java.lang.String                         | string                                   |<br>| java.lang.Throwable                      | throwable                                |<br>| Object[]、boolean[]、byte[]、char[]、short[]、int[]、long[]、float[]、double[] | jobjectArray、jbooleanArray、jbyteArray、jcharArray、jshortArray、jintArray、jlongArray、jfloatArray、jdoubleArray |<br>| java.lang.Object                         | jobject                                  |</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"C调用Java\"><a href=\"#C调用Java\" class=\"headerlink\" title=\"C调用Java\"></a>C调用Java</h1><p>上面介绍了Java如何调用C，本节讲下C如何调用Java：</p>\n<p>C调用Java按流程走也很简单，通过全类名找到类，找到类构造方法，根据构造方法构建对象，根据对象调用变量和方法。OK，我们通过一个示例来讲解下：</p>\n<p>示例流程是这样子，我们通过Java方法stringFromJNI调用JNI实现方法，但是在实现方法中并没有直接返回一个字符串，而是该方法中调用了一个Java方法，其实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String callByNative( )&#123;</div><div class=\"line\">    return &quot;callByNative&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回的字符串直接显示在TextView中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sample_text = (TextView) findViewById(R.id.sample_text);</div><div class=\"line\">TestNative testNative = new TestNative();</div><div class=\"line\">sample_text.setText(testNative.stringFromJNI());</div></pre></td></tr></table></figure>\n<p>接下来我们需要自己在stringFromJNI的实现方法中调用Java层的callByNative：</p>\n<p>首先通过全类名找到类，通过FindClass方法,参数为全类名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/jenson/myapplication/TestNative&quot;);</div></pre></td></tr></table></figure>\n<p>然后通过构造方法构建对象，要调用构造方法先找到构造方法的ID：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jmethodID mid = env-&gt;GetMethodID(clazz,&quot;&lt;init&gt;&quot;,&quot;()V&quot;);</div><div class=\"line\">jobject  obj= env-&gt;NewObject(clazz,mid);</div></pre></td></tr></table></figure>\n<p>要注意的是：构造方法比较特殊，所以第二个参数的方法名要传”<init>“，第三个参数为方法签名，至于签名规则上面有介绍，根据参数自己填写签名。</init></p>\n<p>创建对象时使用NewObject，需要传入创建对象使用的类及构造方法对应的id。</p>\n<p>对象上面已经创建完成，接下来可以调用实例方法callByNative了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mid = env-&gt;GetMethodID(clazz,&quot;callByNative&quot;,&quot;()Ljava/lang/String;&quot;);</div><div class=\"line\">jstring js = (jstring) env-&gt;CallObjectMethod(obj, mid);</div></pre></td></tr></table></figure>\n<p>注意调用一个方法前要先获取方法ID，然后通过Call<type>Method方法传入对象和方法ID，达到实例方法调用。</type></p>\n<p>因为callByNative方法返回的是String，所以按照上面说的应该调用CallStringMethod方法，但是jni没有这个方法，所以直接使用了CallObjectMethod，然后强制转换来得到String，比较Object是一切类基类。</p>\n<p>最终stringFromJNI实现代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Java_com_example_jenson_myapplication_TestNative_stringFromJNI(JNIEnv *env, jobject instance) &#123;</div><div class=\"line\"></div><div class=\"line\">    // 这里通过C调用callByNative方法</div><div class=\"line\">    jclass clazz = env-&gt;FindClass(&quot;com/example/jenson/myapplication/TestNative&quot;);</div><div class=\"line\">    jmethodID mid = env-&gt;GetMethodID(clazz,&quot;&lt;init&gt;&quot;,&quot;()V&quot;);</div><div class=\"line\">    jobject  obj= env-&gt;NewObject(clazz,mid);</div><div class=\"line\">    mid = env-&gt;GetMethodID(clazz,&quot;callByNative&quot;,&quot;()Ljava/lang/String;&quot;);</div><div class=\"line\">    jstring js = (jstring) env-&gt;CallObjectMethod(obj, mid);</div><div class=\"line\">    if (js ==NULL) &#123;</div><div class=\"line\">        js = (jstring) &quot;hello&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return js;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看下执行结果，达到了我们的要求：<img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午2.54.18.png\" alt=\"屏幕快照 2017-04-25 下午2.54.18\"></p>\n<p>jnienv提供了很多参数实现C调用Java，诸如：GetMethodID、FindClass、GetFieldID，还有静态方法和域：GetStaticMethodID、GetStaticFieldID等，感兴趣的可以去jni.h去研究下。</p>\n<h1 id=\"JNIENV是什么鬼\"><a href=\"#JNIENV是什么鬼\" class=\"headerlink\" title=\"JNIENV是什么鬼\"></a>JNIENV是什么鬼</h1><h1 id=\"JNI异常处理\"><a href=\"#JNI异常处理\" class=\"headerlink\" title=\"JNI异常处理\"></a>JNI异常处理</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><blockquote>\n<p>本来是没有打算写JNI的，因为本来是在看Binder机制原理的，但是看着看着就跑偏看到了JNI。。。</p>\n</blockquote>\n<h1 id=\"通过本章可以了解到这些：\"><a href=\"#通过本章可以了解到这些：\" class=\"headerlink\" title=\"通过本章可以了解到这些：\"></a>通过本章可以了解到这些：</h1><ul>\n<li><p>jni介绍</p>\n</li>\n<li><p>为什么要学习jni</p>\n</li>\n<li><p>jni使用流程是怎样的</p>\n</li>\n<li><p>如何Java调用C</p>\n</li>\n<li><p>如何C调用Java</p>\n</li>\n<li><p>了解jni源码和机制</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"什么是jni、ndk\"><a href=\"#什么是jni、ndk\" class=\"headerlink\" title=\"什么是jni、ndk\"></a>什么是jni、ndk</h1><p>jni(java native interface)，Java本地接口。在Java中接口就是一套协议标准，同样这里也是如此，jni是一套让Java和C互通有无的一套标准。看到这脑子里应该有个大概情况：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-062e7ea6f0c17ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-21 下午12.17.32.png\"><br>ndk,它只是一套开发工具集，如果再给它加个形容词，那就是本地开发工具集，即Native Development Kit。</p>\n<blockquote>\n<p>注意区别ndk和jni，一个是一套软件，一个是套标准。</p>\n</blockquote>\n<h1 id=\"为什么使用jni\"><a href=\"#为什么使用jni\" class=\"headerlink\" title=\"为什么使用jni\"></a>为什么使用jni</h1><ul>\n<li><p>1、效率问题</p>\n<p>C和C++效率比Java要高一些，虽然这种差距随着Java性能优化有越来越小的趋势，但是总归还是存在的。</p>\n</li>\n<li><p>2、安全问题</p>\n<p>虽然没有绝对的安全，但是相对来说C语言的反汇编比Java更不容易看懂</p>\n</li>\n<li><p>3、代码复用</p>\n<p>C语言年代久远，有很多现成的库，如果Java需要使用同样的功能，不需要自己从新实现，jni直接调用库即可。</p>\n</li>\n</ul>\n<h1 id=\"jni步骤流程\"><a href=\"#jni步骤流程\" class=\"headerlink\" title=\"jni步骤流程\"></a>jni步骤流程</h1><p>就像使用Java类要先加载类文件一样，要使用jni，首先要加载类库，然后通过Java层方法调用JNI层方法。调用流程如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a4792879d689f210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-21 下午1.29.01.png\"></p>\n<p>上面是调用流程，调用的前提是先完成开发，也就是说开发流程是要先完成Java层方法和Native层方法。</p>\n<p>基础介绍的差不多了，下面开始进入实际开发部分：</p>\n<h1 id=\"Java调用C\"><a href=\"#Java调用C\" class=\"headerlink\" title=\"Java调用C\"></a>Java调用C</h1><h2 id=\"看看一般开发时Java如何调用C\"><a href=\"#看看一般开发时Java如何调用C\" class=\"headerlink\" title=\"看看一般开发时Java如何调用C\"></a>看看一般开发时Java如何调用C</h2><p>Java层和JNI层之间源码是有对应规律的。</p>\n<p>JNI实现文件命名为：Java全类名(下划线作分隔符)</p>\n<p>JNI实现方法命名为：Java_为前缀+全类名(下划线作分隔符)+方法名</p>\n<p>例如，现在Java定义native方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class TestNative &#123;</div><div class=\"line\">    // Used to load the &apos;native-lib&apos; library on application startup.</div><div class=\"line\">    public native int add(int a,int b);</div><div class=\"line\">    public native String stringFromJNI();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么按照规范，jni实现方法名为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Java_com_example_jenson_myapplication_TestNative_add(JNIEnv *env, jobject instance, jint a,</div><div class=\"line\">                                                     jint b) &#123;</div><div class=\"line\">    return a+b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Java声明方法和jni实现方法都已经实现了，接下来就是调用实现库(.so文件，关于so的编译不在讲):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">static &#123;</div><div class=\"line\">       System.loadLibrary(&quot;native-lib&quot;);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>上面是最普通也是最简单的jni开发流程三步走，但是其中有很多问题没有弄明白，比如JNIENV是什么，Java中参数int为什么变为jint了等等。</p>\n<p>学习最好的方法就是看代码，那么我们就看看系统jni使用示例：Log打印系统。</p>\n<h2 id=\"看看Log打印系统Java如何调用C\"><a href=\"#看看Log打印系统Java如何调用C\" class=\"headerlink\" title=\"看看Log打印系统Java如何调用C\"></a>看看Log打印系统Java如何调用C</h2><p>首先我们看下Log.java的源码才好下手。</p>\n<h3 id=\"简单介绍Log-java源码\"><a href=\"#简单介绍Log-java源码\" class=\"headerlink\" title=\"简单介绍Log.java源码\"></a>简单介绍Log.java源码</h3><p>看看Log.i()方法实现：</p>\n<pre><code>public static int i(String tag, String msg, Throwable tr) {\n    return println_native(LOG_ID_MAIN, INFO, tag, msg + &apos;\\n&apos; + getStackTraceString(tr));\n}\n\npublic static int w(String tag, String msg) {\n    return println_native(LOG_ID_MAIN, WARN, tag, msg);\n}\n</code></pre><p>可以看出真正的打印是在 println_native 方法中，而这个方法是一个本地方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static native int println_native(int bufID,int priority, String tag, String msg);</div><div class=\"line\">public static native boolean isLoggable(String tag, int level);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>原来JNI中Java层的实现这么简单，只需要声明一个native修饰的方法，传入必须的参数就行了。</p>\n</blockquote>\n<p>下面研究中心要转移到jni层实现了，源码那么多如何找到jni实现呢？</p>\n<h3 id=\"JNI层源码探究\"><a href=\"#JNI层源码探究\" class=\"headerlink\" title=\"JNI层源码探究\"></a>JNI层源码探究</h3><ul>\n<li><p>查找JNI层实现</p>\n<p>按照上面说的规范，直接查找Java类Log的全类名。</p>\n<p>例如 Log类全类名为android.util.Log，其对应的Native文件名称应该为android_util_Log。我们试下：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午9.57.43.png\" alt=\"屏幕快照 2017-04-24 下午9.57.43\"></p>\n<p>果真找到了，下面开始探究源码：</p>\n</li>\n<li><p>JNI源码开扒</p>\n<p>我们首先找到Java层println_native方法JNI层的实现，按照上面的命名规范，没有找到 Java_android_util_Log_println_native ，但是却找到了这个方法：android_util_Log_println<em>native ，看来Android系统级的JNI没有遵循规范啊。不过没关系，*只要记住JNI有两种方式：一种是遵守JNI命名规范的日常使用方法，另一种是是这种系统级JNI没有Java</em>前缀就行了* 。不影响我们看代码：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午10.29.17.png\" alt=\"屏幕快照 2017-04-24 下午10.29.17\"></p>\n<p>可以看出该方法代码比较少，因为我们是研究JNI，而不是研究Log如何打印，所以方法中对于其他方法调用不再深入研究，但是现在Java声明方法和JNI实现方法都找到了，但是系统式如何把这两个给关联起来的呢？我们继续往下看：</p>\n<p>​</p>\n</li>\n<li><p>Java和JNI双方的方法如何对上眼的</p>\n<p>在该文件中有这样一个方法 register_android_util_Log，我们看下实现：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.04.06.png\" alt=\"屏幕快照 2017-04-24 下午11.04.06\"></p>\n<p>这个方法前面大部分代码给我的第一感觉就是：这么TM和Java的反射好像啊！难道是C++版反射？反正意思就是通过Java的Log类拿到该类的几个变量(C语言中习惯称为域)</p>\n<p>看最后一行调用了AndroidRunTime的方法，顾名思义是注册本地方法，其中参数 gMethods  值得一看：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.14.36.png\" alt=\"屏幕快照 2017-04-24 下午11.14.36\"></p>\n<p>这是一个静态结构体数组，这个比较有意思，看注释可以看出大括弧的三个元素分别是名称、签名和函数指针。而名称恰恰是Java里面声明的本地方法，签名是本地方法的签名，函数指针指向的是Native实现方法。一个数组就把Java方法和Native方法给关联起来了。因为Java支持方法重载，为了确保调用的唯一性，于是就有了方法签名，下面说说方法签名机制：</p>\n<p>首先看下签名规则：</p>\n<p>| Java类型  | 类型签名    |<br>| ——- | ——- |<br>| boolean | Z       |<br>| byte    | B       |<br>| char    | C       |<br>| long    | J       |<br>| float   | F       |<br>| double  | D       |<br>| short   | S       |<br>| int     | I       |<br>| 其他类     | L全类名;   |<br>| 数组      | [元素类型签名 |</p>\n<blockquote>\n<p>注意：方法签名格式分为两部分：参数类型签名+返回值类型签名，类型签名之间没有空格，其中参数类型签名使用()括起来，有多少参数就有多少参数类型签名，格式为： <em>(参数1类型签名参数n类型签名)返回值类型签名</em> ,注意全类名用”/“分隔。</p>\n</blockquote>\n<p>拿 boolean isLoggable(String tag, int level) 举例来说其方法签名为(Ljava/lang/String;I)Z 。</p>\n<p>说完了方法签名规则，我们继续，在android_util_Log文件中有jni方法，所以有了 register_android_util_Log 来注册该文件的jni方法，那么在其他有jni方法的文件中是不是也有类似的register_xxx方法呢？怀着好奇心，打开Parcel看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">int register_android_os_Parcel(JNIEnv* env)</div><div class=\"line\">&#123;</div><div class=\"line\">    jclass clazz;</div><div class=\"line\"></div><div class=\"line\">    clazz = env-&gt;FindClass(kParcelPathName);</div><div class=\"line\">    LOG_FATAL_IF(clazz == NULL, &quot;Unable to find class android.os.Parcel&quot;);</div><div class=\"line\"></div><div class=\"line\">    gParcelOffsets.clazz = (jclass) env-&gt;NewGlobalRef(clazz);</div><div class=\"line\">    gParcelOffsets.mNativePtr = env-&gt;GetFieldID(clazz, &quot;mNativePtr&quot;, &quot;J&quot;);</div><div class=\"line\">    gParcelOffsets.obtain = env-&gt;GetStaticMethodID(clazz, &quot;obtain&quot;,</div><div class=\"line\">                                                   &quot;()Landroid/os/Parcel;&quot;);</div><div class=\"line\">    gParcelOffsets.recycle = env-&gt;GetMethodID(clazz, &quot;recycle&quot;, &quot;()V&quot;);</div><div class=\"line\"></div><div class=\"line\">    return AndroidRuntime::registerNativeMethods(</div><div class=\"line\">        env, kParcelPathName,</div><div class=\"line\">        gParcelMethods, NELEM(gParcelMethods));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看到register_android_os_Parcel 方法证实了我的猜测，所以根据归纳法暂且可以认为系统的涉及jni方法的文件中都会有对应的注册方法而且最终都调用了AndroidRunTime::registerNativeMethods()。</p>\n<p>其实registerNativeMethods方法的第二个参数是类文件路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">AndroidRuntime::registerNativeMethods(env, &quot;android/util/Log&quot;, gMethods, NELEM(gMethods));</div></pre></td></tr></table></figure>\n<p>而mMethods数组中又对应了JNI实现方法和Java方法，通过registerNativeMethods方法调用jniRegisterNativeMethods()然后调用RegisterNatives方法最终告诉了JVM Java类和JNI实现方法的映射关系，这样就完了Java调用C。</p>\n<p>​</p>\n</li>\n<li><p>Java类型和JNI类型如何对应的</p>\n<p>首先看下基本类型的对应关系：</p>\n<p>| Java类型  | JNI类型    | 字长   |<br>| ——- | ——– | —- |<br>| boolean | jboolean | 8位   |<br>| byte    | jbyte    | 8位   |<br>| char    | jchar    | 16位  |<br>| short   | jshort   | 16位  |<br>| int     | jint     | 32位  |<br>| long    | jlong    | 64位  |<br>| float   | jfloat   | 32位  |<br>| double  | jdouble  | 64位  |<br>| void    | void     |      |</p>\n<p>很好奇jboolean这些类型是怎么来的，既然是jni类型就先去jni.h头文件下看看有没有定义：</p>\n<p><img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午12.56.36.png\" alt=\"屏幕快照 2017-04-25 下午12.56.36\"></p>\n<p>竟然找到了，本来以为jxx是jni新开发的类型，原来就是对C类型起了一个别名。简单理解就是把Java基本类型的值给到了占用同样字节大小的C类型上。</p>\n<p>下面再看看引用类型对应关系：</p>\n<p>| Java类型                                   | JNI类型                                    |<br>| —————————————- | —————————————- |<br>| java.lang.Class                          | class                                    |<br>| java.lang.String                         | string                                   |<br>| java.lang.Throwable                      | throwable                                |<br>| Object[]、boolean[]、byte[]、char[]、short[]、int[]、long[]、float[]、double[] | jobjectArray、jbooleanArray、jbyteArray、jcharArray、jshortArray、jintArray、jlongArray、jfloatArray、jdoubleArray |<br>| java.lang.Object                         | jobject                                  |</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"C调用Java\"><a href=\"#C调用Java\" class=\"headerlink\" title=\"C调用Java\"></a>C调用Java</h1><p>上面介绍了Java如何调用C，本节讲下C如何调用Java：</p>\n<p>C调用Java按流程走也很简单，通过全类名找到类，找到类构造方法，根据构造方法构建对象，根据对象调用变量和方法。OK，我们通过一个示例来讲解下：</p>\n<p>示例流程是这样子，我们通过Java方法stringFromJNI调用JNI实现方法，但是在实现方法中并没有直接返回一个字符串，而是该方法中调用了一个Java方法，其实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String callByNative( )&#123;</div><div class=\"line\">    return &quot;callByNative&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回的字符串直接显示在TextView中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sample_text = (TextView) findViewById(R.id.sample_text);</div><div class=\"line\">TestNative testNative = new TestNative();</div><div class=\"line\">sample_text.setText(testNative.stringFromJNI());</div></pre></td></tr></table></figure>\n<p>接下来我们需要自己在stringFromJNI的实现方法中调用Java层的callByNative：</p>\n<p>首先通过全类名找到类，通过FindClass方法,参数为全类名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">jclass clazz = env-&gt;FindClass(&quot;com/example/jenson/myapplication/TestNative&quot;);</div></pre></td></tr></table></figure>\n<p>然后通过构造方法构建对象，要调用构造方法先找到构造方法的ID：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jmethodID mid = env-&gt;GetMethodID(clazz,&quot;&lt;init&gt;&quot;,&quot;()V&quot;);</div><div class=\"line\">jobject  obj= env-&gt;NewObject(clazz,mid);</div></pre></td></tr></table></figure>\n<p>要注意的是：构造方法比较特殊，所以第二个参数的方法名要传”<init>“，第三个参数为方法签名，至于签名规则上面有介绍，根据参数自己填写签名。</init></p>\n<p>创建对象时使用NewObject，需要传入创建对象使用的类及构造方法对应的id。</p>\n<p>对象上面已经创建完成，接下来可以调用实例方法callByNative了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mid = env-&gt;GetMethodID(clazz,&quot;callByNative&quot;,&quot;()Ljava/lang/String;&quot;);</div><div class=\"line\">jstring js = (jstring) env-&gt;CallObjectMethod(obj, mid);</div></pre></td></tr></table></figure>\n<p>注意调用一个方法前要先获取方法ID，然后通过Call<Type>Method方法传入对象和方法ID，达到实例方法调用。</Type></p>\n<p>因为callByNative方法返回的是String，所以按照上面说的应该调用CallStringMethod方法，但是jni没有这个方法，所以直接使用了CallObjectMethod，然后强制转换来得到String，比较Object是一切类基类。</p>\n<p>最终stringFromJNI实现代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Java_com_example_jenson_myapplication_TestNative_stringFromJNI(JNIEnv *env, jobject instance) &#123;</div><div class=\"line\"></div><div class=\"line\">    // 这里通过C调用callByNative方法</div><div class=\"line\">    jclass clazz = env-&gt;FindClass(&quot;com/example/jenson/myapplication/TestNative&quot;);</div><div class=\"line\">    jmethodID mid = env-&gt;GetMethodID(clazz,&quot;&lt;init&gt;&quot;,&quot;()V&quot;);</div><div class=\"line\">    jobject  obj= env-&gt;NewObject(clazz,mid);</div><div class=\"line\">    mid = env-&gt;GetMethodID(clazz,&quot;callByNative&quot;,&quot;()Ljava/lang/String;&quot;);</div><div class=\"line\">    jstring js = (jstring) env-&gt;CallObjectMethod(obj, mid);</div><div class=\"line\">    if (js ==NULL) &#123;</div><div class=\"line\">        js = (jstring) &quot;hello&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return js;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看下执行结果，达到了我们的要求：<img src=\"/2017/04/25/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午2.54.18.png\" alt=\"屏幕快照 2017-04-25 下午2.54.18\"></p>\n<p>jnienv提供了很多参数实现C调用Java，诸如：GetMethodID、FindClass、GetFieldID，还有静态方法和域：GetStaticMethodID、GetStaticFieldID等，感兴趣的可以去jni.h去研究下。</p>\n<h1 id=\"JNIENV是什么鬼\"><a href=\"#JNIENV是什么鬼\" class=\"headerlink\" title=\"JNIENV是什么鬼\"></a>JNIENV是什么鬼</h1><h1 id=\"JNI异常处理\"><a href=\"#JNI异常处理\" class=\"headerlink\" title=\"JNI异常处理\"></a>JNI异常处理</h1>"},{"title":"Android性能优化之耗电优化","date":"2017-04-21T12:55:54.000Z","_content":">作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。\n\n####1、为什么耗电\n\n![屏幕快照 2017-03-23 下午2.51.24.png](http://upload-images.jianshu.io/upload_images/1796052-09bf2f70fae572b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n通过上图先把用户-电量这一流程抽象出来，设备的耗电根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。用户对app频繁使用说明了你用户黏性做的好，我们不能左右，所以我们要在app对硬件调用上做优化来达到节省电量的目的。\n\n先看下移动设备元件耗电大户有哪些：\n![fullsizerender.jpg](http://upload-images.jianshu.io/upload_images/1796052-9f6e93db0de1fb2a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####2、屏幕\n屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。\n\n在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。\n- LCD概述\nLCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。\n- LED概述\nLED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。\n> 优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。\n\n####3、无线网络\n无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。\n\n- 移动网络\n移动网络数据传输有3种状态：\nFull power：高功率状态，网络激活，允许设备以最大传输速率进行传输。\nLow power：低功率状态，传输速率低于15kbps，耗电是Full Power状态的一半，一般不能直接从程序中进入该状态，而是由Full Power状态降级进入。\nStandby：\b空闲状态，没有数据连接需要传输，耗电最少。\n\n这三种状态有一个转换流程：\n\n![mobile_radio_state_machine.png](http://upload-images.jianshu.io/upload_images/1796052-c669c0cfaae7f3b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态需要2s，从低功率状态转换到高功率状态需要1.5s。应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。\n\n- WIFI网络\nWIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。\n当从低(高)功率状态传输数据时，WIFI会暂时进入相应地低(高)传输状态，一旦数据传输完毕就回到初始状态。\n>WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。\n\n\n\n通过上面了解网络连接过程，应该心里有了大概的优化建议。\n\n- 网络优化方案：\n  - 减少网络高功率保持时间：\n   \t\t- 1.文本和文件压缩传输。\n不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样是无线所处的高功率状态时间更短，从而减少了耗电。\n    \t- 2.精简文本文件。所谓精简就是去掉文本中空行、空格、注释等无意义内容。\n\n\t\t\t```\n\t\t\t<html>  \n \t\t\t <title> A Sample Page</title> \n \t\t\t <body> \n   \t\t\t with some sample text \n    \t\t\t<--do more here--> \n  \t\t\t</body> \n\t\t\t</html>\n\t\t\t```\n精简后\n\n\t\t\t```\n\t\t\t<html>  <title> A Sample Page</title> <body> with some sample text \t\t\t<--do more here--> </body> </html>\n\t\t\t```\n   \t\t- 3.根据显示大小从服务器获取图片\n①请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。也可以使用Android端使用Bitmap.Option自行获取缩放的图片\n②使用webp图片。\n  - 减少网络请求次数\n     \t- 1.使用缓存。\n把经常使用的文件缓存到本地，如头像icon、好友信息等。以后很多时间都可以直接从本地读取缓存减少网络请求次数。\n\n    \t- 2.移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，从而减少频繁间隔请求导致状态转换消耗更多电量。\n\n    \n\n\n####4、CPU\n>cpu利用率高和cpu的频率高没有必然关系，这取决于cpu调频策略。高利用率和高频率的cpu都会导致高耗电。\n\n- 浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，例如使用位移代替除法。\n- 避免wakelock不正确使用\nwakelock可以唤醒设备也可以阻止设备休眠。在PowerManager类中谷歌已经声明了：这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。wankelock有几种类型，在使用时注意选择正确地类型。\n\n- 使用JobScheduler\n很多时候为了满足我们的需求而没有考虑cpu的感受，为了执行1s中的数据区唤醒cpu，但实际却消耗了约两分钟的电量。为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：\n必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。\n耗电大德任务，如备份在充电时执行。\n\n- Doze模式\n>Doze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。但是为了不影响应用正常工作，系统还会周期性退出Doze，在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。\n\n####5、其他优化\n- 传感器\n每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。\n\n后面的章节会写一些关于电量检测分析工具的使用。\n\n为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。","source":"_posts/Android性能优化之耗电优化.md","raw":"---\ntitle: Android性能优化之耗电优化\ndate: 2017-04-21 20:55:54\ntags: Android\ncategories: Android\n---\n>作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。\n\n####1、为什么耗电\n\n![屏幕快照 2017-03-23 下午2.51.24.png](http://upload-images.jianshu.io/upload_images/1796052-09bf2f70fae572b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n通过上图先把用户-电量这一流程抽象出来，设备的耗电根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。用户对app频繁使用说明了你用户黏性做的好，我们不能左右，所以我们要在app对硬件调用上做优化来达到节省电量的目的。\n\n先看下移动设备元件耗电大户有哪些：\n![fullsizerender.jpg](http://upload-images.jianshu.io/upload_images/1796052-9f6e93db0de1fb2a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n####2、屏幕\n屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。\n\n在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。\n- LCD概述\nLCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。\n- LED概述\nLED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。\n> 优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。\n\n####3、无线网络\n无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。\n\n- 移动网络\n移动网络数据传输有3种状态：\nFull power：高功率状态，网络激活，允许设备以最大传输速率进行传输。\nLow power：低功率状态，传输速率低于15kbps，耗电是Full Power状态的一半，一般不能直接从程序中进入该状态，而是由Full Power状态降级进入。\nStandby：\b空闲状态，没有数据连接需要传输，耗电最少。\n\n这三种状态有一个转换流程：\n\n![mobile_radio_state_machine.png](http://upload-images.jianshu.io/upload_images/1796052-c669c0cfaae7f3b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态需要2s，从低功率状态转换到高功率状态需要1.5s。应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。\n\n- WIFI网络\nWIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。\n当从低(高)功率状态传输数据时，WIFI会暂时进入相应地低(高)传输状态，一旦数据传输完毕就回到初始状态。\n>WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。\n\n\n\n通过上面了解网络连接过程，应该心里有了大概的优化建议。\n\n- 网络优化方案：\n  - 减少网络高功率保持时间：\n   \t\t- 1.文本和文件压缩传输。\n不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样是无线所处的高功率状态时间更短，从而减少了耗电。\n    \t- 2.精简文本文件。所谓精简就是去掉文本中空行、空格、注释等无意义内容。\n\n\t\t\t```\n\t\t\t<html>  \n \t\t\t <title> A Sample Page</title> \n \t\t\t <body> \n   \t\t\t with some sample text \n    \t\t\t<--do more here--> \n  \t\t\t</body> \n\t\t\t</html>\n\t\t\t```\n精简后\n\n\t\t\t```\n\t\t\t<html>  <title> A Sample Page</title> <body> with some sample text \t\t\t<--do more here--> </body> </html>\n\t\t\t```\n   \t\t- 3.根据显示大小从服务器获取图片\n①请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。也可以使用Android端使用Bitmap.Option自行获取缩放的图片\n②使用webp图片。\n  - 减少网络请求次数\n     \t- 1.使用缓存。\n把经常使用的文件缓存到本地，如头像icon、好友信息等。以后很多时间都可以直接从本地读取缓存减少网络请求次数。\n\n    \t- 2.移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，从而减少频繁间隔请求导致状态转换消耗更多电量。\n\n    \n\n\n####4、CPU\n>cpu利用率高和cpu的频率高没有必然关系，这取决于cpu调频策略。高利用率和高频率的cpu都会导致高耗电。\n\n- 浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，例如使用位移代替除法。\n- 避免wakelock不正确使用\nwakelock可以唤醒设备也可以阻止设备休眠。在PowerManager类中谷歌已经声明了：这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。wankelock有几种类型，在使用时注意选择正确地类型。\n\n- 使用JobScheduler\n很多时候为了满足我们的需求而没有考虑cpu的感受，为了执行1s中的数据区唤醒cpu，但实际却消耗了约两分钟的电量。为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：\n必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。\n耗电大德任务，如备份在充电时执行。\n\n- Doze模式\n>Doze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。但是为了不影响应用正常工作，系统还会周期性退出Doze，在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。\n\n####5、其他优化\n- 传感器\n每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。\n\n后面的章节会写一些关于电量检测分析工具的使用。\n\n为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。","slug":"Android性能优化之耗电优化","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjbq000mwh9c0lrf6x3i","content":"<blockquote>\n<p>作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。</p>\n</blockquote>\n<p>####1、为什么耗电</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-09bf2f70fae572b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-23 下午2.51.24.png\"></p>\n<p>通过上图先把用户-电量这一流程抽象出来，设备的耗电根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。用户对app频繁使用说明了你用户黏性做的好，我们不能左右，所以我们要在app对硬件调用上做优化来达到节省电量的目的。</p>\n<p>先看下移动设备元件耗电大户有哪些：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-9f6e93db0de1fb2a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender.jpg\"></p>\n<p>####2、屏幕<br>屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。</p>\n<p>在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。</p>\n<ul>\n<li>LCD概述<br>LCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。</li>\n<li>LED概述<br>LED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。<blockquote>\n<p>优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。</p>\n</blockquote>\n</li>\n</ul>\n<p>####3、无线网络<br>无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。</p>\n<ul>\n<li>移动网络<br>移动网络数据传输有3种状态：<br>Full power：高功率状态，网络激活，允许设备以最大传输速率进行传输。<br>Low power：低功率状态，传输速率低于15kbps，耗电是Full Power状态的一半，一般不能直接从程序中进入该状态，而是由Full Power状态降级进入。<br>Standby：\b空闲状态，没有数据连接需要传输，耗电最少。</li>\n</ul>\n<p>这三种状态有一个转换流程：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c669c0cfaae7f3b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mobile_radio_state_machine.png\"></p>\n<blockquote>\n<p>可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态需要2s，从低功率状态转换到高功率状态需要1.5s。应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。</p>\n</blockquote>\n<ul>\n<li>WIFI网络<br>WIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。<br>当从低(高)功率状态传输数据时，WIFI会暂时进入相应地低(高)传输状态，一旦数据传输完毕就回到初始状态。<blockquote>\n<p>WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。</p>\n</blockquote>\n</li>\n</ul>\n<p>通过上面了解网络连接过程，应该心里有了大概的优化建议。</p>\n<ul>\n<li><p>网络优化方案：</p>\n<ul>\n<li><p>减少网络高功率保持时间：</p>\n<pre><code>- 1.文本和文件压缩传输。\n</code></pre><p>不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样是无线所处的高功率状态时间更短，从而减少了耗电。</p>\n<pre><code>- 2.精简文本文件。所谓精简就是去掉文本中空行、空格、注释等无意义内容。\n\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;  </div><div class=\"line\">\t &lt;title&gt; A Sample Page&lt;/title&gt; </div><div class=\"line\">\t &lt;body&gt; </div><div class=\"line\">\t\t\t with some sample text </div><div class=\"line\"> \t\t\t&lt;--do more here--&gt; </div><div class=\"line\">\t\t&lt;/body&gt; </div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>精简后</p>\n<pre><code> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;  &lt;title&gt; A Sample Page&lt;/title&gt; &lt;body&gt; with some sample text \t\t\t&lt;--do more here--&gt; &lt;/body&gt; &lt;/html&gt;</div></pre></td></tr></table></figure>\n\n- 3.根据显示大小从服务器获取图片\n</code></pre><p>①请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。也可以使用Android端使用Bitmap.Option自行获取缩放的图片<br>②使用webp图片。</p>\n<ul>\n<li><p>减少网络请求次数</p>\n<pre><code>- 1.使用缓存。\n</code></pre><p>把经常使用的文件缓存到本地，如头像icon、好友信息等。以后很多时间都可以直接从本地读取缓存减少网络请求次数。</p>\n<pre><code>- 2.移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，从而减少频繁间隔请求导致状态转换消耗更多电量。\n</code></pre></li>\n</ul>\n<p>####4、CPU</p>\n<blockquote>\n<p>cpu利用率高和cpu的频率高没有必然关系，这取决于cpu调频策略。高利用率和高频率的cpu都会导致高耗电。</p>\n</blockquote>\n<ul>\n<li>浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，例如使用位移代替除法。</li>\n<li><p>避免wakelock不正确使用<br>wakelock可以唤醒设备也可以阻止设备休眠。在PowerManager类中谷歌已经声明了：这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。wankelock有几种类型，在使用时注意选择正确地类型。</p>\n</li>\n<li><p>使用JobScheduler<br>很多时候为了满足我们的需求而没有考虑cpu的感受，为了执行1s中的数据区唤醒cpu，但实际却消耗了约两分钟的电量。为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：<br>必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。<br>耗电大德任务，如备份在充电时执行。</p>\n</li>\n<li><p>Doze模式</p>\n<blockquote>\n<p>Doze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。但是为了不影响应用正常工作，系统还会周期性退出Doze，在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。</p>\n</blockquote>\n</li>\n</ul>\n<p>####5、其他优化</p>\n<ul>\n<li>传感器<br>每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。</li>\n</ul>\n<p>后面的章节会写一些关于电量检测分析工具的使用。</p>\n<p>为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。</p>\n</blockquote>\n<p>####1、为什么耗电</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-09bf2f70fae572b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-23 下午2.51.24.png\"></p>\n<p>通过上图先把用户-电量这一流程抽象出来，设备的耗电根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。用户对app频繁使用说明了你用户黏性做的好，我们不能左右，所以我们要在app对硬件调用上做优化来达到节省电量的目的。</p>\n<p>先看下移动设备元件耗电大户有哪些：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-9f6e93db0de1fb2a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender.jpg\"></p>\n<p>####2、屏幕<br>屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。</p>\n<p>在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。</p>\n<ul>\n<li>LCD概述<br>LCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。</li>\n<li>LED概述<br>LED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。<blockquote>\n<p>优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。</p>\n</blockquote>\n</li>\n</ul>\n<p>####3、无线网络<br>无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。</p>\n<ul>\n<li>移动网络<br>移动网络数据传输有3种状态：<br>Full power：高功率状态，网络激活，允许设备以最大传输速率进行传输。<br>Low power：低功率状态，传输速率低于15kbps，耗电是Full Power状态的一半，一般不能直接从程序中进入该状态，而是由Full Power状态降级进入。<br>Standby：\b空闲状态，没有数据连接需要传输，耗电最少。</li>\n</ul>\n<p>这三种状态有一个转换流程：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c669c0cfaae7f3b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mobile_radio_state_machine.png\"></p>\n<blockquote>\n<p>可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态需要2s，从低功率状态转换到高功率状态需要1.5s。应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。</p>\n</blockquote>\n<ul>\n<li>WIFI网络<br>WIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。<br>当从低(高)功率状态传输数据时，WIFI会暂时进入相应地低(高)传输状态，一旦数据传输完毕就回到初始状态。<blockquote>\n<p>WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。</p>\n</blockquote>\n</li>\n</ul>\n<p>通过上面了解网络连接过程，应该心里有了大概的优化建议。</p>\n<ul>\n<li><p>网络优化方案：</p>\n<ul>\n<li><p>减少网络高功率保持时间：</p>\n<pre><code>- 1.文本和文件压缩传输。\n</code></pre><p>不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样是无线所处的高功率状态时间更短，从而减少了耗电。</p>\n<pre><code>- 2.精简文本文件。所谓精简就是去掉文本中空行、空格、注释等无意义内容。\n\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;  </div><div class=\"line\">\t &lt;title&gt; A Sample Page&lt;/title&gt; </div><div class=\"line\">\t &lt;body&gt; </div><div class=\"line\">\t\t\t with some sample text </div><div class=\"line\"> \t\t\t&lt;--do more here--&gt; </div><div class=\"line\">\t\t&lt;/body&gt; </div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>精简后</p>\n<pre><code> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html&gt;  &lt;title&gt; A Sample Page&lt;/title&gt; &lt;body&gt; with some sample text \t\t\t&lt;--do more here--&gt; &lt;/body&gt; &lt;/html&gt;</div></pre></td></tr></table></figure>\n\n- 3.根据显示大小从服务器获取图片\n</code></pre><p>①请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。也可以使用Android端使用Bitmap.Option自行获取缩放的图片<br>②使用webp图片。</p>\n<ul>\n<li><p>减少网络请求次数</p>\n<pre><code>- 1.使用缓存。\n</code></pre><p>把经常使用的文件缓存到本地，如头像icon、好友信息等。以后很多时间都可以直接从本地读取缓存减少网络请求次数。</p>\n<pre><code>- 2.移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，从而减少频繁间隔请求导致状态转换消耗更多电量。\n</code></pre></li>\n</ul>\n<p>####4、CPU</p>\n<blockquote>\n<p>cpu利用率高和cpu的频率高没有必然关系，这取决于cpu调频策略。高利用率和高频率的cpu都会导致高耗电。</p>\n</blockquote>\n<ul>\n<li>浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，例如使用位移代替除法。</li>\n<li><p>避免wakelock不正确使用<br>wakelock可以唤醒设备也可以阻止设备休眠。在PowerManager类中谷歌已经声明了：这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。wankelock有几种类型，在使用时注意选择正确地类型。</p>\n</li>\n<li><p>使用JobScheduler<br>很多时候为了满足我们的需求而没有考虑cpu的感受，为了执行1s中的数据区唤醒cpu，但实际却消耗了约两分钟的电量。为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：<br>必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。<br>耗电大德任务，如备份在充电时执行。</p>\n</li>\n<li><p>Doze模式</p>\n<blockquote>\n<p>Doze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。但是为了不影响应用正常工作，系统还会周期性退出Doze，在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。</p>\n</blockquote>\n</li>\n</ul>\n<p>####5、其他优化</p>\n<ul>\n<li>传感器<br>每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。</li>\n</ul>\n<p>后面的章节会写一些关于电量检测分析工具的使用。</p>\n<p>为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。</p>\n"},{"title":"Android各版本新功能及区别","date":"2017-07-26T05:17:15.000Z","_content":"\n#  0x00 前言\n\nAndroid版本更新快，版本越来越越多，兼容性也就要越来越注意，注意各个版本新加了哪些功能，哪些功能和API对开发有帮助，都要心里有个数\n\n\n\n# 0x01 Android8.0 \n\nwaiting...\n\n\n\n# 0x02 Android 7.0 Nougat\n\n- 引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。\n\n- **通知增强** 通知界面直接回复等\n\n- 进一步的低耗电模式Doze 增强版\n\n- 删除了三个常用隐式广播 — `CONNECTIVITY_ACTION`、`ACTION_NEW_PICTURE` 和`ACTION_NEW_VIDEO` \n\n  ​\n\n# 0x03 Android 6.0 Marshmallow\n\n- **引入了一种新的权限模式 运行时权限检查**\n\n  对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 `checkSelfPermission()` 方法。要请求权限，请调用新增的 `requestPermissions()` 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。\n\n- 取消支持 Apache HTTP 客户端\n\n  Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 `HttpURLConnection` 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 `build.gradle`文件中声明以下编译时依赖项：\n\n  ```\n  android {\n      useLibrary 'org.apache.http.legacy'\n  }\n  ```\n\n- **低电耗模式和应用待机模式：Doze模式**\n\n- **新的通知构建方法**\n\n  移除了 `Notification.setLatestEventInfo()` 方法。请改用 `Notification.Builder` 类来构建通知。要重复更新通知，请重复使用 `Notification.Builder` 实例。调用 `build()` 方法可获取更新后的 `Notification` 实例。\n\n  `adb shell dumpsys notification` 命令不再打印输出您的通知文本。请改用 `adb shell dumpsys notification --noredact` 命令打印输出 notification 对象中的文本。\n\n- **Android 密钥库变更**\n\n  从此版本开始，[Android 密钥库提供程序](https://developer.android.com/training/articles/keystore.html)不再支持 DSA。但仍支持 ECDSA。\n\n  停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。\n\n  ​\n\n# 0x04 Android 5.0 Lollipop\n\n- **引入了Material Design并提供了UI工具包**\n\n- **把ART模式作为默认的运行模式**\n\n- Android 5.0 中的通知更醒目、更便于访问并且可配置程度更高。\n\n- Android 5.0 还引入了 Android 扩展包 (AEP)，支持 OpenGL ES 3.1\n\n- Android 5.0 引入了全新的 Camera API\n\n- 在 Android 5.0 中，新增的倾斜检测器传感器有助于改善受支持设备上的 Activity 识别\n\n- 新增的 **Job Scheduling** API 允许通过将作业推迟到稍后或指定条件下（如设备充电或连入 WLAN 时）运行来优化电池寿命。\n\n  新增的 `dumpsys batterystats` 命令可生成**电池使用情况统计信息**，可通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。\n\n\n\n# 0x05 Android 4.4 Jelly Bean\n\n- Android 4.4 针对硬件传感器批处理引入平台支持\n\n- **全屏沉浸模式**\n\n  Android 4.4 添加了新的全屏沉浸模式，让您可以在手机和平板电脑上创建从一个边缘延伸到另一个边缘的全出血 UI，**隐藏所有系统 UI**，例如状态栏和导航栏。它适用于鲜艳的视觉内容，例如照片、视频、地图、书本和游戏。\n\n  在新模式中，系统 UI 保持隐藏状态，即使在用户与您的应用或游戏交互时 - 您可以从屏幕上的任何位置（甚至在系统栏占据的其他位置）捕获触摸事件。这是您在应用或游戏中创建更大、更加丰富和更加沉浸式的 UI 并减少视觉分散的绝佳方式。\n\n  为确保用户在全屏沉浸模式中始终能轻松、一致地访问系统 UI， Android 4.4 支持新的手势。现在，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。\n\n  要返回沉浸模式，用户可以触摸栏界限之外的屏幕或等待一小段时间，让栏自动隐藏。为提供一致的用户体验，新的手势还与之前隐藏状态栏的方法配合使用。\n\n- 安全增强功能\n\n  SELinux（强制模式）\n  Android 4.4 将其 SELinux 配置从“permissive”更新为“enforcing”。这意味着，在具有强制政策的 SELinux 域中，将阻止潜在的政策违规行为。\n\n  改进加密算法\n  Android 添加了对另外两种加密算法的支持，进一步提升了其安全性。已向密钥库提供程序添加椭圆曲线数字签名算法 (ECDSA) 支持，从而提升了数字签名的安全性，适用于应用签名或数据连接等场景。实现 Scrypt 密钥派生函数，以保护用于全磁盘加密的加密密钥。\n\n- 内存使用率分析工具procstats\n\n- Android 4.4 包含新的开发者选项：设备内存状态和分析\n\n  Settings > Developer options > Process stats\n\n- **可重复使用的位图，参考[inBitmap](https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap)**","source":"_posts/Android各版本新功能及区别.md","raw":"---\ntitle: Android各版本新功能及区别\ndate: 2017-07-26 13:17:15\ntags: Android\ncategories: Android\n---\n\n#  0x00 前言\n\nAndroid版本更新快，版本越来越越多，兼容性也就要越来越注意，注意各个版本新加了哪些功能，哪些功能和API对开发有帮助，都要心里有个数\n\n\n\n# 0x01 Android8.0 \n\nwaiting...\n\n\n\n# 0x02 Android 7.0 Nougat\n\n- 引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。\n\n- **通知增强** 通知界面直接回复等\n\n- 进一步的低耗电模式Doze 增强版\n\n- 删除了三个常用隐式广播 — `CONNECTIVITY_ACTION`、`ACTION_NEW_PICTURE` 和`ACTION_NEW_VIDEO` \n\n  ​\n\n# 0x03 Android 6.0 Marshmallow\n\n- **引入了一种新的权限模式 运行时权限检查**\n\n  对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 `checkSelfPermission()` 方法。要请求权限，请调用新增的 `requestPermissions()` 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。\n\n- 取消支持 Apache HTTP 客户端\n\n  Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 `HttpURLConnection` 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 `build.gradle`文件中声明以下编译时依赖项：\n\n  ```\n  android {\n      useLibrary 'org.apache.http.legacy'\n  }\n  ```\n\n- **低电耗模式和应用待机模式：Doze模式**\n\n- **新的通知构建方法**\n\n  移除了 `Notification.setLatestEventInfo()` 方法。请改用 `Notification.Builder` 类来构建通知。要重复更新通知，请重复使用 `Notification.Builder` 实例。调用 `build()` 方法可获取更新后的 `Notification` 实例。\n\n  `adb shell dumpsys notification` 命令不再打印输出您的通知文本。请改用 `adb shell dumpsys notification --noredact` 命令打印输出 notification 对象中的文本。\n\n- **Android 密钥库变更**\n\n  从此版本开始，[Android 密钥库提供程序](https://developer.android.com/training/articles/keystore.html)不再支持 DSA。但仍支持 ECDSA。\n\n  停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。\n\n  ​\n\n# 0x04 Android 5.0 Lollipop\n\n- **引入了Material Design并提供了UI工具包**\n\n- **把ART模式作为默认的运行模式**\n\n- Android 5.0 中的通知更醒目、更便于访问并且可配置程度更高。\n\n- Android 5.0 还引入了 Android 扩展包 (AEP)，支持 OpenGL ES 3.1\n\n- Android 5.0 引入了全新的 Camera API\n\n- 在 Android 5.0 中，新增的倾斜检测器传感器有助于改善受支持设备上的 Activity 识别\n\n- 新增的 **Job Scheduling** API 允许通过将作业推迟到稍后或指定条件下（如设备充电或连入 WLAN 时）运行来优化电池寿命。\n\n  新增的 `dumpsys batterystats` 命令可生成**电池使用情况统计信息**，可通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。\n\n\n\n# 0x05 Android 4.4 Jelly Bean\n\n- Android 4.4 针对硬件传感器批处理引入平台支持\n\n- **全屏沉浸模式**\n\n  Android 4.4 添加了新的全屏沉浸模式，让您可以在手机和平板电脑上创建从一个边缘延伸到另一个边缘的全出血 UI，**隐藏所有系统 UI**，例如状态栏和导航栏。它适用于鲜艳的视觉内容，例如照片、视频、地图、书本和游戏。\n\n  在新模式中，系统 UI 保持隐藏状态，即使在用户与您的应用或游戏交互时 - 您可以从屏幕上的任何位置（甚至在系统栏占据的其他位置）捕获触摸事件。这是您在应用或游戏中创建更大、更加丰富和更加沉浸式的 UI 并减少视觉分散的绝佳方式。\n\n  为确保用户在全屏沉浸模式中始终能轻松、一致地访问系统 UI， Android 4.4 支持新的手势。现在，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。\n\n  要返回沉浸模式，用户可以触摸栏界限之外的屏幕或等待一小段时间，让栏自动隐藏。为提供一致的用户体验，新的手势还与之前隐藏状态栏的方法配合使用。\n\n- 安全增强功能\n\n  SELinux（强制模式）\n  Android 4.4 将其 SELinux 配置从“permissive”更新为“enforcing”。这意味着，在具有强制政策的 SELinux 域中，将阻止潜在的政策违规行为。\n\n  改进加密算法\n  Android 添加了对另外两种加密算法的支持，进一步提升了其安全性。已向密钥库提供程序添加椭圆曲线数字签名算法 (ECDSA) 支持，从而提升了数字签名的安全性，适用于应用签名或数据连接等场景。实现 Scrypt 密钥派生函数，以保护用于全磁盘加密的加密密钥。\n\n- 内存使用率分析工具procstats\n\n- Android 4.4 包含新的开发者选项：设备内存状态和分析\n\n  Settings > Developer options > Process stats\n\n- **可重复使用的位图，参考[inBitmap](https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap)**","slug":"Android各版本新功能及区别","published":1,"updated":"2017-07-26T11:10:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjbu000rwh9cdg908awk","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Android版本更新快，版本越来越越多，兼容性也就要越来越注意，注意各个版本新加了哪些功能，哪些功能和API对开发有帮助，都要心里有个数</p>\n<h1 id=\"0x01-Android8-0\"><a href=\"#0x01-Android8-0\" class=\"headerlink\" title=\"0x01 Android8.0\"></a>0x01 Android8.0</h1><p>waiting…</p>\n<h1 id=\"0x02-Android-7-0-Nougat\"><a href=\"#0x02-Android-7-0-Nougat\" class=\"headerlink\" title=\"0x02 Android 7.0 Nougat\"></a>0x02 Android 7.0 Nougat</h1><ul>\n<li><p>引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。</p>\n</li>\n<li><p><strong>通知增强</strong> 通知界面直接回复等</p>\n</li>\n<li><p>进一步的低耗电模式Doze 增强版</p>\n</li>\n<li><p>删除了三个常用隐式广播 — <code>CONNECTIVITY_ACTION</code>、<code>ACTION_NEW_PICTURE</code> 和<code>ACTION_NEW_VIDEO</code> </p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x03-Android-6-0-Marshmallow\"><a href=\"#0x03-Android-6-0-Marshmallow\" class=\"headerlink\" title=\"0x03 Android 6.0 Marshmallow\"></a>0x03 Android 6.0 Marshmallow</h1><ul>\n<li><p><strong>引入了一种新的权限模式 运行时权限检查</strong></p>\n<p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 <code>checkSelfPermission()</code> 方法。要请求权限，请调用新增的 <code>requestPermissions()</code> 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。</p>\n</li>\n<li><p>取消支持 Apache HTTP 客户端</p>\n<p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 <code>HttpURLConnection</code> 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 <code>build.gradle</code>文件中声明以下编译时依赖项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    useLibrary &apos;org.apache.http.legacy&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>低电耗模式和应用待机模式：Doze模式</strong></p>\n</li>\n<li><p><strong>新的通知构建方法</strong></p>\n<p>移除了 <code>Notification.setLatestEventInfo()</code> 方法。请改用 <code>Notification.Builder</code> 类来构建通知。要重复更新通知，请重复使用 <code>Notification.Builder</code> 实例。调用 <code>build()</code> 方法可获取更新后的 <code>Notification</code> 实例。</p>\n<p><code>adb shell dumpsys notification</code> 命令不再打印输出您的通知文本。请改用 <code>adb shell dumpsys notification --noredact</code> 命令打印输出 notification 对象中的文本。</p>\n</li>\n<li><p><strong>Android 密钥库变更</strong></p>\n<p>从此版本开始，<a href=\"https://developer.android.com/training/articles/keystore.html\" target=\"_blank\" rel=\"external\">Android 密钥库提供程序</a>不再支持 DSA。但仍支持 ECDSA。</p>\n<p>停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x04-Android-5-0-Lollipop\"><a href=\"#0x04-Android-5-0-Lollipop\" class=\"headerlink\" title=\"0x04 Android 5.0 Lollipop\"></a>0x04 Android 5.0 Lollipop</h1><ul>\n<li><p><strong>引入了Material Design并提供了UI工具包</strong></p>\n</li>\n<li><p><strong>把ART模式作为默认的运行模式</strong></p>\n</li>\n<li><p>Android 5.0 中的通知更醒目、更便于访问并且可配置程度更高。</p>\n</li>\n<li><p>Android 5.0 还引入了 Android 扩展包 (AEP)，支持 OpenGL ES 3.1</p>\n</li>\n<li><p>Android 5.0 引入了全新的 Camera API</p>\n</li>\n<li><p>在 Android 5.0 中，新增的倾斜检测器传感器有助于改善受支持设备上的 Activity 识别</p>\n</li>\n<li><p>新增的 <strong>Job Scheduling</strong> API 允许通过将作业推迟到稍后或指定条件下（如设备充电或连入 WLAN 时）运行来优化电池寿命。</p>\n<p>新增的 <code>dumpsys batterystats</code> 命令可生成<strong>电池使用情况统计信息</strong>，可通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。</p>\n</li>\n</ul>\n<h1 id=\"0x05-Android-4-4-Jelly-Bean\"><a href=\"#0x05-Android-4-4-Jelly-Bean\" class=\"headerlink\" title=\"0x05 Android 4.4 Jelly Bean\"></a>0x05 Android 4.4 Jelly Bean</h1><ul>\n<li><p>Android 4.4 针对硬件传感器批处理引入平台支持</p>\n</li>\n<li><p><strong>全屏沉浸模式</strong></p>\n<p>Android 4.4 添加了新的全屏沉浸模式，让您可以在手机和平板电脑上创建从一个边缘延伸到另一个边缘的全出血 UI，<strong>隐藏所有系统 UI</strong>，例如状态栏和导航栏。它适用于鲜艳的视觉内容，例如照片、视频、地图、书本和游戏。</p>\n<p>在新模式中，系统 UI 保持隐藏状态，即使在用户与您的应用或游戏交互时 - 您可以从屏幕上的任何位置（甚至在系统栏占据的其他位置）捕获触摸事件。这是您在应用或游戏中创建更大、更加丰富和更加沉浸式的 UI 并减少视觉分散的绝佳方式。</p>\n<p>为确保用户在全屏沉浸模式中始终能轻松、一致地访问系统 UI， Android 4.4 支持新的手势。现在，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。</p>\n<p>要返回沉浸模式，用户可以触摸栏界限之外的屏幕或等待一小段时间，让栏自动隐藏。为提供一致的用户体验，新的手势还与之前隐藏状态栏的方法配合使用。</p>\n</li>\n<li><p>安全增强功能</p>\n<p>SELinux（强制模式）<br>Android 4.4 将其 SELinux 配置从“permissive”更新为“enforcing”。这意味着，在具有强制政策的 SELinux 域中，将阻止潜在的政策违规行为。</p>\n<p>改进加密算法<br>Android 添加了对另外两种加密算法的支持，进一步提升了其安全性。已向密钥库提供程序添加椭圆曲线数字签名算法 (ECDSA) 支持，从而提升了数字签名的安全性，适用于应用签名或数据连接等场景。实现 Scrypt 密钥派生函数，以保护用于全磁盘加密的加密密钥。</p>\n</li>\n<li><p>内存使用率分析工具procstats</p>\n</li>\n<li><p>Android 4.4 包含新的开发者选项：设备内存状态和分析</p>\n<p>Settings &gt; Developer options &gt; Process stats</p>\n</li>\n<li><p><strong>可重复使用的位图，参考<a href=\"https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap\" target=\"_blank\" rel=\"external\">inBitmap</a></strong></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Android版本更新快，版本越来越越多，兼容性也就要越来越注意，注意各个版本新加了哪些功能，哪些功能和API对开发有帮助，都要心里有个数</p>\n<h1 id=\"0x01-Android8-0\"><a href=\"#0x01-Android8-0\" class=\"headerlink\" title=\"0x01 Android8.0\"></a>0x01 Android8.0</h1><p>waiting…</p>\n<h1 id=\"0x02-Android-7-0-Nougat\"><a href=\"#0x02-Android-7-0-Nougat\" class=\"headerlink\" title=\"0x02 Android 7.0 Nougat\"></a>0x02 Android 7.0 Nougat</h1><ul>\n<li><p>引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。</p>\n</li>\n<li><p><strong>通知增强</strong> 通知界面直接回复等</p>\n</li>\n<li><p>进一步的低耗电模式Doze 增强版</p>\n</li>\n<li><p>删除了三个常用隐式广播 — <code>CONNECTIVITY_ACTION</code>、<code>ACTION_NEW_PICTURE</code> 和<code>ACTION_NEW_VIDEO</code> </p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x03-Android-6-0-Marshmallow\"><a href=\"#0x03-Android-6-0-Marshmallow\" class=\"headerlink\" title=\"0x03 Android 6.0 Marshmallow\"></a>0x03 Android 6.0 Marshmallow</h1><ul>\n<li><p><strong>引入了一种新的权限模式 运行时权限检查</strong></p>\n<p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 <code>checkSelfPermission()</code> 方法。要请求权限，请调用新增的 <code>requestPermissions()</code> 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。</p>\n</li>\n<li><p>取消支持 Apache HTTP 客户端</p>\n<p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 <code>HttpURLConnection</code> 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 <code>build.gradle</code>文件中声明以下编译时依赖项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    useLibrary &apos;org.apache.http.legacy&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>低电耗模式和应用待机模式：Doze模式</strong></p>\n</li>\n<li><p><strong>新的通知构建方法</strong></p>\n<p>移除了 <code>Notification.setLatestEventInfo()</code> 方法。请改用 <code>Notification.Builder</code> 类来构建通知。要重复更新通知，请重复使用 <code>Notification.Builder</code> 实例。调用 <code>build()</code> 方法可获取更新后的 <code>Notification</code> 实例。</p>\n<p><code>adb shell dumpsys notification</code> 命令不再打印输出您的通知文本。请改用 <code>adb shell dumpsys notification --noredact</code> 命令打印输出 notification 对象中的文本。</p>\n</li>\n<li><p><strong>Android 密钥库变更</strong></p>\n<p>从此版本开始，<a href=\"https://developer.android.com/training/articles/keystore.html\">Android 密钥库提供程序</a>不再支持 DSA。但仍支持 ECDSA。</p>\n<p>停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x04-Android-5-0-Lollipop\"><a href=\"#0x04-Android-5-0-Lollipop\" class=\"headerlink\" title=\"0x04 Android 5.0 Lollipop\"></a>0x04 Android 5.0 Lollipop</h1><ul>\n<li><p><strong>引入了Material Design并提供了UI工具包</strong></p>\n</li>\n<li><p><strong>把ART模式作为默认的运行模式</strong></p>\n</li>\n<li><p>Android 5.0 中的通知更醒目、更便于访问并且可配置程度更高。</p>\n</li>\n<li><p>Android 5.0 还引入了 Android 扩展包 (AEP)，支持 OpenGL ES 3.1</p>\n</li>\n<li><p>Android 5.0 引入了全新的 Camera API</p>\n</li>\n<li><p>在 Android 5.0 中，新增的倾斜检测器传感器有助于改善受支持设备上的 Activity 识别</p>\n</li>\n<li><p>新增的 <strong>Job Scheduling</strong> API 允许通过将作业推迟到稍后或指定条件下（如设备充电或连入 WLAN 时）运行来优化电池寿命。</p>\n<p>新增的 <code>dumpsys batterystats</code> 命令可生成<strong>电池使用情况统计信息</strong>，可通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。</p>\n</li>\n</ul>\n<h1 id=\"0x05-Android-4-4-Jelly-Bean\"><a href=\"#0x05-Android-4-4-Jelly-Bean\" class=\"headerlink\" title=\"0x05 Android 4.4 Jelly Bean\"></a>0x05 Android 4.4 Jelly Bean</h1><ul>\n<li><p>Android 4.4 针对硬件传感器批处理引入平台支持</p>\n</li>\n<li><p><strong>全屏沉浸模式</strong></p>\n<p>Android 4.4 添加了新的全屏沉浸模式，让您可以在手机和平板电脑上创建从一个边缘延伸到另一个边缘的全出血 UI，<strong>隐藏所有系统 UI</strong>，例如状态栏和导航栏。它适用于鲜艳的视觉内容，例如照片、视频、地图、书本和游戏。</p>\n<p>在新模式中，系统 UI 保持隐藏状态，即使在用户与您的应用或游戏交互时 - 您可以从屏幕上的任何位置（甚至在系统栏占据的其他位置）捕获触摸事件。这是您在应用或游戏中创建更大、更加丰富和更加沉浸式的 UI 并减少视觉分散的绝佳方式。</p>\n<p>为确保用户在全屏沉浸模式中始终能轻松、一致地访问系统 UI， Android 4.4 支持新的手势。现在，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。</p>\n<p>要返回沉浸模式，用户可以触摸栏界限之外的屏幕或等待一小段时间，让栏自动隐藏。为提供一致的用户体验，新的手势还与之前隐藏状态栏的方法配合使用。</p>\n</li>\n<li><p>安全增强功能</p>\n<p>SELinux（强制模式）<br>Android 4.4 将其 SELinux 配置从“permissive”更新为“enforcing”。这意味着，在具有强制政策的 SELinux 域中，将阻止潜在的政策违规行为。</p>\n<p>改进加密算法<br>Android 添加了对另外两种加密算法的支持，进一步提升了其安全性。已向密钥库提供程序添加椭圆曲线数字签名算法 (ECDSA) 支持，从而提升了数字签名的安全性，适用于应用签名或数据连接等场景。实现 Scrypt 密钥派生函数，以保护用于全磁盘加密的加密密钥。</p>\n</li>\n<li><p>内存使用率分析工具procstats</p>\n</li>\n<li><p>Android 4.4 包含新的开发者选项：设备内存状态和分析</p>\n<p>Settings &gt; Developer options &gt; Process stats</p>\n</li>\n<li><p><strong>可重复使用的位图，参考<a href=\"https://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap\">inBitmap</a></strong></p>\n</li>\n</ul>\n"},{"title":"2016公司清明节坝上草原","date":"2017-04-25T09:35:56.000Z","_content":"\n\n\n# 说在前面的话\n\n公司应承了很久的出游终于兑现了。不过讲真公司还是比较抠门，两年一次的出游只有两天时间，其中赶路时间就占了一半。\n\n目的：丰宁坝上草原\n\n人物：公司同事\n\n在草原玩的照片基本没有拍，当天到那就下午三四点。而后又阴天下雨了，基本没有怎么玩，拍的比较多的是行宫和湖边。\n\n# 上图\n\n\n\n到了行宫，看到骑兵都忍不住上前合影：\n\n小鱼同志，身高不够，蹦起来够~\n\n![20160610075354_IMG_6200](2016公司清明节坝上草原/20160610075354_IMG_6200.JPG)\n\n\n\n\n\n我就刚刚好了。\n\n![20160610075557_IMG_6209](2016公司清明节坝上草原/20160610075557_IMG_6209.JPG)\n\n\n\n主任幸福的一家~\n\n![20160610075842_IMG_6219](2016公司清明节坝上草原/20160610075842_IMG_6219.JPG)\n\n\n\n进入行宫大门不久后需要经过的南天门：\n\n![20160610080912_IMG_6235](2016公司清明节坝上草原/20160610080912_IMG_6235.JPG)\n\n\n\n回顾行宫大门，白云压顶，壮观~\n\n![20160610081259_IMG_6245](2016公司清明节坝上草原/20160610081259_IMG_6245.JPG)\n\n\n\n这好似是一个古代官员的蒙古包~\n\n![20160610082906_IMG_6261](2016公司清明节坝上草原/20160610082906_IMG_6261.JPG)\n\n\n\n嗯~没错，三贱客哈哈\n\n![20160610083541_IMG_6276](2016公司清明节坝上草原/20160610083541_IMG_6276.JPG)\n\n\n\n从小迷宫走出来时，工作人员给的哈达~妥妥的披上。\n\n![20160610084538_IMG_6283](2016公司清明节坝上草原/20160610084538_IMG_6283.JPG)\n\n\n\n\n\n蓝天白云南天门，怎一个美字了得！\n\n![20160610091441_IMG_6323](2016公司清明节坝上草原/20160610091441_IMG_6323.JPG)\n\n\n\n\n\n湿地大门口留念。小鱼、佳姐和李博。\n\n![20160610100357_IMG_6326](2016公司清明节坝上草原/20160610100357_IMG_6326.JPG)\n\n\n\n老李的风采，感觉要立地成佛。\n\n![20160610101211_IMG_6337](2016公司清明节坝上草原/20160610101211_IMG_6337.JPG)\n\n\n\n小末哥看起来好厉害的样子，这样子回公司会不会挨收拾？\n\n![20160610101300_IMG_6342](2016公司清明节坝上草原/20160610101300_IMG_6342.JPG)\n\n\n\n主任家的公子套上小鱼的衣服。可爱，那么小就那么帅，长大了还了得\n\n![20160610101355_IMG_6343](2016公司清明节坝上草原/20160610101355_IMG_6343.JPG)\n\n\n\n远处的白云、草浪\n\n![20160610102213_IMG_6353](2016公司清明节坝上草原/20160610102213_IMG_6353.JPG)","source":"_posts/2016公司清明节坝上草原.md","raw":"---\ntitle: 2016公司清明节坝上草原\ndate: 2017-04-25 17:35:56\ntags: 生活\ncategories: 生活\n---\n\n\n\n# 说在前面的话\n\n公司应承了很久的出游终于兑现了。不过讲真公司还是比较抠门，两年一次的出游只有两天时间，其中赶路时间就占了一半。\n\n目的：丰宁坝上草原\n\n人物：公司同事\n\n在草原玩的照片基本没有拍，当天到那就下午三四点。而后又阴天下雨了，基本没有怎么玩，拍的比较多的是行宫和湖边。\n\n# 上图\n\n\n\n到了行宫，看到骑兵都忍不住上前合影：\n\n小鱼同志，身高不够，蹦起来够~\n\n![20160610075354_IMG_6200](2016公司清明节坝上草原/20160610075354_IMG_6200.JPG)\n\n\n\n\n\n我就刚刚好了。\n\n![20160610075557_IMG_6209](2016公司清明节坝上草原/20160610075557_IMG_6209.JPG)\n\n\n\n主任幸福的一家~\n\n![20160610075842_IMG_6219](2016公司清明节坝上草原/20160610075842_IMG_6219.JPG)\n\n\n\n进入行宫大门不久后需要经过的南天门：\n\n![20160610080912_IMG_6235](2016公司清明节坝上草原/20160610080912_IMG_6235.JPG)\n\n\n\n回顾行宫大门，白云压顶，壮观~\n\n![20160610081259_IMG_6245](2016公司清明节坝上草原/20160610081259_IMG_6245.JPG)\n\n\n\n这好似是一个古代官员的蒙古包~\n\n![20160610082906_IMG_6261](2016公司清明节坝上草原/20160610082906_IMG_6261.JPG)\n\n\n\n嗯~没错，三贱客哈哈\n\n![20160610083541_IMG_6276](2016公司清明节坝上草原/20160610083541_IMG_6276.JPG)\n\n\n\n从小迷宫走出来时，工作人员给的哈达~妥妥的披上。\n\n![20160610084538_IMG_6283](2016公司清明节坝上草原/20160610084538_IMG_6283.JPG)\n\n\n\n\n\n蓝天白云南天门，怎一个美字了得！\n\n![20160610091441_IMG_6323](2016公司清明节坝上草原/20160610091441_IMG_6323.JPG)\n\n\n\n\n\n湿地大门口留念。小鱼、佳姐和李博。\n\n![20160610100357_IMG_6326](2016公司清明节坝上草原/20160610100357_IMG_6326.JPG)\n\n\n\n老李的风采，感觉要立地成佛。\n\n![20160610101211_IMG_6337](2016公司清明节坝上草原/20160610101211_IMG_6337.JPG)\n\n\n\n小末哥看起来好厉害的样子，这样子回公司会不会挨收拾？\n\n![20160610101300_IMG_6342](2016公司清明节坝上草原/20160610101300_IMG_6342.JPG)\n\n\n\n主任家的公子套上小鱼的衣服。可爱，那么小就那么帅，长大了还了得\n\n![20160610101355_IMG_6343](2016公司清明节坝上草原/20160610101355_IMG_6343.JPG)\n\n\n\n远处的白云、草浪\n\n![20160610102213_IMG_6353](2016公司清明节坝上草原/20160610102213_IMG_6353.JPG)","slug":"2016公司清明节坝上草原","published":1,"updated":"2017-04-25T10:00:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjbx000uwh9cxwl7c0yi","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>公司应承了很久的出游终于兑现了。不过讲真公司还是比较抠门，两年一次的出游只有两天时间，其中赶路时间就占了一半。</p>\n<p>目的：丰宁坝上草原</p>\n<p>人物：公司同事</p>\n<p>在草原玩的照片基本没有拍，当天到那就下午三四点。而后又阴天下雨了，基本没有怎么玩，拍的比较多的是行宫和湖边。</p>\n<h1 id=\"上图\"><a href=\"#上图\" class=\"headerlink\" title=\"上图\"></a>上图</h1><p>到了行宫，看到骑兵都忍不住上前合影：</p>\n<p>小鱼同志，身高不够，蹦起来够~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610075354_IMG_6200.JPG\" alt=\"20160610075354_IMG_6200\"></p>\n<p>我就刚刚好了。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610075557_IMG_6209.JPG\" alt=\"20160610075557_IMG_6209\"></p>\n<p>主任幸福的一家~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610075842_IMG_6219.JPG\" alt=\"20160610075842_IMG_6219\"></p>\n<p>进入行宫大门不久后需要经过的南天门：</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610080912_IMG_6235.JPG\" alt=\"20160610080912_IMG_6235\"></p>\n<p>回顾行宫大门，白云压顶，壮观~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610081259_IMG_6245.JPG\" alt=\"20160610081259_IMG_6245\"></p>\n<p>这好似是一个古代官员的蒙古包~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610082906_IMG_6261.JPG\" alt=\"20160610082906_IMG_6261\"></p>\n<p>嗯~没错，三贱客哈哈</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610083541_IMG_6276.JPG\" alt=\"20160610083541_IMG_6276\"></p>\n<p>从小迷宫走出来时，工作人员给的哈达~妥妥的披上。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610084538_IMG_6283.JPG\" alt=\"20160610084538_IMG_6283\"></p>\n<p>蓝天白云南天门，怎一个美字了得！</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610091441_IMG_6323.JPG\" alt=\"20160610091441_IMG_6323\"></p>\n<p>湿地大门口留念。小鱼、佳姐和李博。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610100357_IMG_6326.JPG\" alt=\"20160610100357_IMG_6326\"></p>\n<p>老李的风采，感觉要立地成佛。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610101211_IMG_6337.JPG\" alt=\"20160610101211_IMG_6337\"></p>\n<p>小末哥看起来好厉害的样子，这样子回公司会不会挨收拾？</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610101300_IMG_6342.JPG\" alt=\"20160610101300_IMG_6342\"></p>\n<p>主任家的公子套上小鱼的衣服。可爱，那么小就那么帅，长大了还了得</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610101355_IMG_6343.JPG\" alt=\"20160610101355_IMG_6343\"></p>\n<p>远处的白云、草浪</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610102213_IMG_6353.JPG\" alt=\"20160610102213_IMG_6353\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>公司应承了很久的出游终于兑现了。不过讲真公司还是比较抠门，两年一次的出游只有两天时间，其中赶路时间就占了一半。</p>\n<p>目的：丰宁坝上草原</p>\n<p>人物：公司同事</p>\n<p>在草原玩的照片基本没有拍，当天到那就下午三四点。而后又阴天下雨了，基本没有怎么玩，拍的比较多的是行宫和湖边。</p>\n<h1 id=\"上图\"><a href=\"#上图\" class=\"headerlink\" title=\"上图\"></a>上图</h1><p>到了行宫，看到骑兵都忍不住上前合影：</p>\n<p>小鱼同志，身高不够，蹦起来够~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610075354_IMG_6200.JPG\" alt=\"20160610075354_IMG_6200\"></p>\n<p>我就刚刚好了。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610075557_IMG_6209.JPG\" alt=\"20160610075557_IMG_6209\"></p>\n<p>主任幸福的一家~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610075842_IMG_6219.JPG\" alt=\"20160610075842_IMG_6219\"></p>\n<p>进入行宫大门不久后需要经过的南天门：</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610080912_IMG_6235.JPG\" alt=\"20160610080912_IMG_6235\"></p>\n<p>回顾行宫大门，白云压顶，壮观~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610081259_IMG_6245.JPG\" alt=\"20160610081259_IMG_6245\"></p>\n<p>这好似是一个古代官员的蒙古包~</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610082906_IMG_6261.JPG\" alt=\"20160610082906_IMG_6261\"></p>\n<p>嗯~没错，三贱客哈哈</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610083541_IMG_6276.JPG\" alt=\"20160610083541_IMG_6276\"></p>\n<p>从小迷宫走出来时，工作人员给的哈达~妥妥的披上。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610084538_IMG_6283.JPG\" alt=\"20160610084538_IMG_6283\"></p>\n<p>蓝天白云南天门，怎一个美字了得！</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610091441_IMG_6323.JPG\" alt=\"20160610091441_IMG_6323\"></p>\n<p>湿地大门口留念。小鱼、佳姐和李博。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610100357_IMG_6326.JPG\" alt=\"20160610100357_IMG_6326\"></p>\n<p>老李的风采，感觉要立地成佛。</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610101211_IMG_6337.JPG\" alt=\"20160610101211_IMG_6337\"></p>\n<p>小末哥看起来好厉害的样子，这样子回公司会不会挨收拾？</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610101300_IMG_6342.JPG\" alt=\"20160610101300_IMG_6342\"></p>\n<p>主任家的公子套上小鱼的衣服。可爱，那么小就那么帅，长大了还了得</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610101355_IMG_6343.JPG\" alt=\"20160610101355_IMG_6343\"></p>\n<p>远处的白云、草浪</p>\n<p><img src=\"/2017/04/25/2016公司清明节坝上草原/20160610102213_IMG_6353.JPG\" alt=\"20160610102213_IMG_6353\"></p>\n"},{"title":"Android性能优化之UI优化","date":"2017-05-04T04:00:30.000Z","_content":"\n# 为什么要进行UI优化\n\nUI的现实在应用层需要经过测量、布局、绘制三步，每一步都会耗费一定时间，如果UI繁重，导致耗费时间过多造成画面卡顿，造成不好的用户体验。研究显示，0-100ms的延迟会让用户感知到瞬时的卡顿，100-300ms的延迟会让用户感觉迟缓，300-1000ms的延迟让用户感觉“手机卡死了”，1000ms以上的延迟会让用户想要去干别的事情，由此可见有良好的UI优化习惯很重要。\n\n# 优化到什么程度\n\n如今屏幕刷新频率大都是60FPS，就是说每帧绘制只要16ms，即保证你的UI页面在16ms内绘制渲染完成，就会让用户感觉到体验是流畅的，所以我们需要做的就是确保我们的APP页面渲染小于16ms。\n\n# 如何优化\n\n## 布局优化\n\n- 减少xml布局层级\n\n  - Merge的使用\n\n    Merge是合并的意思，使用Merge合并子元素和父View，而Merge本身可以被忽略。使用Merge的场合：\n\n    xml布局中，根元素是FrameLayout时；\n\n    自定义View中，父元素尽量是FrameLayout或者LinearLayout；\n\n    >Merge不能乱用：\n    >\n    >Merge只能用在xml布局根元素；\n    >\n    >使用Merge加载一个布局时，必须制定一个ViewGroup作为其父元素，并且设置attachToRoot参数为True（inflate(int,ViewGroup,boolean)）；\n    >\n    >不能在ViewStub中使用Merge标签，原因就是ViewStub的inflate方法中没有attachToRoot的设置\n\n  - 合理使用RelativeLayout和LinearLayout\n\n    RelativeLayout一定程度上可以减少布局层级，但是其对子View测量次数多于LinearLayout。所以综合考虑：如果层级较多情况下，使用RelativeLayout能减少层级的话，优先使用RelativeLayout以便保持界面扁平化；如果层级相同的情况下优先使用LinearLayout，这样能减少子View多次测量。\n\n- ViewStub提高加载速度\n\n  ViewStub默认不可见不占位置，\n\n  如果在特定情况下才显示某些布局，可以使用ViewStub。\n\n  显示ViewStub有两种方法：ViewStub.inflate()和ViewStub.setVisibility(View.Visible)；\n\n  > 使用ViewStub注意：\n  >\n  > Viewstub只能加载一次，之后该对象引用会被置空；\n  >\n  > Viewstub只能用来加载一个布局文件，而不是某个View\n  >\n  > Viewstub中不能嵌套Merge\n\n- include实现view复用\n\n  对于在多个页面都会使用的公共布局诸如Title栏或导航栏，提取出来通过使用inlucde引入，这样只需要维护一份代码即可。\n\n## 避免过度绘制\n\n- 什么是过度绘制\n\n  过度绘制是说屏幕上某一像素在同一帧时间内被绘制多次。在UI布局中如果不可见的部分UI也在进行绘制，这会导致浪费多余的CPU和GPU资源。\n\n- 引起过度绘制原因\n\n  xml布局中控件重叠且都设置了背景或图片\n\n  自定义View，onDraw方法中同一区域绘制了多次\n\n- 如何避免过度绘制\n\n  - 布局优化\n\n    移除xml中非必须背景，或根据条件设置\n\n    移除window默认背景\n\n    按需设置占位背景图\n\n  - 自定义View优化\n\n    在自定义 V i e w中可以通过 c a n v a s . c l i p R e c t （ ）来帮助系统识别那些可见的区域 。这个方法可以指定一块矩形区域 ，只有在这个区域内才会被绘制 ，其他的区域会被忽视 。 c a n v a s . c l i p R e c t （ ）可以很好地帮助那些有多组重叠组件的自定义 V i e w来控制显示的区域 。 c l i p R e c t方法还可以帮助节约 C P U与 G P U资源 ，在 c l i p R e c t区域之外的绘制指令都不会被执行 ，那些部分内容在矩形区域内的组件 ，仍然会得到绘制 ，并且可以使用 c a n v a s . q u i c k r e j e c t （ ）来判断是否没和某个矩形相交 ，从而跳过那些非矩形区域内的绘制操作 。\n\n\n\n","source":"_posts/Android性能优化之UI优化.md","raw":"---\ntitle: Android性能优化之UI优化\ndate: 2017-05-04 12:00:30\ntags: Android\ncategories: Android\n---\n\n# 为什么要进行UI优化\n\nUI的现实在应用层需要经过测量、布局、绘制三步，每一步都会耗费一定时间，如果UI繁重，导致耗费时间过多造成画面卡顿，造成不好的用户体验。研究显示，0-100ms的延迟会让用户感知到瞬时的卡顿，100-300ms的延迟会让用户感觉迟缓，300-1000ms的延迟让用户感觉“手机卡死了”，1000ms以上的延迟会让用户想要去干别的事情，由此可见有良好的UI优化习惯很重要。\n\n# 优化到什么程度\n\n如今屏幕刷新频率大都是60FPS，就是说每帧绘制只要16ms，即保证你的UI页面在16ms内绘制渲染完成，就会让用户感觉到体验是流畅的，所以我们需要做的就是确保我们的APP页面渲染小于16ms。\n\n# 如何优化\n\n## 布局优化\n\n- 减少xml布局层级\n\n  - Merge的使用\n\n    Merge是合并的意思，使用Merge合并子元素和父View，而Merge本身可以被忽略。使用Merge的场合：\n\n    xml布局中，根元素是FrameLayout时；\n\n    自定义View中，父元素尽量是FrameLayout或者LinearLayout；\n\n    >Merge不能乱用：\n    >\n    >Merge只能用在xml布局根元素；\n    >\n    >使用Merge加载一个布局时，必须制定一个ViewGroup作为其父元素，并且设置attachToRoot参数为True（inflate(int,ViewGroup,boolean)）；\n    >\n    >不能在ViewStub中使用Merge标签，原因就是ViewStub的inflate方法中没有attachToRoot的设置\n\n  - 合理使用RelativeLayout和LinearLayout\n\n    RelativeLayout一定程度上可以减少布局层级，但是其对子View测量次数多于LinearLayout。所以综合考虑：如果层级较多情况下，使用RelativeLayout能减少层级的话，优先使用RelativeLayout以便保持界面扁平化；如果层级相同的情况下优先使用LinearLayout，这样能减少子View多次测量。\n\n- ViewStub提高加载速度\n\n  ViewStub默认不可见不占位置，\n\n  如果在特定情况下才显示某些布局，可以使用ViewStub。\n\n  显示ViewStub有两种方法：ViewStub.inflate()和ViewStub.setVisibility(View.Visible)；\n\n  > 使用ViewStub注意：\n  >\n  > Viewstub只能加载一次，之后该对象引用会被置空；\n  >\n  > Viewstub只能用来加载一个布局文件，而不是某个View\n  >\n  > Viewstub中不能嵌套Merge\n\n- include实现view复用\n\n  对于在多个页面都会使用的公共布局诸如Title栏或导航栏，提取出来通过使用inlucde引入，这样只需要维护一份代码即可。\n\n## 避免过度绘制\n\n- 什么是过度绘制\n\n  过度绘制是说屏幕上某一像素在同一帧时间内被绘制多次。在UI布局中如果不可见的部分UI也在进行绘制，这会导致浪费多余的CPU和GPU资源。\n\n- 引起过度绘制原因\n\n  xml布局中控件重叠且都设置了背景或图片\n\n  自定义View，onDraw方法中同一区域绘制了多次\n\n- 如何避免过度绘制\n\n  - 布局优化\n\n    移除xml中非必须背景，或根据条件设置\n\n    移除window默认背景\n\n    按需设置占位背景图\n\n  - 自定义View优化\n\n    在自定义 V i e w中可以通过 c a n v a s . c l i p R e c t （ ）来帮助系统识别那些可见的区域 。这个方法可以指定一块矩形区域 ，只有在这个区域内才会被绘制 ，其他的区域会被忽视 。 c a n v a s . c l i p R e c t （ ）可以很好地帮助那些有多组重叠组件的自定义 V i e w来控制显示的区域 。 c l i p R e c t方法还可以帮助节约 C P U与 G P U资源 ，在 c l i p R e c t区域之外的绘制指令都不会被执行 ，那些部分内容在矩形区域内的组件 ，仍然会得到绘制 ，并且可以使用 c a n v a s . q u i c k r e j e c t （ ）来判断是否没和某个矩形相交 ，从而跳过那些非矩形区域内的绘制操作 。\n\n\n\n","slug":"Android性能优化之UI优化","published":1,"updated":"2017-05-04T10:23:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjc0000zwh9ce4dx7txw","content":"<h1 id=\"为什么要进行UI优化\"><a href=\"#为什么要进行UI优化\" class=\"headerlink\" title=\"为什么要进行UI优化\"></a>为什么要进行UI优化</h1><p>UI的现实在应用层需要经过测量、布局、绘制三步，每一步都会耗费一定时间，如果UI繁重，导致耗费时间过多造成画面卡顿，造成不好的用户体验。研究显示，0-100ms的延迟会让用户感知到瞬时的卡顿，100-300ms的延迟会让用户感觉迟缓，300-1000ms的延迟让用户感觉“手机卡死了”，1000ms以上的延迟会让用户想要去干别的事情，由此可见有良好的UI优化习惯很重要。</p>\n<h1 id=\"优化到什么程度\"><a href=\"#优化到什么程度\" class=\"headerlink\" title=\"优化到什么程度\"></a>优化到什么程度</h1><p>如今屏幕刷新频率大都是60FPS，就是说每帧绘制只要16ms，即保证你的UI页面在16ms内绘制渲染完成，就会让用户感觉到体验是流畅的，所以我们需要做的就是确保我们的APP页面渲染小于16ms。</p>\n<h1 id=\"如何优化\"><a href=\"#如何优化\" class=\"headerlink\" title=\"如何优化\"></a>如何优化</h1><h2 id=\"布局优化\"><a href=\"#布局优化\" class=\"headerlink\" title=\"布局优化\"></a>布局优化</h2><ul>\n<li><p>减少xml布局层级</p>\n<ul>\n<li><p>Merge的使用</p>\n<p>Merge是合并的意思，使用Merge合并子元素和父View，而Merge本身可以被忽略。使用Merge的场合：</p>\n<p>xml布局中，根元素是FrameLayout时；</p>\n<p>自定义View中，父元素尽量是FrameLayout或者LinearLayout；</p>\n<blockquote>\n<p>Merge不能乱用：</p>\n<p>Merge只能用在xml布局根元素；</p>\n<p>使用Merge加载一个布局时，必须制定一个ViewGroup作为其父元素，并且设置attachToRoot参数为True（inflate(int,ViewGroup,boolean)）；</p>\n<p>不能在ViewStub中使用Merge标签，原因就是ViewStub的inflate方法中没有attachToRoot的设置</p>\n</blockquote>\n</li>\n<li><p>合理使用RelativeLayout和LinearLayout</p>\n<p>RelativeLayout一定程度上可以减少布局层级，但是其对子View测量次数多于LinearLayout。所以综合考虑：如果层级较多情况下，使用RelativeLayout能减少层级的话，优先使用RelativeLayout以便保持界面扁平化；如果层级相同的情况下优先使用LinearLayout，这样能减少子View多次测量。</p>\n</li>\n</ul>\n</li>\n<li><p>ViewStub提高加载速度</p>\n<p>ViewStub默认不可见不占位置，</p>\n<p>如果在特定情况下才显示某些布局，可以使用ViewStub。</p>\n<p>显示ViewStub有两种方法：ViewStub.inflate()和ViewStub.setVisibility(View.Visible)；</p>\n<blockquote>\n<p>使用ViewStub注意：</p>\n<p>Viewstub只能加载一次，之后该对象引用会被置空；</p>\n<p>Viewstub只能用来加载一个布局文件，而不是某个View</p>\n<p>Viewstub中不能嵌套Merge</p>\n</blockquote>\n</li>\n<li><p>include实现view复用</p>\n<p>对于在多个页面都会使用的公共布局诸如Title栏或导航栏，提取出来通过使用inlucde引入，这样只需要维护一份代码即可。</p>\n</li>\n</ul>\n<h2 id=\"避免过度绘制\"><a href=\"#避免过度绘制\" class=\"headerlink\" title=\"避免过度绘制\"></a>避免过度绘制</h2><ul>\n<li><p>什么是过度绘制</p>\n<p>过度绘制是说屏幕上某一像素在同一帧时间内被绘制多次。在UI布局中如果不可见的部分UI也在进行绘制，这会导致浪费多余的CPU和GPU资源。</p>\n</li>\n<li><p>引起过度绘制原因</p>\n<p>xml布局中控件重叠且都设置了背景或图片</p>\n<p>自定义View，onDraw方法中同一区域绘制了多次</p>\n</li>\n<li><p>如何避免过度绘制</p>\n<ul>\n<li><p>布局优化</p>\n<p>移除xml中非必须背景，或根据条件设置</p>\n<p>移除window默认背景</p>\n<p>按需设置占位背景图</p>\n</li>\n<li><p>自定义View优化</p>\n<p>在自定义 V i e w中可以通过 c a n v a s . c l i p R e c t （ ）来帮助系统识别那些可见的区域 。这个方法可以指定一块矩形区域 ，只有在这个区域内才会被绘制 ，其他的区域会被忽视 。 c a n v a s . c l i p R e c t （ ）可以很好地帮助那些有多组重叠组件的自定义 V i e w来控制显示的区域 。 c l i p R e c t方法还可以帮助节约 C P U与 G P U资源 ，在 c l i p R e c t区域之外的绘制指令都不会被执行 ，那些部分内容在矩形区域内的组件 ，仍然会得到绘制 ，并且可以使用 c a n v a s . q u i c k r e j e c t （ ）来判断是否没和某个矩形相交 ，从而跳过那些非矩形区域内的绘制操作 。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要进行UI优化\"><a href=\"#为什么要进行UI优化\" class=\"headerlink\" title=\"为什么要进行UI优化\"></a>为什么要进行UI优化</h1><p>UI的现实在应用层需要经过测量、布局、绘制三步，每一步都会耗费一定时间，如果UI繁重，导致耗费时间过多造成画面卡顿，造成不好的用户体验。研究显示，0-100ms的延迟会让用户感知到瞬时的卡顿，100-300ms的延迟会让用户感觉迟缓，300-1000ms的延迟让用户感觉“手机卡死了”，1000ms以上的延迟会让用户想要去干别的事情，由此可见有良好的UI优化习惯很重要。</p>\n<h1 id=\"优化到什么程度\"><a href=\"#优化到什么程度\" class=\"headerlink\" title=\"优化到什么程度\"></a>优化到什么程度</h1><p>如今屏幕刷新频率大都是60FPS，就是说每帧绘制只要16ms，即保证你的UI页面在16ms内绘制渲染完成，就会让用户感觉到体验是流畅的，所以我们需要做的就是确保我们的APP页面渲染小于16ms。</p>\n<h1 id=\"如何优化\"><a href=\"#如何优化\" class=\"headerlink\" title=\"如何优化\"></a>如何优化</h1><h2 id=\"布局优化\"><a href=\"#布局优化\" class=\"headerlink\" title=\"布局优化\"></a>布局优化</h2><ul>\n<li><p>减少xml布局层级</p>\n<ul>\n<li><p>Merge的使用</p>\n<p>Merge是合并的意思，使用Merge合并子元素和父View，而Merge本身可以被忽略。使用Merge的场合：</p>\n<p>xml布局中，根元素是FrameLayout时；</p>\n<p>自定义View中，父元素尽量是FrameLayout或者LinearLayout；</p>\n<blockquote>\n<p>Merge不能乱用：</p>\n<p>Merge只能用在xml布局根元素；</p>\n<p>使用Merge加载一个布局时，必须制定一个ViewGroup作为其父元素，并且设置attachToRoot参数为True（inflate(int,ViewGroup,boolean)）；</p>\n<p>不能在ViewStub中使用Merge标签，原因就是ViewStub的inflate方法中没有attachToRoot的设置</p>\n</blockquote>\n</li>\n<li><p>合理使用RelativeLayout和LinearLayout</p>\n<p>RelativeLayout一定程度上可以减少布局层级，但是其对子View测量次数多于LinearLayout。所以综合考虑：如果层级较多情况下，使用RelativeLayout能减少层级的话，优先使用RelativeLayout以便保持界面扁平化；如果层级相同的情况下优先使用LinearLayout，这样能减少子View多次测量。</p>\n</li>\n</ul>\n</li>\n<li><p>ViewStub提高加载速度</p>\n<p>ViewStub默认不可见不占位置，</p>\n<p>如果在特定情况下才显示某些布局，可以使用ViewStub。</p>\n<p>显示ViewStub有两种方法：ViewStub.inflate()和ViewStub.setVisibility(View.Visible)；</p>\n<blockquote>\n<p>使用ViewStub注意：</p>\n<p>Viewstub只能加载一次，之后该对象引用会被置空；</p>\n<p>Viewstub只能用来加载一个布局文件，而不是某个View</p>\n<p>Viewstub中不能嵌套Merge</p>\n</blockquote>\n</li>\n<li><p>include实现view复用</p>\n<p>对于在多个页面都会使用的公共布局诸如Title栏或导航栏，提取出来通过使用inlucde引入，这样只需要维护一份代码即可。</p>\n</li>\n</ul>\n<h2 id=\"避免过度绘制\"><a href=\"#避免过度绘制\" class=\"headerlink\" title=\"避免过度绘制\"></a>避免过度绘制</h2><ul>\n<li><p>什么是过度绘制</p>\n<p>过度绘制是说屏幕上某一像素在同一帧时间内被绘制多次。在UI布局中如果不可见的部分UI也在进行绘制，这会导致浪费多余的CPU和GPU资源。</p>\n</li>\n<li><p>引起过度绘制原因</p>\n<p>xml布局中控件重叠且都设置了背景或图片</p>\n<p>自定义View，onDraw方法中同一区域绘制了多次</p>\n</li>\n<li><p>如何避免过度绘制</p>\n<ul>\n<li><p>布局优化</p>\n<p>移除xml中非必须背景，或根据条件设置</p>\n<p>移除window默认背景</p>\n<p>按需设置占位背景图</p>\n</li>\n<li><p>自定义View优化</p>\n<p>在自定义 V i e w中可以通过 c a n v a s . c l i p R e c t （ ）来帮助系统识别那些可见的区域 。这个方法可以指定一块矩形区域 ，只有在这个区域内才会被绘制 ，其他的区域会被忽视 。 c a n v a s . c l i p R e c t （ ）可以很好地帮助那些有多组重叠组件的自定义 V i e w来控制显示的区域 。 c l i p R e c t方法还可以帮助节约 C P U与 G P U资源 ，在 c l i p R e c t区域之外的绘制指令都不会被执行 ，那些部分内容在矩形区域内的组件 ，仍然会得到绘制 ，并且可以使用 c a n v a s . q u i c k r e j e c t （ ）来判断是否没和某个矩形相交 ，从而跳过那些非矩形区域内的绘制操作 。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Android源码下载","date":"2017-04-21T12:55:54.000Z","_content":"\n#### 说在前面的话\nwin系统的笔记本过年回来就没有带回北京。最近打算看看Android源码，所以需要在mac中从新下载。\n#### 从官网下载\n下载Android源码首先想到的就是[官网](https://source.android.com/source/downloading.html)\n按照指示要先安装repo。但是在执行\n```\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n```\n\n时候就出现异常\n\n```\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:--  0:01:14 --:--:--    0\ncurl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out\n```\n\n搜索了下异常发现很早就有这个问题，比如[这里](https://github.com/npm/npm/issues/10037)\n但是好像没什么好的解决方法。网传有其他地址可以使用，但是没有继续浪费时间了，不能一条路走到黑。\n#### 使用国内资源\n国外太麻烦，毕竟只是想看源码，不想在下载方面浪费太多精力。所以把想法转战到国内的源上。\n分享2个源，[科大源](https://lug.ustc.edu.cn/wiki/mirrors/help/aosp#已有仓库如何改用科大源)和[清大源](https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/)\n其中我选择使用的是科大源，打开页面看到初始同步有两个方法，方法1毕竟简单，下载一个打好的包，自己repo sync。方法2还是要下载repo，而且如果中途断掉还要从头下载，所以果断选了方法1，直接使用迅雷下载tar包还是很快的。\n不到一个小时下载完成，解压后打开aosp文件夹发现没有文件，因为是.开头的，都是隐藏文件，显示后如图：\n![屏幕快照 2017-03-16 下午1.55.14.png](http://upload-images.jianshu.io/upload_images/1796052-a48a38e120b53440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n执行\n```\n/Users/jenson/Downloads/aosp/.repo/repo/repo sync\n```\n\n同步\n\n![屏幕快照 2017-03-16 下午2.08.54.png](http://upload-images.jianshu.io/upload_images/1796052-185f5625074cf187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 如何修改已经init的repo\n如果想下载其他版本的源码，但是repo已经初始化过，\n如果再次执行repo init xxx会提示 :\n```\nYour identity is: jenson <xxx@foxmail.com>\nIf you want to change this, please re-run 'repo init' with --config-name\nrepo has been initialized in /Users/jenson/Downloads/aosp\n```\n\n上面意思是如果要修改init，需要重新运行repo init +新的url +config\n这时会自动修改配置并初始化:\n\n```\n/Users/jenson/Downloads/aosp/.repo/repo/repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r58  --config\n\n```","source":"_posts/Android源码下载.md","raw":"---\ntitle: Android源码下载\ndate: 2017-04-21 20:55:54\ntags: Android\ncategories: Android\n---\n\n#### 说在前面的话\nwin系统的笔记本过年回来就没有带回北京。最近打算看看Android源码，所以需要在mac中从新下载。\n#### 从官网下载\n下载Android源码首先想到的就是[官网](https://source.android.com/source/downloading.html)\n按照指示要先安装repo。但是在执行\n```\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n```\n\n时候就出现异常\n\n```\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:--  0:01:14 --:--:--    0\ncurl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out\n```\n\n搜索了下异常发现很早就有这个问题，比如[这里](https://github.com/npm/npm/issues/10037)\n但是好像没什么好的解决方法。网传有其他地址可以使用，但是没有继续浪费时间了，不能一条路走到黑。\n#### 使用国内资源\n国外太麻烦，毕竟只是想看源码，不想在下载方面浪费太多精力。所以把想法转战到国内的源上。\n分享2个源，[科大源](https://lug.ustc.edu.cn/wiki/mirrors/help/aosp#已有仓库如何改用科大源)和[清大源](https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/)\n其中我选择使用的是科大源，打开页面看到初始同步有两个方法，方法1毕竟简单，下载一个打好的包，自己repo sync。方法2还是要下载repo，而且如果中途断掉还要从头下载，所以果断选了方法1，直接使用迅雷下载tar包还是很快的。\n不到一个小时下载完成，解压后打开aosp文件夹发现没有文件，因为是.开头的，都是隐藏文件，显示后如图：\n![屏幕快照 2017-03-16 下午1.55.14.png](http://upload-images.jianshu.io/upload_images/1796052-a48a38e120b53440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n执行\n```\n/Users/jenson/Downloads/aosp/.repo/repo/repo sync\n```\n\n同步\n\n![屏幕快照 2017-03-16 下午2.08.54.png](http://upload-images.jianshu.io/upload_images/1796052-185f5625074cf187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 如何修改已经init的repo\n如果想下载其他版本的源码，但是repo已经初始化过，\n如果再次执行repo init xxx会提示 :\n```\nYour identity is: jenson <xxx@foxmail.com>\nIf you want to change this, please re-run 'repo init' with --config-name\nrepo has been initialized in /Users/jenson/Downloads/aosp\n```\n\n上面意思是如果要修改init，需要重新运行repo init +新的url +config\n这时会自动修改配置并初始化:\n\n```\n/Users/jenson/Downloads/aosp/.repo/repo/repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r58  --config\n\n```","slug":"Android源码下载","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjc50012wh9cjix7qj81","content":"<h4 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h4><p>win系统的笔记本过年回来就没有带回北京。最近打算看看Android源码，所以需要在mac中从新下载。</p>\n<h4 id=\"从官网下载\"><a href=\"#从官网下载\" class=\"headerlink\" title=\"从官网下载\"></a>从官网下载</h4><p>下载Android源码首先想到的就是<a href=\"https://source.android.com/source/downloading.html\" target=\"_blank\" rel=\"external\">官网</a><br>按照指示要先安装repo。但是在执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div></pre></td></tr></table></figure></p>\n<p>时候就出现异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class=\"line\">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class=\"line\">                                 Dload  Upload   Total   Spent    Left  Speed</div><div class=\"line\">  0     0    0     0    0     0      0      0 --:--:--  0:01:14 --:--:--    0</div><div class=\"line\">curl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out</div></pre></td></tr></table></figure>\n<p>搜索了下异常发现很早就有这个问题，比如<a href=\"https://github.com/npm/npm/issues/10037\" target=\"_blank\" rel=\"external\">这里</a><br>但是好像没什么好的解决方法。网传有其他地址可以使用，但是没有继续浪费时间了，不能一条路走到黑。</p>\n<h4 id=\"使用国内资源\"><a href=\"#使用国内资源\" class=\"headerlink\" title=\"使用国内资源\"></a>使用国内资源</h4><p>国外太麻烦，毕竟只是想看源码，不想在下载方面浪费太多精力。所以把想法转战到国内的源上。<br>分享2个源，<a href=\"https://lug.ustc.edu.cn/wiki/mirrors/help/aosp#已有仓库如何改用科大源\" target=\"_blank\" rel=\"external\">科大源</a>和<a href=\"https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/\" target=\"_blank\" rel=\"external\">清大源</a><br>其中我选择使用的是科大源，打开页面看到初始同步有两个方法，方法1毕竟简单，下载一个打好的包，自己repo sync。方法2还是要下载repo，而且如果中途断掉还要从头下载，所以果断选了方法1，直接使用迅雷下载tar包还是很快的。<br>不到一个小时下载完成，解压后打开aosp文件夹发现没有文件，因为是.开头的，都是隐藏文件，显示后如图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a48a38e120b53440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-16 下午1.55.14.png\"><br>执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/Users/jenson/Downloads/aosp/.repo/repo/repo sync</div></pre></td></tr></table></figure></p>\n<p>同步</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-185f5625074cf187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-16 下午2.08.54.png\"></p>\n<h4 id=\"如何修改已经init的repo\"><a href=\"#如何修改已经init的repo\" class=\"headerlink\" title=\"如何修改已经init的repo\"></a>如何修改已经init的repo</h4><p>如果想下载其他版本的源码，但是repo已经初始化过，<br>如果再次执行repo init xxx会提示 :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Your identity is: jenson &lt;xxx@foxmail.com&gt;</div><div class=\"line\">If you want to change this, please re-run &apos;repo init&apos; with --config-name</div><div class=\"line\">repo has been initialized in /Users/jenson/Downloads/aosp</div></pre></td></tr></table></figure></p>\n<p>上面意思是如果要修改init，需要重新运行repo init +新的url +config<br>这时会自动修改配置并初始化:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/Users/jenson/Downloads/aosp/.repo/repo/repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r58  --config</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h4><p>win系统的笔记本过年回来就没有带回北京。最近打算看看Android源码，所以需要在mac中从新下载。</p>\n<h4 id=\"从官网下载\"><a href=\"#从官网下载\" class=\"headerlink\" title=\"从官网下载\"></a>从官网下载</h4><p>下载Android源码首先想到的就是<a href=\"https://source.android.com/source/downloading.html\">官网</a><br>按照指示要先安装repo。但是在执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div></pre></td></tr></table></figure></p>\n<p>时候就出现异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class=\"line\">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class=\"line\">                                 Dload  Upload   Total   Spent    Left  Speed</div><div class=\"line\">  0     0    0     0    0     0      0      0 --:--:--  0:01:14 --:--:--    0</div><div class=\"line\">curl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out</div></pre></td></tr></table></figure>\n<p>搜索了下异常发现很早就有这个问题，比如<a href=\"https://github.com/npm/npm/issues/10037\">这里</a><br>但是好像没什么好的解决方法。网传有其他地址可以使用，但是没有继续浪费时间了，不能一条路走到黑。</p>\n<h4 id=\"使用国内资源\"><a href=\"#使用国内资源\" class=\"headerlink\" title=\"使用国内资源\"></a>使用国内资源</h4><p>国外太麻烦，毕竟只是想看源码，不想在下载方面浪费太多精力。所以把想法转战到国内的源上。<br>分享2个源，<a href=\"https://lug.ustc.edu.cn/wiki/mirrors/help/aosp#已有仓库如何改用科大源\">科大源</a>和<a href=\"https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/\">清大源</a><br>其中我选择使用的是科大源，打开页面看到初始同步有两个方法，方法1毕竟简单，下载一个打好的包，自己repo sync。方法2还是要下载repo，而且如果中途断掉还要从头下载，所以果断选了方法1，直接使用迅雷下载tar包还是很快的。<br>不到一个小时下载完成，解压后打开aosp文件夹发现没有文件，因为是.开头的，都是隐藏文件，显示后如图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a48a38e120b53440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-16 下午1.55.14.png\"><br>执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/Users/jenson/Downloads/aosp/.repo/repo/repo sync</div></pre></td></tr></table></figure></p>\n<p>同步</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-185f5625074cf187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-16 下午2.08.54.png\"></p>\n<h4 id=\"如何修改已经init的repo\"><a href=\"#如何修改已经init的repo\" class=\"headerlink\" title=\"如何修改已经init的repo\"></a>如何修改已经init的repo</h4><p>如果想下载其他版本的源码，但是repo已经初始化过，<br>如果再次执行repo init xxx会提示 :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Your identity is: jenson &lt;xxx@foxmail.com&gt;</div><div class=\"line\">If you want to change this, please re-run &apos;repo init&apos; with --config-name</div><div class=\"line\">repo has been initialized in /Users/jenson/Downloads/aosp</div></pre></td></tr></table></figure></p>\n<p>上面意思是如果要修改init，需要重新运行repo init +新的url +config<br>这时会自动修改配置并初始化:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/Users/jenson/Downloads/aosp/.repo/repo/repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r58  --config</div></pre></td></tr></table></figure>"},{"title":"Gradle和Gradle Plugin之间对应关系","date":"2017-08-03T09:36:16.000Z","_content":"\n# 前言\n\n每次Android studio版本升级经常会造成Gradle和Gradle plugin版本不兼容问题。进而又会引发其他一些列问题，简直让人泪奔。搞得真的是想去转python的心都有了。\n\n说归说，遇到问题还是要解决。如果知道了Gradle和plugin版本对应兼容关系，那就少了很多麻烦。\n\n经过查找，就目前版本情况，对应关系已经找出来了。\n\n# 对应关系\n\n| Plugin version | Required Gradle version |\n| -------------- | ----------------------- |\n| 1.0.0 - 1.1.3  | 2.2.1 - 2.3             |\n| 1.2.0 - 1.3.1  | 2.2.1 - 2.9             |\n| 1.5.0          | 2.2.1 - 2.13            |\n| 2.0.0 - 2.1.2  | 2.10 - 2.13             |\n| 2.1.3 - 2.2.3  | 2.14.1+                 |\n| 2.3.0+         | 3.3+                    |","source":"_posts/Gradle和Gradle-Plugin之间对应关系.md","raw":"---\ntitle: Gradle和Gradle Plugin之间对应关系\ndate: 2017-08-03 17:36:16\ntags: Android\ncategories: Android\n---\n\n# 前言\n\n每次Android studio版本升级经常会造成Gradle和Gradle plugin版本不兼容问题。进而又会引发其他一些列问题，简直让人泪奔。搞得真的是想去转python的心都有了。\n\n说归说，遇到问题还是要解决。如果知道了Gradle和plugin版本对应兼容关系，那就少了很多麻烦。\n\n经过查找，就目前版本情况，对应关系已经找出来了。\n\n# 对应关系\n\n| Plugin version | Required Gradle version |\n| -------------- | ----------------------- |\n| 1.0.0 - 1.1.3  | 2.2.1 - 2.3             |\n| 1.2.0 - 1.3.1  | 2.2.1 - 2.9             |\n| 1.5.0          | 2.2.1 - 2.13            |\n| 2.0.0 - 2.1.2  | 2.10 - 2.13             |\n| 2.1.3 - 2.2.3  | 2.14.1+                 |\n| 2.3.0+         | 3.3+                    |","slug":"Gradle和Gradle-Plugin之间对应关系","published":1,"updated":"2017-08-03T09:43:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjc80017wh9cyi5kuhgh","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>每次Android studio版本升级经常会造成Gradle和Gradle plugin版本不兼容问题。进而又会引发其他一些列问题，简直让人泪奔。搞得真的是想去转python的心都有了。</p>\n<p>说归说，遇到问题还是要解决。如果知道了Gradle和plugin版本对应兼容关系，那就少了很多麻烦。</p>\n<p>经过查找，就目前版本情况，对应关系已经找出来了。</p>\n<h1 id=\"对应关系\"><a href=\"#对应关系\" class=\"headerlink\" title=\"对应关系\"></a>对应关系</h1><table>\n<thead>\n<tr>\n<th>Plugin version</th>\n<th>Required Gradle version</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.0.0 - 1.1.3</td>\n<td>2.2.1 - 2.3</td>\n</tr>\n<tr>\n<td>1.2.0 - 1.3.1</td>\n<td>2.2.1 - 2.9</td>\n</tr>\n<tr>\n<td>1.5.0</td>\n<td>2.2.1 - 2.13</td>\n</tr>\n<tr>\n<td>2.0.0 - 2.1.2</td>\n<td>2.10 - 2.13</td>\n</tr>\n<tr>\n<td>2.1.3 - 2.2.3</td>\n<td>2.14.1+</td>\n</tr>\n<tr>\n<td>2.3.0+</td>\n<td>3.3+</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>每次Android studio版本升级经常会造成Gradle和Gradle plugin版本不兼容问题。进而又会引发其他一些列问题，简直让人泪奔。搞得真的是想去转python的心都有了。</p>\n<p>说归说，遇到问题还是要解决。如果知道了Gradle和plugin版本对应兼容关系，那就少了很多麻烦。</p>\n<p>经过查找，就目前版本情况，对应关系已经找出来了。</p>\n<h1 id=\"对应关系\"><a href=\"#对应关系\" class=\"headerlink\" title=\"对应关系\"></a>对应关系</h1><table>\n<thead>\n<tr>\n<th>Plugin version</th>\n<th>Required Gradle version</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.0.0 - 1.1.3</td>\n<td>2.2.1 - 2.3</td>\n</tr>\n<tr>\n<td>1.2.0 - 1.3.1</td>\n<td>2.2.1 - 2.9</td>\n</tr>\n<tr>\n<td>1.5.0</td>\n<td>2.2.1 - 2.13</td>\n</tr>\n<tr>\n<td>2.0.0 - 2.1.2</td>\n<td>2.10 - 2.13</td>\n</tr>\n<tr>\n<td>2.1.3 - 2.2.3</td>\n<td>2.14.1+</td>\n</tr>\n<tr>\n<td>2.3.0+</td>\n<td>3.3+</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Django创建数据表时syncdb提示Unknown command：‘syncdb'","date":"2017-06-27T08:32:23.000Z","_content":"\n异常信息如下\n\n```\nJensondeMini:dj_test01 jenson$ python3 ./manage.py syncdb\nUnknown command: 'syncdb'\nType 'manage.py help' for usage.\n```\n\n主要是因为使用的版本太新，如果你安装的Django Version >= 1.9就会出现这个问题\n\n解决方法就是把`python3 ./manage.py syncdb`\n\n替换成`python3 ./manage.py migrate`\n\n之后就会初始化数据表成功\n\n```\nJensondeMini:dj_test01 jenson$ python3 ./manage.py migrate\nOperations to perform:\n  Apply all migrations: admin, auth, contenttypes, sessions\nRunning migrations:\n  Applying contenttypes.0001_initial... OK\n  Applying auth.0001_initial... OK\n  Applying admin.0001_initial... OK\n  Applying admin.0002_logentry_remove_auto_add... OK\n  Applying contenttypes.0002_remove_content_type_name... OK\n  Applying auth.0002_alter_permission_name_max_length... OK\n  Applying auth.0003_alter_user_email_max_length... OK\n  Applying auth.0004_alter_user_username_opts... OK\n  Applying auth.0005_alter_user_last_login_null... OK\n  Applying auth.0006_require_contenttypes_0002... OK\n  Applying auth.0007_alter_validators_add_error_messages... OK\n  Applying auth.0008_alter_user_username_max_length... OK\n  Applying sessions.0001_initial... OK\n```\n\n\n\n\n\n","source":"_posts/Django创建数据表时syncdb提示Unknown-command：‘syncdb.md","raw":"---\ntitle: Django创建数据表时syncdb提示Unknown command：‘syncdb'\ndate: 2017-06-27 16:32:23\ntags: Python\ncategories: Python\n---\n\n异常信息如下\n\n```\nJensondeMini:dj_test01 jenson$ python3 ./manage.py syncdb\nUnknown command: 'syncdb'\nType 'manage.py help' for usage.\n```\n\n主要是因为使用的版本太新，如果你安装的Django Version >= 1.9就会出现这个问题\n\n解决方法就是把`python3 ./manage.py syncdb`\n\n替换成`python3 ./manage.py migrate`\n\n之后就会初始化数据表成功\n\n```\nJensondeMini:dj_test01 jenson$ python3 ./manage.py migrate\nOperations to perform:\n  Apply all migrations: admin, auth, contenttypes, sessions\nRunning migrations:\n  Applying contenttypes.0001_initial... OK\n  Applying auth.0001_initial... OK\n  Applying admin.0001_initial... OK\n  Applying admin.0002_logentry_remove_auto_add... OK\n  Applying contenttypes.0002_remove_content_type_name... OK\n  Applying auth.0002_alter_permission_name_max_length... OK\n  Applying auth.0003_alter_user_email_max_length... OK\n  Applying auth.0004_alter_user_username_opts... OK\n  Applying auth.0005_alter_user_last_login_null... OK\n  Applying auth.0006_require_contenttypes_0002... OK\n  Applying auth.0007_alter_validators_add_error_messages... OK\n  Applying auth.0008_alter_user_username_max_length... OK\n  Applying sessions.0001_initial... OK\n```\n\n\n\n\n\n","slug":"Django创建数据表时syncdb提示Unknown-command：‘syncdb","published":1,"updated":"2017-06-27T08:36:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjca001awh9c3y5p2niu","content":"<p>异常信息如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">JensondeMini:dj_test01 jenson$ python3 ./manage.py syncdb</div><div class=\"line\">Unknown command: &apos;syncdb&apos;</div><div class=\"line\">Type &apos;manage.py help&apos; for usage.</div></pre></td></tr></table></figure>\n<p>主要是因为使用的版本太新，如果你安装的Django Version &gt;= 1.9就会出现这个问题</p>\n<p>解决方法就是把<code>python3 ./manage.py syncdb</code></p>\n<p>替换成<code>python3 ./manage.py migrate</code></p>\n<p>之后就会初始化数据表成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">JensondeMini:dj_test01 jenson$ python3 ./manage.py migrate</div><div class=\"line\">Operations to perform:</div><div class=\"line\">  Apply all migrations: admin, auth, contenttypes, sessions</div><div class=\"line\">Running migrations:</div><div class=\"line\">  Applying contenttypes.0001_initial... OK</div><div class=\"line\">  Applying auth.0001_initial... OK</div><div class=\"line\">  Applying admin.0001_initial... OK</div><div class=\"line\">  Applying admin.0002_logentry_remove_auto_add... OK</div><div class=\"line\">  Applying contenttypes.0002_remove_content_type_name... OK</div><div class=\"line\">  Applying auth.0002_alter_permission_name_max_length... OK</div><div class=\"line\">  Applying auth.0003_alter_user_email_max_length... OK</div><div class=\"line\">  Applying auth.0004_alter_user_username_opts... OK</div><div class=\"line\">  Applying auth.0005_alter_user_last_login_null... OK</div><div class=\"line\">  Applying auth.0006_require_contenttypes_0002... OK</div><div class=\"line\">  Applying auth.0007_alter_validators_add_error_messages... OK</div><div class=\"line\">  Applying auth.0008_alter_user_username_max_length... OK</div><div class=\"line\">  Applying sessions.0001_initial... OK</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>异常信息如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">JensondeMini:dj_test01 jenson$ python3 ./manage.py syncdb</div><div class=\"line\">Unknown command: &apos;syncdb&apos;</div><div class=\"line\">Type &apos;manage.py help&apos; for usage.</div></pre></td></tr></table></figure>\n<p>主要是因为使用的版本太新，如果你安装的Django Version &gt;= 1.9就会出现这个问题</p>\n<p>解决方法就是把<code>python3 ./manage.py syncdb</code></p>\n<p>替换成<code>python3 ./manage.py migrate</code></p>\n<p>之后就会初始化数据表成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">JensondeMini:dj_test01 jenson$ python3 ./manage.py migrate</div><div class=\"line\">Operations to perform:</div><div class=\"line\">  Apply all migrations: admin, auth, contenttypes, sessions</div><div class=\"line\">Running migrations:</div><div class=\"line\">  Applying contenttypes.0001_initial... OK</div><div class=\"line\">  Applying auth.0001_initial... OK</div><div class=\"line\">  Applying admin.0001_initial... OK</div><div class=\"line\">  Applying admin.0002_logentry_remove_auto_add... OK</div><div class=\"line\">  Applying contenttypes.0002_remove_content_type_name... OK</div><div class=\"line\">  Applying auth.0002_alter_permission_name_max_length... OK</div><div class=\"line\">  Applying auth.0003_alter_user_email_max_length... OK</div><div class=\"line\">  Applying auth.0004_alter_user_username_opts... OK</div><div class=\"line\">  Applying auth.0005_alter_user_last_login_null... OK</div><div class=\"line\">  Applying auth.0006_require_contenttypes_0002... OK</div><div class=\"line\">  Applying auth.0007_alter_validators_add_error_messages... OK</div><div class=\"line\">  Applying auth.0008_alter_user_username_max_length... OK</div><div class=\"line\">  Applying sessions.0001_initial... OK</div></pre></td></tr></table></figure>\n"},{"title":"Java wait，notify和notifyAll使用分析","date":"2017-07-21T05:00:51.000Z","_content":"\n# 0x00 前言\n\n提起多线程想当然的就会想到`synchronized` 。但是`synchronized`只能用于线程同步，如果是线程交替执行(生产者/消费者)，`synchronized`也无能为力了。这时wait，notify和notifyAll派上用场了。\n\n# 0x01 它们只是Object里的方法\n\n点开源码发现这三个方法只是object里面的方法，和多线程有神马关系呢？我相信不止我一个人曾经有过这个疑问。\n\n不只是object里的方法，而且还都是native方法。这是Java有意为之。因为Java设计之初就是要每个对象都有一个监控锁(Monitor)。而wait，notify和notifyAll三个方法也必须要在当前线程已经持有监控锁状态下才能执行，否则就会报`java.lang.IllegalMonitorStateException`。\n\n# 0x02 怎么知道线程是否持有状态锁\n\n线程同步原理就是利用了锁的互斥，所以在`synchronized`代码块内能确定是持有锁的。也就是说wait，notify和notifyAll方法需要在`synchronized`代码块内使用。\n\n具体来说有三种方式：\n\n- 同步对象方法持有锁\n\n  ```java\n  \tpublic synchronized void sync_1() {\n  \t} \n  ```\n\n- 同步静态方法持有锁\n\n  ```java\n  \tpublic static synchronized void sync_2() {\n  \t}\n  ```\n\n  ​\n\n- 同步代码块持有锁\n\n  ```java\n  \tpublic  void sync_3() {\n  \t\tsynchronized(lock){\n  \t\t}\n  \t}\n  ```\n\n# 0x03 三个方法都有什么用\n\n- wait后会让当前线程处于阻塞状态\n\n  能调用wait是因为当前线程持有Monitor，但是调用wait后，当前线程会释放锁，给予其他线程执行的机会。\n\n- notify会唤醒一个因为该对象阻塞的线程\n\n  同样notify能正常调用是因为当前线程持有锁，当notify执行后会唤醒其他阻塞线程，但是那些阻塞线程并不会立即执行，因为Monitor被notify线程持有。被唤醒的线程要等`synchronized`代码块执行完毕释放Monitor后才能执行。\n\n- notifyAll会唤醒所有因为该对象阻塞的线程\n\n  同notify。\n\n# 0x04 使用示例\n\n```java\n\tpublic static void main(String[] args) {\n\t\tThread t1 = new Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"start-t1\");\n\t\t\t\tsynchronized (lock) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSystem.out.println(\"t1等待唤醒\");\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"t1被唤醒持有锁\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tThread t2 = new Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"start-t2\");\n\t\t\t\ttry {\n\t\t\t\t\tThread.currentThread().sleep(3000);\n\t\t\t\t} catch (InterruptedException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\tsynchronized (lock) {\n\t\t\t\t\tlock.notify();// 唤醒\n\t\t\t\t\tSystem.out.println(\"t2持有锁，唤醒t1\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.currentThread().sleep(3000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"t2休眠3s\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tt1.start();\n\t\tt2.start();\n\t}\n```\n\n执行结果如下：\n\nstart-t2\nstart-t1\nt1等待唤醒\nt2持有锁，唤醒t1\nt2休眠3s\nt1被唤醒持有锁\n\n在t2中调用notify唤醒t1后，t2又休眠了3s钟，期间t1仍然没有执行，可见确实如上所说，唤醒的线程要在notify线程释放Monitor后才能执行。\n\n\n","source":"_posts/Java-wait，notify和notifyAll使用分析.md","raw":"---\ntitle: Java wait，notify和notifyAll使用分析\ndate: 2017-07-21 13:00:51\ntags: [Java, 多线程]\ncategories: [Java, 多线程]\n---\n\n# 0x00 前言\n\n提起多线程想当然的就会想到`synchronized` 。但是`synchronized`只能用于线程同步，如果是线程交替执行(生产者/消费者)，`synchronized`也无能为力了。这时wait，notify和notifyAll派上用场了。\n\n# 0x01 它们只是Object里的方法\n\n点开源码发现这三个方法只是object里面的方法，和多线程有神马关系呢？我相信不止我一个人曾经有过这个疑问。\n\n不只是object里的方法，而且还都是native方法。这是Java有意为之。因为Java设计之初就是要每个对象都有一个监控锁(Monitor)。而wait，notify和notifyAll三个方法也必须要在当前线程已经持有监控锁状态下才能执行，否则就会报`java.lang.IllegalMonitorStateException`。\n\n# 0x02 怎么知道线程是否持有状态锁\n\n线程同步原理就是利用了锁的互斥，所以在`synchronized`代码块内能确定是持有锁的。也就是说wait，notify和notifyAll方法需要在`synchronized`代码块内使用。\n\n具体来说有三种方式：\n\n- 同步对象方法持有锁\n\n  ```java\n  \tpublic synchronized void sync_1() {\n  \t} \n  ```\n\n- 同步静态方法持有锁\n\n  ```java\n  \tpublic static synchronized void sync_2() {\n  \t}\n  ```\n\n  ​\n\n- 同步代码块持有锁\n\n  ```java\n  \tpublic  void sync_3() {\n  \t\tsynchronized(lock){\n  \t\t}\n  \t}\n  ```\n\n# 0x03 三个方法都有什么用\n\n- wait后会让当前线程处于阻塞状态\n\n  能调用wait是因为当前线程持有Monitor，但是调用wait后，当前线程会释放锁，给予其他线程执行的机会。\n\n- notify会唤醒一个因为该对象阻塞的线程\n\n  同样notify能正常调用是因为当前线程持有锁，当notify执行后会唤醒其他阻塞线程，但是那些阻塞线程并不会立即执行，因为Monitor被notify线程持有。被唤醒的线程要等`synchronized`代码块执行完毕释放Monitor后才能执行。\n\n- notifyAll会唤醒所有因为该对象阻塞的线程\n\n  同notify。\n\n# 0x04 使用示例\n\n```java\n\tpublic static void main(String[] args) {\n\t\tThread t1 = new Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"start-t1\");\n\t\t\t\tsynchronized (lock) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSystem.out.println(\"t1等待唤醒\");\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"t1被唤醒持有锁\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tThread t2 = new Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"start-t2\");\n\t\t\t\ttry {\n\t\t\t\t\tThread.currentThread().sleep(3000);\n\t\t\t\t} catch (InterruptedException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\tsynchronized (lock) {\n\t\t\t\t\tlock.notify();// 唤醒\n\t\t\t\t\tSystem.out.println(\"t2持有锁，唤醒t1\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.currentThread().sleep(3000);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"t2休眠3s\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tt1.start();\n\t\tt2.start();\n\t}\n```\n\n执行结果如下：\n\nstart-t2\nstart-t1\nt1等待唤醒\nt2持有锁，唤醒t1\nt2休眠3s\nt1被唤醒持有锁\n\n在t2中调用notify唤醒t1后，t2又休眠了3s钟，期间t1仍然没有执行，可见确实如上所说，唤醒的线程要在notify线程释放Monitor后才能执行。\n\n\n","slug":"Java-wait，notify和notifyAll使用分析","published":1,"updated":"2017-07-24T06:08:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjcf001dwh9cqtt8nlop","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>提起多线程想当然的就会想到<code>synchronized</code> 。但是<code>synchronized</code>只能用于线程同步，如果是线程交替执行(生产者/消费者)，<code>synchronized</code>也无能为力了。这时wait，notify和notifyAll派上用场了。</p>\n<h1 id=\"0x01-它们只是Object里的方法\"><a href=\"#0x01-它们只是Object里的方法\" class=\"headerlink\" title=\"0x01 它们只是Object里的方法\"></a>0x01 它们只是Object里的方法</h1><p>点开源码发现这三个方法只是object里面的方法，和多线程有神马关系呢？我相信不止我一个人曾经有过这个疑问。</p>\n<p>不只是object里的方法，而且还都是native方法。这是Java有意为之。因为Java设计之初就是要每个对象都有一个监控锁(Monitor)。而wait，notify和notifyAll三个方法也必须要在当前线程已经持有监控锁状态下才能执行，否则就会报<code>java.lang.IllegalMonitorStateException</code>。</p>\n<h1 id=\"0x02-怎么知道线程是否持有状态锁\"><a href=\"#0x02-怎么知道线程是否持有状态锁\" class=\"headerlink\" title=\"0x02 怎么知道线程是否持有状态锁\"></a>0x02 怎么知道线程是否持有状态锁</h1><p>线程同步原理就是利用了锁的互斥，所以在<code>synchronized</code>代码块内能确定是持有锁的。也就是说wait，notify和notifyAll方法需要在<code>synchronized</code>代码块内使用。</p>\n<p>具体来说有三种方式：</p>\n<ul>\n<li><p>同步对象方法持有锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">sync_1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>同步静态方法持有锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">sync_2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>同步代码块持有锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">sync_3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span>(lock)&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"0x03-三个方法都有什么用\"><a href=\"#0x03-三个方法都有什么用\" class=\"headerlink\" title=\"0x03 三个方法都有什么用\"></a>0x03 三个方法都有什么用</h1><ul>\n<li><p>wait后会让当前线程处于阻塞状态</p>\n<p>能调用wait是因为当前线程持有Monitor，但是调用wait后，当前线程会释放锁，给予其他线程执行的机会。</p>\n</li>\n<li><p>notify会唤醒一个因为该对象阻塞的线程</p>\n<p>同样notify能正常调用是因为当前线程持有锁，当notify执行后会唤醒其他阻塞线程，但是那些阻塞线程并不会立即执行，因为Monitor被notify线程持有。被唤醒的线程要等<code>synchronized</code>代码块执行完毕释放Monitor后才能执行。</p>\n</li>\n<li><p>notifyAll会唤醒所有因为该对象阻塞的线程</p>\n<p>同notify。</p>\n</li>\n</ul>\n<h1 id=\"0x04-使用示例\"><a href=\"#0x04-使用示例\" class=\"headerlink\" title=\"0x04 使用示例\"></a>0x04 使用示例</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tThread t1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"start-t1\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tSystem.out.println(<span class=\"string\">\"t1等待唤醒\"</span>);</div><div class=\"line\">\t\t\t\t\tlock.wait();</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"t1被唤醒持有锁\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tThread t2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"start-t2\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.currentThread().sleep(<span class=\"number\">3000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</div><div class=\"line\">\t\t\t\te1.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">\t\t\t\tlock.notify();<span class=\"comment\">// 唤醒</span></div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"t2持有锁，唤醒t1\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tThread.currentThread().sleep(<span class=\"number\">3000</span>);</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"t2休眠3s\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tt1.start();</div><div class=\"line\">\tt2.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<p>start-t2<br>start-t1<br>t1等待唤醒<br>t2持有锁，唤醒t1<br>t2休眠3s<br>t1被唤醒持有锁</p>\n<p>在t2中调用notify唤醒t1后，t2又休眠了3s钟，期间t1仍然没有执行，可见确实如上所说，唤醒的线程要在notify线程释放Monitor后才能执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>提起多线程想当然的就会想到<code>synchronized</code> 。但是<code>synchronized</code>只能用于线程同步，如果是线程交替执行(生产者/消费者)，<code>synchronized</code>也无能为力了。这时wait，notify和notifyAll派上用场了。</p>\n<h1 id=\"0x01-它们只是Object里的方法\"><a href=\"#0x01-它们只是Object里的方法\" class=\"headerlink\" title=\"0x01 它们只是Object里的方法\"></a>0x01 它们只是Object里的方法</h1><p>点开源码发现这三个方法只是object里面的方法，和多线程有神马关系呢？我相信不止我一个人曾经有过这个疑问。</p>\n<p>不只是object里的方法，而且还都是native方法。这是Java有意为之。因为Java设计之初就是要每个对象都有一个监控锁(Monitor)。而wait，notify和notifyAll三个方法也必须要在当前线程已经持有监控锁状态下才能执行，否则就会报<code>java.lang.IllegalMonitorStateException</code>。</p>\n<h1 id=\"0x02-怎么知道线程是否持有状态锁\"><a href=\"#0x02-怎么知道线程是否持有状态锁\" class=\"headerlink\" title=\"0x02 怎么知道线程是否持有状态锁\"></a>0x02 怎么知道线程是否持有状态锁</h1><p>线程同步原理就是利用了锁的互斥，所以在<code>synchronized</code>代码块内能确定是持有锁的。也就是说wait，notify和notifyAll方法需要在<code>synchronized</code>代码块内使用。</p>\n<p>具体来说有三种方式：</p>\n<ul>\n<li><p>同步对象方法持有锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">sync_1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>同步静态方法持有锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">sync_2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>同步代码块持有锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">sync_3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">synchronized</span>(lock)&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"0x03-三个方法都有什么用\"><a href=\"#0x03-三个方法都有什么用\" class=\"headerlink\" title=\"0x03 三个方法都有什么用\"></a>0x03 三个方法都有什么用</h1><ul>\n<li><p>wait后会让当前线程处于阻塞状态</p>\n<p>能调用wait是因为当前线程持有Monitor，但是调用wait后，当前线程会释放锁，给予其他线程执行的机会。</p>\n</li>\n<li><p>notify会唤醒一个因为该对象阻塞的线程</p>\n<p>同样notify能正常调用是因为当前线程持有锁，当notify执行后会唤醒其他阻塞线程，但是那些阻塞线程并不会立即执行，因为Monitor被notify线程持有。被唤醒的线程要等<code>synchronized</code>代码块执行完毕释放Monitor后才能执行。</p>\n</li>\n<li><p>notifyAll会唤醒所有因为该对象阻塞的线程</p>\n<p>同notify。</p>\n</li>\n</ul>\n<h1 id=\"0x04-使用示例\"><a href=\"#0x04-使用示例\" class=\"headerlink\" title=\"0x04 使用示例\"></a>0x04 使用示例</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tThread t1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"start-t1\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tSystem.out.println(<span class=\"string\">\"t1等待唤醒\"</span>);</div><div class=\"line\">\t\t\t\t\tlock.wait();</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">\t\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"t1被唤醒持有锁\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tThread t2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"start-t2\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.currentThread().sleep(<span class=\"number\">3000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e1) &#123;</div><div class=\"line\">\t\t\t\te1.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (lock) &#123;</div><div class=\"line\">\t\t\t\tlock.notify();<span class=\"comment\">// 唤醒</span></div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"t2持有锁，唤醒t1\"</span>);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tThread.currentThread().sleep(<span class=\"number\">3000</span>);</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"t2休眠3s\"</span>);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\tt1.start();</div><div class=\"line\">\tt2.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<p>start-t2<br>start-t1<br>t1等待唤醒<br>t2持有锁，唤醒t1<br>t2休眠3s<br>t1被唤醒持有锁</p>\n<p>在t2中调用notify唤醒t1后，t2又休眠了3s钟，期间t1仍然没有执行，可见确实如上所说，唤醒的线程要在notify线程释放Monitor后才能执行。</p>\n"},{"title":"Java字符串压缩去重","date":"2017-05-03T09:42:06.000Z","_content":"\n# 说在前面的话\n\n去一家公司面试，开始就一道笔试题，做对了就继续，做不对就不用往下面了。内容是读取文件内容并压缩内容去重，压缩去重意思是如果内容为ABBCCCCAA压缩后字符串显示为A1B2C3A2。以此类推。其实这道题不难，但是我脑子转悠慢，读取文件和遍历字符做出来了，但是其余的没有做出了，或者说大概思路对了，但是卡在某一个点。总之有点废物就是了。。\n\n\n\n# 我的做法\n\n```\n\tpublic static String compress(String str){\n\t\tStringBuffer mystr = new StringBuffer();\n\t\t//我这里是从0开始的\n\t\tint count = 0;\n\t\t//而这也是初始为0，这样的设置导致下面判断时候一直\n\t\t//无所适从，对于何时该给count++，\n\t\t//何时该给mystr.append有点混乱\n\t\tchar last = 0;\n\t\tint length = str.length();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(last!=c){\n\t\t\t\tlast = c;\n\t\t\t\tcount++;\n\t\t\t\tmystr.append(last);\n\t\t\t\tmystr.append(count);\n\t\t\t}else{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn mystr.toString();\n\t}\n```\n\n# 正确地做法\n\n- 直接使用string做法\n\n  ```\n  public String compressBad (String str)  \n  {  \n      String mystr = \" \";  \n      int count = 1;  \n      char last = str.charAt(0);  \n      for (int i = 1; i < str.length(); i++)  \n      {  \n          if (last == str.charAt(i))  \n          {  \n              count++;  \n          }  \n          else  \n          {  \n              mystr += last + count;  \n              last = str.charAt(i);  \n              count = 1;                \n          }  \n      }  \n      return mystr += last + count;  \n  }  \n  ```\n\n  ​\n\n\n\n- 使用StringBuffer\n\n  ```\n  \tpublic static  String compressBetter(String str) {\n  \t\tStringBuffer mystr = new StringBuffer();\n  \t\tint count = 1;\n  \t\t//取出第一个字符作为比较字符\n  \t\tchar last = str.charAt(0);\n  \t\tfor (int i = 1; i < str.length(); i++) {\n  \t\t\t//如果当前字符和之前的字符相同，说明是重复的，\n  \t\t\t//直接在数量值+1；\n  \t\t\tif (last == str.charAt(i)) {\n  \t\t\t\tcount++;\n  \t\t\t} else {\n  \t\t\t\t//如果不相同，说明开始了一个新的字符，\n  \t\t\t\t//这时要做的只有两件事：\n  \t\t\t\t//1、结束上格字符计数并添加字符串，\n  \t\t\t\tmystr.append(last);\n  \t\t\t\tmystr.append(count);\n  \t\t\t\t//2、2、开始新的字符计数\n  \t\t\t\tlast = str.charAt(i);\n  \t\t\t\tcount = 1;\n  \t\t\t}\n  \t\t}\n  \t\t//最后一个字符计数并显示\n  \t\tmystr.append(last);\n  \t\tmystr.append(count);\n  \t\treturn mystr.toString();\n  \t}\n  ```\n\n  ​\n\n# 感想\n\n作为IT从业者，大部分时间都在写业务逻辑，很多基本功已经近乎荒废了，这是非常不可取的。眼光放长远些，我们的技术不应该局限于某一种语言，而应该把重心放在跨语言的那些通用技术。比如：操作系统、算法和数据结构、网络及设计模式重构思想等，这些东西在任何语言中都会用到而且也会是重点。","source":"_posts/Java字符串压缩去重.md","raw":"---\ntitle: Java字符串压缩去重\ndate: 2017-05-03 17:42:06\ntags: Java\ncategories: Java\n---\n\n# 说在前面的话\n\n去一家公司面试，开始就一道笔试题，做对了就继续，做不对就不用往下面了。内容是读取文件内容并压缩内容去重，压缩去重意思是如果内容为ABBCCCCAA压缩后字符串显示为A1B2C3A2。以此类推。其实这道题不难，但是我脑子转悠慢，读取文件和遍历字符做出来了，但是其余的没有做出了，或者说大概思路对了，但是卡在某一个点。总之有点废物就是了。。\n\n\n\n# 我的做法\n\n```\n\tpublic static String compress(String str){\n\t\tStringBuffer mystr = new StringBuffer();\n\t\t//我这里是从0开始的\n\t\tint count = 0;\n\t\t//而这也是初始为0，这样的设置导致下面判断时候一直\n\t\t//无所适从，对于何时该给count++，\n\t\t//何时该给mystr.append有点混乱\n\t\tchar last = 0;\n\t\tint length = str.length();\n\t\tfor(int i=0;i<length;i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(last!=c){\n\t\t\t\tlast = c;\n\t\t\t\tcount++;\n\t\t\t\tmystr.append(last);\n\t\t\t\tmystr.append(count);\n\t\t\t}else{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn mystr.toString();\n\t}\n```\n\n# 正确地做法\n\n- 直接使用string做法\n\n  ```\n  public String compressBad (String str)  \n  {  \n      String mystr = \" \";  \n      int count = 1;  \n      char last = str.charAt(0);  \n      for (int i = 1; i < str.length(); i++)  \n      {  \n          if (last == str.charAt(i))  \n          {  \n              count++;  \n          }  \n          else  \n          {  \n              mystr += last + count;  \n              last = str.charAt(i);  \n              count = 1;                \n          }  \n      }  \n      return mystr += last + count;  \n  }  \n  ```\n\n  ​\n\n\n\n- 使用StringBuffer\n\n  ```\n  \tpublic static  String compressBetter(String str) {\n  \t\tStringBuffer mystr = new StringBuffer();\n  \t\tint count = 1;\n  \t\t//取出第一个字符作为比较字符\n  \t\tchar last = str.charAt(0);\n  \t\tfor (int i = 1; i < str.length(); i++) {\n  \t\t\t//如果当前字符和之前的字符相同，说明是重复的，\n  \t\t\t//直接在数量值+1；\n  \t\t\tif (last == str.charAt(i)) {\n  \t\t\t\tcount++;\n  \t\t\t} else {\n  \t\t\t\t//如果不相同，说明开始了一个新的字符，\n  \t\t\t\t//这时要做的只有两件事：\n  \t\t\t\t//1、结束上格字符计数并添加字符串，\n  \t\t\t\tmystr.append(last);\n  \t\t\t\tmystr.append(count);\n  \t\t\t\t//2、2、开始新的字符计数\n  \t\t\t\tlast = str.charAt(i);\n  \t\t\t\tcount = 1;\n  \t\t\t}\n  \t\t}\n  \t\t//最后一个字符计数并显示\n  \t\tmystr.append(last);\n  \t\tmystr.append(count);\n  \t\treturn mystr.toString();\n  \t}\n  ```\n\n  ​\n\n# 感想\n\n作为IT从业者，大部分时间都在写业务逻辑，很多基本功已经近乎荒废了，这是非常不可取的。眼光放长远些，我们的技术不应该局限于某一种语言，而应该把重心放在跨语言的那些通用技术。比如：操作系统、算法和数据结构、网络及设计模式重构思想等，这些东西在任何语言中都会用到而且也会是重点。","slug":"Java字符串压缩去重","published":1,"updated":"2017-05-03T10:04:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjcm001iwh9cked65ckj","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>去一家公司面试，开始就一道笔试题，做对了就继续，做不对就不用往下面了。内容是读取文件内容并压缩内容去重，压缩去重意思是如果内容为ABBCCCCAA压缩后字符串显示为A1B2C3A2。以此类推。其实这道题不难，但是我脑子转悠慢，读取文件和遍历字符做出来了，但是其余的没有做出了，或者说大概思路对了，但是卡在某一个点。总之有点废物就是了。。</p>\n<h1 id=\"我的做法\"><a href=\"#我的做法\" class=\"headerlink\" title=\"我的做法\"></a>我的做法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static String compress(String str)&#123;</div><div class=\"line\">\tStringBuffer mystr = new StringBuffer();</div><div class=\"line\">\t//我这里是从0开始的</div><div class=\"line\">\tint count = 0;</div><div class=\"line\">\t//而这也是初始为0，这样的设置导致下面判断时候一直</div><div class=\"line\">\t//无所适从，对于何时该给count++，</div><div class=\"line\">\t//何时该给mystr.append有点混乱</div><div class=\"line\">\tchar last = 0;</div><div class=\"line\">\tint length = str.length();</div><div class=\"line\">\tfor(int i=0;i&lt;length;i++)&#123;</div><div class=\"line\">\t\tchar c = str.charAt(i);</div><div class=\"line\">\t\tif(last!=c)&#123;</div><div class=\"line\">\t\t\tlast = c;</div><div class=\"line\">\t\t\tcount++;</div><div class=\"line\">\t\t\tmystr.append(last);</div><div class=\"line\">\t\t\tmystr.append(count);</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\tcount++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn mystr.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"正确地做法\"><a href=\"#正确地做法\" class=\"headerlink\" title=\"正确地做法\"></a>正确地做法</h1><ul>\n<li><p>直接使用string做法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String compressBad (String str)  </div><div class=\"line\">&#123;  </div><div class=\"line\">    String mystr = &quot; &quot;;  </div><div class=\"line\">    int count = 1;  </div><div class=\"line\">    char last = str.charAt(0);  </div><div class=\"line\">    for (int i = 1; i &lt; str.length(); i++)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        if (last == str.charAt(i))  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            count++;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        else  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mystr += last + count;  </div><div class=\"line\">            last = str.charAt(i);  </div><div class=\"line\">            count = 1;                </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    return mystr += last + count;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<ul>\n<li><p>使用StringBuffer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static  String compressBetter(String str) &#123;</div><div class=\"line\">\tStringBuffer mystr = new StringBuffer();</div><div class=\"line\">\tint count = 1;</div><div class=\"line\">\t//取出第一个字符作为比较字符</div><div class=\"line\">\tchar last = str.charAt(0);</div><div class=\"line\">\tfor (int i = 1; i &lt; str.length(); i++) &#123;</div><div class=\"line\">\t\t//如果当前字符和之前的字符相同，说明是重复的，</div><div class=\"line\">\t\t//直接在数量值+1；</div><div class=\"line\">\t\tif (last == str.charAt(i)) &#123;</div><div class=\"line\">\t\t\tcount++;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t//如果不相同，说明开始了一个新的字符，</div><div class=\"line\">\t\t\t//这时要做的只有两件事：</div><div class=\"line\">\t\t\t//1、结束上格字符计数并添加字符串，</div><div class=\"line\">\t\t\tmystr.append(last);</div><div class=\"line\">\t\t\tmystr.append(count);</div><div class=\"line\">\t\t\t//2、2、开始新的字符计数</div><div class=\"line\">\t\t\tlast = str.charAt(i);</div><div class=\"line\">\t\t\tcount = 1;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//最后一个字符计数并显示</div><div class=\"line\">\tmystr.append(last);</div><div class=\"line\">\tmystr.append(count);</div><div class=\"line\">\treturn mystr.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>作为IT从业者，大部分时间都在写业务逻辑，很多基本功已经近乎荒废了，这是非常不可取的。眼光放长远些，我们的技术不应该局限于某一种语言，而应该把重心放在跨语言的那些通用技术。比如：操作系统、算法和数据结构、网络及设计模式重构思想等，这些东西在任何语言中都会用到而且也会是重点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>去一家公司面试，开始就一道笔试题，做对了就继续，做不对就不用往下面了。内容是读取文件内容并压缩内容去重，压缩去重意思是如果内容为ABBCCCCAA压缩后字符串显示为A1B2C3A2。以此类推。其实这道题不难，但是我脑子转悠慢，读取文件和遍历字符做出来了，但是其余的没有做出了，或者说大概思路对了，但是卡在某一个点。总之有点废物就是了。。</p>\n<h1 id=\"我的做法\"><a href=\"#我的做法\" class=\"headerlink\" title=\"我的做法\"></a>我的做法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static String compress(String str)&#123;</div><div class=\"line\">\tStringBuffer mystr = new StringBuffer();</div><div class=\"line\">\t//我这里是从0开始的</div><div class=\"line\">\tint count = 0;</div><div class=\"line\">\t//而这也是初始为0，这样的设置导致下面判断时候一直</div><div class=\"line\">\t//无所适从，对于何时该给count++，</div><div class=\"line\">\t//何时该给mystr.append有点混乱</div><div class=\"line\">\tchar last = 0;</div><div class=\"line\">\tint length = str.length();</div><div class=\"line\">\tfor(int i=0;i&lt;length;i++)&#123;</div><div class=\"line\">\t\tchar c = str.charAt(i);</div><div class=\"line\">\t\tif(last!=c)&#123;</div><div class=\"line\">\t\t\tlast = c;</div><div class=\"line\">\t\t\tcount++;</div><div class=\"line\">\t\t\tmystr.append(last);</div><div class=\"line\">\t\t\tmystr.append(count);</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\tcount++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn mystr.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"正确地做法\"><a href=\"#正确地做法\" class=\"headerlink\" title=\"正确地做法\"></a>正确地做法</h1><ul>\n<li><p>直接使用string做法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public String compressBad (String str)  </div><div class=\"line\">&#123;  </div><div class=\"line\">    String mystr = &quot; &quot;;  </div><div class=\"line\">    int count = 1;  </div><div class=\"line\">    char last = str.charAt(0);  </div><div class=\"line\">    for (int i = 1; i &lt; str.length(); i++)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        if (last == str.charAt(i))  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            count++;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        else  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mystr += last + count;  </div><div class=\"line\">            last = str.charAt(i);  </div><div class=\"line\">            count = 1;                </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    return mystr += last + count;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<ul>\n<li><p>使用StringBuffer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static  String compressBetter(String str) &#123;</div><div class=\"line\">\tStringBuffer mystr = new StringBuffer();</div><div class=\"line\">\tint count = 1;</div><div class=\"line\">\t//取出第一个字符作为比较字符</div><div class=\"line\">\tchar last = str.charAt(0);</div><div class=\"line\">\tfor (int i = 1; i &lt; str.length(); i++) &#123;</div><div class=\"line\">\t\t//如果当前字符和之前的字符相同，说明是重复的，</div><div class=\"line\">\t\t//直接在数量值+1；</div><div class=\"line\">\t\tif (last == str.charAt(i)) &#123;</div><div class=\"line\">\t\t\tcount++;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t//如果不相同，说明开始了一个新的字符，</div><div class=\"line\">\t\t\t//这时要做的只有两件事：</div><div class=\"line\">\t\t\t//1、结束上格字符计数并添加字符串，</div><div class=\"line\">\t\t\tmystr.append(last);</div><div class=\"line\">\t\t\tmystr.append(count);</div><div class=\"line\">\t\t\t//2、2、开始新的字符计数</div><div class=\"line\">\t\t\tlast = str.charAt(i);</div><div class=\"line\">\t\t\tcount = 1;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//最后一个字符计数并显示</div><div class=\"line\">\tmystr.append(last);</div><div class=\"line\">\tmystr.append(count);</div><div class=\"line\">\treturn mystr.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>作为IT从业者，大部分时间都在写业务逻辑，很多基本功已经近乎荒废了，这是非常不可取的。眼光放长远些，我们的技术不应该局限于某一种语言，而应该把重心放在跨语言的那些通用技术。比如：操作系统、算法和数据结构、网络及设计模式重构思想等，这些东西在任何语言中都会用到而且也会是重点。</p>\n"},{"title":"Java参数到底是值传递还是引用传递","date":"2017-08-10T05:55:54.000Z","_content":"\n# 0x00前言\n\n基本类型是值传递，引用类型是引用传递，在此前很长的一段时间内，我一直是这么认为的！\n\n然鹅，这个错误的想法竟然伴随多年，仿佛多年的Java白学了。\n\n\n\n# 0x01 说明\n\n**其实Java中参数的传递都是byValue方式传递**。\n\n讲道理先通过虚拟机机制来说明下：\n\n![讲道理](http://othg5ggzi.bkt.clouddn.com/%E8%AE%B2%E9%81%93%E7%90%86.jpg)\n\n\n\n虚拟机在内存中有一块区域叫Java栈，也叫虚拟机栈。栈里面装的是什么？\n\n栈中存放的是栈帧，栈帧里面又装的是什么？是局部变量表、操作数栈和方法返回地址等信息。\n\n其实一个Java线程运行时就会产生一个Java栈，每次的方法调用就会产生一个栈帧入栈，方法执行完毕则出栈。其中栈帧中的局部变量表存储的是参数和局部变量信息。\n\n当方法执行完毕，栈帧出栈内存就会被释放，如果引用类型的参数是直接把函数外的引用直接传递过来，那么出栈时，岂不是连函数外的这个变量也一同给释放掉了吗？\n\n所以为了避免这种情况发生，**引用类型的参数传递，只是对引用类型值的一个拷贝。**\n\n就是说**函数外的变量和参数是两个不同的变量，只是它们指向的地址是一样的**：\n\n![参数引用类型传递](http://othg5ggzi.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92.png)\n\n\n\n说到底，引用类型也躲不过值传递的命运。\n\n下面用示例来验证下外部变量和参数是两个不同的变量：\n\n# 0x02 示例\n\n```Java\npublic class ReTest {\n\tstatic void setStu(Student stu, int x) {\n      \tSystem.out.println(\"改变前stu变量：\"+stu+\"##x值：\"+x);\n\t\tstu = new Student(\"lisi\", 21);\n\t\tx=20;\n\t\tSystem.out.println(\"stu变量：\"+stu+\"##x值：\"+x);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStudent p = new Student(\"jenson\", 10);\n\t\tint i = 10;\n\t\tSystem.out.println(\"改变前p变量：\"+p+\"##i值：\"+i);\n\t\tsetStu(p, i);\n\t\tSystem.out.println(\"改变后p变量：\"+p+\"##i值：\"+i);\n\t}\n\n\tstatic class Student {\n\t\tint age;\n\t\tString name;\n\n\t\tStudent(String name, int age) {\n\t\t\tthis.age = age;\n\t\t\tthis.name = name;\n\t\t}\n\t}\n}\n\n```\n\n代码很简单，打印结果如下：\n\n```\n改变前p变量：thread.ReTest$Student@7852e922##i值：10\n改变前stu变量：thread.ReTest$Student@7852e922##x值：10\nstu变量：thread.ReTest$Student@4e25154f##x值：20\n改变后p变量：thread.ReTest$Student@7852e922##i值：10\n```\n\n参考打印结果可以发现：\n\n**基本类型是值传递，而引用类型为Student变量p和参数stu是两个不同的变量但指向同一块内存，在函数setStu中给参数stu从新赋值时，不影响变量p的引用。证明了参数stu是p变量的一个值拷贝。**\n\n","source":"_posts/Java参数到底是值传递还是引用传递.md","raw":"---\ntitle: Java参数到底是值传递还是引用传递\ndate: 2017-08-10 13:55:54\ntags: Java\ncategories: Java\n---\n\n# 0x00前言\n\n基本类型是值传递，引用类型是引用传递，在此前很长的一段时间内，我一直是这么认为的！\n\n然鹅，这个错误的想法竟然伴随多年，仿佛多年的Java白学了。\n\n\n\n# 0x01 说明\n\n**其实Java中参数的传递都是byValue方式传递**。\n\n讲道理先通过虚拟机机制来说明下：\n\n![讲道理](http://othg5ggzi.bkt.clouddn.com/%E8%AE%B2%E9%81%93%E7%90%86.jpg)\n\n\n\n虚拟机在内存中有一块区域叫Java栈，也叫虚拟机栈。栈里面装的是什么？\n\n栈中存放的是栈帧，栈帧里面又装的是什么？是局部变量表、操作数栈和方法返回地址等信息。\n\n其实一个Java线程运行时就会产生一个Java栈，每次的方法调用就会产生一个栈帧入栈，方法执行完毕则出栈。其中栈帧中的局部变量表存储的是参数和局部变量信息。\n\n当方法执行完毕，栈帧出栈内存就会被释放，如果引用类型的参数是直接把函数外的引用直接传递过来，那么出栈时，岂不是连函数外的这个变量也一同给释放掉了吗？\n\n所以为了避免这种情况发生，**引用类型的参数传递，只是对引用类型值的一个拷贝。**\n\n就是说**函数外的变量和参数是两个不同的变量，只是它们指向的地址是一样的**：\n\n![参数引用类型传递](http://othg5ggzi.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92.png)\n\n\n\n说到底，引用类型也躲不过值传递的命运。\n\n下面用示例来验证下外部变量和参数是两个不同的变量：\n\n# 0x02 示例\n\n```Java\npublic class ReTest {\n\tstatic void setStu(Student stu, int x) {\n      \tSystem.out.println(\"改变前stu变量：\"+stu+\"##x值：\"+x);\n\t\tstu = new Student(\"lisi\", 21);\n\t\tx=20;\n\t\tSystem.out.println(\"stu变量：\"+stu+\"##x值：\"+x);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStudent p = new Student(\"jenson\", 10);\n\t\tint i = 10;\n\t\tSystem.out.println(\"改变前p变量：\"+p+\"##i值：\"+i);\n\t\tsetStu(p, i);\n\t\tSystem.out.println(\"改变后p变量：\"+p+\"##i值：\"+i);\n\t}\n\n\tstatic class Student {\n\t\tint age;\n\t\tString name;\n\n\t\tStudent(String name, int age) {\n\t\t\tthis.age = age;\n\t\t\tthis.name = name;\n\t\t}\n\t}\n}\n\n```\n\n代码很简单，打印结果如下：\n\n```\n改变前p变量：thread.ReTest$Student@7852e922##i值：10\n改变前stu变量：thread.ReTest$Student@7852e922##x值：10\nstu变量：thread.ReTest$Student@4e25154f##x值：20\n改变后p变量：thread.ReTest$Student@7852e922##i值：10\n```\n\n参考打印结果可以发现：\n\n**基本类型是值传递，而引用类型为Student变量p和参数stu是两个不同的变量但指向同一块内存，在函数setStu中给参数stu从新赋值时，不影响变量p的引用。证明了参数stu是p变量的一个值拷贝。**\n\n","slug":"Java参数到底是值传递还是引用传递","published":1,"updated":"2017-08-10T07:00:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjco001lwh9ce3rz1a5r","content":"<h1 id=\"0x00前言\"><a href=\"#0x00前言\" class=\"headerlink\" title=\"0x00前言\"></a>0x00前言</h1><p>基本类型是值传递，引用类型是引用传递，在此前很长的一段时间内，我一直是这么认为的！</p>\n<p>然鹅，这个错误的想法竟然伴随多年，仿佛多年的Java白学了。</p>\n<h1 id=\"0x01-说明\"><a href=\"#0x01-说明\" class=\"headerlink\" title=\"0x01 说明\"></a>0x01 说明</h1><p><strong>其实Java中参数的传递都是byValue方式传递</strong>。</p>\n<p>讲道理先通过虚拟机机制来说明下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E8%AE%B2%E9%81%93%E7%90%86.jpg\" alt=\"讲道理\"></p>\n<p>虚拟机在内存中有一块区域叫Java栈，也叫虚拟机栈。栈里面装的是什么？</p>\n<p>栈中存放的是栈帧，栈帧里面又装的是什么？是局部变量表、操作数栈和方法返回地址等信息。</p>\n<p>其实一个Java线程运行时就会产生一个Java栈，每次的方法调用就会产生一个栈帧入栈，方法执行完毕则出栈。其中栈帧中的局部变量表存储的是参数和局部变量信息。</p>\n<p>当方法执行完毕，栈帧出栈内存就会被释放，如果引用类型的参数是直接把函数外的引用直接传递过来，那么出栈时，岂不是连函数外的这个变量也一同给释放掉了吗？</p>\n<p>所以为了避免这种情况发生，<strong>引用类型的参数传递，只是对引用类型值的一个拷贝。</strong></p>\n<p>就是说<strong>函数外的变量和参数是两个不同的变量，只是它们指向的地址是一样的</strong>：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92.png\" alt=\"参数引用类型传递\"></p>\n<p>说到底，引用类型也躲不过值传递的命运。</p>\n<p>下面用示例来验证下外部变量和参数是两个不同的变量：</p>\n<h1 id=\"0x02-示例\"><a href=\"#0x02-示例\" class=\"headerlink\" title=\"0x02 示例\"></a>0x02 示例</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setStu</span><span class=\"params\">(Student stu, <span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">      \tSystem.out.println(<span class=\"string\">\"改变前stu变量：\"</span>+stu+<span class=\"string\">\"##x值：\"</span>+x);</div><div class=\"line\">\t\tstu = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"lisi\"</span>, <span class=\"number\">21</span>);</div><div class=\"line\">\t\tx=<span class=\"number\">20</span>;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"stu变量：\"</span>+stu+<span class=\"string\">\"##x值：\"</span>+x);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tStudent p = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"jenson\"</span>, <span class=\"number\">10</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"改变前p变量：\"</span>+p+<span class=\"string\">\"##i值：\"</span>+i);</div><div class=\"line\">\t\tsetStu(p, i);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"改变后p变量：\"</span>+p+<span class=\"string\">\"##i值：\"</span>+i);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> age;</div><div class=\"line\">\t\tString name;</div><div class=\"line\"></div><div class=\"line\">\t\tStudent(String name, <span class=\"keyword\">int</span> age) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很简单，打印结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">改变前p变量：thread.ReTest$Student@7852e922##i值：10</div><div class=\"line\">改变前stu变量：thread.ReTest$Student@7852e922##x值：10</div><div class=\"line\">stu变量：thread.ReTest$Student@4e25154f##x值：20</div><div class=\"line\">改变后p变量：thread.ReTest$Student@7852e922##i值：10</div></pre></td></tr></table></figure>\n<p>参考打印结果可以发现：</p>\n<p><strong>基本类型是值传递，而引用类型为Student变量p和参数stu是两个不同的变量但指向同一块内存，在函数setStu中给参数stu从新赋值时，不影响变量p的引用。证明了参数stu是p变量的一个值拷贝。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00前言\"><a href=\"#0x00前言\" class=\"headerlink\" title=\"0x00前言\"></a>0x00前言</h1><p>基本类型是值传递，引用类型是引用传递，在此前很长的一段时间内，我一直是这么认为的！</p>\n<p>然鹅，这个错误的想法竟然伴随多年，仿佛多年的Java白学了。</p>\n<h1 id=\"0x01-说明\"><a href=\"#0x01-说明\" class=\"headerlink\" title=\"0x01 说明\"></a>0x01 说明</h1><p><strong>其实Java中参数的传递都是byValue方式传递</strong>。</p>\n<p>讲道理先通过虚拟机机制来说明下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E8%AE%B2%E9%81%93%E7%90%86.jpg\" alt=\"讲道理\"></p>\n<p>虚拟机在内存中有一块区域叫Java栈，也叫虚拟机栈。栈里面装的是什么？</p>\n<p>栈中存放的是栈帧，栈帧里面又装的是什么？是局部变量表、操作数栈和方法返回地址等信息。</p>\n<p>其实一个Java线程运行时就会产生一个Java栈，每次的方法调用就会产生一个栈帧入栈，方法执行完毕则出栈。其中栈帧中的局部变量表存储的是参数和局部变量信息。</p>\n<p>当方法执行完毕，栈帧出栈内存就会被释放，如果引用类型的参数是直接把函数外的引用直接传递过来，那么出栈时，岂不是连函数外的这个变量也一同给释放掉了吗？</p>\n<p>所以为了避免这种情况发生，<strong>引用类型的参数传递，只是对引用类型值的一个拷贝。</strong></p>\n<p>就是说<strong>函数外的变量和参数是两个不同的变量，只是它们指向的地址是一样的</strong>：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92.png\" alt=\"参数引用类型传递\"></p>\n<p>说到底，引用类型也躲不过值传递的命运。</p>\n<p>下面用示例来验证下外部变量和参数是两个不同的变量：</p>\n<h1 id=\"0x02-示例\"><a href=\"#0x02-示例\" class=\"headerlink\" title=\"0x02 示例\"></a>0x02 示例</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReTest</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setStu</span><span class=\"params\">(Student stu, <span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">      \tSystem.out.println(<span class=\"string\">\"改变前stu变量：\"</span>+stu+<span class=\"string\">\"##x值：\"</span>+x);</div><div class=\"line\">\t\tstu = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"lisi\"</span>, <span class=\"number\">21</span>);</div><div class=\"line\">\t\tx=<span class=\"number\">20</span>;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"stu变量：\"</span>+stu+<span class=\"string\">\"##x值：\"</span>+x);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tStudent p = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"jenson\"</span>, <span class=\"number\">10</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"改变前p变量：\"</span>+p+<span class=\"string\">\"##i值：\"</span>+i);</div><div class=\"line\">\t\tsetStu(p, i);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"改变后p变量：\"</span>+p+<span class=\"string\">\"##i值：\"</span>+i);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> age;</div><div class=\"line\">\t\tString name;</div><div class=\"line\"></div><div class=\"line\">\t\tStudent(String name, <span class=\"keyword\">int</span> age) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码很简单，打印结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">改变前p变量：thread.ReTest$Student@7852e922##i值：10</div><div class=\"line\">改变前stu变量：thread.ReTest$Student@7852e922##x值：10</div><div class=\"line\">stu变量：thread.ReTest$Student@4e25154f##x值：20</div><div class=\"line\">改变后p变量：thread.ReTest$Student@7852e922##i值：10</div></pre></td></tr></table></figure>\n<p>参考打印结果可以发现：</p>\n<p><strong>基本类型是值传递，而引用类型为Student变量p和参数stu是两个不同的变量但指向同一块内存，在函数setStu中给参数stu从新赋值时，不影响变量p的引用。证明了参数stu是p变量的一个值拷贝。</strong></p>\n"},{"title":"Android进程和线程","date":"2017-04-27T12:36:13.000Z","_content":"\n# 进程\n\n一般情况下，进程是应用程序的单元，一个应用对应一个进程同时对应一个主线程。但是通过设置 `android:process`，可以使原本一个应用中的组件运行在多个进程中。\n\n> 如果进程名称设置为“:remote”，那么这个进程的名字是包名+设置的名字，以冒号开头的进程属于私有进程，其他应用的组件不能和它跑在一个进程。如果进程名设置是完整的(\"非冒号开头\")，则属于全局进程，其他应用可以通过shareUID方式和它共享一个进程。\n\n# 进程优先级分类\n\n根据进程的优先级可以分为五级，\n\n- 前台进程\n\n  用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：\n  ​\t托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）\n  ​\t托管某个 Service，后者绑定到用户正在交互的 Activity\n  ​\t托管正在“前台”运行的 Service（服务已调用 startForeground()）\n  ​\t托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）\n  ​\t托管正执行其 onReceive() 方法的 BroadcastReceiver\n  通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。\n\n- 可见进程\n\n  没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：\n  ​\t托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。\n  ​\t托管绑定到可见（或前台）Activity 的 Service。\n  可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。\n\n- 服务进程\n\n  正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。\n\n- 后台进程\n\n  包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。\n\n- 空进程\n\n  不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\n\n# 线程\n\n线程可以看作是一个轻量级的进程，在Android中启动应用时系统会为APP创建一个UI线程，Android UI是非线程安全的。\n\n在Android开发中注意两点：\n\n①不能在UI线程以外的其他线程操作UI，否则异常。\n\n②不能阻塞UI线程，否则ANR。\n\n当然在某些特殊条件下，非UI线程操作 UI没有报错，参考我的[[为什么我在工作线程刷新UI没报错？](http://www.jensondev.me/2017/04/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%E6%B2%A1%E6%8A%A5%E9%94%99/)] 。\n\nAndroid 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法：\n\nActivity.runOnUiThread(Runnable)\nView.post(Runnable)\nView.postDelayed(Runnable, long)\n\n","source":"_posts/Android进程和线程.md","raw":"---\ntitle: Android进程和线程\ndate: 2017-04-27 20:36:13\ntags: Android\ncategories: Android\n---\n\n# 进程\n\n一般情况下，进程是应用程序的单元，一个应用对应一个进程同时对应一个主线程。但是通过设置 `android:process`，可以使原本一个应用中的组件运行在多个进程中。\n\n> 如果进程名称设置为“:remote”，那么这个进程的名字是包名+设置的名字，以冒号开头的进程属于私有进程，其他应用的组件不能和它跑在一个进程。如果进程名设置是完整的(\"非冒号开头\")，则属于全局进程，其他应用可以通过shareUID方式和它共享一个进程。\n\n# 进程优先级分类\n\n根据进程的优先级可以分为五级，\n\n- 前台进程\n\n  用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：\n  ​\t托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）\n  ​\t托管某个 Service，后者绑定到用户正在交互的 Activity\n  ​\t托管正在“前台”运行的 Service（服务已调用 startForeground()）\n  ​\t托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）\n  ​\t托管正执行其 onReceive() 方法的 BroadcastReceiver\n  通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。\n\n- 可见进程\n\n  没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：\n  ​\t托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。\n  ​\t托管绑定到可见（或前台）Activity 的 Service。\n  可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。\n\n- 服务进程\n\n  正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。\n\n- 后台进程\n\n  包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。\n\n- 空进程\n\n  不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\n\n# 线程\n\n线程可以看作是一个轻量级的进程，在Android中启动应用时系统会为APP创建一个UI线程，Android UI是非线程安全的。\n\n在Android开发中注意两点：\n\n①不能在UI线程以外的其他线程操作UI，否则异常。\n\n②不能阻塞UI线程，否则ANR。\n\n当然在某些特殊条件下，非UI线程操作 UI没有报错，参考我的[[为什么我在工作线程刷新UI没报错？](http://www.jensondev.me/2017/04/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%E6%B2%A1%E6%8A%A5%E9%94%99/)] 。\n\nAndroid 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法：\n\nActivity.runOnUiThread(Runnable)\nView.post(Runnable)\nView.postDelayed(Runnable, long)\n\n","slug":"Android进程和线程","published":1,"updated":"2017-04-27T12:59:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjcr001owh9co1zkx13j","content":"<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><p>一般情况下，进程是应用程序的单元，一个应用对应一个进程同时对应一个主线程。但是通过设置 <code>android:process</code>，可以使原本一个应用中的组件运行在多个进程中。</p>\n<blockquote>\n<p>如果进程名称设置为“:remote”，那么这个进程的名字是包名+设置的名字，以冒号开头的进程属于私有进程，其他应用的组件不能和它跑在一个进程。如果进程名设置是完整的(“非冒号开头”)，则属于全局进程，其他应用可以通过shareUID方式和它共享一个进程。</p>\n</blockquote>\n<h1 id=\"进程优先级分类\"><a href=\"#进程优先级分类\" class=\"headerlink\" title=\"进程优先级分类\"></a>进程优先级分类</h1><p>根据进程的优先级可以分为五级，</p>\n<ul>\n<li><p>前台进程</p>\n<p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：<br>​    托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）<br>​    托管某个 Service，后者绑定到用户正在交互的 Activity<br>​    托管正在“前台”运行的 Service（服务已调用 startForeground()）<br>​    托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）<br>​    托管正执行其 onReceive() 方法的 BroadcastReceiver<br>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>\n</li>\n<li><p>可见进程</p>\n<p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：<br>​    托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。<br>​    托管绑定到可见（或前台）Activity 的 Service。<br>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>\n</li>\n<li><p>服务进程</p>\n<p>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>\n</li>\n<li><p>后台进程</p>\n<p>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。</p>\n</li>\n<li><p>空进程</p>\n<p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>\n</li>\n</ul>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><p>线程可以看作是一个轻量级的进程，在Android中启动应用时系统会为APP创建一个UI线程，Android UI是非线程安全的。</p>\n<p>在Android开发中注意两点：</p>\n<p>①不能在UI线程以外的其他线程操作UI，否则异常。</p>\n<p>②不能阻塞UI线程，否则ANR。</p>\n<p>当然在某些特殊条件下，非UI线程操作 UI没有报错，参考我的[<a href=\"http://www.jensondev.me/2017/04/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%E6%B2%A1%E6%8A%A5%E9%94%99/\" target=\"_blank\" rel=\"external\">为什么我在工作线程刷新UI没报错？</a>] 。</p>\n<p>Android 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法：</p>\n<p>Activity.runOnUiThread(Runnable)<br>View.post(Runnable)<br>View.postDelayed(Runnable, long)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><p>一般情况下，进程是应用程序的单元，一个应用对应一个进程同时对应一个主线程。但是通过设置 <code>android:process</code>，可以使原本一个应用中的组件运行在多个进程中。</p>\n<blockquote>\n<p>如果进程名称设置为“:remote”，那么这个进程的名字是包名+设置的名字，以冒号开头的进程属于私有进程，其他应用的组件不能和它跑在一个进程。如果进程名设置是完整的(“非冒号开头”)，则属于全局进程，其他应用可以通过shareUID方式和它共享一个进程。</p>\n</blockquote>\n<h1 id=\"进程优先级分类\"><a href=\"#进程优先级分类\" class=\"headerlink\" title=\"进程优先级分类\"></a>进程优先级分类</h1><p>根据进程的优先级可以分为五级，</p>\n<ul>\n<li><p>前台进程</p>\n<p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：<br>​    托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）<br>​    托管某个 Service，后者绑定到用户正在交互的 Activity<br>​    托管正在“前台”运行的 Service（服务已调用 startForeground()）<br>​    托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）<br>​    托管正执行其 onReceive() 方法的 BroadcastReceiver<br>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>\n</li>\n<li><p>可见进程</p>\n<p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：<br>​    托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。<br>​    托管绑定到可见（或前台）Activity 的 Service。<br>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>\n</li>\n<li><p>服务进程</p>\n<p>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>\n</li>\n<li><p>后台进程</p>\n<p>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。</p>\n</li>\n<li><p>空进程</p>\n<p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>\n</li>\n</ul>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><p>线程可以看作是一个轻量级的进程，在Android中启动应用时系统会为APP创建一个UI线程，Android UI是非线程安全的。</p>\n<p>在Android开发中注意两点：</p>\n<p>①不能在UI线程以外的其他线程操作UI，否则异常。</p>\n<p>②不能阻塞UI线程，否则ANR。</p>\n<p>当然在某些特殊条件下，非UI线程操作 UI没有报错，参考我的[<a href=\"http://www.jensondev.me/2017/04/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%E6%B2%A1%E6%8A%A5%E9%94%99/\">为什么我在工作线程刷新UI没报错？</a>] 。</p>\n<p>Android 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法：</p>\n<p>Activity.runOnUiThread(Runnable)<br>View.post(Runnable)<br>View.postDelayed(Runnable, long)</p>\n"},{"title":"Mac版eclipse中每次重启电脑后字体自动变小","date":"2017-04-22T10:50:50.000Z","_content":"如题每次开机后打开eclipse时，发现上次调好的字体又变小了。每次都这样，比较影响心情。今天决定把这个问题解决掉。\n\b网友的做法是：\n打开 应用程序/Eclipse.app/Contents/Eclipse/eclipse.ini 文件中，\n把文中“-Dorg.eclipse.swt.internal.carbon.smallFonts”删掉。\n这样可以避免Eclipse里面的字体奇怪地自动变小。。\n\n发现很久以前就存在这个问题，不过当时的fix方法和最新的不一样。\n[传送通道](http://t-machine.org/index.php/2011/08/21/fix-eclipses-fonts-on-os-x/)\n\n但是上面的2方法好像对我来说没有效果(我只试了第一种)。后来在偏好设置里发现Theme为mac时使用的是Reduced Palette这个选项，我好奇的把选项改为了Default。然后点了确认再调整好需要的字体并重启。然后真的没有再恢复小字体了。\n\n![屏幕快照 2017-03-08 下午12.04.34.png](http://upload-images.jianshu.io/upload_images/1796052-3ea1ef0bbc0ed211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/Mac版eclipse中每次重启电脑后字体自动变小.md","raw":"---\ntitle: Mac版eclipse中每次重启电脑后字体自动变小\ndate: 2017-04-22 18:50:50\ntags: 工具\ncategories: 工具\n---\n如题每次开机后打开eclipse时，发现上次调好的字体又变小了。每次都这样，比较影响心情。今天决定把这个问题解决掉。\n\b网友的做法是：\n打开 应用程序/Eclipse.app/Contents/Eclipse/eclipse.ini 文件中，\n把文中“-Dorg.eclipse.swt.internal.carbon.smallFonts”删掉。\n这样可以避免Eclipse里面的字体奇怪地自动变小。。\n\n发现很久以前就存在这个问题，不过当时的fix方法和最新的不一样。\n[传送通道](http://t-machine.org/index.php/2011/08/21/fix-eclipses-fonts-on-os-x/)\n\n但是上面的2方法好像对我来说没有效果(我只试了第一种)。后来在偏好设置里发现Theme为mac时使用的是Reduced Palette这个选项，我好奇的把选项改为了Default。然后点了确认再调整好需要的字体并重启。然后真的没有再恢复小字体了。\n\n![屏幕快照 2017-03-08 下午12.04.34.png](http://upload-images.jianshu.io/upload_images/1796052-3ea1ef0bbc0ed211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"Mac版eclipse中每次重启电脑后字体自动变小","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjcw001twh9cy77lz2mw","content":"<p>如题每次开机后打开eclipse时，发现上次调好的字体又变小了。每次都这样，比较影响心情。今天决定把这个问题解决掉。<br>\b网友的做法是：<br>打开 应用程序/Eclipse.app/Contents/Eclipse/eclipse.ini 文件中，<br>把文中“-Dorg.eclipse.swt.internal.carbon.smallFonts”删掉。<br>这样可以避免Eclipse里面的字体奇怪地自动变小。。</p>\n<p>发现很久以前就存在这个问题，不过当时的fix方法和最新的不一样。<br><a href=\"http://t-machine.org/index.php/2011/08/21/fix-eclipses-fonts-on-os-x/\" target=\"_blank\" rel=\"external\">传送通道</a></p>\n<p>但是上面的2方法好像对我来说没有效果(我只试了第一种)。后来在偏好设置里发现Theme为mac时使用的是Reduced Palette这个选项，我好奇的把选项改为了Default。然后点了确认再调整好需要的字体并重启。然后真的没有再恢复小字体了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-3ea1ef0bbc0ed211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-08 下午12.04.34.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>如题每次开机后打开eclipse时，发现上次调好的字体又变小了。每次都这样，比较影响心情。今天决定把这个问题解决掉。<br>\b网友的做法是：<br>打开 应用程序/Eclipse.app/Contents/Eclipse/eclipse.ini 文件中，<br>把文中“-Dorg.eclipse.swt.internal.carbon.smallFonts”删掉。<br>这样可以避免Eclipse里面的字体奇怪地自动变小。。</p>\n<p>发现很久以前就存在这个问题，不过当时的fix方法和最新的不一样。<br><a href=\"http://t-machine.org/index.php/2011/08/21/fix-eclipses-fonts-on-os-x/\">传送通道</a></p>\n<p>但是上面的2方法好像对我来说没有效果(我只试了第一种)。后来在偏好设置里发现Theme为mac时使用的是Reduced Palette这个选项，我好奇的把选项改为了Default。然后点了确认再调整好需要的字体并重启。然后真的没有再恢复小字体了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-3ea1ef0bbc0ed211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-08 下午12.04.34.png\"></p>\n"},{"title":"Java知识点","date":"2017-06-30T10:51:23.000Z","_content":"\n# 字符串\n\n1、==对基本数据类型来说比较的是值是否相等，但对于引用类型来说，其和equals医院，比较的都是对象地址，前提是equals没有被重写。\n\n```java\n\t\tString c = \"c\";\n\t\tfinal String c1 = \"c\";\n\t\tString s0 = \"a\" + \"b\" + c1;\n\t\tString s1 = \"a\" + \"b\" + c;\n\t\tString s2 = \"a\" + \"b\" + \"c\";\n\t\tString s3 = \"abc\";\n\t\tSystem.out.println(s0 == s3);//true\n\t\tSystem.out.println(s1 == s3);//false\n\t\tSystem.out.println(s2 == s3);//true\n```\n\n根据Java编译时优化方案，s2中加号的三个值都为固定常量，所以s2在编译时也被认为是常量，即编译期就确定了s2的值，并且和s3一样，所以打印true\n\n在s1中，a和b的值是常量，但是c属于局部变量，而且也没有谁指定c这个值是不可变的。既然是可变量，导致s1也被编译期认为是不确定值，\n\n接下来s0，a和b不用说了都是常量，而c1虽然和c一样也是局部变量，但是c1有finla修饰，明确告诉编译器明面上我是一个局部变量，但是同时我的值是不可变的，final修饰了，现在不变，将来也不会改变，所以编译器在编译期确定了s0 的值。所以把s0也作为常量和s3一样，都在常量池\n\n***编译器优化要在编译期能确定的值得情况下进行，而能确定值的只能是在常量池中的内容。***\n\n2、string.intern()，当字符串调用这个方法时，都会拿着当前字符串的值去常量池中找，如果找到则返回常量池这个常量地址，否则在常量池创建一个常量并把字符串填进去，然后返回创建的地址。当然这是在JDK1.6情况下，在1.7及以后会有不同\n\n```java\n\t\tString c = \"c\";\n\t\tfinal String c1 = \"c\";\n\t\tString s0 = \"a\" + \"b\" + c1;\n\t\tString s1 = \"a\" + \"b\" + c;\n\t\tString s2 = \"a\" + \"b\" + \"c\";\n\t\tString s3 = \"abc\";\n\t\tSystem.out.println(s0 == s3);\n\t\tSystem.out.println(s1.intern() == s3);//true\n\t\tSystem.out.println(s2 == s3);\n```\n\n***由于intern()需要去常量池中做字符串比较，而常量池又很可能有多个常量，所以一般来说intern()效率并不高***\n\n\n\n\n\n\n\n","source":"_posts/Java知识点.md","raw":"---\ntitle: Java知识点\ndate: 2017-06-30 18:51:23\ntags: Java\ncategories: Java\n---\n\n# 字符串\n\n1、==对基本数据类型来说比较的是值是否相等，但对于引用类型来说，其和equals医院，比较的都是对象地址，前提是equals没有被重写。\n\n```java\n\t\tString c = \"c\";\n\t\tfinal String c1 = \"c\";\n\t\tString s0 = \"a\" + \"b\" + c1;\n\t\tString s1 = \"a\" + \"b\" + c;\n\t\tString s2 = \"a\" + \"b\" + \"c\";\n\t\tString s3 = \"abc\";\n\t\tSystem.out.println(s0 == s3);//true\n\t\tSystem.out.println(s1 == s3);//false\n\t\tSystem.out.println(s2 == s3);//true\n```\n\n根据Java编译时优化方案，s2中加号的三个值都为固定常量，所以s2在编译时也被认为是常量，即编译期就确定了s2的值，并且和s3一样，所以打印true\n\n在s1中，a和b的值是常量，但是c属于局部变量，而且也没有谁指定c这个值是不可变的。既然是可变量，导致s1也被编译期认为是不确定值，\n\n接下来s0，a和b不用说了都是常量，而c1虽然和c一样也是局部变量，但是c1有finla修饰，明确告诉编译器明面上我是一个局部变量，但是同时我的值是不可变的，final修饰了，现在不变，将来也不会改变，所以编译器在编译期确定了s0 的值。所以把s0也作为常量和s3一样，都在常量池\n\n***编译器优化要在编译期能确定的值得情况下进行，而能确定值的只能是在常量池中的内容。***\n\n2、string.intern()，当字符串调用这个方法时，都会拿着当前字符串的值去常量池中找，如果找到则返回常量池这个常量地址，否则在常量池创建一个常量并把字符串填进去，然后返回创建的地址。当然这是在JDK1.6情况下，在1.7及以后会有不同\n\n```java\n\t\tString c = \"c\";\n\t\tfinal String c1 = \"c\";\n\t\tString s0 = \"a\" + \"b\" + c1;\n\t\tString s1 = \"a\" + \"b\" + c;\n\t\tString s2 = \"a\" + \"b\" + \"c\";\n\t\tString s3 = \"abc\";\n\t\tSystem.out.println(s0 == s3);\n\t\tSystem.out.println(s1.intern() == s3);//true\n\t\tSystem.out.println(s2 == s3);\n```\n\n***由于intern()需要去常量池中做字符串比较，而常量池又很可能有多个常量，所以一般来说intern()效率并不高***\n\n\n\n\n\n\n\n","slug":"Java知识点","published":1,"updated":"2017-06-30T11:28:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjd1001wwh9cz2yajftu","content":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>1、==对基本数据类型来说比较的是值是否相等，但对于引用类型来说，其和equals医院，比较的都是对象地址，前提是equals没有被重写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String c = <span class=\"string\">\"c\"</span>;</div><div class=\"line\"><span class=\"keyword\">final</span> String c1 = <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s0 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c1;</div><div class=\"line\">String s1 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c;</div><div class=\"line\">String s2 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s3 = <span class=\"string\">\"abc\"</span>;</div><div class=\"line\">System.out.println(s0 == s3);<span class=\"comment\">//true</span></div><div class=\"line\">System.out.println(s1 == s3);<span class=\"comment\">//false</span></div><div class=\"line\">System.out.println(s2 == s3);<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<p>根据Java编译时优化方案，s2中加号的三个值都为固定常量，所以s2在编译时也被认为是常量，即编译期就确定了s2的值，并且和s3一样，所以打印true</p>\n<p>在s1中，a和b的值是常量，但是c属于局部变量，而且也没有谁指定c这个值是不可变的。既然是可变量，导致s1也被编译期认为是不确定值，</p>\n<p>接下来s0，a和b不用说了都是常量，而c1虽然和c一样也是局部变量，但是c1有finla修饰，明确告诉编译器明面上我是一个局部变量，但是同时我的值是不可变的，final修饰了，现在不变，将来也不会改变，所以编译器在编译期确定了s0 的值。所以把s0也作为常量和s3一样，都在常量池</p>\n<p><strong><em>编译器优化要在编译期能确定的值得情况下进行，而能确定值的只能是在常量池中的内容。</em></strong></p>\n<p>2、string.intern()，当字符串调用这个方法时，都会拿着当前字符串的值去常量池中找，如果找到则返回常量池这个常量地址，否则在常量池创建一个常量并把字符串填进去，然后返回创建的地址。当然这是在JDK1.6情况下，在1.7及以后会有不同</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String c = <span class=\"string\">\"c\"</span>;</div><div class=\"line\"><span class=\"keyword\">final</span> String c1 = <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s0 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c1;</div><div class=\"line\">String s1 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c;</div><div class=\"line\">String s2 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s3 = <span class=\"string\">\"abc\"</span>;</div><div class=\"line\">System.out.println(s0 == s3);</div><div class=\"line\">System.out.println(s1.intern() == s3);<span class=\"comment\">//true</span></div><div class=\"line\">System.out.println(s2 == s3);</div></pre></td></tr></table></figure>\n<p><strong><em>由于intern()需要去常量池中做字符串比较，而常量池又很可能有多个常量，所以一般来说intern()效率并不高</em></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>1、==对基本数据类型来说比较的是值是否相等，但对于引用类型来说，其和equals医院，比较的都是对象地址，前提是equals没有被重写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String c = <span class=\"string\">\"c\"</span>;</div><div class=\"line\"><span class=\"keyword\">final</span> String c1 = <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s0 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c1;</div><div class=\"line\">String s1 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c;</div><div class=\"line\">String s2 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s3 = <span class=\"string\">\"abc\"</span>;</div><div class=\"line\">System.out.println(s0 == s3);<span class=\"comment\">//true</span></div><div class=\"line\">System.out.println(s1 == s3);<span class=\"comment\">//false</span></div><div class=\"line\">System.out.println(s2 == s3);<span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<p>根据Java编译时优化方案，s2中加号的三个值都为固定常量，所以s2在编译时也被认为是常量，即编译期就确定了s2的值，并且和s3一样，所以打印true</p>\n<p>在s1中，a和b的值是常量，但是c属于局部变量，而且也没有谁指定c这个值是不可变的。既然是可变量，导致s1也被编译期认为是不确定值，</p>\n<p>接下来s0，a和b不用说了都是常量，而c1虽然和c一样也是局部变量，但是c1有finla修饰，明确告诉编译器明面上我是一个局部变量，但是同时我的值是不可变的，final修饰了，现在不变，将来也不会改变，所以编译器在编译期确定了s0 的值。所以把s0也作为常量和s3一样，都在常量池</p>\n<p><strong><em>编译器优化要在编译期能确定的值得情况下进行，而能确定值的只能是在常量池中的内容。</em></strong></p>\n<p>2、string.intern()，当字符串调用这个方法时，都会拿着当前字符串的值去常量池中找，如果找到则返回常量池这个常量地址，否则在常量池创建一个常量并把字符串填进去，然后返回创建的地址。当然这是在JDK1.6情况下，在1.7及以后会有不同</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">String c = <span class=\"string\">\"c\"</span>;</div><div class=\"line\"><span class=\"keyword\">final</span> String c1 = <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s0 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c1;</div><div class=\"line\">String s1 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + c;</div><div class=\"line\">String s2 = <span class=\"string\">\"a\"</span> + <span class=\"string\">\"b\"</span> + <span class=\"string\">\"c\"</span>;</div><div class=\"line\">String s3 = <span class=\"string\">\"abc\"</span>;</div><div class=\"line\">System.out.println(s0 == s3);</div><div class=\"line\">System.out.println(s1.intern() == s3);<span class=\"comment\">//true</span></div><div class=\"line\">System.out.println(s2 == s3);</div></pre></td></tr></table></figure>\n<p><strong><em>由于intern()需要去常量池中做字符串比较，而常量池又很可能有多个常量，所以一般来说intern()效率并不高</em></strong></p>\n"},{"title":"Mac下配置adb","date":"2017-07-13T13:10:42.000Z","_content":"\n# 0x00 前言\n\nMac和windows一样，如果要在终端命令行全局使用非系统命令，需要手动把命令环境配置到指定文件中，具体操作就是把命令文件所属路径配置到.bash_profile里面。\n\n# 0x01 分别找到双方路径\n\n## 找到adb\n\n我是通过Android studio中的idk location找到SDK位置`/Users/jenson/Library/Android/sdk` .\n\n\n\n\n\n## 找到.bash_profile\n\n- 使用命令行`cd $home` 进入home路径下，\n\n- 因为mac下以点开头的文件为隐藏文件，所以使用`ls -al` 查看所有文件，查看列表是否有.bash_profile文件，\n\n- 如果没有，使用`touch .bash_profile` 创建，如果有则执行命令`open -e .bash_profile` 使用文本编辑器打开文件，\n\n- 在下面按格式添加SDK路径：\n\n  ```\n  export PATH=/Users/jenson/Library/Android/sdk/platform-tools:$PATH\n  export PATH=/Users/jenson/Library/Android/sdk/tools:$PATH\n  ```\n\n  ​\n\n## open -e .bash_profile提示open命令不存在\n\n通过Finder根据路径找到.bash_profile文件，编辑添加\n\n```\nexport PATH=\"/usr/bin:/bin:/usr/sbin:/sbin\"\nexport PATH=\"/usr/local/bin:/usr/local/sbin:$PATH\"\n```\n\n","source":"_posts/Mac下配置adb.md","raw":"---\ntitle: Mac下配置adb\ndate: 2017-07-13 21:10:42\ntags: Android\ncategories: Android\n---\n\n# 0x00 前言\n\nMac和windows一样，如果要在终端命令行全局使用非系统命令，需要手动把命令环境配置到指定文件中，具体操作就是把命令文件所属路径配置到.bash_profile里面。\n\n# 0x01 分别找到双方路径\n\n## 找到adb\n\n我是通过Android studio中的idk location找到SDK位置`/Users/jenson/Library/Android/sdk` .\n\n\n\n\n\n## 找到.bash_profile\n\n- 使用命令行`cd $home` 进入home路径下，\n\n- 因为mac下以点开头的文件为隐藏文件，所以使用`ls -al` 查看所有文件，查看列表是否有.bash_profile文件，\n\n- 如果没有，使用`touch .bash_profile` 创建，如果有则执行命令`open -e .bash_profile` 使用文本编辑器打开文件，\n\n- 在下面按格式添加SDK路径：\n\n  ```\n  export PATH=/Users/jenson/Library/Android/sdk/platform-tools:$PATH\n  export PATH=/Users/jenson/Library/Android/sdk/tools:$PATH\n  ```\n\n  ​\n\n## open -e .bash_profile提示open命令不存在\n\n通过Finder根据路径找到.bash_profile文件，编辑添加\n\n```\nexport PATH=\"/usr/bin:/bin:/usr/sbin:/sbin\"\nexport PATH=\"/usr/local/bin:/usr/local/sbin:$PATH\"\n```\n\n","slug":"Mac下配置adb","published":1,"updated":"2017-07-13T13:30:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjd80021wh9c6r3ht0zu","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Mac和windows一样，如果要在终端命令行全局使用非系统命令，需要手动把命令环境配置到指定文件中，具体操作就是把命令文件所属路径配置到.bash_profile里面。</p>\n<h1 id=\"0x01-分别找到双方路径\"><a href=\"#0x01-分别找到双方路径\" class=\"headerlink\" title=\"0x01 分别找到双方路径\"></a>0x01 分别找到双方路径</h1><h2 id=\"找到adb\"><a href=\"#找到adb\" class=\"headerlink\" title=\"找到adb\"></a>找到adb</h2><p>我是通过Android studio中的idk location找到SDK位置<code>/Users/jenson/Library/Android/sdk</code> .</p>\n<h2 id=\"找到-bash-profile\"><a href=\"#找到-bash-profile\" class=\"headerlink\" title=\"找到.bash_profile\"></a>找到.bash_profile</h2><ul>\n<li><p>使用命令行<code>cd $home</code> 进入home路径下，</p>\n</li>\n<li><p>因为mac下以点开头的文件为隐藏文件，所以使用<code>ls -al</code> 查看所有文件，查看列表是否有.bash_profile文件，</p>\n</li>\n<li><p>如果没有，使用<code>touch .bash_profile</code> 创建，如果有则执行命令<code>open -e .bash_profile</code> 使用文本编辑器打开文件，</p>\n</li>\n<li><p>在下面按格式添加SDK路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=/Users/jenson/Library/Android/sdk/platform-tools:$PATH</div><div class=\"line\">export PATH=/Users/jenson/Library/Android/sdk/tools:$PATH</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"open-e-bash-profile提示open命令不存在\"><a href=\"#open-e-bash-profile提示open命令不存在\" class=\"headerlink\" title=\"open -e .bash_profile提示open命令不存在\"></a>open -e .bash_profile提示open命令不存在</h2><p>通过Finder根据路径找到.bash_profile文件，编辑添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=&quot;/usr/bin:/bin:/usr/sbin:/sbin&quot;</div><div class=\"line\">export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Mac和windows一样，如果要在终端命令行全局使用非系统命令，需要手动把命令环境配置到指定文件中，具体操作就是把命令文件所属路径配置到.bash_profile里面。</p>\n<h1 id=\"0x01-分别找到双方路径\"><a href=\"#0x01-分别找到双方路径\" class=\"headerlink\" title=\"0x01 分别找到双方路径\"></a>0x01 分别找到双方路径</h1><h2 id=\"找到adb\"><a href=\"#找到adb\" class=\"headerlink\" title=\"找到adb\"></a>找到adb</h2><p>我是通过Android studio中的idk location找到SDK位置<code>/Users/jenson/Library/Android/sdk</code> .</p>\n<h2 id=\"找到-bash-profile\"><a href=\"#找到-bash-profile\" class=\"headerlink\" title=\"找到.bash_profile\"></a>找到.bash_profile</h2><ul>\n<li><p>使用命令行<code>cd $home</code> 进入home路径下，</p>\n</li>\n<li><p>因为mac下以点开头的文件为隐藏文件，所以使用<code>ls -al</code> 查看所有文件，查看列表是否有.bash_profile文件，</p>\n</li>\n<li><p>如果没有，使用<code>touch .bash_profile</code> 创建，如果有则执行命令<code>open -e .bash_profile</code> 使用文本编辑器打开文件，</p>\n</li>\n<li><p>在下面按格式添加SDK路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=/Users/jenson/Library/Android/sdk/platform-tools:$PATH</div><div class=\"line\">export PATH=/Users/jenson/Library/Android/sdk/tools:$PATH</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"open-e-bash-profile提示open命令不存在\"><a href=\"#open-e-bash-profile提示open命令不存在\" class=\"headerlink\" title=\"open -e .bash_profile提示open命令不存在\"></a>open -e .bash_profile提示open命令不存在</h2><p>通过Finder根据路径找到.bash_profile文件，编辑添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=&quot;/usr/bin:/bin:/usr/sbin:/sbin&quot;</div><div class=\"line\">export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot;</div></pre></td></tr></table></figure>\n"},{"title":"Mac系统下载文本都是打开都是乱码","date":"2017-07-29T10:58:43.000Z","_content":"\n# 前言\n\n系统升级后出现个问题，就是所有下载的文本文档打开时都出现了异常：\n\n![文本打开异常](http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8.png)\n\n\n\n\n\n# 解决\n\n在文本编辑的偏好中进行设置即可：\n\n![文本编辑偏好设置](http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE.png)\n\n","source":"_posts/Mac系统下载文本都是打开都是乱码.md","raw":"---\ntitle: Mac系统下载文本都是打开都是乱码\ndate: 2017-07-29 18:58:43\ntags: MAC\ncategories: MAC\n---\n\n# 前言\n\n系统升级后出现个问题，就是所有下载的文本文档打开时都出现了异常：\n\n![文本打开异常](http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8.png)\n\n\n\n\n\n# 解决\n\n在文本编辑的偏好中进行设置即可：\n\n![文本编辑偏好设置](http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE.png)\n\n","slug":"Mac系统下载文本都是打开都是乱码","published":1,"updated":"2017-08-02T11:10:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjda0024wh9cigvofhzo","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>系统升级后出现个问题，就是所有下载的文本文档打开时都出现了异常：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8.png\" alt=\"文本打开异常\"></p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>在文本编辑的偏好中进行设置即可：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE.png\" alt=\"文本编辑偏好设置\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>系统升级后出现个问题，就是所有下载的文本文档打开时都出现了异常：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8.png\" alt=\"文本打开异常\"></p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>在文本编辑的偏好中进行设置即可：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE.png\" alt=\"文本编辑偏好设置\"></p>\n"},{"title":"Android网络框架okhttp执行流程分析","date":"2017-05-09T16:58:46.000Z","_content":"\n# 说在前面的话\n\nAndroid开发中，网络框架okhttp可以说是越来越风光，Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp，能够被谷歌认可，足见okhttp的强大之处了。既如此还有什么理由不去深入理解下它呢？很惭愧，这么好的东西以前一直处于简单调用，今天有时间把流程看了一下，简单总结了下执行请求时的大概流程作为备忘。\n\n\n\n# 执行流程\n\n![流程](Android网络框架执行流程分析/流程.png)\n\n\n\n","source":"_posts/Android网络框架执行流程分析.md","raw":"---\ntitle: Android网络框架okhttp执行流程分析\ndate: 2017-05-10 00:58:46\ntags: Android\ncategories: Android\n---\n\n# 说在前面的话\n\nAndroid开发中，网络框架okhttp可以说是越来越风光，Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp，能够被谷歌认可，足见okhttp的强大之处了。既如此还有什么理由不去深入理解下它呢？很惭愧，这么好的东西以前一直处于简单调用，今天有时间把流程看了一下，简单总结了下执行请求时的大概流程作为备忘。\n\n\n\n# 执行流程\n\n![流程](Android网络框架执行流程分析/流程.png)\n\n\n\n","slug":"Android网络框架执行流程分析","published":1,"updated":"2017-05-09T17:10:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjdg0029wh9cxn6c7eus","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>Android开发中，网络框架okhttp可以说是越来越风光，Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp，能够被谷歌认可，足见okhttp的强大之处了。既如此还有什么理由不去深入理解下它呢？很惭愧，这么好的东西以前一直处于简单调用，今天有时间把流程看了一下，简单总结了下执行请求时的大概流程作为备忘。</p>\n<h1 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h1><p><img src=\"/2017/05/10/Android网络框架执行流程分析/流程.png\" alt=\"流程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>Android开发中，网络框架okhttp可以说是越来越风光，Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp，能够被谷歌认可，足见okhttp的强大之处了。既如此还有什么理由不去深入理解下它呢？很惭愧，这么好的东西以前一直处于简单调用，今天有时间把流程看了一下，简单总结了下执行请求时的大概流程作为备忘。</p>\n<h1 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h1><p><img src=\"/2017/05/10/Android网络框架执行流程分析/流程.png\" alt=\"流程\"></p>\n"},{"title":"Mac系统中希捷移动硬盘NTFS格式只能读","date":"2017-07-31T17:03:05.000Z","_content":"\n# 前言\n\n今天Mac系统更新完成后，希捷移动硬盘突然只能读不能写了。\n\n\n\n\n\n# 解决\n\nMac默认不支持NTFS格式，所以要想兼容需要安装[Paragon驱动](http://www.seagate.com/cn/zh/support/downloads/item/ntfs-driver-for-mac-os-master-dl/)。\n\n- 在开始安装前，确保硬盘连接至电脑。\n- 双击您下载的 **NTFS_for_Mac_14.0.456.dmg** 文件。\n- 按照屏幕提示完成安装。\n- 重启后即可读写硬盘","source":"_posts/Mac系统中希捷移动硬盘NTFS格式只能读.md","raw":"---\ntitle: Mac系统中希捷移动硬盘NTFS格式只能读\ndate: 2017-08-01 01:03:05\ntags: [Mac, 工具]\ncategories: [Mac, 工具]\n---\n\n# 前言\n\n今天Mac系统更新完成后，希捷移动硬盘突然只能读不能写了。\n\n\n\n\n\n# 解决\n\nMac默认不支持NTFS格式，所以要想兼容需要安装[Paragon驱动](http://www.seagate.com/cn/zh/support/downloads/item/ntfs-driver-for-mac-os-master-dl/)。\n\n- 在开始安装前，确保硬盘连接至电脑。\n- 双击您下载的 **NTFS_for_Mac_14.0.456.dmg** 文件。\n- 按照屏幕提示完成安装。\n- 重启后即可读写硬盘","slug":"Mac系统中希捷移动硬盘NTFS格式只能读","published":1,"updated":"2017-08-02T17:07:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjdj002cwh9c0eavtrpy","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>今天Mac系统更新完成后，希捷移动硬盘突然只能读不能写了。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>Mac默认不支持NTFS格式，所以要想兼容需要安装<a href=\"http://www.seagate.com/cn/zh/support/downloads/item/ntfs-driver-for-mac-os-master-dl/\" target=\"_blank\" rel=\"external\">Paragon驱动</a>。</p>\n<ul>\n<li>在开始安装前，确保硬盘连接至电脑。</li>\n<li>双击您下载的 <strong>NTFS_for_Mac_14.0.456.dmg</strong> 文件。</li>\n<li>按照屏幕提示完成安装。</li>\n<li>重启后即可读写硬盘</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>今天Mac系统更新完成后，希捷移动硬盘突然只能读不能写了。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>Mac默认不支持NTFS格式，所以要想兼容需要安装<a href=\"http://www.seagate.com/cn/zh/support/downloads/item/ntfs-driver-for-mac-os-master-dl/\">Paragon驱动</a>。</p>\n<ul>\n<li>在开始安装前，确保硬盘连接至电脑。</li>\n<li>双击您下载的 <strong>NTFS_for_Mac_14.0.456.dmg</strong> 文件。</li>\n<li>按照屏幕提示完成安装。</li>\n<li>重启后即可读写硬盘</li>\n</ul>\n"},{"title":"Mac终端光标变成粗体","date":"2017-07-01T05:46:51.000Z","_content":"\n打开终端偏好设置，勾选 竖条，闪动光标\n\n![设置光标](Mac终端光标变成粗体/设置光标.png)\n\n","source":"_posts/Mac终端光标变成粗体.md","raw":"---\ntitle: Mac终端光标变成粗体\ndate: 2017-07-1 13:46:51\ntags: 工具\ncategories: 工具\n---\n\n打开终端偏好设置，勾选 竖条，闪动光标\n\n![设置光标](Mac终端光标变成粗体/设置光标.png)\n\n","slug":"Mac终端光标变成粗体","published":1,"updated":"2017-07-19T05:49:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjdo002hwh9cieox1an1","content":"<p>打开终端偏好设置，勾选 竖条，闪动光标</p>\n<p><img src=\"/2017/07/01/Mac终端光标变成粗体/设置光标.png\" alt=\"设置光标\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>打开终端偏好设置，勾选 竖条，闪动光标</p>\n<p><img src=\"/2017/07/01/Mac终端光标变成粗体/设置光标.png\" alt=\"设置光标\"></p>\n"},{"title":"No resource identifier found for attribute 'roundIcon' in package 'android'","date":"2017-08-04T03:37:39.000Z","_content":"\n# 前言\n\nAndroid studio更新到2.3后创建项目时就出现了这个问题，我只要降低版本就出现编译异常信息：\n\n`No resource identifier found for attribute 'roundIcon' in package 'android'Ask Question`。\n\n这个**roundIcon**真是害人匪浅。\n\n而且也是感受到了天下文章一大抄的说法所言非虚。。\n\n只要搜出来的说法都是删掉`roundIcon`那个属性即可。\n\n可是我和其他网友都遇到了另一个问题：删除后再编译又会自动给添加上，而编译版本已经改为了5.0。\n\n# 解决\n\n- 简单做法\n\n如果只是因为没有为最新系统功能做好适配工作。那么可以把**targetSdkVersion**降回到所需版本，但保留**compileSdkVersion 26**编译版本最新。这是最简单做法，但是可能有一些过时API需要进行版本判断。\n\n- 我还想降低compileSdkVersion为20\n\n  当把**compileSdkVersion**降为20的时候，再次编译项目就出现了`Error:(11) No resource identifier found for attribute 'roundIcon' in package 'android'`。\n\n  这时想到还有构建版本还是26.0.0，然后也改为20.0.0了。再次编译\n\n  这时候仍然有异常，但是信息变了：`Error:The SDK Build Tools revision (20.0.0) is too low for project ':app'. Minimum required is 25.0.0\n  <a href=\"fix.build.tools.version\">Update Build Tools version and sync project</a><br><a href=\"openFile:/Users/jenson/AndroidStudioProjects/CanvasTest/app/build.gradle\">Open File</a>`。\n\n  这是一个好兆头，说明我们的对手变了。我现在要做的就是让项目认可低版本的bt(build tool)。\n\n  这条异常是由：Gradle sync发出的。所以异常和Gradle有关，那现在问题矛头指向Gradle，而Gradle又有Gradle版本和插件版本，\n\n  **会不会是版本太新缘故，毕竟谷歌老喜欢搞新花样，所以现在的想法是回退到一个合适的版本。**\n  目前版本是**gradle-3.3-all**和**com.android.tools.build:gradle:2.3.3**\n\n  现在使用**gradle-3.0-all**和**com.android.tools.build:gradle:2.2.0**\n\n  从新编译时出现了如下弹窗：\n\n  ![gradle版本升级弹窗](http://othg5ggzi.bkt.clouddn.com/gradle%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8F%90%E7%A4%BA%E5%BC%B9%E7%AA%97.png)\n\n\n\n​\t说明两个版本在匹配范围内，获得初步成功，但是编译完成时再次提示了**roundIcon**，然后这次把**属性删掉**，同时**clean project**。\n\n然后又出现了如下异常信息：\n\nError:In <declare-styleable> ConstraintSet, unable to find attribute android:elevation\n\n这可能是由于把compileSdkVersion设置20，有点太低了得缘故。\n\n既然如此，干脆一不做二不休，进入布局文件把**android.support.constraint.ConstraintLayout**布局替换为其他布局。同时删除该类用到的一些属性，譬如：\n\n```\napp:layout_constraintBottom_toBottomOf=\"parent\"\napp:layout_constraintLeft_toLeftOf=\"parent\"\napp:layout_constraintRight_toRightOf=\"parent\"\napp:layout_constraintTop_toTopOf=\"parent\"\n```\n\n斩草要除根，把依赖包也干脆去掉：\n\n删除**compile 'com.android.support.constraint:constraint-layout:1.0.2'**\n\n\n\n最最最后clean project，各种build后没有终于恢复正常了。。。。\n\n\n\n> 提示：每次升级前注意下当前Gradle版本是多少，对应的Plugin版本又是多少，如果升级后有问题，可以方便的回退。\n\n\n\ngradle本地：\n\n```\ndistributionUrl=file:/Users/jenson/.gradle/wrapper/dists/gradle-3.0-all.zip\n```","source":"_posts/No-resource-identifier-found-for-attribute-roundIcon-in-package-android.md","raw":"---\ntitle: No resource identifier found for attribute 'roundIcon' in package 'android'\ndate: 2017-08-04 11:37:39\ntags: Android\ncategories: Android\n---\n\n# 前言\n\nAndroid studio更新到2.3后创建项目时就出现了这个问题，我只要降低版本就出现编译异常信息：\n\n`No resource identifier found for attribute 'roundIcon' in package 'android'Ask Question`。\n\n这个**roundIcon**真是害人匪浅。\n\n而且也是感受到了天下文章一大抄的说法所言非虚。。\n\n只要搜出来的说法都是删掉`roundIcon`那个属性即可。\n\n可是我和其他网友都遇到了另一个问题：删除后再编译又会自动给添加上，而编译版本已经改为了5.0。\n\n# 解决\n\n- 简单做法\n\n如果只是因为没有为最新系统功能做好适配工作。那么可以把**targetSdkVersion**降回到所需版本，但保留**compileSdkVersion 26**编译版本最新。这是最简单做法，但是可能有一些过时API需要进行版本判断。\n\n- 我还想降低compileSdkVersion为20\n\n  当把**compileSdkVersion**降为20的时候，再次编译项目就出现了`Error:(11) No resource identifier found for attribute 'roundIcon' in package 'android'`。\n\n  这时想到还有构建版本还是26.0.0，然后也改为20.0.0了。再次编译\n\n  这时候仍然有异常，但是信息变了：`Error:The SDK Build Tools revision (20.0.0) is too low for project ':app'. Minimum required is 25.0.0\n  <a href=\"fix.build.tools.version\">Update Build Tools version and sync project</a><br><a href=\"openFile:/Users/jenson/AndroidStudioProjects/CanvasTest/app/build.gradle\">Open File</a>`。\n\n  这是一个好兆头，说明我们的对手变了。我现在要做的就是让项目认可低版本的bt(build tool)。\n\n  这条异常是由：Gradle sync发出的。所以异常和Gradle有关，那现在问题矛头指向Gradle，而Gradle又有Gradle版本和插件版本，\n\n  **会不会是版本太新缘故，毕竟谷歌老喜欢搞新花样，所以现在的想法是回退到一个合适的版本。**\n  目前版本是**gradle-3.3-all**和**com.android.tools.build:gradle:2.3.3**\n\n  现在使用**gradle-3.0-all**和**com.android.tools.build:gradle:2.2.0**\n\n  从新编译时出现了如下弹窗：\n\n  ![gradle版本升级弹窗](http://othg5ggzi.bkt.clouddn.com/gradle%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8F%90%E7%A4%BA%E5%BC%B9%E7%AA%97.png)\n\n\n\n​\t说明两个版本在匹配范围内，获得初步成功，但是编译完成时再次提示了**roundIcon**，然后这次把**属性删掉**，同时**clean project**。\n\n然后又出现了如下异常信息：\n\nError:In <declare-styleable> ConstraintSet, unable to find attribute android:elevation\n\n这可能是由于把compileSdkVersion设置20，有点太低了得缘故。\n\n既然如此，干脆一不做二不休，进入布局文件把**android.support.constraint.ConstraintLayout**布局替换为其他布局。同时删除该类用到的一些属性，譬如：\n\n```\napp:layout_constraintBottom_toBottomOf=\"parent\"\napp:layout_constraintLeft_toLeftOf=\"parent\"\napp:layout_constraintRight_toRightOf=\"parent\"\napp:layout_constraintTop_toTopOf=\"parent\"\n```\n\n斩草要除根，把依赖包也干脆去掉：\n\n删除**compile 'com.android.support.constraint:constraint-layout:1.0.2'**\n\n\n\n最最最后clean project，各种build后没有终于恢复正常了。。。。\n\n\n\n> 提示：每次升级前注意下当前Gradle版本是多少，对应的Plugin版本又是多少，如果升级后有问题，可以方便的回退。\n\n\n\ngradle本地：\n\n```\ndistributionUrl=file:/Users/jenson/.gradle/wrapper/dists/gradle-3.0-all.zip\n```","slug":"No-resource-identifier-found-for-attribute-roundIcon-in-package-android","published":1,"updated":"2017-08-08T05:52:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjdr002kwh9c3zcfeyl5","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Android studio更新到2.3后创建项目时就出现了这个问题，我只要降低版本就出现编译异常信息：</p>\n<p><code>No resource identifier found for attribute &#39;roundIcon&#39; in package &#39;android&#39;Ask Question</code>。</p>\n<p>这个<strong>roundIcon</strong>真是害人匪浅。</p>\n<p>而且也是感受到了天下文章一大抄的说法所言非虚。。</p>\n<p>只要搜出来的说法都是删掉<code>roundIcon</code>那个属性即可。</p>\n<p>可是我和其他网友都遇到了另一个问题：删除后再编译又会自动给添加上，而编译版本已经改为了5.0。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><ul>\n<li>简单做法</li>\n</ul>\n<p>如果只是因为没有为最新系统功能做好适配工作。那么可以把<strong>targetSdkVersion</strong>降回到所需版本，但保留<strong>compileSdkVersion 26</strong>编译版本最新。这是最简单做法，但是可能有一些过时API需要进行版本判断。</p>\n<ul>\n<li><p>我还想降低compileSdkVersion为20</p>\n<p>当把<strong>compileSdkVersion</strong>降为20的时候，再次编译项目就出现了<code>Error:(11) No resource identifier found for attribute &#39;roundIcon&#39; in package &#39;android&#39;</code>。</p>\n<p>这时想到还有构建版本还是26.0.0，然后也改为20.0.0了。再次编译</p>\n<p>这时候仍然有异常，但是信息变了：<code>Error:The SDK Build Tools revision (20.0.0) is too low for project &#39;:app&#39;. Minimum required is 25.0.0\n&lt;a href=&quot;fix.build.tools.version&quot;&gt;Update Build Tools version and sync project&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;openFile:/Users/jenson/AndroidStudioProjects/CanvasTest/app/build.gradle&quot;&gt;Open File&lt;/a&gt;</code>。</p>\n<p>这是一个好兆头，说明我们的对手变了。我现在要做的就是让项目认可低版本的bt(build tool)。</p>\n<p>这条异常是由：Gradle sync发出的。所以异常和Gradle有关，那现在问题矛头指向Gradle，而Gradle又有Gradle版本和插件版本，</p>\n<p><strong>会不会是版本太新缘故，毕竟谷歌老喜欢搞新花样，所以现在的想法是回退到一个合适的版本。</strong><br>目前版本是<strong>gradle-3.3-all</strong>和<strong>com.android.tools.build:gradle:2.3.3</strong></p>\n<p>现在使用<strong>gradle-3.0-all</strong>和<strong>com.android.tools.build:gradle:2.2.0</strong></p>\n<p>从新编译时出现了如下弹窗：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/gradle%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8F%90%E7%A4%BA%E5%BC%B9%E7%AA%97.png\" alt=\"gradle版本升级弹窗\"></p>\n</li>\n</ul>\n<p>​    说明两个版本在匹配范围内，获得初步成功，但是编译完成时再次提示了<strong>roundIcon</strong>，然后这次把<strong>属性删掉</strong>，同时<strong>clean project</strong>。</p>\n<p>然后又出现了如下异常信息：</p>\n<p>Error:In <declare-styleable> ConstraintSet, unable to find attribute android:elevation</declare-styleable></p>\n<p>这可能是由于把compileSdkVersion设置20，有点太低了得缘故。</p>\n<p>既然如此，干脆一不做二不休，进入布局文件把<strong>android.support.constraint.ConstraintLayout</strong>布局替换为其他布局。同时删除该类用到的一些属性，譬如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</div><div class=\"line\">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</div><div class=\"line\">app:layout_constraintRight_toRightOf=&quot;parent&quot;</div><div class=\"line\">app:layout_constraintTop_toTopOf=&quot;parent&quot;</div></pre></td></tr></table></figure>\n<p>斩草要除根，把依赖包也干脆去掉：</p>\n<p>删除<strong>compile ‘com.android.support.constraint:constraint-layout:1.0.2’</strong></p>\n<p>最最最后clean project，各种build后没有终于恢复正常了。。。。</p>\n<blockquote>\n<p>提示：每次升级前注意下当前Gradle版本是多少，对应的Plugin版本又是多少，如果升级后有问题，可以方便的回退。</p>\n</blockquote>\n<p>gradle本地：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">distributionUrl=file:/Users/jenson/.gradle/wrapper/dists/gradle-3.0-all.zip</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Android studio更新到2.3后创建项目时就出现了这个问题，我只要降低版本就出现编译异常信息：</p>\n<p><code>No resource identifier found for attribute &#39;roundIcon&#39; in package &#39;android&#39;Ask Question</code>。</p>\n<p>这个<strong>roundIcon</strong>真是害人匪浅。</p>\n<p>而且也是感受到了天下文章一大抄的说法所言非虚。。</p>\n<p>只要搜出来的说法都是删掉<code>roundIcon</code>那个属性即可。</p>\n<p>可是我和其他网友都遇到了另一个问题：删除后再编译又会自动给添加上，而编译版本已经改为了5.0。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><ul>\n<li>简单做法</li>\n</ul>\n<p>如果只是因为没有为最新系统功能做好适配工作。那么可以把<strong>targetSdkVersion</strong>降回到所需版本，但保留<strong>compileSdkVersion 26</strong>编译版本最新。这是最简单做法，但是可能有一些过时API需要进行版本判断。</p>\n<ul>\n<li><p>我还想降低compileSdkVersion为20</p>\n<p>当把<strong>compileSdkVersion</strong>降为20的时候，再次编译项目就出现了<code>Error:(11) No resource identifier found for attribute &#39;roundIcon&#39; in package &#39;android&#39;</code>。</p>\n<p>这时想到还有构建版本还是26.0.0，然后也改为20.0.0了。再次编译</p>\n<p>这时候仍然有异常，但是信息变了：<code>Error:The SDK Build Tools revision (20.0.0) is too low for project &#39;:app&#39;. Minimum required is 25.0.0\n&lt;a href=&quot;fix.build.tools.version&quot;&gt;Update Build Tools version and sync project&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;openFile:/Users/jenson/AndroidStudioProjects/CanvasTest/app/build.gradle&quot;&gt;Open File&lt;/a&gt;</code>。</p>\n<p>这是一个好兆头，说明我们的对手变了。我现在要做的就是让项目认可低版本的bt(build tool)。</p>\n<p>这条异常是由：Gradle sync发出的。所以异常和Gradle有关，那现在问题矛头指向Gradle，而Gradle又有Gradle版本和插件版本，</p>\n<p><strong>会不会是版本太新缘故，毕竟谷歌老喜欢搞新花样，所以现在的想法是回退到一个合适的版本。</strong><br>目前版本是<strong>gradle-3.3-all</strong>和<strong>com.android.tools.build:gradle:2.3.3</strong></p>\n<p>现在使用<strong>gradle-3.0-all</strong>和<strong>com.android.tools.build:gradle:2.2.0</strong></p>\n<p>从新编译时出现了如下弹窗：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/gradle%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8F%90%E7%A4%BA%E5%BC%B9%E7%AA%97.png\" alt=\"gradle版本升级弹窗\"></p>\n</li>\n</ul>\n<p>​    说明两个版本在匹配范围内，获得初步成功，但是编译完成时再次提示了<strong>roundIcon</strong>，然后这次把<strong>属性删掉</strong>，同时<strong>clean project</strong>。</p>\n<p>然后又出现了如下异常信息：</p>\n<p>Error:In <declare-styleable> ConstraintSet, unable to find attribute android:elevation</declare-styleable></p>\n<p>这可能是由于把compileSdkVersion设置20，有点太低了得缘故。</p>\n<p>既然如此，干脆一不做二不休，进入布局文件把<strong>android.support.constraint.ConstraintLayout</strong>布局替换为其他布局。同时删除该类用到的一些属性，譬如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</div><div class=\"line\">app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</div><div class=\"line\">app:layout_constraintRight_toRightOf=&quot;parent&quot;</div><div class=\"line\">app:layout_constraintTop_toTopOf=&quot;parent&quot;</div></pre></td></tr></table></figure>\n<p>斩草要除根，把依赖包也干脆去掉：</p>\n<p>删除<strong>compile ‘com.android.support.constraint:constraint-layout:1.0.2’</strong></p>\n<p>最最最后clean project，各种build后没有终于恢复正常了。。。。</p>\n<blockquote>\n<p>提示：每次升级前注意下当前Gradle版本是多少，对应的Plugin版本又是多少，如果升级后有问题，可以方便的回退。</p>\n</blockquote>\n<p>gradle本地：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">distributionUrl=file:/Users/jenson/.gradle/wrapper/dists/gradle-3.0-all.zip</div></pre></td></tr></table></figure>"},{"title":"Python中_和__有什么意义?","date":"2017-08-08T14:35:40.000Z","_content":"\n# 前言\n\npython中很多源码都是由单下划线和双下划线开头的函数、变量、模块。\n\n但是一直不太明白这表示什么意思。然后因为好奇就查了下资料才才明白怎么回事。\n\n\n\n# 了解\n\n## 单下划线（_）\n\n以**单下划线**开头的名字都应该是内部实现.\n\n函数以单下划线开头说明这是一个特殊函数或者认为是一个隐藏函数，作为一个内部方法，只能被本模块代码使用。\n\nPython没有强制依赖于语言特性去达到封装数据目的，而是通过归约。而这里的下划线就是归约。\n\n> Python 并不会真的阻止别人访问内部名称。但是如果你这么做肯定是不好的，可能会导致脆弱的代码。同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数。\n\n\n\n## 双下划线（__）\n\n使用双下划线开始会导致访问名称变成其他形式。这种以双下划线开头的函数不会被通过类继承覆盖。\n\nPython文档指出，“__spam”这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被“_classname__spam”这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。\n\n```python\nclass B:\n    def __init__(self):\n        self.__private = 0\n\n    def __private_method(self):\n        print('b___private_method')\n\n\n    def public_method(self):\n        self.__private_method()\n\n    def getPrivateValue(self):\n        return self.__private\n\nclass C(B):\n    def __init__(self):\n        super().__init__()\n        self.__private = 1\n\n    def __private_method(self):\n        print('c___private_method')\n\n    def getPrivateValue(self):\n        return self.__private\n\n\nc = C()\nc.public_method()\n# print(c.getPrivateValue())\n\n```\n\n上面代码执行后结果如下：\n\n```\nb___private_method\n\nProcess finished with exit code 0\n```\n\n可以看到打印的时B类中方法，而不是C类方法，说明虽然这两个方法方法名一样，但是没有被重写。\n\n## 前后双下划线\n\n这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“__init__”方法。\n\n","source":"_posts/Python中-和-有什么意义.md","raw":"---\ntitle: Python中_和__有什么意义?\ndate: 2017-08-08 22:35:40\ntags: Python\ncategories: Python\n---\n\n# 前言\n\npython中很多源码都是由单下划线和双下划线开头的函数、变量、模块。\n\n但是一直不太明白这表示什么意思。然后因为好奇就查了下资料才才明白怎么回事。\n\n\n\n# 了解\n\n## 单下划线（_）\n\n以**单下划线**开头的名字都应该是内部实现.\n\n函数以单下划线开头说明这是一个特殊函数或者认为是一个隐藏函数，作为一个内部方法，只能被本模块代码使用。\n\nPython没有强制依赖于语言特性去达到封装数据目的，而是通过归约。而这里的下划线就是归约。\n\n> Python 并不会真的阻止别人访问内部名称。但是如果你这么做肯定是不好的，可能会导致脆弱的代码。同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数。\n\n\n\n## 双下划线（__）\n\n使用双下划线开始会导致访问名称变成其他形式。这种以双下划线开头的函数不会被通过类继承覆盖。\n\nPython文档指出，“__spam”这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被“_classname__spam”这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。\n\n```python\nclass B:\n    def __init__(self):\n        self.__private = 0\n\n    def __private_method(self):\n        print('b___private_method')\n\n\n    def public_method(self):\n        self.__private_method()\n\n    def getPrivateValue(self):\n        return self.__private\n\nclass C(B):\n    def __init__(self):\n        super().__init__()\n        self.__private = 1\n\n    def __private_method(self):\n        print('c___private_method')\n\n    def getPrivateValue(self):\n        return self.__private\n\n\nc = C()\nc.public_method()\n# print(c.getPrivateValue())\n\n```\n\n上面代码执行后结果如下：\n\n```\nb___private_method\n\nProcess finished with exit code 0\n```\n\n可以看到打印的时B类中方法，而不是C类方法，说明虽然这两个方法方法名一样，但是没有被重写。\n\n## 前后双下划线\n\n这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“__init__”方法。\n\n","slug":"Python中-和-有什么意义","published":1,"updated":"2017-08-08T15:42:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjdw002pwh9cyyq023rd","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>python中很多源码都是由单下划线和双下划线开头的函数、变量、模块。</p>\n<p>但是一直不太明白这表示什么意思。然后因为好奇就查了下资料才才明白怎么回事。</p>\n<h1 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h1><h2 id=\"单下划线（-）\"><a href=\"#单下划线（-）\" class=\"headerlink\" title=\"单下划线（_）\"></a>单下划线（_）</h2><p>以<strong>单下划线</strong>开头的名字都应该是内部实现.</p>\n<p>函数以单下划线开头说明这是一个特殊函数或者认为是一个隐藏函数，作为一个内部方法，只能被本模块代码使用。</p>\n<p>Python没有强制依赖于语言特性去达到封装数据目的，而是通过归约。而这里的下划线就是归约。</p>\n<blockquote>\n<p>Python 并不会真的阻止别人访问内部名称。但是如果你这么做肯定是不好的，可能会导致脆弱的代码。同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数。</p>\n</blockquote>\n<h2 id=\"双下划线（-）\"><a href=\"#双下划线（-）\" class=\"headerlink\" title=\"双下划线（__）\"></a>双下划线（__）</h2><p>使用双下划线开始会导致访问名称变成其他形式。这种以双下划线开头的函数不会被通过类继承覆盖。</p>\n<p>Python文档指出，“<strong>spam”这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被“_classname</strong>spam”这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.__private = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__private_method</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'b___private_method'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">public_method</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.__private_method()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPrivateValue</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self.__private</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(B)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.__private = <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__private_method</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'c___private_method'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPrivateValue</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self.__private</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">c = C()</div><div class=\"line\">c.public_method()</div><div class=\"line\"><span class=\"comment\"># print(c.getPrivateValue())</span></div></pre></td></tr></table></figure>\n<p>上面代码执行后结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">b___private_method</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code 0</div></pre></td></tr></table></figure>\n<p>可以看到打印的时B类中方法，而不是C类方法，说明虽然这两个方法方法名一样，但是没有被重写。</p>\n<h2 id=\"前后双下划线\"><a href=\"#前后双下划线\" class=\"headerlink\" title=\"前后双下划线\"></a>前后双下划线</h2><p>这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“<strong>init</strong>”方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>python中很多源码都是由单下划线和双下划线开头的函数、变量、模块。</p>\n<p>但是一直不太明白这表示什么意思。然后因为好奇就查了下资料才才明白怎么回事。</p>\n<h1 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h1><h2 id=\"单下划线（-）\"><a href=\"#单下划线（-）\" class=\"headerlink\" title=\"单下划线（_）\"></a>单下划线（_）</h2><p>以<strong>单下划线</strong>开头的名字都应该是内部实现.</p>\n<p>函数以单下划线开头说明这是一个特殊函数或者认为是一个隐藏函数，作为一个内部方法，只能被本模块代码使用。</p>\n<p>Python没有强制依赖于语言特性去达到封装数据目的，而是通过归约。而这里的下划线就是归约。</p>\n<blockquote>\n<p>Python 并不会真的阻止别人访问内部名称。但是如果你这么做肯定是不好的，可能会导致脆弱的代码。同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数。</p>\n</blockquote>\n<h2 id=\"双下划线（-）\"><a href=\"#双下划线（-）\" class=\"headerlink\" title=\"双下划线（__）\"></a>双下划线（__）</h2><p>使用双下划线开始会导致访问名称变成其他形式。这种以双下划线开头的函数不会被通过类继承覆盖。</p>\n<p>Python文档指出，“<strong>spam”这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被“_classname</strong>spam”这种形式原文取代，在这里“classname”是去掉前导下划线的当前类名。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.__private = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__private_method</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'b___private_method'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">public_method</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.__private_method()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPrivateValue</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self.__private</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(B)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super().__init__()</div><div class=\"line\">        self.__private = <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__private_method</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'c___private_method'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPrivateValue</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self.__private</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">c = C()</div><div class=\"line\">c.public_method()</div><div class=\"line\"><span class=\"comment\"># print(c.getPrivateValue())</span></div></pre></td></tr></table></figure>\n<p>上面代码执行后结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">b___private_method</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code 0</div></pre></td></tr></table></figure>\n<p>可以看到打印的时B类中方法，而不是C类方法，说明虽然这两个方法方法名一样，但是没有被重写。</p>\n<h2 id=\"前后双下划线\"><a href=\"#前后双下划线\" class=\"headerlink\" title=\"前后双下划线\"></a>前后双下划线</h2><p>这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“<strong>init</strong>”方法。</p>\n"},{"title":"Python入门系列(0):OSX系统下Python3的配置与安装","date":"2017-04-22T10:55:54.000Z","_content":"# 关于Python默认安装的问题\n在Linux和osx中都默认集成了Python，这时我们要查看集成的版本是不是我们需要的3.x。如果是，那么恭喜你不用往下看了，如果不是请继续。\n如何查看Python版本呢？打开终端输入如下命令即可：\n```\npython --version\n```\n\n![屏幕快照 2017-01-06 下午6.45.53.png](http://upload-images.jianshu.io/upload_images/1796052-8911115b3e35e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到我的系统默认的版本是2.7.10，看来还是需要安装3.x的。咱门继续\n\n# Python3下载与安装\n\n先附上[python3.6](https://www.python.org/ftp/python/3.6.0/python-3.6.0-macosx10.6.pkg)下载地址。\n下载完成直接点击安装即可，一直点击继续或者同意操作，直到出现如下界面：\n\n![屏幕快照 2017-01-06 下午6.10.33.png](http://upload-images.jianshu.io/upload_images/1796052-79c9c599a48d6f23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n关闭安装窗口，如果此时已经打开了terminal终端需要重新启动，来使刚才的安装生效(*osx下Python安装后不需要配置类似jdk的环境变量*)\n需要注意一点的是 2.x版本使用Python命令，在3.x下需要在后加上3\n\n```\npython3 --version\n```\n\n查看输出结果，发现已经能识别出3.x版本，至此Python3安装完毕。\n\n![屏幕快照 2017-01-06 下午7.01.29.png](http://upload-images.jianshu.io/upload_images/1796052-ec941e46202d0d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/Python入门系列(0) OSX系统下Python3的配置与安装.md","raw":"---\ntitle: Python入门系列(0):OSX系统下Python3的配置与安装\ndate: 2017-04-22 18:55:54\ntags: Python\ncategories: Python\n---\n# 关于Python默认安装的问题\n在Linux和osx中都默认集成了Python，这时我们要查看集成的版本是不是我们需要的3.x。如果是，那么恭喜你不用往下看了，如果不是请继续。\n如何查看Python版本呢？打开终端输入如下命令即可：\n```\npython --version\n```\n\n![屏幕快照 2017-01-06 下午6.45.53.png](http://upload-images.jianshu.io/upload_images/1796052-8911115b3e35e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到我的系统默认的版本是2.7.10，看来还是需要安装3.x的。咱门继续\n\n# Python3下载与安装\n\n先附上[python3.6](https://www.python.org/ftp/python/3.6.0/python-3.6.0-macosx10.6.pkg)下载地址。\n下载完成直接点击安装即可，一直点击继续或者同意操作，直到出现如下界面：\n\n![屏幕快照 2017-01-06 下午6.10.33.png](http://upload-images.jianshu.io/upload_images/1796052-79c9c599a48d6f23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n关闭安装窗口，如果此时已经打开了terminal终端需要重新启动，来使刚才的安装生效(*osx下Python安装后不需要配置类似jdk的环境变量*)\n需要注意一点的是 2.x版本使用Python命令，在3.x下需要在后加上3\n\n```\npython3 --version\n```\n\n查看输出结果，发现已经能识别出3.x版本，至此Python3安装完毕。\n\n![屏幕快照 2017-01-06 下午7.01.29.png](http://upload-images.jianshu.io/upload_images/1796052-ec941e46202d0d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"Python入门系列(0) OSX系统下Python3的配置与安装","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjdy002swh9cr9ry1c5g","content":"<h1 id=\"关于Python默认安装的问题\"><a href=\"#关于Python默认安装的问题\" class=\"headerlink\" title=\"关于Python默认安装的问题\"></a>关于Python默认安装的问题</h1><p>在Linux和osx中都默认集成了Python，这时我们要查看集成的版本是不是我们需要的3.x。如果是，那么恭喜你不用往下看了，如果不是请继续。<br>如何查看Python版本呢？打开终端输入如下命令即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python --version</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-8911115b3e35e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午6.45.53.png\"></p>\n<p>可以看到我的系统默认的版本是2.7.10，看来还是需要安装3.x的。咱门继续</p>\n<h1 id=\"Python3下载与安装\"><a href=\"#Python3下载与安装\" class=\"headerlink\" title=\"Python3下载与安装\"></a>Python3下载与安装</h1><p>先附上<a href=\"https://www.python.org/ftp/python/3.6.0/python-3.6.0-macosx10.6.pkg\" target=\"_blank\" rel=\"external\">python3.6</a>下载地址。<br>下载完成直接点击安装即可，一直点击继续或者同意操作，直到出现如下界面：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-79c9c599a48d6f23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午6.10.33.png\"></p>\n<p>关闭安装窗口，如果此时已经打开了terminal终端需要重新启动，来使刚才的安装生效(<em>osx下Python安装后不需要配置类似jdk的环境变量</em>)<br>需要注意一点的是 2.x版本使用Python命令，在3.x下需要在后加上3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python3 --version</div></pre></td></tr></table></figure>\n<p>查看输出结果，发现已经能识别出3.x版本，至此Python3安装完毕。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-ec941e46202d0d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午7.01.29.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于Python默认安装的问题\"><a href=\"#关于Python默认安装的问题\" class=\"headerlink\" title=\"关于Python默认安装的问题\"></a>关于Python默认安装的问题</h1><p>在Linux和osx中都默认集成了Python，这时我们要查看集成的版本是不是我们需要的3.x。如果是，那么恭喜你不用往下看了，如果不是请继续。<br>如何查看Python版本呢？打开终端输入如下命令即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python --version</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-8911115b3e35e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午6.45.53.png\"></p>\n<p>可以看到我的系统默认的版本是2.7.10，看来还是需要安装3.x的。咱门继续</p>\n<h1 id=\"Python3下载与安装\"><a href=\"#Python3下载与安装\" class=\"headerlink\" title=\"Python3下载与安装\"></a>Python3下载与安装</h1><p>先附上<a href=\"https://www.python.org/ftp/python/3.6.0/python-3.6.0-macosx10.6.pkg\">python3.6</a>下载地址。<br>下载完成直接点击安装即可，一直点击继续或者同意操作，直到出现如下界面：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-79c9c599a48d6f23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午6.10.33.png\"></p>\n<p>关闭安装窗口，如果此时已经打开了terminal终端需要重新启动，来使刚才的安装生效(<em>osx下Python安装后不需要配置类似jdk的环境变量</em>)<br>需要注意一点的是 2.x版本使用Python命令，在3.x下需要在后加上3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python3 --version</div></pre></td></tr></table></figure>\n<p>查看输出结果，发现已经能识别出3.x版本，至此Python3安装完毕。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-ec941e46202d0d97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午7.01.29.png\"></p>\n"},{"title":"Python入门系列(1):如何使用Sublime text开发Python","date":"2017-04-22T10:55:54.000Z","_content":"# 下载并安装Sublime text3\n点击下载[osx版](https://download.sublimetext.com/Sublime%20Text%20Build%203126.dmg)直接安装即可。\n如果需要其他系统版本请移步[这里](http://www.sublimetext.com/3)\n安装完成，在launcher启动Sublime\n\n![屏幕快照 2017-01-06 下午8.32.28.png](http://upload-images.jianshu.io/upload_images/1796052-c2bc5a099511d506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 配置Python3的编译环境\n-  找到Python3的安装路径\n终端中输入命令\n\n``` type -a python3 ```\n\n可以看到结果\n\n![屏幕快照 2017-01-06 下午8.37.07.png](http://upload-images.jianshu.io/upload_images/1796052-01e91620f87d697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n复制路径```/Library/Frameworks/Python.framework/Versions/3.5/bin/python3```\n\n- 配置Sublime\n  打开Sublime->Tools->build system->new build system \n如下图可以看到列表里面已经有了Python编译环境，但这是针对Python2.x的版本的，需要我们手动添加3.x版本。\n\n![屏幕快照 2017-01-06 下午8.41.06.png](http://upload-images.jianshu.io/upload_images/1796052-8353a6ec526679ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击new build system 后的窗口如下图：\n\n![屏幕快照 2017-01-06 下午8.46.29.png](http://upload-images.jianshu.io/upload_images/1796052-e855b34a3025e14a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将其修改为\n```\n{\n\"cmd\": [\"之前得到的python3路径\",\"-u\",\"$file\"],\n}\n```\n\n然后点击save as保存为```Python3.sublime-build```\n此时再次查看build system列表发现Python3已经出现了，至此Sublime的Python3编译环境已经完成。\n\n![屏幕快照 2017-01-06 下午8.51.22.png](http://upload-images.jianshu.io/upload_images/1796052-81e3e153c615759e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 开始我们的第一个程序hello Python！\n- 新建工作目录\n桌面新建一个名为python_work的文件夹，用来存放python文件\n- 新建文件\n使用Sublime-->new file 新建一个空文件保存到刚才创建的python_work中，命名为hello_python.py 。(*这里命名时加了.py后缀是告诉Sublime说我这个文件是python程序，这样在编写时候会给出关键字的颜色标示，并且 编译时候会使用python编译环境*)\n\n- 打印hello python\n\n```\nprint(\"hello python!\")\n```\n\n编写完代码保存，command+B执行编译\n\n![屏幕快照 2017-01-06 下午9.03.31.png](http://upload-images.jianshu.io/upload_images/1796052-a4f30b1ba7ac0f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n本节完成。","source":"_posts/Python入门系列(1) 如何使用Sublime text开发Python.md","raw":"---\ntitle: Python入门系列(1):如何使用Sublime text开发Python\ndate: 2017-04-22 18:55:54\ntags: Python\ncategories: Python\n---\n# 下载并安装Sublime text3\n点击下载[osx版](https://download.sublimetext.com/Sublime%20Text%20Build%203126.dmg)直接安装即可。\n如果需要其他系统版本请移步[这里](http://www.sublimetext.com/3)\n安装完成，在launcher启动Sublime\n\n![屏幕快照 2017-01-06 下午8.32.28.png](http://upload-images.jianshu.io/upload_images/1796052-c2bc5a099511d506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 配置Python3的编译环境\n-  找到Python3的安装路径\n终端中输入命令\n\n``` type -a python3 ```\n\n可以看到结果\n\n![屏幕快照 2017-01-06 下午8.37.07.png](http://upload-images.jianshu.io/upload_images/1796052-01e91620f87d697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n复制路径```/Library/Frameworks/Python.framework/Versions/3.5/bin/python3```\n\n- 配置Sublime\n  打开Sublime->Tools->build system->new build system \n如下图可以看到列表里面已经有了Python编译环境，但这是针对Python2.x的版本的，需要我们手动添加3.x版本。\n\n![屏幕快照 2017-01-06 下午8.41.06.png](http://upload-images.jianshu.io/upload_images/1796052-8353a6ec526679ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击new build system 后的窗口如下图：\n\n![屏幕快照 2017-01-06 下午8.46.29.png](http://upload-images.jianshu.io/upload_images/1796052-e855b34a3025e14a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将其修改为\n```\n{\n\"cmd\": [\"之前得到的python3路径\",\"-u\",\"$file\"],\n}\n```\n\n然后点击save as保存为```Python3.sublime-build```\n此时再次查看build system列表发现Python3已经出现了，至此Sublime的Python3编译环境已经完成。\n\n![屏幕快照 2017-01-06 下午8.51.22.png](http://upload-images.jianshu.io/upload_images/1796052-81e3e153c615759e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 开始我们的第一个程序hello Python！\n- 新建工作目录\n桌面新建一个名为python_work的文件夹，用来存放python文件\n- 新建文件\n使用Sublime-->new file 新建一个空文件保存到刚才创建的python_work中，命名为hello_python.py 。(*这里命名时加了.py后缀是告诉Sublime说我这个文件是python程序，这样在编写时候会给出关键字的颜色标示，并且 编译时候会使用python编译环境*)\n\n- 打印hello python\n\n```\nprint(\"hello python!\")\n```\n\n编写完代码保存，command+B执行编译\n\n![屏幕快照 2017-01-06 下午9.03.31.png](http://upload-images.jianshu.io/upload_images/1796052-a4f30b1ba7ac0f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n本节完成。","slug":"Python入门系列(1) 如何使用Sublime text开发Python","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwje1002xwh9cdy6cs4hc","content":"<h1 id=\"下载并安装Sublime-text3\"><a href=\"#下载并安装Sublime-text3\" class=\"headerlink\" title=\"下载并安装Sublime text3\"></a>下载并安装Sublime text3</h1><p>点击下载<a href=\"https://download.sublimetext.com/Sublime%20Text%20Build%203126.dmg\" target=\"_blank\" rel=\"external\">osx版</a>直接安装即可。<br>如果需要其他系统版本请移步<a href=\"http://www.sublimetext.com/3\" target=\"_blank\" rel=\"external\">这里</a><br>安装完成，在launcher启动Sublime</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c2bc5a099511d506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午8.32.28.png\"></p>\n<h1 id=\"配置Python3的编译环境\"><a href=\"#配置Python3的编译环境\" class=\"headerlink\" title=\"配置Python3的编译环境\"></a>配置Python3的编译环境</h1><ul>\n<li>找到Python3的安装路径<br>终端中输入命令</li>\n</ul>\n<figure class=\"highlight plain\"><figcaption><span>-a python3 ```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">可以看到结果</div><div class=\"line\"></div><div class=\"line\">![屏幕快照 2017-01-06 下午8.37.07.png](http://upload-images.jianshu.io/upload_images/1796052-01e91620f87d697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\">复制路径```/Library/Frameworks/Python.framework/Versions/3.5/bin/python3</div></pre></td></tr></table></figure>\n<ul>\n<li>配置Sublime<br>打开Sublime-&gt;Tools-&gt;build system-&gt;new build system<br>如下图可以看到列表里面已经有了Python编译环境，但这是针对Python2.x的版本的，需要我们手动添加3.x版本。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-8353a6ec526679ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午8.41.06.png\"></p>\n<p>点击new build system 后的窗口如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-e855b34a3025e14a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午8.46.29.png\"></p>\n<p>将其修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">&quot;cmd&quot;: [&quot;之前得到的python3路径&quot;,&quot;-u&quot;,&quot;$file&quot;],</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后点击save as保存为<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">此时再次查看build system列表发现Python3已经出现了，至此Sublime的Python3编译环境已经完成。</div><div class=\"line\"></div><div class=\"line\">![屏幕快照 2017-01-06 下午8.51.22.png](http://upload-images.jianshu.io/upload_images/1796052-81e3e153c615759e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\"># 开始我们的第一个程序hello Python！</div><div class=\"line\">- 新建工作目录</div><div class=\"line\">桌面新建一个名为python_work的文件夹，用来存放python文件</div><div class=\"line\">- 新建文件</div><div class=\"line\">使用Sublime--&gt;new file 新建一个空文件保存到刚才创建的python_work中，命名为hello_python.py 。(*这里命名时加了.py后缀是告诉Sublime说我这个文件是python程序，这样在编写时候会给出关键字的颜色标示，并且 编译时候会使用python编译环境*)</div><div class=\"line\"></div><div class=\"line\">- 打印hello python</div></pre></td></tr></table></figure></p>\n<p>print(“hello python!”)<br>```</p>\n<p>编写完代码保存，command+B执行编译</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a4f30b1ba7ac0f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午9.03.31.png\"></p>\n<p>本节完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"下载并安装Sublime-text3\"><a href=\"#下载并安装Sublime-text3\" class=\"headerlink\" title=\"下载并安装Sublime text3\"></a>下载并安装Sublime text3</h1><p>点击下载<a href=\"https://download.sublimetext.com/Sublime%20Text%20Build%203126.dmg\">osx版</a>直接安装即可。<br>如果需要其他系统版本请移步<a href=\"http://www.sublimetext.com/3\">这里</a><br>安装完成，在launcher启动Sublime</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c2bc5a099511d506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午8.32.28.png\"></p>\n<h1 id=\"配置Python3的编译环境\"><a href=\"#配置Python3的编译环境\" class=\"headerlink\" title=\"配置Python3的编译环境\"></a>配置Python3的编译环境</h1><ul>\n<li>找到Python3的安装路径<br>终端中输入命令</li>\n</ul>\n<figure class=\"highlight plain\"><figcaption><span>-a python3 ```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">可以看到结果</div><div class=\"line\"></div><div class=\"line\">![屏幕快照 2017-01-06 下午8.37.07.png](http://upload-images.jianshu.io/upload_images/1796052-01e91620f87d697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\">复制路径```/Library/Frameworks/Python.framework/Versions/3.5/bin/python3</div></pre></td></tr></table></figure>\n<ul>\n<li>配置Sublime<br>打开Sublime-&gt;Tools-&gt;build system-&gt;new build system<br>如下图可以看到列表里面已经有了Python编译环境，但这是针对Python2.x的版本的，需要我们手动添加3.x版本。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-8353a6ec526679ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午8.41.06.png\"></p>\n<p>点击new build system 后的窗口如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-e855b34a3025e14a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午8.46.29.png\"></p>\n<p>将其修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">&quot;cmd&quot;: [&quot;之前得到的python3路径&quot;,&quot;-u&quot;,&quot;$file&quot;],</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后点击save as保存为<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">此时再次查看build system列表发现Python3已经出现了，至此Sublime的Python3编译环境已经完成。</div><div class=\"line\"></div><div class=\"line\">![屏幕快照 2017-01-06 下午8.51.22.png](http://upload-images.jianshu.io/upload_images/1796052-81e3e153c615759e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\"></div><div class=\"line\"># 开始我们的第一个程序hello Python！</div><div class=\"line\">- 新建工作目录</div><div class=\"line\">桌面新建一个名为python_work的文件夹，用来存放python文件</div><div class=\"line\">- 新建文件</div><div class=\"line\">使用Sublime--&gt;new file 新建一个空文件保存到刚才创建的python_work中，命名为hello_python.py 。(*这里命名时加了.py后缀是告诉Sublime说我这个文件是python程序，这样在编写时候会给出关键字的颜色标示，并且 编译时候会使用python编译环境*)</div><div class=\"line\"></div><div class=\"line\">- 打印hello python</div></pre></td></tr></table></figure></p>\n<p>print(“hello python!”)<br>```</p>\n<p>编写完代码保存，command+B执行编译</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a4f30b1ba7ac0f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午9.03.31.png\"></p>\n<p>本节完成。</p>\n"},{"title":"Python入门系列(2):字符串、变量和简单数据类型的上手","date":"2017-04-22T10:55:54.000Z","_content":"\n# 说在前面的话\n\njava在声明变量时都要先指定数据类型 比如 int a=3 ; Stringt name = \"jenson\";\n但是在python中可以直接使用变量\npython中的注释使用\"#\"\n\n# 字符串的使用\n\n- 直接声明变量\n\n```\nprint(\"jenson\")\nname =\"jenson\"\nprint(name)\n```\n\n打印如下\n\n```\njenson\njenson\n[Finished in 0.0s]\n```\n- 字符串拼接直接使用+号\n\n```\nprint(\"hello jenson\")\nname = \"hello\"+ \" jenson\"\nprint(name)\n```\n\n打印结果一样一样的\n\n```\nhello jenson\nhello jenson\n[Finished in 0.0s]\n```\n\n- 去除字符串的空白\n\n```\nname = \"   jenson   \"\nprint(name.lstrip())\nprint(name.rstrip())\nprint(name.strip())\n```\n\n结果如下\n\n![屏幕快照 2017-01-06 下午10.01.19.png](http://upload-images.jianshu.io/upload_images/1796052-c10ea4a7be3c8130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里去除的空白分别是左边、右边和两边的空白，并不能去除中间空白\n- 字符串的大小写\n\n```\nsay = \"hello jenson\"\nprint(say)\nprint(say.upper())\nprint(say.lower())\nprint(say.title())\n```\n\n结果如下：\n\n```\nhello jenson\nHELLO JENSON\nhello jenson\nHello Jenson\n[Finished in 0.0s]\n```\n\n可见三个函数的作用分别是使字符串大写、小写、单词首字母大写。\n- 基本类型和运算\n\n```\nprint(3+5)\nprint(10-2)\nprint(2*4)\nprint(16/2)\nprint(2+3*4)\nprint(2**3)\n```\n\n输出如下：\n\n```\n8\n8\n8\n8.0\n14\n8\n[Finished in 0.2s]\n\n```\n可以看出python对四则运算支持优先级，注意一下*这里的幂用2个乘号表示*\n- 基本类型转为字符串\n基本类型和字符串混合使用时注意把基本类型先转换为字符串，使用str(基本类型值)，否则会引发异常。\n```\nage = 25;\nprint(str(age))\nsay = \"I'am \"+age \nprint(say)\n```\n\n```\n25\nTraceback (most recent call last):\n  File \"/Users/jenson/Desktop/python_work/str_text.py\", line 15, in <module>\n    say = \"I'am \"+age \nTypeError: Can't convert 'int' object to str implicitly\n[Finished in 0.0s with exit code 1]\n[cmd: ['/Library/Frameworks/Python.framework/Versions/3.5/bin/python3', '-u', '/Users/jenson/Desktop/python_work/str_text.py']]\n[dir: /Users/jenson/Desktop/python_work]\n[path: /usr/bin:/bin:/usr/sbin:/sbin]\n```\n\n第一个print已经打印，第二个却报了异常，因为没有转换。\n\n- python2和python3整数除法比较\n\n在python2下做除法运算3/2，得到结果是1 ，并不是1.5\n\n![屏幕快照 2017-01-06 下午10.34.19.png](http://upload-images.jianshu.io/upload_images/1796052-92eac21fee40ffd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n而在python3下是正常的\n\n![屏幕快照 2017-01-06 下午10.35.27.png](http://upload-images.jianshu.io/upload_images/1796052-4b8c5bd6f9354a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这是因为python2中计算整数结果时不是采取四舍五入，而是将整数部分直接删除，所以在python2中如果要避免这种情况，要确保至少有一个操作数为浮点数，这样得到的结果也为浮点数\n\n完毕。","source":"_posts/Python入门系列(2) 字符串、变量和简单数据类型的上手.md","raw":"---\ntitle: Python入门系列(2):字符串、变量和简单数据类型的上手\ndate: 2017-04-22 18:55:54\ntags: Python\ncategories: Python\n---\n\n# 说在前面的话\n\njava在声明变量时都要先指定数据类型 比如 int a=3 ; Stringt name = \"jenson\";\n但是在python中可以直接使用变量\npython中的注释使用\"#\"\n\n# 字符串的使用\n\n- 直接声明变量\n\n```\nprint(\"jenson\")\nname =\"jenson\"\nprint(name)\n```\n\n打印如下\n\n```\njenson\njenson\n[Finished in 0.0s]\n```\n- 字符串拼接直接使用+号\n\n```\nprint(\"hello jenson\")\nname = \"hello\"+ \" jenson\"\nprint(name)\n```\n\n打印结果一样一样的\n\n```\nhello jenson\nhello jenson\n[Finished in 0.0s]\n```\n\n- 去除字符串的空白\n\n```\nname = \"   jenson   \"\nprint(name.lstrip())\nprint(name.rstrip())\nprint(name.strip())\n```\n\n结果如下\n\n![屏幕快照 2017-01-06 下午10.01.19.png](http://upload-images.jianshu.io/upload_images/1796052-c10ea4a7be3c8130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里去除的空白分别是左边、右边和两边的空白，并不能去除中间空白\n- 字符串的大小写\n\n```\nsay = \"hello jenson\"\nprint(say)\nprint(say.upper())\nprint(say.lower())\nprint(say.title())\n```\n\n结果如下：\n\n```\nhello jenson\nHELLO JENSON\nhello jenson\nHello Jenson\n[Finished in 0.0s]\n```\n\n可见三个函数的作用分别是使字符串大写、小写、单词首字母大写。\n- 基本类型和运算\n\n```\nprint(3+5)\nprint(10-2)\nprint(2*4)\nprint(16/2)\nprint(2+3*4)\nprint(2**3)\n```\n\n输出如下：\n\n```\n8\n8\n8\n8.0\n14\n8\n[Finished in 0.2s]\n\n```\n可以看出python对四则运算支持优先级，注意一下*这里的幂用2个乘号表示*\n- 基本类型转为字符串\n基本类型和字符串混合使用时注意把基本类型先转换为字符串，使用str(基本类型值)，否则会引发异常。\n```\nage = 25;\nprint(str(age))\nsay = \"I'am \"+age \nprint(say)\n```\n\n```\n25\nTraceback (most recent call last):\n  File \"/Users/jenson/Desktop/python_work/str_text.py\", line 15, in <module>\n    say = \"I'am \"+age \nTypeError: Can't convert 'int' object to str implicitly\n[Finished in 0.0s with exit code 1]\n[cmd: ['/Library/Frameworks/Python.framework/Versions/3.5/bin/python3', '-u', '/Users/jenson/Desktop/python_work/str_text.py']]\n[dir: /Users/jenson/Desktop/python_work]\n[path: /usr/bin:/bin:/usr/sbin:/sbin]\n```\n\n第一个print已经打印，第二个却报了异常，因为没有转换。\n\n- python2和python3整数除法比较\n\n在python2下做除法运算3/2，得到结果是1 ，并不是1.5\n\n![屏幕快照 2017-01-06 下午10.34.19.png](http://upload-images.jianshu.io/upload_images/1796052-92eac21fee40ffd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n而在python3下是正常的\n\n![屏幕快照 2017-01-06 下午10.35.27.png](http://upload-images.jianshu.io/upload_images/1796052-4b8c5bd6f9354a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这是因为python2中计算整数结果时不是采取四舍五入，而是将整数部分直接删除，所以在python2中如果要避免这种情况，要确保至少有一个操作数为浮点数，这样得到的结果也为浮点数\n\n完毕。","slug":"Python入门系列(2) 字符串、变量和简单数据类型的上手","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwje40030wh9cr5h24d4y","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>java在声明变量时都要先指定数据类型 比如 int a=3 ; Stringt name = “jenson”;<br>但是在python中可以直接使用变量<br>python中的注释使用”#”</p>\n<h1 id=\"字符串的使用\"><a href=\"#字符串的使用\" class=\"headerlink\" title=\"字符串的使用\"></a>字符串的使用</h1><ul>\n<li>直接声明变量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&quot;jenson&quot;)</div><div class=\"line\">name =&quot;jenson&quot;</div><div class=\"line\">print(name)</div></pre></td></tr></table></figure>\n<p>打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">jenson</div><div class=\"line\">jenson</div><div class=\"line\">[Finished in 0.0s]</div></pre></td></tr></table></figure>\n<ul>\n<li>字符串拼接直接使用+号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&quot;hello jenson&quot;)</div><div class=\"line\">name = &quot;hello&quot;+ &quot; jenson&quot;</div><div class=\"line\">print(name)</div></pre></td></tr></table></figure>\n<p>打印结果一样一样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello jenson</div><div class=\"line\">hello jenson</div><div class=\"line\">[Finished in 0.0s]</div></pre></td></tr></table></figure>\n<ul>\n<li>去除字符串的空白</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name = &quot;   jenson   &quot;</div><div class=\"line\">print(name.lstrip())</div><div class=\"line\">print(name.rstrip())</div><div class=\"line\">print(name.strip())</div></pre></td></tr></table></figure>\n<p>结果如下</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c10ea4a7be3c8130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午10.01.19.png\"></p>\n<p>这里去除的空白分别是左边、右边和两边的空白，并不能去除中间空白</p>\n<ul>\n<li>字符串的大小写</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say = &quot;hello jenson&quot;</div><div class=\"line\">print(say)</div><div class=\"line\">print(say.upper())</div><div class=\"line\">print(say.lower())</div><div class=\"line\">print(say.title())</div></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello jenson</div><div class=\"line\">HELLO JENSON</div><div class=\"line\">hello jenson</div><div class=\"line\">Hello Jenson</div><div class=\"line\">[Finished in 0.0s]</div></pre></td></tr></table></figure>\n<p>可见三个函数的作用分别是使字符串大写、小写、单词首字母大写。</p>\n<ul>\n<li>基本类型和运算</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(3+5)</div><div class=\"line\">print(10-2)</div><div class=\"line\">print(2*4)</div><div class=\"line\">print(16/2)</div><div class=\"line\">print(2+3*4)</div><div class=\"line\">print(2**3)</div></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">8</div><div class=\"line\">8</div><div class=\"line\">8</div><div class=\"line\">8.0</div><div class=\"line\">14</div><div class=\"line\">8</div><div class=\"line\">[Finished in 0.2s]</div></pre></td></tr></table></figure>\n<p>可以看出python对四则运算支持优先级，注意一下<em>这里的幂用2个乘号表示</em></p>\n<ul>\n<li>基本类型转为字符串<br>基本类型和字符串混合使用时注意把基本类型先转换为字符串，使用str(基本类型值)，否则会引发异常。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">age = 25;</div><div class=\"line\">print(str(age))</div><div class=\"line\">say = &quot;I&apos;am &quot;+age </div><div class=\"line\">print(say)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">25</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/Users/jenson/Desktop/python_work/str_text.py&quot;, line 15, in &lt;module&gt;</div><div class=\"line\">    say = &quot;I&apos;am &quot;+age </div><div class=\"line\">TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly</div><div class=\"line\">[Finished in 0.0s with exit code 1]</div><div class=\"line\">[cmd: [&apos;/Library/Frameworks/Python.framework/Versions/3.5/bin/python3&apos;, &apos;-u&apos;, &apos;/Users/jenson/Desktop/python_work/str_text.py&apos;]]</div><div class=\"line\">[dir: /Users/jenson/Desktop/python_work]</div><div class=\"line\">[path: /usr/bin:/bin:/usr/sbin:/sbin]</div></pre></td></tr></table></figure>\n<p>第一个print已经打印，第二个却报了异常，因为没有转换。</p>\n<ul>\n<li>python2和python3整数除法比较</li>\n</ul>\n<p>在python2下做除法运算3/2，得到结果是1 ，并不是1.5</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-92eac21fee40ffd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午10.34.19.png\"></p>\n<p>而在python3下是正常的</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-4b8c5bd6f9354a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午10.35.27.png\"></p>\n<p>这是因为python2中计算整数结果时不是采取四舍五入，而是将整数部分直接删除，所以在python2中如果要避免这种情况，要确保至少有一个操作数为浮点数，这样得到的结果也为浮点数</p>\n<p>完毕。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>java在声明变量时都要先指定数据类型 比如 int a=3 ; Stringt name = “jenson”;<br>但是在python中可以直接使用变量<br>python中的注释使用”#”</p>\n<h1 id=\"字符串的使用\"><a href=\"#字符串的使用\" class=\"headerlink\" title=\"字符串的使用\"></a>字符串的使用</h1><ul>\n<li>直接声明变量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&quot;jenson&quot;)</div><div class=\"line\">name =&quot;jenson&quot;</div><div class=\"line\">print(name)</div></pre></td></tr></table></figure>\n<p>打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">jenson</div><div class=\"line\">jenson</div><div class=\"line\">[Finished in 0.0s]</div></pre></td></tr></table></figure>\n<ul>\n<li>字符串拼接直接使用+号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(&quot;hello jenson&quot;)</div><div class=\"line\">name = &quot;hello&quot;+ &quot; jenson&quot;</div><div class=\"line\">print(name)</div></pre></td></tr></table></figure>\n<p>打印结果一样一样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello jenson</div><div class=\"line\">hello jenson</div><div class=\"line\">[Finished in 0.0s]</div></pre></td></tr></table></figure>\n<ul>\n<li>去除字符串的空白</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">name = &quot;   jenson   &quot;</div><div class=\"line\">print(name.lstrip())</div><div class=\"line\">print(name.rstrip())</div><div class=\"line\">print(name.strip())</div></pre></td></tr></table></figure>\n<p>结果如下</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-c10ea4a7be3c8130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午10.01.19.png\"></p>\n<p>这里去除的空白分别是左边、右边和两边的空白，并不能去除中间空白</p>\n<ul>\n<li>字符串的大小写</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">say = &quot;hello jenson&quot;</div><div class=\"line\">print(say)</div><div class=\"line\">print(say.upper())</div><div class=\"line\">print(say.lower())</div><div class=\"line\">print(say.title())</div></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hello jenson</div><div class=\"line\">HELLO JENSON</div><div class=\"line\">hello jenson</div><div class=\"line\">Hello Jenson</div><div class=\"line\">[Finished in 0.0s]</div></pre></td></tr></table></figure>\n<p>可见三个函数的作用分别是使字符串大写、小写、单词首字母大写。</p>\n<ul>\n<li>基本类型和运算</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(3+5)</div><div class=\"line\">print(10-2)</div><div class=\"line\">print(2*4)</div><div class=\"line\">print(16/2)</div><div class=\"line\">print(2+3*4)</div><div class=\"line\">print(2**3)</div></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">8</div><div class=\"line\">8</div><div class=\"line\">8</div><div class=\"line\">8.0</div><div class=\"line\">14</div><div class=\"line\">8</div><div class=\"line\">[Finished in 0.2s]</div></pre></td></tr></table></figure>\n<p>可以看出python对四则运算支持优先级，注意一下<em>这里的幂用2个乘号表示</em></p>\n<ul>\n<li>基本类型转为字符串<br>基本类型和字符串混合使用时注意把基本类型先转换为字符串，使用str(基本类型值)，否则会引发异常。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">age = 25;</div><div class=\"line\">print(str(age))</div><div class=\"line\">say = &quot;I&apos;am &quot;+age </div><div class=\"line\">print(say)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">25</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;/Users/jenson/Desktop/python_work/str_text.py&quot;, line 15, in &lt;module&gt;</div><div class=\"line\">    say = &quot;I&apos;am &quot;+age </div><div class=\"line\">TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly</div><div class=\"line\">[Finished in 0.0s with exit code 1]</div><div class=\"line\">[cmd: [&apos;/Library/Frameworks/Python.framework/Versions/3.5/bin/python3&apos;, &apos;-u&apos;, &apos;/Users/jenson/Desktop/python_work/str_text.py&apos;]]</div><div class=\"line\">[dir: /Users/jenson/Desktop/python_work]</div><div class=\"line\">[path: /usr/bin:/bin:/usr/sbin:/sbin]</div></pre></td></tr></table></figure>\n<p>第一个print已经打印，第二个却报了异常，因为没有转换。</p>\n<ul>\n<li>python2和python3整数除法比较</li>\n</ul>\n<p>在python2下做除法运算3/2，得到结果是1 ，并不是1.5</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-92eac21fee40ffd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午10.34.19.png\"></p>\n<p>而在python3下是正常的</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-4b8c5bd6f9354a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-06 下午10.35.27.png\"></p>\n<p>这是因为python2中计算整数结果时不是采取四舍五入，而是将整数部分直接删除，所以在python2中如果要避免这种情况，要确保至少有一个操作数为浮点数，这样得到的结果也为浮点数</p>\n<p>完毕。</p>\n"},{"title":"Python入门系列(4):文件IO","date":"2017-08-06T09:25:54.000Z","_content":"\n# 前言\n\n文件读写是最常见的IO操作，而python也内置了文件读写的函数，下面看看如何读写文件。\n\n# 操作\n\n## mode\n\n不论读还是写，只要想操作文件就要先打开文件，而打开文件时要告诉系统你的mode是什么？\n\n什么是mode？就是你打算对这个文件操作的类型，是读还是写，如果是写是覆盖还是追加？\n\n下面表格列出了mode值及含义：\n\n|  值   |  描述   |\n| :--: | :---: |\n| 'r'  |  读模式  |\n| 'w'  |  写模式  |\n| 'a'  | 追加模式  |\n| 'b'  | 二进制模式 |\n| '+'  | 读/写模式 |\n\n**其中b和+可以和前面模式混用**。\n\n打开文件使用**open***函数：\n\n```python\nfile= open(r\"file\\t.txt\", mode='a+')\n```\n\n>open函数中第三个可选参数buffering控制着⽂件的缓冲。 如果参数是0， I/O操作就是⽆缓冲的， 直接\n>将数据写到硬盘上； 如果参数是1， I/O操作就是有缓冲的， 数据先写到内存⾥， 只有使⽤flush函数或者\n>close函数才会将数据更新到硬盘； 如果参数为⼤于1的数字则代表缓冲区的⼤⼩（单位是字节） ， -1（或者\n>是任何负数） 代表使⽤默认缓冲区的⼤⼩。 \n\n\n\n## 读文件\n\n文件读取使用read方法。可以一次读取全部、读取一行、读取指定长度\n\n```python\nprint(file.read())\nprint(file.readline())\nprint(file.read(3))\n```\n\n## 写文件\n\n写文件使用write方法。\n\n```python\nfile.write('\\ntoday is sunday')\nstr=['aa', 'bb', 'cc']\nfile.writelines(str)\n```\n\n## 异常处理\n\nIO操作完成后都要有一个关闭操作对于文件来说，不使用时要关闭：\n\n```python\nfile.close()\n```\n\n但是IO操作难免出现异常，如果在文件操作期间出现异常可能会导致无法关闭文件。这时需要异常处理机制：`try except`\n\n但是异常处理机制又略显繁琐，so这里推荐使用**with**语法：\n\n```python\nwith  open(r\"file\\t.txt\", mode='a+') as file_object:\ncontents = file_object.read()\nprint(contents)\n```\n\n> 关键字with在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但\n> 没有调用close()；你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存\n> 在bug，导致close()语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能\n> 会导致数据丢失或受损。如果在程序中过早地调用close()，你会发现需要使用文件时它已关闭\n> （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通\n> 过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它， Python自会\n> 在合适的时候自动将其关闭 ","source":"_posts/Python入门系列(4)文件IO.md","raw":"---\ntitle: Python入门系列(4):文件IO\ndate: 2017-08-06 17:25:54\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n文件读写是最常见的IO操作，而python也内置了文件读写的函数，下面看看如何读写文件。\n\n# 操作\n\n## mode\n\n不论读还是写，只要想操作文件就要先打开文件，而打开文件时要告诉系统你的mode是什么？\n\n什么是mode？就是你打算对这个文件操作的类型，是读还是写，如果是写是覆盖还是追加？\n\n下面表格列出了mode值及含义：\n\n|  值   |  描述   |\n| :--: | :---: |\n| 'r'  |  读模式  |\n| 'w'  |  写模式  |\n| 'a'  | 追加模式  |\n| 'b'  | 二进制模式 |\n| '+'  | 读/写模式 |\n\n**其中b和+可以和前面模式混用**。\n\n打开文件使用**open***函数：\n\n```python\nfile= open(r\"file\\t.txt\", mode='a+')\n```\n\n>open函数中第三个可选参数buffering控制着⽂件的缓冲。 如果参数是0， I/O操作就是⽆缓冲的， 直接\n>将数据写到硬盘上； 如果参数是1， I/O操作就是有缓冲的， 数据先写到内存⾥， 只有使⽤flush函数或者\n>close函数才会将数据更新到硬盘； 如果参数为⼤于1的数字则代表缓冲区的⼤⼩（单位是字节） ， -1（或者\n>是任何负数） 代表使⽤默认缓冲区的⼤⼩。 \n\n\n\n## 读文件\n\n文件读取使用read方法。可以一次读取全部、读取一行、读取指定长度\n\n```python\nprint(file.read())\nprint(file.readline())\nprint(file.read(3))\n```\n\n## 写文件\n\n写文件使用write方法。\n\n```python\nfile.write('\\ntoday is sunday')\nstr=['aa', 'bb', 'cc']\nfile.writelines(str)\n```\n\n## 异常处理\n\nIO操作完成后都要有一个关闭操作对于文件来说，不使用时要关闭：\n\n```python\nfile.close()\n```\n\n但是IO操作难免出现异常，如果在文件操作期间出现异常可能会导致无法关闭文件。这时需要异常处理机制：`try except`\n\n但是异常处理机制又略显繁琐，so这里推荐使用**with**语法：\n\n```python\nwith  open(r\"file\\t.txt\", mode='a+') as file_object:\ncontents = file_object.read()\nprint(contents)\n```\n\n> 关键字with在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但\n> 没有调用close()；你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存\n> 在bug，导致close()语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能\n> 会导致数据丢失或受损。如果在程序中过早地调用close()，你会发现需要使用文件时它已关闭\n> （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通\n> 过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它， Python自会\n> 在合适的时候自动将其关闭 ","slug":"Python入门系列(4)文件IO","published":1,"updated":"2017-08-08T05:53:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwje90033wh9cfhi443al","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>文件读写是最常见的IO操作，而python也内置了文件读写的函数，下面看看如何读写文件。</p>\n<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><h2 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h2><p>不论读还是写，只要想操作文件就要先打开文件，而打开文件时要告诉系统你的mode是什么？</p>\n<p>什么是mode？就是你打算对这个文件操作的类型，是读还是写，如果是写是覆盖还是追加？</p>\n<p>下面表格列出了mode值及含义：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">‘r’</td>\n<td style=\"text-align:center\">读模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘w’</td>\n<td style=\"text-align:center\">写模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘a’</td>\n<td style=\"text-align:center\">追加模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘b’</td>\n<td style=\"text-align:center\">二进制模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘+’</td>\n<td style=\"text-align:center\">读/写模式</td>\n</tr>\n</tbody>\n</table>\n<p><strong>其中b和+可以和前面模式混用</strong>。</p>\n<p>打开文件使用<strong>open*</strong>函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">file= open(<span class=\"string\">r\"file\\t.txt\"</span>, mode=<span class=\"string\">'a+'</span>)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>open函数中第三个可选参数buffering控制着⽂件的缓冲。 如果参数是0， I/O操作就是⽆缓冲的， 直接<br>将数据写到硬盘上； 如果参数是1， I/O操作就是有缓冲的， 数据先写到内存⾥， 只有使⽤flush函数或者<br>close函数才会将数据更新到硬盘； 如果参数为⼤于1的数字则代表缓冲区的⼤⼩（单位是字节） ， -1（或者<br>是任何负数） 代表使⽤默认缓冲区的⼤⼩。 </p>\n</blockquote>\n<h2 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h2><p>文件读取使用read方法。可以一次读取全部、读取一行、读取指定长度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(file.read())</div><div class=\"line\">print(file.readline())</div><div class=\"line\">print(file.read(<span class=\"number\">3</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h2><p>写文件使用write方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">file.write(<span class=\"string\">'\\ntoday is sunday'</span>)</div><div class=\"line\">str=[<span class=\"string\">'aa'</span>, <span class=\"string\">'bb'</span>, <span class=\"string\">'cc'</span>]</div><div class=\"line\">file.writelines(str)</div></pre></td></tr></table></figure>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>IO操作完成后都要有一个关闭操作对于文件来说，不使用时要关闭：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">file.close()</div></pre></td></tr></table></figure>\n<p>但是IO操作难免出现异常，如果在文件操作期间出现异常可能会导致无法关闭文件。这时需要异常处理机制：<code>try except</code></p>\n<p>但是异常处理机制又略显繁琐，so这里推荐使用<strong>with</strong>语法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span>  open(<span class=\"string\">r\"file\\t.txt\"</span>, mode=<span class=\"string\">'a+'</span>) <span class=\"keyword\">as</span> file_object:</div><div class=\"line\">contents = file_object.read()</div><div class=\"line\">print(contents)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>关键字with在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但<br>没有调用close()；你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存<br>在bug，导致close()语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能<br>会导致数据丢失或受损。如果在程序中过早地调用close()，你会发现需要使用文件时它已关闭<br>（无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通<br>过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它， Python自会<br>在合适的时候自动将其关闭 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>文件读写是最常见的IO操作，而python也内置了文件读写的函数，下面看看如何读写文件。</p>\n<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><h2 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h2><p>不论读还是写，只要想操作文件就要先打开文件，而打开文件时要告诉系统你的mode是什么？</p>\n<p>什么是mode？就是你打算对这个文件操作的类型，是读还是写，如果是写是覆盖还是追加？</p>\n<p>下面表格列出了mode值及含义：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">‘r’</td>\n<td style=\"text-align:center\">读模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘w’</td>\n<td style=\"text-align:center\">写模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘a’</td>\n<td style=\"text-align:center\">追加模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘b’</td>\n<td style=\"text-align:center\">二进制模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘+’</td>\n<td style=\"text-align:center\">读/写模式</td>\n</tr>\n</tbody>\n</table>\n<p><strong>其中b和+可以和前面模式混用</strong>。</p>\n<p>打开文件使用<strong>open*</strong>函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">file= open(<span class=\"string\">r\"file\\t.txt\"</span>, mode=<span class=\"string\">'a+'</span>)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>open函数中第三个可选参数buffering控制着⽂件的缓冲。 如果参数是0， I/O操作就是⽆缓冲的， 直接<br>将数据写到硬盘上； 如果参数是1， I/O操作就是有缓冲的， 数据先写到内存⾥， 只有使⽤flush函数或者<br>close函数才会将数据更新到硬盘； 如果参数为⼤于1的数字则代表缓冲区的⼤⼩（单位是字节） ， -1（或者<br>是任何负数） 代表使⽤默认缓冲区的⼤⼩。 </p>\n</blockquote>\n<h2 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h2><p>文件读取使用read方法。可以一次读取全部、读取一行、读取指定长度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(file.read())</div><div class=\"line\">print(file.readline())</div><div class=\"line\">print(file.read(<span class=\"number\">3</span>))</div></pre></td></tr></table></figure>\n<h2 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h2><p>写文件使用write方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">file.write(<span class=\"string\">'\\ntoday is sunday'</span>)</div><div class=\"line\">str=[<span class=\"string\">'aa'</span>, <span class=\"string\">'bb'</span>, <span class=\"string\">'cc'</span>]</div><div class=\"line\">file.writelines(str)</div></pre></td></tr></table></figure>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>IO操作完成后都要有一个关闭操作对于文件来说，不使用时要关闭：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">file.close()</div></pre></td></tr></table></figure>\n<p>但是IO操作难免出现异常，如果在文件操作期间出现异常可能会导致无法关闭文件。这时需要异常处理机制：<code>try except</code></p>\n<p>但是异常处理机制又略显繁琐，so这里推荐使用<strong>with</strong>语法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span>  open(<span class=\"string\">r\"file\\t.txt\"</span>, mode=<span class=\"string\">'a+'</span>) <span class=\"keyword\">as</span> file_object:</div><div class=\"line\">contents = file_object.read()</div><div class=\"line\">print(contents)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>关键字with在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但<br>没有调用close()；你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存<br>在bug，导致close()语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能<br>会导致数据丢失或受损。如果在程序中过早地调用close()，你会发现需要使用文件时它已关闭<br>（无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通<br>过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它， Python自会<br>在合适的时候自动将其关闭 </p>\n</blockquote>\n"},{"title":"Python爬虫应该掌握哪些知识","date":"2017-08-01T02:24:54.000Z","_content":"\n# 前言\n\n其实对某些网站有针对性的爬取需要的内容并不是很难，只要缕清自己的需求。从0到需求实现须要哪些步骤给列出来，然后各个实现最后组合在一起就基本完成了一个简单的爬虫。\n\n# 整体流程分析\n\n![爬虫整体流程](http://othg5ggzi.bkt.clouddn.com/%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.png)\n\n如图，我们爬取数据最终都是要展示出来看的，所以基本的一个自己的小型爬虫流程可以分为数据采集、数据存储、数据清洗、数据展示四大流程。\n\n**兵法云:\"分而治之，各个击破\"**，下面把四个步骤涉及到得知识分别说一下。\n\n\n\n# 数据采集\n\n爬虫爬取过程就是采集过程，既然要爬取别人的网站数据，首先要处理网络请求这就是离不开网络库，通常使用`urllib`就可以。\n\n爬到的页面都是html源码形式的，习惯称为DOM树，要通过DOM树获取需要的信息，需要使用解析库，这里推荐`BeautifulSoup4`。\n\n因为要找到内容的规律才能进行顺利爬取，期间免不了涉及到正则表达式。所以这也是必须要掌握的。\n\n这样基本能完成简单的爬取了。\n\n> 如果涉及到透过表单和登陆窗口后面的爬取或者爬取内容和实际显示不一样，这些涉及深入爬取暂时不做讨论。\n\n# 数据存储\n\n爬取到得数据总在内存中存放是个问题。所以爬取后的内容需要及时进行存储以防丢失。\n\n存储一般分为文件存储和数据库存储，Android中也是如此。\n\n而数据处理的文件存储一般式CVS格式，so使用`cvs`库可以方便进行数据读写，\n\n数据库存储可以自由选择所熟悉的数据库类型。\n\n很多时候个人爬虫到这步基本已经完成了。后面两步主要在数据分析时才会用到\n\n# 数据清洗\n\n如果爬取到得数据本身就是很符合规范的话那就省心了，否则需要对采集的数据进行清洗。\n\n由于错误的标点符号、大小写字母不一致、断行和拼写错误等问题，零乱的数据是网络中的大问题。而数据清洗就是清除这些问题，让数据标准化。\n\n\n\n\n\n# 数据展示\n\n数据展示即数据可视化，可以使用`matplotlib`库生成各种统计图","source":"_posts/Python爬虫应该掌握哪些知识.md","raw":"---\ntitle: Python爬虫应该掌握哪些知识\ndate: 2017-08-01 10:24:54\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n其实对某些网站有针对性的爬取需要的内容并不是很难，只要缕清自己的需求。从0到需求实现须要哪些步骤给列出来，然后各个实现最后组合在一起就基本完成了一个简单的爬虫。\n\n# 整体流程分析\n\n![爬虫整体流程](http://othg5ggzi.bkt.clouddn.com/%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.png)\n\n如图，我们爬取数据最终都是要展示出来看的，所以基本的一个自己的小型爬虫流程可以分为数据采集、数据存储、数据清洗、数据展示四大流程。\n\n**兵法云:\"分而治之，各个击破\"**，下面把四个步骤涉及到得知识分别说一下。\n\n\n\n# 数据采集\n\n爬虫爬取过程就是采集过程，既然要爬取别人的网站数据，首先要处理网络请求这就是离不开网络库，通常使用`urllib`就可以。\n\n爬到的页面都是html源码形式的，习惯称为DOM树，要通过DOM树获取需要的信息，需要使用解析库，这里推荐`BeautifulSoup4`。\n\n因为要找到内容的规律才能进行顺利爬取，期间免不了涉及到正则表达式。所以这也是必须要掌握的。\n\n这样基本能完成简单的爬取了。\n\n> 如果涉及到透过表单和登陆窗口后面的爬取或者爬取内容和实际显示不一样，这些涉及深入爬取暂时不做讨论。\n\n# 数据存储\n\n爬取到得数据总在内存中存放是个问题。所以爬取后的内容需要及时进行存储以防丢失。\n\n存储一般分为文件存储和数据库存储，Android中也是如此。\n\n而数据处理的文件存储一般式CVS格式，so使用`cvs`库可以方便进行数据读写，\n\n数据库存储可以自由选择所熟悉的数据库类型。\n\n很多时候个人爬虫到这步基本已经完成了。后面两步主要在数据分析时才会用到\n\n# 数据清洗\n\n如果爬取到得数据本身就是很符合规范的话那就省心了，否则需要对采集的数据进行清洗。\n\n由于错误的标点符号、大小写字母不一致、断行和拼写错误等问题，零乱的数据是网络中的大问题。而数据清洗就是清除这些问题，让数据标准化。\n\n\n\n\n\n# 数据展示\n\n数据展示即数据可视化，可以使用`matplotlib`库生成各种统计图","slug":"Python爬虫应该掌握哪些知识","published":1,"updated":"2017-08-01T04:15:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjeg0038wh9cm1fp6ojd","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实对某些网站有针对性的爬取需要的内容并不是很难，只要缕清自己的需求。从0到需求实现须要哪些步骤给列出来，然后各个实现最后组合在一起就基本完成了一个简单的爬虫。</p>\n<h1 id=\"整体流程分析\"><a href=\"#整体流程分析\" class=\"headerlink\" title=\"整体流程分析\"></a>整体流程分析</h1><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.png\" alt=\"爬虫整体流程\"></p>\n<p>如图，我们爬取数据最终都是要展示出来看的，所以基本的一个自己的小型爬虫流程可以分为数据采集、数据存储、数据清洗、数据展示四大流程。</p>\n<p><strong>兵法云:”分而治之，各个击破”</strong>，下面把四个步骤涉及到得知识分别说一下。</p>\n<h1 id=\"数据采集\"><a href=\"#数据采集\" class=\"headerlink\" title=\"数据采集\"></a>数据采集</h1><p>爬虫爬取过程就是采集过程，既然要爬取别人的网站数据，首先要处理网络请求这就是离不开网络库，通常使用<code>urllib</code>就可以。</p>\n<p>爬到的页面都是html源码形式的，习惯称为DOM树，要通过DOM树获取需要的信息，需要使用解析库，这里推荐<code>BeautifulSoup4</code>。</p>\n<p>因为要找到内容的规律才能进行顺利爬取，期间免不了涉及到正则表达式。所以这也是必须要掌握的。</p>\n<p>这样基本能完成简单的爬取了。</p>\n<blockquote>\n<p>如果涉及到透过表单和登陆窗口后面的爬取或者爬取内容和实际显示不一样，这些涉及深入爬取暂时不做讨论。</p>\n</blockquote>\n<h1 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h1><p>爬取到得数据总在内存中存放是个问题。所以爬取后的内容需要及时进行存储以防丢失。</p>\n<p>存储一般分为文件存储和数据库存储，Android中也是如此。</p>\n<p>而数据处理的文件存储一般式CVS格式，so使用<code>cvs</code>库可以方便进行数据读写，</p>\n<p>数据库存储可以自由选择所熟悉的数据库类型。</p>\n<p>很多时候个人爬虫到这步基本已经完成了。后面两步主要在数据分析时才会用到</p>\n<h1 id=\"数据清洗\"><a href=\"#数据清洗\" class=\"headerlink\" title=\"数据清洗\"></a>数据清洗</h1><p>如果爬取到得数据本身就是很符合规范的话那就省心了，否则需要对采集的数据进行清洗。</p>\n<p>由于错误的标点符号、大小写字母不一致、断行和拼写错误等问题，零乱的数据是网络中的大问题。而数据清洗就是清除这些问题，让数据标准化。</p>\n<h1 id=\"数据展示\"><a href=\"#数据展示\" class=\"headerlink\" title=\"数据展示\"></a>数据展示</h1><p>数据展示即数据可视化，可以使用<code>matplotlib</code>库生成各种统计图</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实对某些网站有针对性的爬取需要的内容并不是很难，只要缕清自己的需求。从0到需求实现须要哪些步骤给列出来，然后各个实现最后组合在一起就基本完成了一个简单的爬虫。</p>\n<h1 id=\"整体流程分析\"><a href=\"#整体流程分析\" class=\"headerlink\" title=\"整体流程分析\"></a>整体流程分析</h1><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.png\" alt=\"爬虫整体流程\"></p>\n<p>如图，我们爬取数据最终都是要展示出来看的，所以基本的一个自己的小型爬虫流程可以分为数据采集、数据存储、数据清洗、数据展示四大流程。</p>\n<p><strong>兵法云:”分而治之，各个击破”</strong>，下面把四个步骤涉及到得知识分别说一下。</p>\n<h1 id=\"数据采集\"><a href=\"#数据采集\" class=\"headerlink\" title=\"数据采集\"></a>数据采集</h1><p>爬虫爬取过程就是采集过程，既然要爬取别人的网站数据，首先要处理网络请求这就是离不开网络库，通常使用<code>urllib</code>就可以。</p>\n<p>爬到的页面都是html源码形式的，习惯称为DOM树，要通过DOM树获取需要的信息，需要使用解析库，这里推荐<code>BeautifulSoup4</code>。</p>\n<p>因为要找到内容的规律才能进行顺利爬取，期间免不了涉及到正则表达式。所以这也是必须要掌握的。</p>\n<p>这样基本能完成简单的爬取了。</p>\n<blockquote>\n<p>如果涉及到透过表单和登陆窗口后面的爬取或者爬取内容和实际显示不一样，这些涉及深入爬取暂时不做讨论。</p>\n</blockquote>\n<h1 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h1><p>爬取到得数据总在内存中存放是个问题。所以爬取后的内容需要及时进行存储以防丢失。</p>\n<p>存储一般分为文件存储和数据库存储，Android中也是如此。</p>\n<p>而数据处理的文件存储一般式CVS格式，so使用<code>cvs</code>库可以方便进行数据读写，</p>\n<p>数据库存储可以自由选择所熟悉的数据库类型。</p>\n<p>很多时候个人爬虫到这步基本已经完成了。后面两步主要在数据分析时才会用到</p>\n<h1 id=\"数据清洗\"><a href=\"#数据清洗\" class=\"headerlink\" title=\"数据清洗\"></a>数据清洗</h1><p>如果爬取到得数据本身就是很符合规范的话那就省心了，否则需要对采集的数据进行清洗。</p>\n<p>由于错误的标点符号、大小写字母不一致、断行和拼写错误等问题，零乱的数据是网络中的大问题。而数据清洗就是清除这些问题，让数据标准化。</p>\n<h1 id=\"数据展示\"><a href=\"#数据展示\" class=\"headerlink\" title=\"数据展示\"></a>数据展示</h1><p>数据展示即数据可视化，可以使用<code>matplotlib</code>库生成各种统计图</p>\n"},{"title":"Python入门系列(3):元组、列表和字典","date":"2017-06-26T11:00:58.000Z","_content":"\n# 0x00 前言\n\n​\t上一节说明了Python字符串和简单数据类型的基本用法，因为比较简单，所以没有做太多说明，这一节介绍下列表、元组和字典。之所以把这三个放在同一节讲是因为这三个数据结构有很多相似地方，对比学习让人印象更深。\n\n# 0x01 列表\n\n## 什么是列表？如何表示列表？\n\n​\t列表就是由一组特定顺序的元素组成，使用中括号“[ ]\"来表示，元素之间使用逗号分隔，例如：animal = ['cat', 'dog', 'monkey']\n\n## 访问列表\n\n​\t列表的访问通过索引下标来访问，索引和其他大多数语言一样从0开始。\n\n也就是说访问第一个元素为：animal[0]。而和其他语言不一样的是Python中索引可以为负值，如：animal[-1]实际为最后一个元素，以此类推。\n\n## 列表增加元素\n\n​\t元素的添加分为两种，列表末尾追加和任意位置添加\n\n-   末尾追加\n\n    使用方法append，animal.append(’fox‘)\n\n- 任意位置添加\n\n  使用方法insert，animal.insert(1,'fox')。第一个参数为索引值\n\n## 列表删除元素\n\n元素删除也可以通过四种方式实现：\n\n- 使用del\n\n  如果知道元素所处列表位置，则使用del  animal[ i ]\n\n- 使用pop\n\n  如果只需删除了列表末尾元素，则直接使用animal.pop方法。类似出栈\n\n- 使用pop\n\n  如果要删除任意位置元素，使用animal.pop（i)，参数为索引值\n\n- 使用remove\n\n  如果知道元素值而不知道位置，则使用animal.remove（value），参数为元素值\n\n## 列表修改元素\n\n​\t修改列表元素的语法与访问列表元素的语法类似，如果要进行元素修改只要拿到元素后对其进行从新赋值即可：animal[1] = 'bird'。\n\n## 列表元素遍历\n\n列表遍历使用循环即可。\n\n```python\nfor ani in animal:\n\tprint(ani)\n```\n\n# 0x02 元组\n\n\n元组使用小括号，列表使用方括号。\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。\n\n- Python 的元组与列表类似，不同之处在于元组的元素不能修改。\n\n\n- 元组中只包含一个元素时，需要在元素后面添加逗号\n\n  ​\ttup1 = (10,)\n\n- 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组\n\n  ```python\n  cats = ('xm','dm')\n  print(cats)\n  del cats\n  print(cats)#打印异常\n  ```\n\n- 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合\n\n  ```python\n  cats = ('xm', 'dm')\n  cat1 = ('mm',)\n  allCat = cats + cat1\n  print(allCat)#('xm', 'dm', 'mm')\n  ```\n\n  ​\n\n# 0x03 字典\n\n\n\n\n\n ","source":"_posts/Python入门系列-3-元组、列表和字典.md","raw":"---\ntitle: 'Python入门系列(3):元组、列表和字典'\ndate: 2017-06-26 19:00:58\ntags: Python\ncategories: Python\n---\n\n# 0x00 前言\n\n​\t上一节说明了Python字符串和简单数据类型的基本用法，因为比较简单，所以没有做太多说明，这一节介绍下列表、元组和字典。之所以把这三个放在同一节讲是因为这三个数据结构有很多相似地方，对比学习让人印象更深。\n\n# 0x01 列表\n\n## 什么是列表？如何表示列表？\n\n​\t列表就是由一组特定顺序的元素组成，使用中括号“[ ]\"来表示，元素之间使用逗号分隔，例如：animal = ['cat', 'dog', 'monkey']\n\n## 访问列表\n\n​\t列表的访问通过索引下标来访问，索引和其他大多数语言一样从0开始。\n\n也就是说访问第一个元素为：animal[0]。而和其他语言不一样的是Python中索引可以为负值，如：animal[-1]实际为最后一个元素，以此类推。\n\n## 列表增加元素\n\n​\t元素的添加分为两种，列表末尾追加和任意位置添加\n\n-   末尾追加\n\n    使用方法append，animal.append(’fox‘)\n\n- 任意位置添加\n\n  使用方法insert，animal.insert(1,'fox')。第一个参数为索引值\n\n## 列表删除元素\n\n元素删除也可以通过四种方式实现：\n\n- 使用del\n\n  如果知道元素所处列表位置，则使用del  animal[ i ]\n\n- 使用pop\n\n  如果只需删除了列表末尾元素，则直接使用animal.pop方法。类似出栈\n\n- 使用pop\n\n  如果要删除任意位置元素，使用animal.pop（i)，参数为索引值\n\n- 使用remove\n\n  如果知道元素值而不知道位置，则使用animal.remove（value），参数为元素值\n\n## 列表修改元素\n\n​\t修改列表元素的语法与访问列表元素的语法类似，如果要进行元素修改只要拿到元素后对其进行从新赋值即可：animal[1] = 'bird'。\n\n## 列表元素遍历\n\n列表遍历使用循环即可。\n\n```python\nfor ani in animal:\n\tprint(ani)\n```\n\n# 0x02 元组\n\n\n元组使用小括号，列表使用方括号。\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。\n\n- Python 的元组与列表类似，不同之处在于元组的元素不能修改。\n\n\n- 元组中只包含一个元素时，需要在元素后面添加逗号\n\n  ​\ttup1 = (10,)\n\n- 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组\n\n  ```python\n  cats = ('xm','dm')\n  print(cats)\n  del cats\n  print(cats)#打印异常\n  ```\n\n- 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合\n\n  ```python\n  cats = ('xm', 'dm')\n  cat1 = ('mm',)\n  allCat = cats + cat1\n  print(allCat)#('xm', 'dm', 'mm')\n  ```\n\n  ​\n\n# 0x03 字典\n\n\n\n\n\n ","slug":"Python入门系列-3-元组、列表和字典","published":1,"updated":"2017-07-13T17:05:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjel003bwh9c9l09isiq","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>​    上一节说明了Python字符串和简单数据类型的基本用法，因为比较简单，所以没有做太多说明，这一节介绍下列表、元组和字典。之所以把这三个放在同一节讲是因为这三个数据结构有很多相似地方，对比学习让人印象更深。</p>\n<h1 id=\"0x01-列表\"><a href=\"#0x01-列表\" class=\"headerlink\" title=\"0x01 列表\"></a>0x01 列表</h1><h2 id=\"什么是列表？如何表示列表？\"><a href=\"#什么是列表？如何表示列表？\" class=\"headerlink\" title=\"什么是列表？如何表示列表？\"></a>什么是列表？如何表示列表？</h2><p>​    列表就是由一组特定顺序的元素组成，使用中括号“[ ]”来表示，元素之间使用逗号分隔，例如：animal = [‘cat’, ‘dog’, ‘monkey’]</p>\n<h2 id=\"访问列表\"><a href=\"#访问列表\" class=\"headerlink\" title=\"访问列表\"></a>访问列表</h2><p>​    列表的访问通过索引下标来访问，索引和其他大多数语言一样从0开始。</p>\n<p>也就是说访问第一个元素为：animal[0]。而和其他语言不一样的是Python中索引可以为负值，如：animal[-1]实际为最后一个元素，以此类推。</p>\n<h2 id=\"列表增加元素\"><a href=\"#列表增加元素\" class=\"headerlink\" title=\"列表增加元素\"></a>列表增加元素</h2><p>​    元素的添加分为两种，列表末尾追加和任意位置添加</p>\n<ul>\n<li><p>末尾追加</p>\n<p>使用方法append，animal.append(’fox‘)</p>\n</li>\n<li><p>任意位置添加</p>\n<p>使用方法insert，animal.insert(1,’fox’)。第一个参数为索引值</p>\n</li>\n</ul>\n<h2 id=\"列表删除元素\"><a href=\"#列表删除元素\" class=\"headerlink\" title=\"列表删除元素\"></a>列表删除元素</h2><p>元素删除也可以通过四种方式实现：</p>\n<ul>\n<li><p>使用del</p>\n<p>如果知道元素所处列表位置，则使用del  animal[ i ]</p>\n</li>\n<li><p>使用pop</p>\n<p>如果只需删除了列表末尾元素，则直接使用animal.pop方法。类似出栈</p>\n</li>\n<li><p>使用pop</p>\n<p>如果要删除任意位置元素，使用animal.pop（i)，参数为索引值</p>\n</li>\n<li><p>使用remove</p>\n<p>如果知道元素值而不知道位置，则使用animal.remove（value），参数为元素值</p>\n</li>\n</ul>\n<h2 id=\"列表修改元素\"><a href=\"#列表修改元素\" class=\"headerlink\" title=\"列表修改元素\"></a>列表修改元素</h2><p>​    修改列表元素的语法与访问列表元素的语法类似，如果要进行元素修改只要拿到元素后对其进行从新赋值即可：animal[1] = ‘bird’。</p>\n<h2 id=\"列表元素遍历\"><a href=\"#列表元素遍历\" class=\"headerlink\" title=\"列表元素遍历\"></a>列表元素遍历</h2><p>列表遍历使用循环即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> ani <span class=\"keyword\">in</span> animal:</div><div class=\"line\">\tprint(ani)</div></pre></td></tr></table></figure>\n<h1 id=\"0x02-元组\"><a href=\"#0x02-元组\" class=\"headerlink\" title=\"0x02 元组\"></a>0x02 元组</h1><p>元组使用小括号，列表使用方括号。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>\n<ul>\n<li>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</li>\n</ul>\n<ul>\n<li><p>元组中只包含一个元素时，需要在元素后面添加逗号</p>\n<p>​    tup1 = (10,)</p>\n</li>\n<li><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cats = (<span class=\"string\">'xm'</span>,<span class=\"string\">'dm'</span>)</div><div class=\"line\">print(cats)</div><div class=\"line\"><span class=\"keyword\">del</span> cats</div><div class=\"line\">print(cats)<span class=\"comment\">#打印异常</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cats = (<span class=\"string\">'xm'</span>, <span class=\"string\">'dm'</span>)</div><div class=\"line\">cat1 = (<span class=\"string\">'mm'</span>,)</div><div class=\"line\">allCat = cats + cat1</div><div class=\"line\">print(allCat)<span class=\"comment\">#('xm', 'dm', 'mm')</span></div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x03-字典\"><a href=\"#0x03-字典\" class=\"headerlink\" title=\"0x03 字典\"></a>0x03 字典</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>​    上一节说明了Python字符串和简单数据类型的基本用法，因为比较简单，所以没有做太多说明，这一节介绍下列表、元组和字典。之所以把这三个放在同一节讲是因为这三个数据结构有很多相似地方，对比学习让人印象更深。</p>\n<h1 id=\"0x01-列表\"><a href=\"#0x01-列表\" class=\"headerlink\" title=\"0x01 列表\"></a>0x01 列表</h1><h2 id=\"什么是列表？如何表示列表？\"><a href=\"#什么是列表？如何表示列表？\" class=\"headerlink\" title=\"什么是列表？如何表示列表？\"></a>什么是列表？如何表示列表？</h2><p>​    列表就是由一组特定顺序的元素组成，使用中括号“[ ]”来表示，元素之间使用逗号分隔，例如：animal = [‘cat’, ‘dog’, ‘monkey’]</p>\n<h2 id=\"访问列表\"><a href=\"#访问列表\" class=\"headerlink\" title=\"访问列表\"></a>访问列表</h2><p>​    列表的访问通过索引下标来访问，索引和其他大多数语言一样从0开始。</p>\n<p>也就是说访问第一个元素为：animal[0]。而和其他语言不一样的是Python中索引可以为负值，如：animal[-1]实际为最后一个元素，以此类推。</p>\n<h2 id=\"列表增加元素\"><a href=\"#列表增加元素\" class=\"headerlink\" title=\"列表增加元素\"></a>列表增加元素</h2><p>​    元素的添加分为两种，列表末尾追加和任意位置添加</p>\n<ul>\n<li><p>末尾追加</p>\n<p>使用方法append，animal.append(’fox‘)</p>\n</li>\n<li><p>任意位置添加</p>\n<p>使用方法insert，animal.insert(1,’fox’)。第一个参数为索引值</p>\n</li>\n</ul>\n<h2 id=\"列表删除元素\"><a href=\"#列表删除元素\" class=\"headerlink\" title=\"列表删除元素\"></a>列表删除元素</h2><p>元素删除也可以通过四种方式实现：</p>\n<ul>\n<li><p>使用del</p>\n<p>如果知道元素所处列表位置，则使用del  animal[ i ]</p>\n</li>\n<li><p>使用pop</p>\n<p>如果只需删除了列表末尾元素，则直接使用animal.pop方法。类似出栈</p>\n</li>\n<li><p>使用pop</p>\n<p>如果要删除任意位置元素，使用animal.pop（i)，参数为索引值</p>\n</li>\n<li><p>使用remove</p>\n<p>如果知道元素值而不知道位置，则使用animal.remove（value），参数为元素值</p>\n</li>\n</ul>\n<h2 id=\"列表修改元素\"><a href=\"#列表修改元素\" class=\"headerlink\" title=\"列表修改元素\"></a>列表修改元素</h2><p>​    修改列表元素的语法与访问列表元素的语法类似，如果要进行元素修改只要拿到元素后对其进行从新赋值即可：animal[1] = ‘bird’。</p>\n<h2 id=\"列表元素遍历\"><a href=\"#列表元素遍历\" class=\"headerlink\" title=\"列表元素遍历\"></a>列表元素遍历</h2><p>列表遍历使用循环即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> ani <span class=\"keyword\">in</span> animal:</div><div class=\"line\">\tprint(ani)</div></pre></td></tr></table></figure>\n<h1 id=\"0x02-元组\"><a href=\"#0x02-元组\" class=\"headerlink\" title=\"0x02 元组\"></a>0x02 元组</h1><p>元组使用小括号，列表使用方括号。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>\n<ul>\n<li>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</li>\n</ul>\n<ul>\n<li><p>元组中只包含一个元素时，需要在元素后面添加逗号</p>\n<p>​    tup1 = (10,)</p>\n</li>\n<li><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cats = (<span class=\"string\">'xm'</span>,<span class=\"string\">'dm'</span>)</div><div class=\"line\">print(cats)</div><div class=\"line\"><span class=\"keyword\">del</span> cats</div><div class=\"line\">print(cats)<span class=\"comment\">#打印异常</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cats = (<span class=\"string\">'xm'</span>, <span class=\"string\">'dm'</span>)</div><div class=\"line\">cat1 = (<span class=\"string\">'mm'</span>,)</div><div class=\"line\">allCat = cats + cat1</div><div class=\"line\">print(allCat)<span class=\"comment\">#('xm', 'dm', 'mm')</span></div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x03-字典\"><a href=\"#0x03-字典\" class=\"headerlink\" title=\"0x03 字典\"></a>0x03 字典</h1>"},{"title":"Python用qq邮箱发邮件","date":"2017-08-09T09:30:48.000Z","_content":"\n# 前言\n\n如果经常无人看管的项目出现了异常，那比较好的办法就是发个邮件给运营人一个提示，这样方便及时处理。\n\n所以写一个自动发邮件的模块就显得有必要了。\n\n但是默认QQ邮箱是没有开启第三方收发支持的，所以我们首先要开启支持\n\n# 开启QQ邮箱支持\n\n打开 QQ邮箱页面—>设置—>账户—>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务\n\n开启需要的服务，我这里打开**POP3/SMTP服务**\n\n![qq邮箱三方服务器设置](http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E8%AE%BE%E7%BD%AE%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E5%99%A8.png)\n\n\n\n使用SSL的通用配置如下：\n\n**接收邮件服务器：**pop.qq.com，使用SSL，端口号995\n\n**发送邮件服务器：**smtp.qq.com，使用SSL，端口号465或587\n\n**账户名：**您的QQ邮箱账户名（如果您是VIP帐号或Foxmail帐号，账户名需要填写完整的邮件地址）\n\n**密码：**您的QQ邮箱密码\n\n**电子邮件地址：**您的QQ邮箱的完整邮件地址\n\n第三方需要使用授权码作为上面的密码。\n\n# 用qq邮箱发送邮件\n\n发送邮件使用**smtplib库**。\n\n## 发送文本内容\n\n```python\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\n\nhost = 'smtp.qq.com'  # 发送服务器地址\nuser = '840418528@qq.com'  # 验证用户名\npwd = '***'  # 验证密码(授权码)\nsender = '840418528@qq.com'  # 发件人地址，和验证用户名应一致\nreceivers = ['840418528@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n\nmessage = MIMEText('a test for python', 'plain', 'utf-8')  # 邮件内容\nmessage['From'] = Header(\"Jenson\", 'utf-8')  # 发件人名字\nmessage['To'] = Header(\"songjl\", 'utf-8')  # 收件人名字\nsubject = '周报'  # 邮件标题\nmessage['Subject'] = Header(subject, 'utf-8')\n\ntry:\n    smtpObj = smtplib.SMTP_SSL(host, 465)\n    login_result = smtpObj.login(user, pwd)\n    if 235 == login_result[0]:  # 235表示登陆成功\n        send_result = smtpObj.sendmail(sender, receivers, message.as_string())\n        print(\"邮件发送成功\")\n    smtpObj.quit()\n\nexcept smtplib.SMTPException as e:\n    print(e)\n\n```\n\n上面我是自己给自己发了封邮件，打印显示成功：\n\n![qq邮箱发送成功](http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E6%88%90%E5%8A%9F%E6%88%AA%E5%9B%BE.png)\n\n\n\n接下来查看QQ邮箱：\n\n![收到邮件](http://othg5ggzi.bkt.clouddn.com/%E6%94%B6%E5%88%B0%E9%82%AE%E4%BB%B6%E6%88%AA%E5%9B%BE.png)\n\n上面虽然发送成功了，但是内容只是文本，下面试试如何发送HTML格式\n\n\n\n## 发送HTML内容\n\n```python\nmessage = MIMEText(r'<p>发送测试</p><a href=\"www.jensondev.me\">我的技术博客</a>', 'html', 'utf-8')  # 邮件内容\n\n```\n\n发送HTML内容，除了内容是HTML网页格式，还要把内容格式改为**‘HTML’**。\n\n收到邮件内容如下：\n\n![html邮件内容](http://othg5ggzi.bkt.clouddn.com/HTML%E5%86%85%E5%AE%B9%E9%82%AE%E4%BB%B6.png)\n\n可以看到已经显示出链接来了。\n\n\n\n## 发送附件内容\n\n发送附件使用**MIMEMultipart**类\n\n```python\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\nfrom email.mime.multipart import MIMEMultipart\n\nhost = 'smtp.qq.com'  # 发送服务器地址\nuser = '840418528@qq.com'  # 验证用户名\npwd = '***'  # 验证密码(授权码)\nsender = '840418528@qq.com'  # 发件人地址，和验证用户名应一致\nreceivers = ['840418528@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n\n# message = MIMEText(r'<p>发送测试</p><a href=\"www.jensondev.me\">我的技术博客</a>', 'html', 'utf-8')  # 邮件内容\nmessage = MIMEMultipart()\n# 邮件正文内容\nmessage.attach(MIMEText('这是正文内容', 'plain', 'utf-8'))\n\n# 附件1，传送当前目录下的 txt 文件\natt1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')\natt1[\"Content-Type\"] = 'application/octet-stream'\n# 这里的filename可以任意写，写什么名字，邮件中显示什么名字\natt1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"'\nmessage.attach(att1)\n\n# 构造附件2，传送当前目录下的 图片 文件\natt2 = MIMEText(open('email.png', 'rb').read(), 'base64', 'utf-8')\natt2[\"Content-Type\"] = 'application/png'\natt2[\"Content-Disposition\"] = 'attachment; filename=\"email.png\"'\nmessage.attach(att2)\n\nmessage['From'] = Header(\"Jenson\", 'utf-8')  # 发件人名字\nmessage['To'] = Header(\"songjl\", 'utf-8')  # 收件人名字\nsubject = '带附件周报'  # 邮件标题\nmessage['Subject'] = Header(subject, 'utf-8')\n\ntry:\n    smtpObj = smtplib.SMTP_SSL(host, 465)\n    login_result = smtpObj.login(user, pwd)\n    if 235 == login_result[0]:  # 235表示登陆成功\n        send_result = smtpObj.sendmail(sender, receivers, message.as_string())\n        print(\"邮件发送成功\")\n    smtpObj.quit()\n\nexcept smtplib.SMTPException as e:\n    print(e)\n\n\n```\n\n\n\n收到内容如下：\n\n![带邮件附件](http://othg5ggzi.bkt.clouddn.com/%E5%B8%A6%E9%99%84%E4%BB%B6%E9%82%AE%E4%BB%B6.png)\n\n可见文本和图片都已经收到了。\n\n## 附件中文乱码问题\n\n```python\natt2[\"Content-Disposition\"] = 'attachment; filename= '+filename\n\n```\n\n这里的filename只能是字符串，但是如果encode('utf-8')后是字节，这样行不通。\n\n但是**Content-Disposition**这个属性可以通过另一种方式添加：\n\n```python\natt2.add_header('Content-Disposition', 'attachment',filename=('gbk','',filename))\n\n```\n\n这时filename就可以设置为元组了，可以同时传编码和文件名称。\n\n可以参考[官方文档](https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.add_header)。\n\n\n\n","source":"_posts/Python用qq邮箱发邮件.md","raw":"---\ntitle: Python用qq邮箱发邮件\ndate: 2017-08-09 17:30:48\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n如果经常无人看管的项目出现了异常，那比较好的办法就是发个邮件给运营人一个提示，这样方便及时处理。\n\n所以写一个自动发邮件的模块就显得有必要了。\n\n但是默认QQ邮箱是没有开启第三方收发支持的，所以我们首先要开启支持\n\n# 开启QQ邮箱支持\n\n打开 QQ邮箱页面—>设置—>账户—>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务\n\n开启需要的服务，我这里打开**POP3/SMTP服务**\n\n![qq邮箱三方服务器设置](http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E8%AE%BE%E7%BD%AE%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E5%99%A8.png)\n\n\n\n使用SSL的通用配置如下：\n\n**接收邮件服务器：**pop.qq.com，使用SSL，端口号995\n\n**发送邮件服务器：**smtp.qq.com，使用SSL，端口号465或587\n\n**账户名：**您的QQ邮箱账户名（如果您是VIP帐号或Foxmail帐号，账户名需要填写完整的邮件地址）\n\n**密码：**您的QQ邮箱密码\n\n**电子邮件地址：**您的QQ邮箱的完整邮件地址\n\n第三方需要使用授权码作为上面的密码。\n\n# 用qq邮箱发送邮件\n\n发送邮件使用**smtplib库**。\n\n## 发送文本内容\n\n```python\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\n\nhost = 'smtp.qq.com'  # 发送服务器地址\nuser = '840418528@qq.com'  # 验证用户名\npwd = '***'  # 验证密码(授权码)\nsender = '840418528@qq.com'  # 发件人地址，和验证用户名应一致\nreceivers = ['840418528@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n\nmessage = MIMEText('a test for python', 'plain', 'utf-8')  # 邮件内容\nmessage['From'] = Header(\"Jenson\", 'utf-8')  # 发件人名字\nmessage['To'] = Header(\"songjl\", 'utf-8')  # 收件人名字\nsubject = '周报'  # 邮件标题\nmessage['Subject'] = Header(subject, 'utf-8')\n\ntry:\n    smtpObj = smtplib.SMTP_SSL(host, 465)\n    login_result = smtpObj.login(user, pwd)\n    if 235 == login_result[0]:  # 235表示登陆成功\n        send_result = smtpObj.sendmail(sender, receivers, message.as_string())\n        print(\"邮件发送成功\")\n    smtpObj.quit()\n\nexcept smtplib.SMTPException as e:\n    print(e)\n\n```\n\n上面我是自己给自己发了封邮件，打印显示成功：\n\n![qq邮箱发送成功](http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E6%88%90%E5%8A%9F%E6%88%AA%E5%9B%BE.png)\n\n\n\n接下来查看QQ邮箱：\n\n![收到邮件](http://othg5ggzi.bkt.clouddn.com/%E6%94%B6%E5%88%B0%E9%82%AE%E4%BB%B6%E6%88%AA%E5%9B%BE.png)\n\n上面虽然发送成功了，但是内容只是文本，下面试试如何发送HTML格式\n\n\n\n## 发送HTML内容\n\n```python\nmessage = MIMEText(r'<p>发送测试</p><a href=\"www.jensondev.me\">我的技术博客</a>', 'html', 'utf-8')  # 邮件内容\n\n```\n\n发送HTML内容，除了内容是HTML网页格式，还要把内容格式改为**‘HTML’**。\n\n收到邮件内容如下：\n\n![html邮件内容](http://othg5ggzi.bkt.clouddn.com/HTML%E5%86%85%E5%AE%B9%E9%82%AE%E4%BB%B6.png)\n\n可以看到已经显示出链接来了。\n\n\n\n## 发送附件内容\n\n发送附件使用**MIMEMultipart**类\n\n```python\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\nfrom email.mime.multipart import MIMEMultipart\n\nhost = 'smtp.qq.com'  # 发送服务器地址\nuser = '840418528@qq.com'  # 验证用户名\npwd = '***'  # 验证密码(授权码)\nsender = '840418528@qq.com'  # 发件人地址，和验证用户名应一致\nreceivers = ['840418528@qq.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱\n\n# message = MIMEText(r'<p>发送测试</p><a href=\"www.jensondev.me\">我的技术博客</a>', 'html', 'utf-8')  # 邮件内容\nmessage = MIMEMultipart()\n# 邮件正文内容\nmessage.attach(MIMEText('这是正文内容', 'plain', 'utf-8'))\n\n# 附件1，传送当前目录下的 txt 文件\natt1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')\natt1[\"Content-Type\"] = 'application/octet-stream'\n# 这里的filename可以任意写，写什么名字，邮件中显示什么名字\natt1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"'\nmessage.attach(att1)\n\n# 构造附件2，传送当前目录下的 图片 文件\natt2 = MIMEText(open('email.png', 'rb').read(), 'base64', 'utf-8')\natt2[\"Content-Type\"] = 'application/png'\natt2[\"Content-Disposition\"] = 'attachment; filename=\"email.png\"'\nmessage.attach(att2)\n\nmessage['From'] = Header(\"Jenson\", 'utf-8')  # 发件人名字\nmessage['To'] = Header(\"songjl\", 'utf-8')  # 收件人名字\nsubject = '带附件周报'  # 邮件标题\nmessage['Subject'] = Header(subject, 'utf-8')\n\ntry:\n    smtpObj = smtplib.SMTP_SSL(host, 465)\n    login_result = smtpObj.login(user, pwd)\n    if 235 == login_result[0]:  # 235表示登陆成功\n        send_result = smtpObj.sendmail(sender, receivers, message.as_string())\n        print(\"邮件发送成功\")\n    smtpObj.quit()\n\nexcept smtplib.SMTPException as e:\n    print(e)\n\n\n```\n\n\n\n收到内容如下：\n\n![带邮件附件](http://othg5ggzi.bkt.clouddn.com/%E5%B8%A6%E9%99%84%E4%BB%B6%E9%82%AE%E4%BB%B6.png)\n\n可见文本和图片都已经收到了。\n\n## 附件中文乱码问题\n\n```python\natt2[\"Content-Disposition\"] = 'attachment; filename= '+filename\n\n```\n\n这里的filename只能是字符串，但是如果encode('utf-8')后是字节，这样行不通。\n\n但是**Content-Disposition**这个属性可以通过另一种方式添加：\n\n```python\natt2.add_header('Content-Disposition', 'attachment',filename=('gbk','',filename))\n\n```\n\n这时filename就可以设置为元组了，可以同时传编码和文件名称。\n\n可以参考[官方文档](https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.add_header)。\n\n\n\n","slug":"Python用qq邮箱发邮件","published":1,"updated":"2017-08-09T15:51:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjeo003fwh9copbrxdij","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>如果经常无人看管的项目出现了异常，那比较好的办法就是发个邮件给运营人一个提示，这样方便及时处理。</p>\n<p>所以写一个自动发邮件的模块就显得有必要了。</p>\n<p>但是默认QQ邮箱是没有开启第三方收发支持的，所以我们首先要开启支持</p>\n<h1 id=\"开启QQ邮箱支持\"><a href=\"#开启QQ邮箱支持\" class=\"headerlink\" title=\"开启QQ邮箱支持\"></a>开启QQ邮箱支持</h1><p>打开 QQ邮箱页面—&gt;设置—&gt;账户—&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</p>\n<p>开启需要的服务，我这里打开<strong>POP3/SMTP服务</strong></p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E8%AE%BE%E7%BD%AE%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E5%99%A8.png\" alt=\"qq邮箱三方服务器设置\"></p>\n<p>使用SSL的通用配置如下：</p>\n<p><strong>接收邮件服务器：</strong>pop.qq.com，使用SSL，端口号995</p>\n<p><strong>发送邮件服务器：</strong>smtp.qq.com，使用SSL，端口号465或587</p>\n<p><strong>账户名：</strong>您的QQ邮箱账户名（如果您是VIP帐号或Foxmail帐号，账户名需要填写完整的邮件地址）</p>\n<p><strong>密码：</strong>您的QQ邮箱密码</p>\n<p><strong>电子邮件地址：</strong>您的QQ邮箱的完整邮件地址</p>\n<p>第三方需要使用授权码作为上面的密码。</p>\n<h1 id=\"用qq邮箱发送邮件\"><a href=\"#用qq邮箱发送邮件\" class=\"headerlink\" title=\"用qq邮箱发送邮件\"></a>用qq邮箱发送邮件</h1><p>发送邮件使用<strong>smtplib库</strong>。</p>\n<h2 id=\"发送文本内容\"><a href=\"#发送文本内容\" class=\"headerlink\" title=\"发送文本内容\"></a>发送文本内容</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> smtplib</div><div class=\"line\"><span class=\"keyword\">from</span> email.mime.text <span class=\"keyword\">import</span> MIMEText</div><div class=\"line\"><span class=\"keyword\">from</span> email.header <span class=\"keyword\">import</span> Header</div><div class=\"line\"></div><div class=\"line\">host = <span class=\"string\">'smtp.qq.com'</span>  <span class=\"comment\"># 发送服务器地址</span></div><div class=\"line\">user = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 验证用户名</span></div><div class=\"line\">pwd = <span class=\"string\">'***'</span>  <span class=\"comment\"># 验证密码(授权码)</span></div><div class=\"line\">sender = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 发件人地址，和验证用户名应一致</span></div><div class=\"line\">receivers = [<span class=\"string\">'840418528@qq.com'</span>]  <span class=\"comment\"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></div><div class=\"line\"></div><div class=\"line\">message = MIMEText(<span class=\"string\">'a test for python'</span>, <span class=\"string\">'plain'</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 邮件内容</span></div><div class=\"line\">message[<span class=\"string\">'From'</span>] = Header(<span class=\"string\">\"Jenson\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 发件人名字</span></div><div class=\"line\">message[<span class=\"string\">'To'</span>] = Header(<span class=\"string\">\"songjl\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 收件人名字</span></div><div class=\"line\">subject = <span class=\"string\">'周报'</span>  <span class=\"comment\"># 邮件标题</span></div><div class=\"line\">message[<span class=\"string\">'Subject'</span>] = Header(subject, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    smtpObj = smtplib.SMTP_SSL(host, <span class=\"number\">465</span>)</div><div class=\"line\">    login_result = smtpObj.login(user, pwd)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">235</span> == login_result[<span class=\"number\">0</span>]:  <span class=\"comment\"># 235表示登陆成功</span></div><div class=\"line\">        send_result = smtpObj.sendmail(sender, receivers, message.as_string())</div><div class=\"line\">        print(<span class=\"string\">\"邮件发送成功\"</span>)</div><div class=\"line\">    smtpObj.quit()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">except</span> smtplib.SMTPException <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div></pre></td></tr></table></figure>\n<p>上面我是自己给自己发了封邮件，打印显示成功：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E6%88%90%E5%8A%9F%E6%88%AA%E5%9B%BE.png\" alt=\"qq邮箱发送成功\"></p>\n<p>接下来查看QQ邮箱：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%94%B6%E5%88%B0%E9%82%AE%E4%BB%B6%E6%88%AA%E5%9B%BE.png\" alt=\"收到邮件\"></p>\n<p>上面虽然发送成功了，但是内容只是文本，下面试试如何发送HTML格式</p>\n<h2 id=\"发送HTML内容\"><a href=\"#发送HTML内容\" class=\"headerlink\" title=\"发送HTML内容\"></a>发送HTML内容</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">message = MIMEText(<span class=\"string\">r'&lt;p&gt;发送测试&lt;/p&gt;&lt;a href=\"www.jensondev.me\"&gt;我的技术博客&lt;/a&gt;'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 邮件内容</span></div></pre></td></tr></table></figure>\n<p>发送HTML内容，除了内容是HTML网页格式，还要把内容格式改为<strong>‘HTML’</strong>。</p>\n<p>收到邮件内容如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/HTML%E5%86%85%E5%AE%B9%E9%82%AE%E4%BB%B6.png\" alt=\"html邮件内容\"></p>\n<p>可以看到已经显示出链接来了。</p>\n<h2 id=\"发送附件内容\"><a href=\"#发送附件内容\" class=\"headerlink\" title=\"发送附件内容\"></a>发送附件内容</h2><p>发送附件使用<strong>MIMEMultipart</strong>类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> smtplib</div><div class=\"line\"><span class=\"keyword\">from</span> email.mime.text <span class=\"keyword\">import</span> MIMEText</div><div class=\"line\"><span class=\"keyword\">from</span> email.header <span class=\"keyword\">import</span> Header</div><div class=\"line\"><span class=\"keyword\">from</span> email.mime.multipart <span class=\"keyword\">import</span> MIMEMultipart</div><div class=\"line\"></div><div class=\"line\">host = <span class=\"string\">'smtp.qq.com'</span>  <span class=\"comment\"># 发送服务器地址</span></div><div class=\"line\">user = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 验证用户名</span></div><div class=\"line\">pwd = <span class=\"string\">'***'</span>  <span class=\"comment\"># 验证密码(授权码)</span></div><div class=\"line\">sender = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 发件人地址，和验证用户名应一致</span></div><div class=\"line\">receivers = [<span class=\"string\">'840418528@qq.com'</span>]  <span class=\"comment\"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># message = MIMEText(r'&lt;p&gt;发送测试&lt;/p&gt;&lt;a href=\"www.jensondev.me\"&gt;我的技术博客&lt;/a&gt;', 'html', 'utf-8')  # 邮件内容</span></div><div class=\"line\">message = MIMEMultipart()</div><div class=\"line\"><span class=\"comment\"># 邮件正文内容</span></div><div class=\"line\">message.attach(MIMEText(<span class=\"string\">'这是正文内容'</span>, <span class=\"string\">'plain'</span>, <span class=\"string\">'utf-8'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 附件1，传送当前目录下的 txt 文件</span></div><div class=\"line\">att1 = MIMEText(open(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'rb'</span>).read(), <span class=\"string\">'base64'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\">att1[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">'application/octet-stream'</span></div><div class=\"line\"><span class=\"comment\"># 这里的filename可以任意写，写什么名字，邮件中显示什么名字</span></div><div class=\"line\">att1[<span class=\"string\">\"Content-Disposition\"</span>] = <span class=\"string\">'attachment; filename=\"test.txt\"'</span></div><div class=\"line\">message.attach(att1)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造附件2，传送当前目录下的 图片 文件</span></div><div class=\"line\">att2 = MIMEText(open(<span class=\"string\">'email.png'</span>, <span class=\"string\">'rb'</span>).read(), <span class=\"string\">'base64'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\">att2[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">'application/png'</span></div><div class=\"line\">att2[<span class=\"string\">\"Content-Disposition\"</span>] = <span class=\"string\">'attachment; filename=\"email.png\"'</span></div><div class=\"line\">message.attach(att2)</div><div class=\"line\"></div><div class=\"line\">message[<span class=\"string\">'From'</span>] = Header(<span class=\"string\">\"Jenson\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 发件人名字</span></div><div class=\"line\">message[<span class=\"string\">'To'</span>] = Header(<span class=\"string\">\"songjl\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 收件人名字</span></div><div class=\"line\">subject = <span class=\"string\">'带附件周报'</span>  <span class=\"comment\"># 邮件标题</span></div><div class=\"line\">message[<span class=\"string\">'Subject'</span>] = Header(subject, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    smtpObj = smtplib.SMTP_SSL(host, <span class=\"number\">465</span>)</div><div class=\"line\">    login_result = smtpObj.login(user, pwd)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">235</span> == login_result[<span class=\"number\">0</span>]:  <span class=\"comment\"># 235表示登陆成功</span></div><div class=\"line\">        send_result = smtpObj.sendmail(sender, receivers, message.as_string())</div><div class=\"line\">        print(<span class=\"string\">\"邮件发送成功\"</span>)</div><div class=\"line\">    smtpObj.quit()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">except</span> smtplib.SMTPException <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div></pre></td></tr></table></figure>\n<p>收到内容如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%B8%A6%E9%99%84%E4%BB%B6%E9%82%AE%E4%BB%B6.png\" alt=\"带邮件附件\"></p>\n<p>可见文本和图片都已经收到了。</p>\n<h2 id=\"附件中文乱码问题\"><a href=\"#附件中文乱码问题\" class=\"headerlink\" title=\"附件中文乱码问题\"></a>附件中文乱码问题</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">att2[<span class=\"string\">\"Content-Disposition\"</span>] = <span class=\"string\">'attachment; filename= '</span>+filename</div></pre></td></tr></table></figure>\n<p>这里的filename只能是字符串，但是如果encode(‘utf-8’)后是字节，这样行不通。</p>\n<p>但是<strong>Content-Disposition</strong>这个属性可以通过另一种方式添加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">att2.add_header(<span class=\"string\">'Content-Disposition'</span>, <span class=\"string\">'attachment'</span>,filename=(<span class=\"string\">'gbk'</span>,<span class=\"string\">''</span>,filename))</div></pre></td></tr></table></figure>\n<p>这时filename就可以设置为元组了，可以同时传编码和文件名称。</p>\n<p>可以参考<a href=\"https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.add_header\" target=\"_blank\" rel=\"external\">官方文档</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>如果经常无人看管的项目出现了异常，那比较好的办法就是发个邮件给运营人一个提示，这样方便及时处理。</p>\n<p>所以写一个自动发邮件的模块就显得有必要了。</p>\n<p>但是默认QQ邮箱是没有开启第三方收发支持的，所以我们首先要开启支持</p>\n<h1 id=\"开启QQ邮箱支持\"><a href=\"#开启QQ邮箱支持\" class=\"headerlink\" title=\"开启QQ邮箱支持\"></a>开启QQ邮箱支持</h1><p>打开 QQ邮箱页面—&gt;设置—&gt;账户—&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</p>\n<p>开启需要的服务，我这里打开<strong>POP3/SMTP服务</strong></p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E8%AE%BE%E7%BD%AE%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E5%99%A8.png\" alt=\"qq邮箱三方服务器设置\"></p>\n<p>使用SSL的通用配置如下：</p>\n<p><strong>接收邮件服务器：</strong>pop.qq.com，使用SSL，端口号995</p>\n<p><strong>发送邮件服务器：</strong>smtp.qq.com，使用SSL，端口号465或587</p>\n<p><strong>账户名：</strong>您的QQ邮箱账户名（如果您是VIP帐号或Foxmail帐号，账户名需要填写完整的邮件地址）</p>\n<p><strong>密码：</strong>您的QQ邮箱密码</p>\n<p><strong>电子邮件地址：</strong>您的QQ邮箱的完整邮件地址</p>\n<p>第三方需要使用授权码作为上面的密码。</p>\n<h1 id=\"用qq邮箱发送邮件\"><a href=\"#用qq邮箱发送邮件\" class=\"headerlink\" title=\"用qq邮箱发送邮件\"></a>用qq邮箱发送邮件</h1><p>发送邮件使用<strong>smtplib库</strong>。</p>\n<h2 id=\"发送文本内容\"><a href=\"#发送文本内容\" class=\"headerlink\" title=\"发送文本内容\"></a>发送文本内容</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> smtplib</div><div class=\"line\"><span class=\"keyword\">from</span> email.mime.text <span class=\"keyword\">import</span> MIMEText</div><div class=\"line\"><span class=\"keyword\">from</span> email.header <span class=\"keyword\">import</span> Header</div><div class=\"line\"></div><div class=\"line\">host = <span class=\"string\">'smtp.qq.com'</span>  <span class=\"comment\"># 发送服务器地址</span></div><div class=\"line\">user = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 验证用户名</span></div><div class=\"line\">pwd = <span class=\"string\">'***'</span>  <span class=\"comment\"># 验证密码(授权码)</span></div><div class=\"line\">sender = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 发件人地址，和验证用户名应一致</span></div><div class=\"line\">receivers = [<span class=\"string\">'840418528@qq.com'</span>]  <span class=\"comment\"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></div><div class=\"line\"></div><div class=\"line\">message = MIMEText(<span class=\"string\">'a test for python'</span>, <span class=\"string\">'plain'</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 邮件内容</span></div><div class=\"line\">message[<span class=\"string\">'From'</span>] = Header(<span class=\"string\">\"Jenson\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 发件人名字</span></div><div class=\"line\">message[<span class=\"string\">'To'</span>] = Header(<span class=\"string\">\"songjl\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 收件人名字</span></div><div class=\"line\">subject = <span class=\"string\">'周报'</span>  <span class=\"comment\"># 邮件标题</span></div><div class=\"line\">message[<span class=\"string\">'Subject'</span>] = Header(subject, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    smtpObj = smtplib.SMTP_SSL(host, <span class=\"number\">465</span>)</div><div class=\"line\">    login_result = smtpObj.login(user, pwd)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">235</span> == login_result[<span class=\"number\">0</span>]:  <span class=\"comment\"># 235表示登陆成功</span></div><div class=\"line\">        send_result = smtpObj.sendmail(sender, receivers, message.as_string())</div><div class=\"line\">        print(<span class=\"string\">\"邮件发送成功\"</span>)</div><div class=\"line\">    smtpObj.quit()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">except</span> smtplib.SMTPException <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div></pre></td></tr></table></figure>\n<p>上面我是自己给自己发了封邮件，打印显示成功：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/qq%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E6%88%90%E5%8A%9F%E6%88%AA%E5%9B%BE.png\" alt=\"qq邮箱发送成功\"></p>\n<p>接下来查看QQ邮箱：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%94%B6%E5%88%B0%E9%82%AE%E4%BB%B6%E6%88%AA%E5%9B%BE.png\" alt=\"收到邮件\"></p>\n<p>上面虽然发送成功了，但是内容只是文本，下面试试如何发送HTML格式</p>\n<h2 id=\"发送HTML内容\"><a href=\"#发送HTML内容\" class=\"headerlink\" title=\"发送HTML内容\"></a>发送HTML内容</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">message = MIMEText(<span class=\"string\">r'&lt;p&gt;发送测试&lt;/p&gt;&lt;a href=\"www.jensondev.me\"&gt;我的技术博客&lt;/a&gt;'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 邮件内容</span></div></pre></td></tr></table></figure>\n<p>发送HTML内容，除了内容是HTML网页格式，还要把内容格式改为<strong>‘HTML’</strong>。</p>\n<p>收到邮件内容如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/HTML%E5%86%85%E5%AE%B9%E9%82%AE%E4%BB%B6.png\" alt=\"html邮件内容\"></p>\n<p>可以看到已经显示出链接来了。</p>\n<h2 id=\"发送附件内容\"><a href=\"#发送附件内容\" class=\"headerlink\" title=\"发送附件内容\"></a>发送附件内容</h2><p>发送附件使用<strong>MIMEMultipart</strong>类</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> smtplib</div><div class=\"line\"><span class=\"keyword\">from</span> email.mime.text <span class=\"keyword\">import</span> MIMEText</div><div class=\"line\"><span class=\"keyword\">from</span> email.header <span class=\"keyword\">import</span> Header</div><div class=\"line\"><span class=\"keyword\">from</span> email.mime.multipart <span class=\"keyword\">import</span> MIMEMultipart</div><div class=\"line\"></div><div class=\"line\">host = <span class=\"string\">'smtp.qq.com'</span>  <span class=\"comment\"># 发送服务器地址</span></div><div class=\"line\">user = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 验证用户名</span></div><div class=\"line\">pwd = <span class=\"string\">'***'</span>  <span class=\"comment\"># 验证密码(授权码)</span></div><div class=\"line\">sender = <span class=\"string\">'840418528@qq.com'</span>  <span class=\"comment\"># 发件人地址，和验证用户名应一致</span></div><div class=\"line\">receivers = [<span class=\"string\">'840418528@qq.com'</span>]  <span class=\"comment\"># 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># message = MIMEText(r'&lt;p&gt;发送测试&lt;/p&gt;&lt;a href=\"www.jensondev.me\"&gt;我的技术博客&lt;/a&gt;', 'html', 'utf-8')  # 邮件内容</span></div><div class=\"line\">message = MIMEMultipart()</div><div class=\"line\"><span class=\"comment\"># 邮件正文内容</span></div><div class=\"line\">message.attach(MIMEText(<span class=\"string\">'这是正文内容'</span>, <span class=\"string\">'plain'</span>, <span class=\"string\">'utf-8'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 附件1，传送当前目录下的 txt 文件</span></div><div class=\"line\">att1 = MIMEText(open(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'rb'</span>).read(), <span class=\"string\">'base64'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\">att1[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">'application/octet-stream'</span></div><div class=\"line\"><span class=\"comment\"># 这里的filename可以任意写，写什么名字，邮件中显示什么名字</span></div><div class=\"line\">att1[<span class=\"string\">\"Content-Disposition\"</span>] = <span class=\"string\">'attachment; filename=\"test.txt\"'</span></div><div class=\"line\">message.attach(att1)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 构造附件2，传送当前目录下的 图片 文件</span></div><div class=\"line\">att2 = MIMEText(open(<span class=\"string\">'email.png'</span>, <span class=\"string\">'rb'</span>).read(), <span class=\"string\">'base64'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\">att2[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">'application/png'</span></div><div class=\"line\">att2[<span class=\"string\">\"Content-Disposition\"</span>] = <span class=\"string\">'attachment; filename=\"email.png\"'</span></div><div class=\"line\">message.attach(att2)</div><div class=\"line\"></div><div class=\"line\">message[<span class=\"string\">'From'</span>] = Header(<span class=\"string\">\"Jenson\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 发件人名字</span></div><div class=\"line\">message[<span class=\"string\">'To'</span>] = Header(<span class=\"string\">\"songjl\"</span>, <span class=\"string\">'utf-8'</span>)  <span class=\"comment\"># 收件人名字</span></div><div class=\"line\">subject = <span class=\"string\">'带附件周报'</span>  <span class=\"comment\"># 邮件标题</span></div><div class=\"line\">message[<span class=\"string\">'Subject'</span>] = Header(subject, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    smtpObj = smtplib.SMTP_SSL(host, <span class=\"number\">465</span>)</div><div class=\"line\">    login_result = smtpObj.login(user, pwd)</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">235</span> == login_result[<span class=\"number\">0</span>]:  <span class=\"comment\"># 235表示登陆成功</span></div><div class=\"line\">        send_result = smtpObj.sendmail(sender, receivers, message.as_string())</div><div class=\"line\">        print(<span class=\"string\">\"邮件发送成功\"</span>)</div><div class=\"line\">    smtpObj.quit()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">except</span> smtplib.SMTPException <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div></pre></td></tr></table></figure>\n<p>收到内容如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%B8%A6%E9%99%84%E4%BB%B6%E9%82%AE%E4%BB%B6.png\" alt=\"带邮件附件\"></p>\n<p>可见文本和图片都已经收到了。</p>\n<h2 id=\"附件中文乱码问题\"><a href=\"#附件中文乱码问题\" class=\"headerlink\" title=\"附件中文乱码问题\"></a>附件中文乱码问题</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">att2[<span class=\"string\">\"Content-Disposition\"</span>] = <span class=\"string\">'attachment; filename= '</span>+filename</div></pre></td></tr></table></figure>\n<p>这里的filename只能是字符串，但是如果encode(‘utf-8’)后是字节，这样行不通。</p>\n<p>但是<strong>Content-Disposition</strong>这个属性可以通过另一种方式添加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">att2.add_header(<span class=\"string\">'Content-Disposition'</span>, <span class=\"string\">'attachment'</span>,filename=(<span class=\"string\">'gbk'</span>,<span class=\"string\">''</span>,filename))</div></pre></td></tr></table></figure>\n<p>这时filename就可以设置为元组了，可以同时传编码和文件名称。</p>\n<p>可以参考<a href=\"https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.add_header\">官方文档</a>。</p>\n"},{"title":"Python入门系列(5)：进程、线程和协程","date":"2017-08-07T07:22:54.000Z","_content":"\n# 前言\n\n如今硬件发展速度很快，就连手机cpu都是四核八核起步了。那么如何充分发掘、利用强大的cpu资源是作为研发人员的我们需要考虑的事情了。\n\n# 并发和并行\n\n**知己知彼，百战不殆**，要充分利用cpu首先要了解cpu是如何调用程序的。\n\n在线程出现之前，cpu的调度单位是进程，每个程序启动就生成一个独立的进程。\n\n进程拥有独立的内存空间，进行IPC难度较大，且cpu对进程上下文切换耗时较多，种种因素催生了进程的亲戚~线程，自此cpu的最小调度单位就是线程了。\n\n进程，又叫重量级进程，而线程，又叫轻量级进程，之所以是轻量级，是因为多个线程共享进程空间，使得多任务执行时，多线程进行数据交换容易了不少，而且上下文切换也更容易。\n\n对进程和线程有了了解，那多并发和并行又直到多少呢？并行和并发有什么区别？\n\n**并行，同时运行，可以理解为多个不同实体处理多个任务**，\n\n**并发，同时发生，可以理解为一个实体不同时间段处理多个任务**，\n\n**所以并行可以理解为硬件上的，并发理解为逻辑上的**。\n\n对以上都有了了解，下面看看在Python中如何使用：\n\n# 进程\n\n## 创建进程\n\n- os.fork()\n\n  fork⽅法来⾃于Unix/Linux操作系统中提供的⼀个fork系统调⽤， 这个⽅法⾮常特殊。 \n\n  普通的⽅法都是调⽤⼀次， 返回⼀次， ⽽fork⽅法是调⽤⼀次， 返回两次， \n\n  原因在于操作系统将当前进程（⽗进程） 复制出⼀份进程（⼦进程） ， 这两个进程⼏乎完\n  全相同， 于是fork⽅法分别在⽗进程和⼦进程中返回。 ⼦进程中永远返回0， ⽗进程中返回的是⼦进程的ID。\n\n  ```python\n  def getPidTest():\n      print(\"当前进程ID：\" + str(os.getpid()))\n\n  print(\"当前进程ID：\" + str(os.getpid()))\n  pid = os.fork()\n  if pid == 0:#子进程\n      getPidTest()\n  elif pid > 0:# 父进程\n      getPidTest()\n  ```\n\n  ​\n\n- subprocess\n\n  subprocess模块可以用来创建子进程，但是主要功能是执行外部的命令和程序，而不是运行python文件中的函数，另外这里的IPC只能通过管道进行文本交流。\n\n  比如执行终端命令时：\n\n  ```python\n  subprocess.Popen('ls -al', shell=True)\n  ```\n\n  ​\n\n- multiprocessing\n\n  multiprocessing模块提供了⼀个Process类来描述⼀个进程对象。\n\n  创建⼦进程时， 只需要传⼊⼀个执⾏函数和函数的参数， 即可完成⼀个Process实例的创建， ⽤start（） ⽅法启动进程， ⽤join（） ⽅法实现进程间的同步。  \n\n  ```python\n  def getPidTest():\n      print(\"当前进程ID：\" + str(os.getpid()))\n\n  print(\"当前进程ID：\" + str(os.getpid()))\n  if __name__ == '__main__':\n      p = Process(target=getPidTest, name='p1', args=())\n      p.start()\n  ```\n\n  **target**表示进程要调用的函数名\n\n  **name**表示进程名\n\n  **args**表示函数参数的元组形式\n\n  **kargs**表示函数参数的字典形式\n\n## IPC\n\n\n\n# 线程\n\n## 创建线程\n\nPython中有多个模块都可以实现多线程，比如thread，threading，但是由于thread模块自身一些原因，推荐使用threading模块。\n\n- thread模块\n\n   thread 模块提供了基本的线程和锁定支持。\n\n  ```python\n  import _thread\n  _thread.start_new_thread(function=getPidTest, args=(),kwargs={})\n  ```\n\n  thread 模块的核心函数是 start_new_thread()。它的参数包括函数、函数的参数以及可选的关键字参数。\n\n  **该模块基本已经作为保留模块，原本的thread模块已经变为_thread**  \n\n- threading 模块\n\n  threading模块下有个Thread类，可以帮助我们实现多线程：\n\n  ```python\n  import threading\n\n  threading.Thread(target=wrapper,args=(),kwargs={},name=\"thread1\").start()\n\n  ```\n\n  **target**表示线程要调用的函数名\n\n  **name**表示线程名\n\n  **args**表示函数参数的元组形式\n\n  **kargs**表示函数参数的字典形式\n\n## 线程间通信\n\n\n\n## 线程同步和锁\n\n\n\n# 协程\n\n协程是什么东西呢？\n\n我们知道线程是轻量级进程，而协程又是轻量级线程。\n\n协程拥有⾃⼰的寄存器上下⽂和栈。 协程调度切换时， 将寄存器上下⽂和栈保存到其他地⽅， 在切回来的时候， 恢复先前保存的寄存器上下⽂和栈。 因此协程能保留上⼀次调⽤时的状态， 每次过程重⼊时， 就相当于进⼊上⼀次调⽤的状态。\n\n在并发编程中， 协程与线程类似， 每个协程表⽰⼀个执⾏单元， 有⾃⼰的本地数据， 与其他协程共享全局数据和其他资源。\n\nPython通过yield提供了对协程的基本⽀持， 但是不完全， ⽽使⽤第三⽅gevent库是更好的选择， gevent提供了⽐较完善的协程⽀持。 gevent是⼀个基于协程的Python⽹络函数库， 使⽤greenlet在libev事件循环顶部提供了⼀个有⾼级别并发性的API。\n\n\n\n## 创建协程\n\n这里使用gevent库创建协程:\n\n```python\nfrom gevent import monkey;\nmonkey.patch_all()\nimport gevent\nfrom  urllib import request\n\ndef run_task(url):\n    print(\"visit==\"+url)\n    try:\n        response = request.urlopen(url)\n        data = response.read()\n        print('%d bytes received from %s.' % (len(data), url))\n    except Exception as e:\n        print(e)\n    # print(threading.Thread.getName())\n\n\nif __name__ == '__main__':\n    urls = ['http://jensondev.me/', 'http://www.baidu.com', 'http://www.cnblogs.com/']\n    greenlets = [gevent.spawn(run_task, url) for url in urls]\n    gevent.joinall(greenlets)\n```\n\n以上程序主要⽤了gevent中的spawn⽅法和joinall⽅法。 spawn⽅法可以看做是⽤来形成协程， joinall⽅法就是添加这些协程任务， 并且启动运⾏。 从运⾏结果来看， 3个⽹络操作是并发执⾏的， ⽽且结束顺序不同， 但其实只有⼀个线程。\n\n\n\ngevent中还提供了对池的⽀持。 当拥有动态数量的greenlet需要进⾏并发管理（ 限制并发数） 时， 就可以使⽤池， 这在处理⼤量的⽹络和IO操作时是⾮常需要的：\n\n```python\nfrom gevent import monkey,pool;\nmonkey.patch_all()\nimport gevent\nfrom  urllib import request\n\ndef run_task(url):\n    print(\"visit==\"+url)\n    try:\n        response = request.urlopen(url)\n        data = response.read()\n        print('%d bytes received from %s.' % (len(data), url))\n    except Exception as e:\n        print(e)\n    # print(threading.Thread.getName())\n\n\nif __name__ == '__main__':\n    urls = ['http://jensondev.me/', 'http://www.baidu.com', 'http://www.cnblogs.com/']\n    # greenlets = [gevent.spawn(run_task, url) for url in urls]\n    # gevent.joinall(greenlets)\n    p =pool.Pool(2)\n    p.map(func=run_task,iterable=urls)\n```\n\n","source":"_posts/Python入门系列(5)：进程、线程和协程.md","raw":"---\ntitle: Python入门系列(5)：进程、线程和协程\ndate: 2017-08-7 15:22:54\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n如今硬件发展速度很快，就连手机cpu都是四核八核起步了。那么如何充分发掘、利用强大的cpu资源是作为研发人员的我们需要考虑的事情了。\n\n# 并发和并行\n\n**知己知彼，百战不殆**，要充分利用cpu首先要了解cpu是如何调用程序的。\n\n在线程出现之前，cpu的调度单位是进程，每个程序启动就生成一个独立的进程。\n\n进程拥有独立的内存空间，进行IPC难度较大，且cpu对进程上下文切换耗时较多，种种因素催生了进程的亲戚~线程，自此cpu的最小调度单位就是线程了。\n\n进程，又叫重量级进程，而线程，又叫轻量级进程，之所以是轻量级，是因为多个线程共享进程空间，使得多任务执行时，多线程进行数据交换容易了不少，而且上下文切换也更容易。\n\n对进程和线程有了了解，那多并发和并行又直到多少呢？并行和并发有什么区别？\n\n**并行，同时运行，可以理解为多个不同实体处理多个任务**，\n\n**并发，同时发生，可以理解为一个实体不同时间段处理多个任务**，\n\n**所以并行可以理解为硬件上的，并发理解为逻辑上的**。\n\n对以上都有了了解，下面看看在Python中如何使用：\n\n# 进程\n\n## 创建进程\n\n- os.fork()\n\n  fork⽅法来⾃于Unix/Linux操作系统中提供的⼀个fork系统调⽤， 这个⽅法⾮常特殊。 \n\n  普通的⽅法都是调⽤⼀次， 返回⼀次， ⽽fork⽅法是调⽤⼀次， 返回两次， \n\n  原因在于操作系统将当前进程（⽗进程） 复制出⼀份进程（⼦进程） ， 这两个进程⼏乎完\n  全相同， 于是fork⽅法分别在⽗进程和⼦进程中返回。 ⼦进程中永远返回0， ⽗进程中返回的是⼦进程的ID。\n\n  ```python\n  def getPidTest():\n      print(\"当前进程ID：\" + str(os.getpid()))\n\n  print(\"当前进程ID：\" + str(os.getpid()))\n  pid = os.fork()\n  if pid == 0:#子进程\n      getPidTest()\n  elif pid > 0:# 父进程\n      getPidTest()\n  ```\n\n  ​\n\n- subprocess\n\n  subprocess模块可以用来创建子进程，但是主要功能是执行外部的命令和程序，而不是运行python文件中的函数，另外这里的IPC只能通过管道进行文本交流。\n\n  比如执行终端命令时：\n\n  ```python\n  subprocess.Popen('ls -al', shell=True)\n  ```\n\n  ​\n\n- multiprocessing\n\n  multiprocessing模块提供了⼀个Process类来描述⼀个进程对象。\n\n  创建⼦进程时， 只需要传⼊⼀个执⾏函数和函数的参数， 即可完成⼀个Process实例的创建， ⽤start（） ⽅法启动进程， ⽤join（） ⽅法实现进程间的同步。  \n\n  ```python\n  def getPidTest():\n      print(\"当前进程ID：\" + str(os.getpid()))\n\n  print(\"当前进程ID：\" + str(os.getpid()))\n  if __name__ == '__main__':\n      p = Process(target=getPidTest, name='p1', args=())\n      p.start()\n  ```\n\n  **target**表示进程要调用的函数名\n\n  **name**表示进程名\n\n  **args**表示函数参数的元组形式\n\n  **kargs**表示函数参数的字典形式\n\n## IPC\n\n\n\n# 线程\n\n## 创建线程\n\nPython中有多个模块都可以实现多线程，比如thread，threading，但是由于thread模块自身一些原因，推荐使用threading模块。\n\n- thread模块\n\n   thread 模块提供了基本的线程和锁定支持。\n\n  ```python\n  import _thread\n  _thread.start_new_thread(function=getPidTest, args=(),kwargs={})\n  ```\n\n  thread 模块的核心函数是 start_new_thread()。它的参数包括函数、函数的参数以及可选的关键字参数。\n\n  **该模块基本已经作为保留模块，原本的thread模块已经变为_thread**  \n\n- threading 模块\n\n  threading模块下有个Thread类，可以帮助我们实现多线程：\n\n  ```python\n  import threading\n\n  threading.Thread(target=wrapper,args=(),kwargs={},name=\"thread1\").start()\n\n  ```\n\n  **target**表示线程要调用的函数名\n\n  **name**表示线程名\n\n  **args**表示函数参数的元组形式\n\n  **kargs**表示函数参数的字典形式\n\n## 线程间通信\n\n\n\n## 线程同步和锁\n\n\n\n# 协程\n\n协程是什么东西呢？\n\n我们知道线程是轻量级进程，而协程又是轻量级线程。\n\n协程拥有⾃⼰的寄存器上下⽂和栈。 协程调度切换时， 将寄存器上下⽂和栈保存到其他地⽅， 在切回来的时候， 恢复先前保存的寄存器上下⽂和栈。 因此协程能保留上⼀次调⽤时的状态， 每次过程重⼊时， 就相当于进⼊上⼀次调⽤的状态。\n\n在并发编程中， 协程与线程类似， 每个协程表⽰⼀个执⾏单元， 有⾃⼰的本地数据， 与其他协程共享全局数据和其他资源。\n\nPython通过yield提供了对协程的基本⽀持， 但是不完全， ⽽使⽤第三⽅gevent库是更好的选择， gevent提供了⽐较完善的协程⽀持。 gevent是⼀个基于协程的Python⽹络函数库， 使⽤greenlet在libev事件循环顶部提供了⼀个有⾼级别并发性的API。\n\n\n\n## 创建协程\n\n这里使用gevent库创建协程:\n\n```python\nfrom gevent import monkey;\nmonkey.patch_all()\nimport gevent\nfrom  urllib import request\n\ndef run_task(url):\n    print(\"visit==\"+url)\n    try:\n        response = request.urlopen(url)\n        data = response.read()\n        print('%d bytes received from %s.' % (len(data), url))\n    except Exception as e:\n        print(e)\n    # print(threading.Thread.getName())\n\n\nif __name__ == '__main__':\n    urls = ['http://jensondev.me/', 'http://www.baidu.com', 'http://www.cnblogs.com/']\n    greenlets = [gevent.spawn(run_task, url) for url in urls]\n    gevent.joinall(greenlets)\n```\n\n以上程序主要⽤了gevent中的spawn⽅法和joinall⽅法。 spawn⽅法可以看做是⽤来形成协程， joinall⽅法就是添加这些协程任务， 并且启动运⾏。 从运⾏结果来看， 3个⽹络操作是并发执⾏的， ⽽且结束顺序不同， 但其实只有⼀个线程。\n\n\n\ngevent中还提供了对池的⽀持。 当拥有动态数量的greenlet需要进⾏并发管理（ 限制并发数） 时， 就可以使⽤池， 这在处理⼤量的⽹络和IO操作时是⾮常需要的：\n\n```python\nfrom gevent import monkey,pool;\nmonkey.patch_all()\nimport gevent\nfrom  urllib import request\n\ndef run_task(url):\n    print(\"visit==\"+url)\n    try:\n        response = request.urlopen(url)\n        data = response.read()\n        print('%d bytes received from %s.' % (len(data), url))\n    except Exception as e:\n        print(e)\n    # print(threading.Thread.getName())\n\n\nif __name__ == '__main__':\n    urls = ['http://jensondev.me/', 'http://www.baidu.com', 'http://www.cnblogs.com/']\n    # greenlets = [gevent.spawn(run_task, url) for url in urls]\n    # gevent.joinall(greenlets)\n    p =pool.Pool(2)\n    p.map(func=run_task,iterable=urls)\n```\n\n","slug":"Python入门系列(5)：进程、线程和协程","published":1,"updated":"2017-08-08T08:46:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjes003jwh9ch8ly3wue","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>如今硬件发展速度很快，就连手机cpu都是四核八核起步了。那么如何充分发掘、利用强大的cpu资源是作为研发人员的我们需要考虑的事情了。</p>\n<h1 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h1><p><strong>知己知彼，百战不殆</strong>，要充分利用cpu首先要了解cpu是如何调用程序的。</p>\n<p>在线程出现之前，cpu的调度单位是进程，每个程序启动就生成一个独立的进程。</p>\n<p>进程拥有独立的内存空间，进行IPC难度较大，且cpu对进程上下文切换耗时较多，种种因素催生了进程的亲戚~线程，自此cpu的最小调度单位就是线程了。</p>\n<p>进程，又叫重量级进程，而线程，又叫轻量级进程，之所以是轻量级，是因为多个线程共享进程空间，使得多任务执行时，多线程进行数据交换容易了不少，而且上下文切换也更容易。</p>\n<p>对进程和线程有了了解，那多并发和并行又直到多少呢？并行和并发有什么区别？</p>\n<p><strong>并行，同时运行，可以理解为多个不同实体处理多个任务</strong>，</p>\n<p><strong>并发，同时发生，可以理解为一个实体不同时间段处理多个任务</strong>，</p>\n<p><strong>所以并行可以理解为硬件上的，并发理解为逻辑上的</strong>。</p>\n<p>对以上都有了了解，下面看看在Python中如何使用：</p>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h2><ul>\n<li><p>os.fork()</p>\n<p>fork⽅法来⾃于Unix/Linux操作系统中提供的⼀个fork系统调⽤， 这个⽅法⾮常特殊。 </p>\n<p>普通的⽅法都是调⽤⼀次， 返回⼀次， ⽽fork⽅法是调⽤⼀次， 返回两次， </p>\n<p>原因在于操作系统将当前进程（⽗进程） 复制出⼀份进程（⼦进程） ， 这两个进程⼏乎完<br>全相同， 于是fork⽅法分别在⽗进程和⼦进程中返回。 ⼦进程中永远返回0， ⽗进程中返回的是⼦进程的ID。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPidTest</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\">pid = os.fork()</div><div class=\"line\"><span class=\"keyword\">if</span> pid == <span class=\"number\">0</span>:<span class=\"comment\">#子进程</span></div><div class=\"line\">    getPidTest()</div><div class=\"line\"><span class=\"keyword\">elif</span> pid &gt; <span class=\"number\">0</span>:<span class=\"comment\"># 父进程</span></div><div class=\"line\">    getPidTest()</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>subprocess</p>\n<p>subprocess模块可以用来创建子进程，但是主要功能是执行外部的命令和程序，而不是运行python文件中的函数，另外这里的IPC只能通过管道进行文本交流。</p>\n<p>比如执行终端命令时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">subprocess.Popen(<span class=\"string\">'ls -al'</span>, shell=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>multiprocessing</p>\n<p>multiprocessing模块提供了⼀个Process类来描述⼀个进程对象。</p>\n<p>创建⼦进程时， 只需要传⼊⼀个执⾏函数和函数的参数， 即可完成⼀个Process实例的创建， ⽤start（） ⽅法启动进程， ⽤join（） ⽅法实现进程间的同步。  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPidTest</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    p = Process(target=getPidTest, name=<span class=\"string\">'p1'</span>, args=())</div><div class=\"line\">    p.start()</div></pre></td></tr></table></figure>\n<p><strong>target</strong>表示进程要调用的函数名</p>\n<p><strong>name</strong>表示进程名</p>\n<p><strong>args</strong>表示函数参数的元组形式</p>\n<p><strong>kargs</strong>表示函数参数的字典形式</p>\n</li>\n</ul>\n<h2 id=\"IPC\"><a href=\"#IPC\" class=\"headerlink\" title=\"IPC\"></a>IPC</h2><h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>Python中有多个模块都可以实现多线程，比如thread，threading，但是由于thread模块自身一些原因，推荐使用threading模块。</p>\n<ul>\n<li><p>thread模块</p>\n<p> thread 模块提供了基本的线程和锁定支持。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> _thread</div><div class=\"line\">_thread.start_new_thread(function=getPidTest, args=(),kwargs=&#123;&#125;)</div></pre></td></tr></table></figure>\n<p>thread 模块的核心函数是 start_new_thread()。它的参数包括函数、函数的参数以及可选的关键字参数。</p>\n<p><strong>该模块基本已经作为保留模块，原本的thread模块已经变为_thread</strong>  </p>\n</li>\n<li><p>threading 模块</p>\n<p>threading模块下有个Thread类，可以帮助我们实现多线程：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\">threading.Thread(target=wrapper,args=(),kwargs=&#123;&#125;,name=<span class=\"string\">\"thread1\"</span>).start()</div></pre></td></tr></table></figure>\n<p><strong>target</strong>表示线程要调用的函数名</p>\n<p><strong>name</strong>表示线程名</p>\n<p><strong>args</strong>表示函数参数的元组形式</p>\n<p><strong>kargs</strong>表示函数参数的字典形式</p>\n</li>\n</ul>\n<h2 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h2><h2 id=\"线程同步和锁\"><a href=\"#线程同步和锁\" class=\"headerlink\" title=\"线程同步和锁\"></a>线程同步和锁</h2><h1 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h1><p>协程是什么东西呢？</p>\n<p>我们知道线程是轻量级进程，而协程又是轻量级线程。</p>\n<p>协程拥有⾃⼰的寄存器上下⽂和栈。 协程调度切换时， 将寄存器上下⽂和栈保存到其他地⽅， 在切回来的时候， 恢复先前保存的寄存器上下⽂和栈。 因此协程能保留上⼀次调⽤时的状态， 每次过程重⼊时， 就相当于进⼊上⼀次调⽤的状态。</p>\n<p>在并发编程中， 协程与线程类似， 每个协程表⽰⼀个执⾏单元， 有⾃⼰的本地数据， 与其他协程共享全局数据和其他资源。</p>\n<p>Python通过yield提供了对协程的基本⽀持， 但是不完全， ⽽使⽤第三⽅gevent库是更好的选择， gevent提供了⽐较完善的协程⽀持。 gevent是⼀个基于协程的Python⽹络函数库， 使⽤greenlet在libev事件循环顶部提供了⼀个有⾼级别并发性的API。</p>\n<h2 id=\"创建协程\"><a href=\"#创建协程\" class=\"headerlink\" title=\"创建协程\"></a>创建协程</h2><p>这里使用gevent库创建协程:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> gevent <span class=\"keyword\">import</span> monkey;</div><div class=\"line\">monkey.patch_all()</div><div class=\"line\"><span class=\"keyword\">import</span> gevent</div><div class=\"line\"><span class=\"keyword\">from</span>  urllib <span class=\"keyword\">import</span> request</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_task</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"visit==\"</span>+url)</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        response = request.urlopen(url)</div><div class=\"line\">        data = response.read()</div><div class=\"line\">        print(<span class=\"string\">'%d bytes received from %s.'</span> % (len(data), url))</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        print(e)</div><div class=\"line\">    <span class=\"comment\"># print(threading.Thread.getName())</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    urls = [<span class=\"string\">'http://jensondev.me/'</span>, <span class=\"string\">'http://www.baidu.com'</span>, <span class=\"string\">'http://www.cnblogs.com/'</span>]</div><div class=\"line\">    greenlets = [gevent.spawn(run_task, url) <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> urls]</div><div class=\"line\">    gevent.joinall(greenlets)</div></pre></td></tr></table></figure>\n<p>以上程序主要⽤了gevent中的spawn⽅法和joinall⽅法。 spawn⽅法可以看做是⽤来形成协程， joinall⽅法就是添加这些协程任务， 并且启动运⾏。 从运⾏结果来看， 3个⽹络操作是并发执⾏的， ⽽且结束顺序不同， 但其实只有⼀个线程。</p>\n<p>gevent中还提供了对池的⽀持。 当拥有动态数量的greenlet需要进⾏并发管理（ 限制并发数） 时， 就可以使⽤池， 这在处理⼤量的⽹络和IO操作时是⾮常需要的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> gevent <span class=\"keyword\">import</span> monkey,pool;</div><div class=\"line\">monkey.patch_all()</div><div class=\"line\"><span class=\"keyword\">import</span> gevent</div><div class=\"line\"><span class=\"keyword\">from</span>  urllib <span class=\"keyword\">import</span> request</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_task</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"visit==\"</span>+url)</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        response = request.urlopen(url)</div><div class=\"line\">        data = response.read()</div><div class=\"line\">        print(<span class=\"string\">'%d bytes received from %s.'</span> % (len(data), url))</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        print(e)</div><div class=\"line\">    <span class=\"comment\"># print(threading.Thread.getName())</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    urls = [<span class=\"string\">'http://jensondev.me/'</span>, <span class=\"string\">'http://www.baidu.com'</span>, <span class=\"string\">'http://www.cnblogs.com/'</span>]</div><div class=\"line\">    <span class=\"comment\"># greenlets = [gevent.spawn(run_task, url) for url in urls]</span></div><div class=\"line\">    <span class=\"comment\"># gevent.joinall(greenlets)</span></div><div class=\"line\">    p =pool.Pool(<span class=\"number\">2</span>)</div><div class=\"line\">    p.map(func=run_task,iterable=urls)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>如今硬件发展速度很快，就连手机cpu都是四核八核起步了。那么如何充分发掘、利用强大的cpu资源是作为研发人员的我们需要考虑的事情了。</p>\n<h1 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h1><p><strong>知己知彼，百战不殆</strong>，要充分利用cpu首先要了解cpu是如何调用程序的。</p>\n<p>在线程出现之前，cpu的调度单位是进程，每个程序启动就生成一个独立的进程。</p>\n<p>进程拥有独立的内存空间，进行IPC难度较大，且cpu对进程上下文切换耗时较多，种种因素催生了进程的亲戚~线程，自此cpu的最小调度单位就是线程了。</p>\n<p>进程，又叫重量级进程，而线程，又叫轻量级进程，之所以是轻量级，是因为多个线程共享进程空间，使得多任务执行时，多线程进行数据交换容易了不少，而且上下文切换也更容易。</p>\n<p>对进程和线程有了了解，那多并发和并行又直到多少呢？并行和并发有什么区别？</p>\n<p><strong>并行，同时运行，可以理解为多个不同实体处理多个任务</strong>，</p>\n<p><strong>并发，同时发生，可以理解为一个实体不同时间段处理多个任务</strong>，</p>\n<p><strong>所以并行可以理解为硬件上的，并发理解为逻辑上的</strong>。</p>\n<p>对以上都有了了解，下面看看在Python中如何使用：</p>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h2><ul>\n<li><p>os.fork()</p>\n<p>fork⽅法来⾃于Unix/Linux操作系统中提供的⼀个fork系统调⽤， 这个⽅法⾮常特殊。 </p>\n<p>普通的⽅法都是调⽤⼀次， 返回⼀次， ⽽fork⽅法是调⽤⼀次， 返回两次， </p>\n<p>原因在于操作系统将当前进程（⽗进程） 复制出⼀份进程（⼦进程） ， 这两个进程⼏乎完<br>全相同， 于是fork⽅法分别在⽗进程和⼦进程中返回。 ⼦进程中永远返回0， ⽗进程中返回的是⼦进程的ID。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPidTest</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\">pid = os.fork()</div><div class=\"line\"><span class=\"keyword\">if</span> pid == <span class=\"number\">0</span>:<span class=\"comment\">#子进程</span></div><div class=\"line\">    getPidTest()</div><div class=\"line\"><span class=\"keyword\">elif</span> pid &gt; <span class=\"number\">0</span>:<span class=\"comment\"># 父进程</span></div><div class=\"line\">    getPidTest()</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>subprocess</p>\n<p>subprocess模块可以用来创建子进程，但是主要功能是执行外部的命令和程序，而不是运行python文件中的函数，另外这里的IPC只能通过管道进行文本交流。</p>\n<p>比如执行终端命令时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">subprocess.Popen(<span class=\"string\">'ls -al'</span>, shell=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>multiprocessing</p>\n<p>multiprocessing模块提供了⼀个Process类来描述⼀个进程对象。</p>\n<p>创建⼦进程时， 只需要传⼊⼀个执⾏函数和函数的参数， 即可完成⼀个Process实例的创建， ⽤start（） ⽅法启动进程， ⽤join（） ⽅法实现进程间的同步。  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getPidTest</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">\"当前进程ID：\"</span> + str(os.getpid()))</div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    p = Process(target=getPidTest, name=<span class=\"string\">'p1'</span>, args=())</div><div class=\"line\">    p.start()</div></pre></td></tr></table></figure>\n<p><strong>target</strong>表示进程要调用的函数名</p>\n<p><strong>name</strong>表示进程名</p>\n<p><strong>args</strong>表示函数参数的元组形式</p>\n<p><strong>kargs</strong>表示函数参数的字典形式</p>\n</li>\n</ul>\n<h2 id=\"IPC\"><a href=\"#IPC\" class=\"headerlink\" title=\"IPC\"></a>IPC</h2><h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>Python中有多个模块都可以实现多线程，比如thread，threading，但是由于thread模块自身一些原因，推荐使用threading模块。</p>\n<ul>\n<li><p>thread模块</p>\n<p> thread 模块提供了基本的线程和锁定支持。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> _thread</div><div class=\"line\">_thread.start_new_thread(function=getPidTest, args=(),kwargs=&#123;&#125;)</div></pre></td></tr></table></figure>\n<p>thread 模块的核心函数是 start_new_thread()。它的参数包括函数、函数的参数以及可选的关键字参数。</p>\n<p><strong>该模块基本已经作为保留模块，原本的thread模块已经变为_thread</strong>  </p>\n</li>\n<li><p>threading 模块</p>\n<p>threading模块下有个Thread类，可以帮助我们实现多线程：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\">threading.Thread(target=wrapper,args=(),kwargs=&#123;&#125;,name=<span class=\"string\">\"thread1\"</span>).start()</div></pre></td></tr></table></figure>\n<p><strong>target</strong>表示线程要调用的函数名</p>\n<p><strong>name</strong>表示线程名</p>\n<p><strong>args</strong>表示函数参数的元组形式</p>\n<p><strong>kargs</strong>表示函数参数的字典形式</p>\n</li>\n</ul>\n<h2 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h2><h2 id=\"线程同步和锁\"><a href=\"#线程同步和锁\" class=\"headerlink\" title=\"线程同步和锁\"></a>线程同步和锁</h2><h1 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h1><p>协程是什么东西呢？</p>\n<p>我们知道线程是轻量级进程，而协程又是轻量级线程。</p>\n<p>协程拥有⾃⼰的寄存器上下⽂和栈。 协程调度切换时， 将寄存器上下⽂和栈保存到其他地⽅， 在切回来的时候， 恢复先前保存的寄存器上下⽂和栈。 因此协程能保留上⼀次调⽤时的状态， 每次过程重⼊时， 就相当于进⼊上⼀次调⽤的状态。</p>\n<p>在并发编程中， 协程与线程类似， 每个协程表⽰⼀个执⾏单元， 有⾃⼰的本地数据， 与其他协程共享全局数据和其他资源。</p>\n<p>Python通过yield提供了对协程的基本⽀持， 但是不完全， ⽽使⽤第三⽅gevent库是更好的选择， gevent提供了⽐较完善的协程⽀持。 gevent是⼀个基于协程的Python⽹络函数库， 使⽤greenlet在libev事件循环顶部提供了⼀个有⾼级别并发性的API。</p>\n<h2 id=\"创建协程\"><a href=\"#创建协程\" class=\"headerlink\" title=\"创建协程\"></a>创建协程</h2><p>这里使用gevent库创建协程:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> gevent <span class=\"keyword\">import</span> monkey;</div><div class=\"line\">monkey.patch_all()</div><div class=\"line\"><span class=\"keyword\">import</span> gevent</div><div class=\"line\"><span class=\"keyword\">from</span>  urllib <span class=\"keyword\">import</span> request</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_task</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"visit==\"</span>+url)</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        response = request.urlopen(url)</div><div class=\"line\">        data = response.read()</div><div class=\"line\">        print(<span class=\"string\">'%d bytes received from %s.'</span> % (len(data), url))</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        print(e)</div><div class=\"line\">    <span class=\"comment\"># print(threading.Thread.getName())</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    urls = [<span class=\"string\">'http://jensondev.me/'</span>, <span class=\"string\">'http://www.baidu.com'</span>, <span class=\"string\">'http://www.cnblogs.com/'</span>]</div><div class=\"line\">    greenlets = [gevent.spawn(run_task, url) <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> urls]</div><div class=\"line\">    gevent.joinall(greenlets)</div></pre></td></tr></table></figure>\n<p>以上程序主要⽤了gevent中的spawn⽅法和joinall⽅法。 spawn⽅法可以看做是⽤来形成协程， joinall⽅法就是添加这些协程任务， 并且启动运⾏。 从运⾏结果来看， 3个⽹络操作是并发执⾏的， ⽽且结束顺序不同， 但其实只有⼀个线程。</p>\n<p>gevent中还提供了对池的⽀持。 当拥有动态数量的greenlet需要进⾏并发管理（ 限制并发数） 时， 就可以使⽤池， 这在处理⼤量的⽹络和IO操作时是⾮常需要的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> gevent <span class=\"keyword\">import</span> monkey,pool;</div><div class=\"line\">monkey.patch_all()</div><div class=\"line\"><span class=\"keyword\">import</span> gevent</div><div class=\"line\"><span class=\"keyword\">from</span>  urllib <span class=\"keyword\">import</span> request</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_task</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"visit==\"</span>+url)</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        response = request.urlopen(url)</div><div class=\"line\">        data = response.read()</div><div class=\"line\">        print(<span class=\"string\">'%d bytes received from %s.'</span> % (len(data), url))</div><div class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">        print(e)</div><div class=\"line\">    <span class=\"comment\"># print(threading.Thread.getName())</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    urls = [<span class=\"string\">'http://jensondev.me/'</span>, <span class=\"string\">'http://www.baidu.com'</span>, <span class=\"string\">'http://www.cnblogs.com/'</span>]</div><div class=\"line\">    <span class=\"comment\"># greenlets = [gevent.spawn(run_task, url) for url in urls]</span></div><div class=\"line\">    <span class=\"comment\"># gevent.joinall(greenlets)</span></div><div class=\"line\">    p =pool.Pool(<span class=\"number\">2</span>)</div><div class=\"line\">    p.map(func=run_task,iterable=urls)</div></pre></td></tr></table></figure>\n"},{"title":"Python第三方库没有代码快捷提示","date":"2017-07-31T16:45:00.000Z","_content":"\n# 前言\n\n做Python开发IDE首选当然是Pycharm，但是有个问题是如果安装第三方库后，在使用的时候，第三方库返回的变量调用方法时没有代码快捷提示。\n\n\n\n# 解决\n\n其实是因为Python是弱类型编程语言。\n\n像Java这种强类型语言，在声明变量时都要先声明变量类型。这种类型明确自然也就知道其实例所对应的方法，所以能给出提示。\n\n而Python这种弱类型语言，使用时候只声明变量，不声明类型即可使用，\n\n变量不知道当前引用所指向的类型是哪个，IDE自然也给不出快捷提示。\n\n但是如果在代码中给出变量指定类型，那么IDE就可以给出提示。\n\n那么问题来了，如何给变量指定类型？\n\n- 单行注释指定类型 :\n\n  `csv_writer = csv.writer(csvFile)  # type: csv.DictWriter`。\n\n  **注意格式：#后面跟type:**\n\n- 多行注释指定类型：\n\n  ```python\n  \"\"\"\n     :type: csv.DictWriter\n  \"\"\"\n  ```\n\n  **注意：这个多行注释中的type前须添加 : **\n\n  ​\n\n- 使用isinstance指定\n\n  `assert isinstance(item, bs4.Tag)`。\n\n  **注意：参数1表示变量，参数2表示指定类型**\n\n  ​","source":"_posts/Python第三方库没有代码快捷提示.md","raw":"---\ntitle: Python第三方库没有代码快捷提示\ndate: 2017-08-01 00:45:00\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n做Python开发IDE首选当然是Pycharm，但是有个问题是如果安装第三方库后，在使用的时候，第三方库返回的变量调用方法时没有代码快捷提示。\n\n\n\n# 解决\n\n其实是因为Python是弱类型编程语言。\n\n像Java这种强类型语言，在声明变量时都要先声明变量类型。这种类型明确自然也就知道其实例所对应的方法，所以能给出提示。\n\n而Python这种弱类型语言，使用时候只声明变量，不声明类型即可使用，\n\n变量不知道当前引用所指向的类型是哪个，IDE自然也给不出快捷提示。\n\n但是如果在代码中给出变量指定类型，那么IDE就可以给出提示。\n\n那么问题来了，如何给变量指定类型？\n\n- 单行注释指定类型 :\n\n  `csv_writer = csv.writer(csvFile)  # type: csv.DictWriter`。\n\n  **注意格式：#后面跟type:**\n\n- 多行注释指定类型：\n\n  ```python\n  \"\"\"\n     :type: csv.DictWriter\n  \"\"\"\n  ```\n\n  **注意：这个多行注释中的type前须添加 : **\n\n  ​\n\n- 使用isinstance指定\n\n  `assert isinstance(item, bs4.Tag)`。\n\n  **注意：参数1表示变量，参数2表示指定类型**\n\n  ​","slug":"Python第三方库没有代码快捷提示","published":1,"updated":"2017-07-31T17:03:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjey003nwh9cwcuzdx9k","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>做Python开发IDE首选当然是Pycharm，但是有个问题是如果安装第三方库后，在使用的时候，第三方库返回的变量调用方法时没有代码快捷提示。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>其实是因为Python是弱类型编程语言。</p>\n<p>像Java这种强类型语言，在声明变量时都要先声明变量类型。这种类型明确自然也就知道其实例所对应的方法，所以能给出提示。</p>\n<p>而Python这种弱类型语言，使用时候只声明变量，不声明类型即可使用，</p>\n<p>变量不知道当前引用所指向的类型是哪个，IDE自然也给不出快捷提示。</p>\n<p>但是如果在代码中给出变量指定类型，那么IDE就可以给出提示。</p>\n<p>那么问题来了，如何给变量指定类型？</p>\n<ul>\n<li><p>单行注释指定类型 :</p>\n<p><code>csv_writer = csv.writer(csvFile)  # type: csv.DictWriter</code>。</p>\n<p><strong>注意格式：#后面跟type:</strong></p>\n</li>\n<li><p>多行注释指定类型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">   :type: csv.DictWriter</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<p><strong>注意：这个多行注释中的type前须添加 : </strong></p>\n<p>​</p>\n</li>\n<li><p>使用isinstance指定</p>\n<p><code>assert isinstance(item, bs4.Tag)</code>。</p>\n<p><strong>注意：参数1表示变量，参数2表示指定类型</strong></p>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>做Python开发IDE首选当然是Pycharm，但是有个问题是如果安装第三方库后，在使用的时候，第三方库返回的变量调用方法时没有代码快捷提示。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>其实是因为Python是弱类型编程语言。</p>\n<p>像Java这种强类型语言，在声明变量时都要先声明变量类型。这种类型明确自然也就知道其实例所对应的方法，所以能给出提示。</p>\n<p>而Python这种弱类型语言，使用时候只声明变量，不声明类型即可使用，</p>\n<p>变量不知道当前引用所指向的类型是哪个，IDE自然也给不出快捷提示。</p>\n<p>但是如果在代码中给出变量指定类型，那么IDE就可以给出提示。</p>\n<p>那么问题来了，如何给变量指定类型？</p>\n<ul>\n<li><p>单行注释指定类型 :</p>\n<p><code>csv_writer = csv.writer(csvFile)  # type: csv.DictWriter</code>。</p>\n<p><strong>注意格式：#后面跟type:</strong></p>\n</li>\n<li><p>多行注释指定类型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"\"\"</span></div><div class=\"line\">   :type: csv.DictWriter</div><div class=\"line\">\"\"\"</div></pre></td></tr></table></figure>\n<p><strong>注意：这个多行注释中的type前须添加 : </strong></p>\n<p>​</p>\n</li>\n<li><p>使用isinstance指定</p>\n<p><code>assert isinstance(item, bs4.Tag)</code>。</p>\n<p><strong>注意：参数1表示变量，参数2表示指定类型</strong></p>\n<p>​</p>\n</li>\n</ul>\n"},{"title":"Python爬虫爬取简书首页文章(一)","date":"2017-08-02T03:42:28.000Z","_content":"\n# 前言\n\n最近对Python兴趣很大，因为觉得这门语言很好玩。学了些东西就总得做点什么出来吧。\n\n**虽然兴趣是最好的老师，但是毕竟实践才是检验真理的唯一标准**\n\n首先想到的就是写个爬虫试试，专门针对特定网站的mini爬虫。\n\n那就采集[简书](www.jianshu.com)首页文章吧。\n\n\n\n# 准备工作\n\n在开始代码前先做好准备工作：安装所需库。\n\n这里的数据存储在csv文件中，而不是存储在数据库，因为数据流并不大,使用`csv`库。\n\n网络请求库使用`urllib`。\n\nDom解析库使用`BeautifulSoup4`。\n\n如果本地没有的库可以使用`pip3 install xxx`命令安装。\n\n\n\n准备工作做完了就开始编码了吗？NO~，接下来要分析网页，分析要爬取网页的内容。\n\n# 网页分析\n\n分析简书首页文章列表，找到共通的规则，才能让后面的采集有迹可循。\n\n- 打开简书首页，复制一个文章标题\n\n  应该是这样子的：\n\n  ![简书首页标题复制](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%A0%87%E9%A2%98%E5%A4%8D%E5%88%B6.png)\n\n- 查看网页源码，在源码中查找复制的标题\n\n  ![源码中标题区域](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%A0%87%E9%A2%98%E5%8C%BA%E5%9F%9F.png)\n\n  从标题逐步扩散式查找，最终定位到标签`li`。就是说每个首页文章区域部分就是一个`li`标签显示的。而且这些标签的**id**属性都是以**note-**开头的。\n\n- 查找父元素\n\n  既然每个文章是一个`li`标签，那么父元素应该是`ul`标签。顺藤摸瓜发现了\n\n  ```html\n  <!-- 文章列表模块 -->\n          <ul class=\"note-list\" infinite-scroll-url=\"/\">\n  ```\n\n  所以Dom解析时查找**class**为**note-list**子元素即可\n\n**这里首页文章基本理清规则了，其他网站可能复杂性会高，但是只要耐心点，基本都能找到规律**\n\n下面开始创建项目：\n\n# 创建项目\n\n我这里使用Pycharm IDE，创建一个项目名称为`JianShuSpider`。\n\n创建main文件夹，同时在其下创建JS.py文件，该文件主要写逻辑。\n\n创建Article文件，其中创建Article类，用来存储爬取的文章信息。\n\n\n\n# 开始实现\n\n## 确定爬取内容\n\n因为这里只是个练习爬虫，不想存储太多内容，所以只爬取文章标题、作者、链接\n\n完善Article类：\n\n```python\nclass Article:\n    \"\"\"\n        文章信息类\n    \"\"\"\n    def __init__(self):\n        self.title = ''\n        self.author = ''\n        self.url = ''\n\n```\n\n## 逻辑实现\n\n总体逻辑大概分成三个方法：\n\n①定义`def getArticles(url):`方法获取文章列表\n\n②定义`def saveCSV(articles):`方法存储获取的文章列表信息\n\n③定义`def wrapper():`包装上述两个方法以便在让工作线程执行\n\n下面按次序一次实现\n\n### 获取文章列表\n\n获取文章列表又细分为4个小步骤：\n\n①定义一个空列表用来后面存储文章信息：\n\n```python\narticle_list = []\n```\n\n②发起网络请求读取网页源码，为后面DOM解析做准备，如果出现异常返回空列表\n\n```python\nfrom urllib import error, request\n try:                                      \n     req = request.urlopen(url=url)        \n     content = req.read()                  \n except error.HTTPError as  err:           \n     print(err)                            \n     return article_list                   \n```\n\n③根据步骤②提供的content DOM树和上面分析li标签规则，通过正则表达式查找当前页所有文章标签li：\n\n```python\n import bs4\n import re\n\n bsobj = bs4.BeautifulSoup(content, \"html.parser\")\n    list = bsobj.find_all(name=\"li\",\n                          attrs={\"id\": re.compile(\"^(note-)[0-9]+$\")})\n```\n\n④根据步骤③返回的li标签列表，对li列表标签进行遍历查找子标签中标题、作者和链接信息，赋值给Article对象，并添加到步骤①创建的**article_list**列表\n\n```python\n for item in list:                                                                 \n     assert isinstance(item, bs4.Tag)                                              \n     article = Article()                                                           \n     article.author = item.find(name='a', attrs={'class': 'blue-link'}).get_text() \n     titleTag = item.find(name='a', attrs={'class': 'title'})                      \n     assert isinstance(titleTag, bs4.Tag)                                          \n     article.title = titleTag.get_text()                                           \n     article.url = url + titleTag.attrs['href']                                    \n     article_list.append(article)                                                  \n```\n\n经过上面一些列步骤已经得到了文章列表信息，下面要把文章列表存储到csv文件中\n\n### 存储文章列表\n\n**注意：csv是按逗号分隔的文件，每一行代表一条完整信息，所以写入信息时是逐行写入。**\n\n存储文章可以分为3个小步骤：\n\n①根据path打开或创建一个csv文件，同时获取writer\n\n```python\nimport csv\n csvFile = open(\"/Users/jenson/Downloads/js.csv\", 'w+')    \n csv_writer = csv.writer(csvFile)                          \n```\n\n②向文件写入头行，用来说明每个被逗号隔断的数据表示的意义\n\n```python\n   csv_writer.writerow([\"作者\", \"标题\", \"链接\"])   \n```\n\n③遍历文章列表存储\n\n```python\nfor article in articles:                               \n    csv_writer.writerow(                               \n        [article.author, article.title, article.url])  \n```\n\n\n\n### 包装方法\n\n包装方法就简单了，直接上代码：\n\n```python\ndef wrapper():    \n    \"\"\"           \n    包装方法          \n    :return:      \n    \"\"\"           \n    list = getArti\n    saveCSV(list) \n```\n\n\n\n### 线程调用\n\n```python\nthreading.Thread(target=wrapper).start()\n\n```\n\n# 爬取结果\n\n![爬取结果](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%AC%AC%E4%B8%80%E9%A1%B5%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9E%9C.png)\n\n\n\n通过上面的图片可以看到文章信息已经存储到csv文件中。\n\n目前为止，一个mini爬虫已经初步完成。当然目前只是爬取第一页信息。\n\n后面文章会完成分页爬取，请参考**Python爬虫爬取简书首页文章(二)**\n\n","source":"_posts/Python爬虫爬取简书首页文章-一.md","raw":"---\ntitle: Python爬虫爬取简书首页文章(一)\ndate: 2017-08-02 11:42:28\ntags: [Python, 自己写爬虫]\ncategories: [Python, 自己写爬虫]\n---\n\n# 前言\n\n最近对Python兴趣很大，因为觉得这门语言很好玩。学了些东西就总得做点什么出来吧。\n\n**虽然兴趣是最好的老师，但是毕竟实践才是检验真理的唯一标准**\n\n首先想到的就是写个爬虫试试，专门针对特定网站的mini爬虫。\n\n那就采集[简书](www.jianshu.com)首页文章吧。\n\n\n\n# 准备工作\n\n在开始代码前先做好准备工作：安装所需库。\n\n这里的数据存储在csv文件中，而不是存储在数据库，因为数据流并不大,使用`csv`库。\n\n网络请求库使用`urllib`。\n\nDom解析库使用`BeautifulSoup4`。\n\n如果本地没有的库可以使用`pip3 install xxx`命令安装。\n\n\n\n准备工作做完了就开始编码了吗？NO~，接下来要分析网页，分析要爬取网页的内容。\n\n# 网页分析\n\n分析简书首页文章列表，找到共通的规则，才能让后面的采集有迹可循。\n\n- 打开简书首页，复制一个文章标题\n\n  应该是这样子的：\n\n  ![简书首页标题复制](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%A0%87%E9%A2%98%E5%A4%8D%E5%88%B6.png)\n\n- 查看网页源码，在源码中查找复制的标题\n\n  ![源码中标题区域](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%A0%87%E9%A2%98%E5%8C%BA%E5%9F%9F.png)\n\n  从标题逐步扩散式查找，最终定位到标签`li`。就是说每个首页文章区域部分就是一个`li`标签显示的。而且这些标签的**id**属性都是以**note-**开头的。\n\n- 查找父元素\n\n  既然每个文章是一个`li`标签，那么父元素应该是`ul`标签。顺藤摸瓜发现了\n\n  ```html\n  <!-- 文章列表模块 -->\n          <ul class=\"note-list\" infinite-scroll-url=\"/\">\n  ```\n\n  所以Dom解析时查找**class**为**note-list**子元素即可\n\n**这里首页文章基本理清规则了，其他网站可能复杂性会高，但是只要耐心点，基本都能找到规律**\n\n下面开始创建项目：\n\n# 创建项目\n\n我这里使用Pycharm IDE，创建一个项目名称为`JianShuSpider`。\n\n创建main文件夹，同时在其下创建JS.py文件，该文件主要写逻辑。\n\n创建Article文件，其中创建Article类，用来存储爬取的文章信息。\n\n\n\n# 开始实现\n\n## 确定爬取内容\n\n因为这里只是个练习爬虫，不想存储太多内容，所以只爬取文章标题、作者、链接\n\n完善Article类：\n\n```python\nclass Article:\n    \"\"\"\n        文章信息类\n    \"\"\"\n    def __init__(self):\n        self.title = ''\n        self.author = ''\n        self.url = ''\n\n```\n\n## 逻辑实现\n\n总体逻辑大概分成三个方法：\n\n①定义`def getArticles(url):`方法获取文章列表\n\n②定义`def saveCSV(articles):`方法存储获取的文章列表信息\n\n③定义`def wrapper():`包装上述两个方法以便在让工作线程执行\n\n下面按次序一次实现\n\n### 获取文章列表\n\n获取文章列表又细分为4个小步骤：\n\n①定义一个空列表用来后面存储文章信息：\n\n```python\narticle_list = []\n```\n\n②发起网络请求读取网页源码，为后面DOM解析做准备，如果出现异常返回空列表\n\n```python\nfrom urllib import error, request\n try:                                      \n     req = request.urlopen(url=url)        \n     content = req.read()                  \n except error.HTTPError as  err:           \n     print(err)                            \n     return article_list                   \n```\n\n③根据步骤②提供的content DOM树和上面分析li标签规则，通过正则表达式查找当前页所有文章标签li：\n\n```python\n import bs4\n import re\n\n bsobj = bs4.BeautifulSoup(content, \"html.parser\")\n    list = bsobj.find_all(name=\"li\",\n                          attrs={\"id\": re.compile(\"^(note-)[0-9]+$\")})\n```\n\n④根据步骤③返回的li标签列表，对li列表标签进行遍历查找子标签中标题、作者和链接信息，赋值给Article对象，并添加到步骤①创建的**article_list**列表\n\n```python\n for item in list:                                                                 \n     assert isinstance(item, bs4.Tag)                                              \n     article = Article()                                                           \n     article.author = item.find(name='a', attrs={'class': 'blue-link'}).get_text() \n     titleTag = item.find(name='a', attrs={'class': 'title'})                      \n     assert isinstance(titleTag, bs4.Tag)                                          \n     article.title = titleTag.get_text()                                           \n     article.url = url + titleTag.attrs['href']                                    \n     article_list.append(article)                                                  \n```\n\n经过上面一些列步骤已经得到了文章列表信息，下面要把文章列表存储到csv文件中\n\n### 存储文章列表\n\n**注意：csv是按逗号分隔的文件，每一行代表一条完整信息，所以写入信息时是逐行写入。**\n\n存储文章可以分为3个小步骤：\n\n①根据path打开或创建一个csv文件，同时获取writer\n\n```python\nimport csv\n csvFile = open(\"/Users/jenson/Downloads/js.csv\", 'w+')    \n csv_writer = csv.writer(csvFile)                          \n```\n\n②向文件写入头行，用来说明每个被逗号隔断的数据表示的意义\n\n```python\n   csv_writer.writerow([\"作者\", \"标题\", \"链接\"])   \n```\n\n③遍历文章列表存储\n\n```python\nfor article in articles:                               \n    csv_writer.writerow(                               \n        [article.author, article.title, article.url])  \n```\n\n\n\n### 包装方法\n\n包装方法就简单了，直接上代码：\n\n```python\ndef wrapper():    \n    \"\"\"           \n    包装方法          \n    :return:      \n    \"\"\"           \n    list = getArti\n    saveCSV(list) \n```\n\n\n\n### 线程调用\n\n```python\nthreading.Thread(target=wrapper).start()\n\n```\n\n# 爬取结果\n\n![爬取结果](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%AC%AC%E4%B8%80%E9%A1%B5%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9E%9C.png)\n\n\n\n通过上面的图片可以看到文章信息已经存储到csv文件中。\n\n目前为止，一个mini爬虫已经初步完成。当然目前只是爬取第一页信息。\n\n后面文章会完成分页爬取，请参考**Python爬虫爬取简书首页文章(二)**\n\n","slug":"Python爬虫爬取简书首页文章-一","published":1,"updated":"2017-08-02T05:06:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjf2003qwh9cjz06lvr1","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近对Python兴趣很大，因为觉得这门语言很好玩。学了些东西就总得做点什么出来吧。</p>\n<p><strong>虽然兴趣是最好的老师，但是毕竟实践才是检验真理的唯一标准</strong></p>\n<p>首先想到的就是写个爬虫试试，专门针对特定网站的mini爬虫。</p>\n<p>那就采集<a href=\"www.jianshu.com\">简书</a>首页文章吧。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>在开始代码前先做好准备工作：安装所需库。</p>\n<p>这里的数据存储在csv文件中，而不是存储在数据库，因为数据流并不大,使用<code>csv</code>库。</p>\n<p>网络请求库使用<code>urllib</code>。</p>\n<p>Dom解析库使用<code>BeautifulSoup4</code>。</p>\n<p>如果本地没有的库可以使用<code>pip3 install xxx</code>命令安装。</p>\n<p>准备工作做完了就开始编码了吗？NO~，接下来要分析网页，分析要爬取网页的内容。</p>\n<h1 id=\"网页分析\"><a href=\"#网页分析\" class=\"headerlink\" title=\"网页分析\"></a>网页分析</h1><p>分析简书首页文章列表，找到共通的规则，才能让后面的采集有迹可循。</p>\n<ul>\n<li><p>打开简书首页，复制一个文章标题</p>\n<p>应该是这样子的：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%A0%87%E9%A2%98%E5%A4%8D%E5%88%B6.png\" alt=\"简书首页标题复制\"></p>\n</li>\n<li><p>查看网页源码，在源码中查找复制的标题</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%A0%87%E9%A2%98%E5%8C%BA%E5%9F%9F.png\" alt=\"源码中标题区域\"></p>\n<p>从标题逐步扩散式查找，最终定位到标签<code>li</code>。就是说每个首页文章区域部分就是一个<code>li</code>标签显示的。而且这些标签的<strong>id</strong>属性都是以<strong>note-</strong>开头的。</p>\n</li>\n<li><p>查找父元素</p>\n<p>既然每个文章是一个<code>li</code>标签，那么父元素应该是<code>ul</code>标签。顺藤摸瓜发现了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 文章列表模块 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"note-list\"</span> <span class=\"attr\">infinite-scroll-url</span>=<span class=\"string\">\"/\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>所以Dom解析时查找<strong>class</strong>为<strong>note-list</strong>子元素即可</p>\n</li>\n</ul>\n<p><strong>这里首页文章基本理清规则了，其他网站可能复杂性会高，但是只要耐心点，基本都能找到规律</strong></p>\n<p>下面开始创建项目：</p>\n<h1 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h1><p>我这里使用Pycharm IDE，创建一个项目名称为<code>JianShuSpider</code>。</p>\n<p>创建main文件夹，同时在其下创建JS.py文件，该文件主要写逻辑。</p>\n<p>创建Article文件，其中创建Article类，用来存储爬取的文章信息。</p>\n<h1 id=\"开始实现\"><a href=\"#开始实现\" class=\"headerlink\" title=\"开始实现\"></a>开始实现</h1><h2 id=\"确定爬取内容\"><a href=\"#确定爬取内容\" class=\"headerlink\" title=\"确定爬取内容\"></a>确定爬取内容</h2><p>因为这里只是个练习爬虫，不想存储太多内容，所以只爬取文章标题、作者、链接</p>\n<p>完善Article类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Article</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">        文章信息类</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.title = <span class=\"string\">''</span></div><div class=\"line\">        self.author = <span class=\"string\">''</span></div><div class=\"line\">        self.url = <span class=\"string\">''</span></div></pre></td></tr></table></figure>\n<h2 id=\"逻辑实现\"><a href=\"#逻辑实现\" class=\"headerlink\" title=\"逻辑实现\"></a>逻辑实现</h2><p>总体逻辑大概分成三个方法：</p>\n<p>①定义<code>def getArticles(url):</code>方法获取文章列表</p>\n<p>②定义<code>def saveCSV(articles):</code>方法存储获取的文章列表信息</p>\n<p>③定义<code>def wrapper():</code>包装上述两个方法以便在让工作线程执行</p>\n<p>下面按次序一次实现</p>\n<h3 id=\"获取文章列表\"><a href=\"#获取文章列表\" class=\"headerlink\" title=\"获取文章列表\"></a>获取文章列表</h3><p>获取文章列表又细分为4个小步骤：</p>\n<p>①定义一个空列表用来后面存储文章信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">article_list = []</div></pre></td></tr></table></figure>\n<p>②发起网络请求读取网页源码，为后面DOM解析做准备，如果出现异常返回空列表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error, request</div><div class=\"line\"> <span class=\"keyword\">try</span>:                                      </div><div class=\"line\">     req = request.urlopen(url=url)        </div><div class=\"line\">     content = req.read()                  </div><div class=\"line\"> <span class=\"keyword\">except</span> error.HTTPError <span class=\"keyword\">as</span>  err:           </div><div class=\"line\">     print(err)                            </div><div class=\"line\">     <span class=\"keyword\">return</span> article_list</div></pre></td></tr></table></figure>\n<p>③根据步骤②提供的content DOM树和上面分析li标签规则，通过正则表达式查找当前页所有文章标签li：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> bs4</div><div class=\"line\"><span class=\"keyword\">import</span> re</div><div class=\"line\"></div><div class=\"line\">bsobj = bs4.BeautifulSoup(content, <span class=\"string\">\"html.parser\"</span>)</div><div class=\"line\">   list = bsobj.find_all(name=<span class=\"string\">\"li\"</span>,</div><div class=\"line\">                         attrs=&#123;<span class=\"string\">\"id\"</span>: re.compile(<span class=\"string\">\"^(note-)[0-9]+$\"</span>)&#125;)</div></pre></td></tr></table></figure>\n<p>④根据步骤③返回的li标签列表，对li列表标签进行遍历查找子标签中标题、作者和链接信息，赋值给Article对象，并添加到步骤①创建的<strong>article_list</strong>列表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> list:                                                                 </div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(item, bs4.Tag)                                              </div><div class=\"line\">    article = Article()                                                           </div><div class=\"line\">    article.author = item.find(name=<span class=\"string\">'a'</span>, attrs=&#123;<span class=\"string\">'class'</span>: <span class=\"string\">'blue-link'</span>&#125;).get_text() </div><div class=\"line\">    titleTag = item.find(name=<span class=\"string\">'a'</span>, attrs=&#123;<span class=\"string\">'class'</span>: <span class=\"string\">'title'</span>&#125;)                      </div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(titleTag, bs4.Tag)                                          </div><div class=\"line\">    article.title = titleTag.get_text()                                           </div><div class=\"line\">    article.url = url + titleTag.attrs[<span class=\"string\">'href'</span>]                                    </div><div class=\"line\">    article_list.append(article)</div></pre></td></tr></table></figure>\n<p>经过上面一些列步骤已经得到了文章列表信息，下面要把文章列表存储到csv文件中</p>\n<h3 id=\"存储文章列表\"><a href=\"#存储文章列表\" class=\"headerlink\" title=\"存储文章列表\"></a>存储文章列表</h3><p><strong>注意：csv是按逗号分隔的文件，每一行代表一条完整信息，所以写入信息时是逐行写入。</strong></p>\n<p>存储文章可以分为3个小步骤：</p>\n<p>①根据path打开或创建一个csv文件，同时获取writer</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> csv</div><div class=\"line\"> csvFile = open(<span class=\"string\">\"/Users/jenson/Downloads/js.csv\"</span>, <span class=\"string\">'w+'</span>)    </div><div class=\"line\"> csv_writer = csv.writer(csvFile)</div></pre></td></tr></table></figure>\n<p>②向文件写入头行，用来说明每个被逗号隔断的数据表示的意义</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">csv_writer.writerow([<span class=\"string\">\"作者\"</span>, <span class=\"string\">\"标题\"</span>, <span class=\"string\">\"链接\"</span>])</div></pre></td></tr></table></figure>\n<p>③遍历文章列表存储</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> article <span class=\"keyword\">in</span> articles:                               </div><div class=\"line\">    csv_writer.writerow(                               </div><div class=\"line\">        [article.author, article.title, article.url])</div></pre></td></tr></table></figure>\n<h3 id=\"包装方法\"><a href=\"#包装方法\" class=\"headerlink\" title=\"包装方法\"></a>包装方法</h3><p>包装方法就简单了，直接上代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span>    </div><div class=\"line\">    <span class=\"string\">\"\"\"           </span></div><div class=\"line\">    包装方法          </div><div class=\"line\">    :return:      </div><div class=\"line\">    \"\"\"           </div><div class=\"line\">    list = getArti</div><div class=\"line\">    saveCSV(list)</div></pre></td></tr></table></figure>\n<h3 id=\"线程调用\"><a href=\"#线程调用\" class=\"headerlink\" title=\"线程调用\"></a>线程调用</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">threading.Thread(target=wrapper).start()</div></pre></td></tr></table></figure>\n<h1 id=\"爬取结果\"><a href=\"#爬取结果\" class=\"headerlink\" title=\"爬取结果\"></a>爬取结果</h1><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%AC%AC%E4%B8%80%E9%A1%B5%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9E%9C.png\" alt=\"爬取结果\"></p>\n<p>通过上面的图片可以看到文章信息已经存储到csv文件中。</p>\n<p>目前为止，一个mini爬虫已经初步完成。当然目前只是爬取第一页信息。</p>\n<p>后面文章会完成分页爬取，请参考<strong>Python爬虫爬取简书首页文章(二)</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近对Python兴趣很大，因为觉得这门语言很好玩。学了些东西就总得做点什么出来吧。</p>\n<p><strong>虽然兴趣是最好的老师，但是毕竟实践才是检验真理的唯一标准</strong></p>\n<p>首先想到的就是写个爬虫试试，专门针对特定网站的mini爬虫。</p>\n<p>那就采集<a href=\"www.jianshu.com\">简书</a>首页文章吧。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>在开始代码前先做好准备工作：安装所需库。</p>\n<p>这里的数据存储在csv文件中，而不是存储在数据库，因为数据流并不大,使用<code>csv</code>库。</p>\n<p>网络请求库使用<code>urllib</code>。</p>\n<p>Dom解析库使用<code>BeautifulSoup4</code>。</p>\n<p>如果本地没有的库可以使用<code>pip3 install xxx</code>命令安装。</p>\n<p>准备工作做完了就开始编码了吗？NO~，接下来要分析网页，分析要爬取网页的内容。</p>\n<h1 id=\"网页分析\"><a href=\"#网页分析\" class=\"headerlink\" title=\"网页分析\"></a>网页分析</h1><p>分析简书首页文章列表，找到共通的规则，才能让后面的采集有迹可循。</p>\n<ul>\n<li><p>打开简书首页，复制一个文章标题</p>\n<p>应该是这样子的：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%A0%87%E9%A2%98%E5%A4%8D%E5%88%B6.png\" alt=\"简书首页标题复制\"></p>\n</li>\n<li><p>查看网页源码，在源码中查找复制的标题</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BA%90%E7%A0%81%E6%98%BE%E7%A4%BA%E6%A0%87%E9%A2%98%E5%8C%BA%E5%9F%9F.png\" alt=\"源码中标题区域\"></p>\n<p>从标题逐步扩散式查找，最终定位到标签<code>li</code>。就是说每个首页文章区域部分就是一个<code>li</code>标签显示的。而且这些标签的<strong>id</strong>属性都是以<strong>note-</strong>开头的。</p>\n</li>\n<li><p>查找父元素</p>\n<p>既然每个文章是一个<code>li</code>标签，那么父元素应该是<code>ul</code>标签。顺藤摸瓜发现了</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 文章列表模块 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"note-list\"</span> <span class=\"attr\">infinite-scroll-url</span>=<span class=\"string\">\"/\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>所以Dom解析时查找<strong>class</strong>为<strong>note-list</strong>子元素即可</p>\n</li>\n</ul>\n<p><strong>这里首页文章基本理清规则了，其他网站可能复杂性会高，但是只要耐心点，基本都能找到规律</strong></p>\n<p>下面开始创建项目：</p>\n<h1 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h1><p>我这里使用Pycharm IDE，创建一个项目名称为<code>JianShuSpider</code>。</p>\n<p>创建main文件夹，同时在其下创建JS.py文件，该文件主要写逻辑。</p>\n<p>创建Article文件，其中创建Article类，用来存储爬取的文章信息。</p>\n<h1 id=\"开始实现\"><a href=\"#开始实现\" class=\"headerlink\" title=\"开始实现\"></a>开始实现</h1><h2 id=\"确定爬取内容\"><a href=\"#确定爬取内容\" class=\"headerlink\" title=\"确定爬取内容\"></a>确定爬取内容</h2><p>因为这里只是个练习爬虫，不想存储太多内容，所以只爬取文章标题、作者、链接</p>\n<p>完善Article类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Article</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">        文章信息类</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.title = <span class=\"string\">''</span></div><div class=\"line\">        self.author = <span class=\"string\">''</span></div><div class=\"line\">        self.url = <span class=\"string\">''</span></div></pre></td></tr></table></figure>\n<h2 id=\"逻辑实现\"><a href=\"#逻辑实现\" class=\"headerlink\" title=\"逻辑实现\"></a>逻辑实现</h2><p>总体逻辑大概分成三个方法：</p>\n<p>①定义<code>def getArticles(url):</code>方法获取文章列表</p>\n<p>②定义<code>def saveCSV(articles):</code>方法存储获取的文章列表信息</p>\n<p>③定义<code>def wrapper():</code>包装上述两个方法以便在让工作线程执行</p>\n<p>下面按次序一次实现</p>\n<h3 id=\"获取文章列表\"><a href=\"#获取文章列表\" class=\"headerlink\" title=\"获取文章列表\"></a>获取文章列表</h3><p>获取文章列表又细分为4个小步骤：</p>\n<p>①定义一个空列表用来后面存储文章信息：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">article_list = []</div></pre></td></tr></table></figure>\n<p>②发起网络请求读取网页源码，为后面DOM解析做准备，如果出现异常返回空列表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error, request</div><div class=\"line\"> <span class=\"keyword\">try</span>:                                      </div><div class=\"line\">     req = request.urlopen(url=url)        </div><div class=\"line\">     content = req.read()                  </div><div class=\"line\"> <span class=\"keyword\">except</span> error.HTTPError <span class=\"keyword\">as</span>  err:           </div><div class=\"line\">     print(err)                            </div><div class=\"line\">     <span class=\"keyword\">return</span> article_list</div></pre></td></tr></table></figure>\n<p>③根据步骤②提供的content DOM树和上面分析li标签规则，通过正则表达式查找当前页所有文章标签li：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> bs4</div><div class=\"line\"><span class=\"keyword\">import</span> re</div><div class=\"line\"></div><div class=\"line\">bsobj = bs4.BeautifulSoup(content, <span class=\"string\">\"html.parser\"</span>)</div><div class=\"line\">   list = bsobj.find_all(name=<span class=\"string\">\"li\"</span>,</div><div class=\"line\">                         attrs=&#123;<span class=\"string\">\"id\"</span>: re.compile(<span class=\"string\">\"^(note-)[0-9]+$\"</span>)&#125;)</div></pre></td></tr></table></figure>\n<p>④根据步骤③返回的li标签列表，对li列表标签进行遍历查找子标签中标题、作者和链接信息，赋值给Article对象，并添加到步骤①创建的<strong>article_list</strong>列表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> list:                                                                 </div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(item, bs4.Tag)                                              </div><div class=\"line\">    article = Article()                                                           </div><div class=\"line\">    article.author = item.find(name=<span class=\"string\">'a'</span>, attrs=&#123;<span class=\"string\">'class'</span>: <span class=\"string\">'blue-link'</span>&#125;).get_text() </div><div class=\"line\">    titleTag = item.find(name=<span class=\"string\">'a'</span>, attrs=&#123;<span class=\"string\">'class'</span>: <span class=\"string\">'title'</span>&#125;)                      </div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(titleTag, bs4.Tag)                                          </div><div class=\"line\">    article.title = titleTag.get_text()                                           </div><div class=\"line\">    article.url = url + titleTag.attrs[<span class=\"string\">'href'</span>]                                    </div><div class=\"line\">    article_list.append(article)</div></pre></td></tr></table></figure>\n<p>经过上面一些列步骤已经得到了文章列表信息，下面要把文章列表存储到csv文件中</p>\n<h3 id=\"存储文章列表\"><a href=\"#存储文章列表\" class=\"headerlink\" title=\"存储文章列表\"></a>存储文章列表</h3><p><strong>注意：csv是按逗号分隔的文件，每一行代表一条完整信息，所以写入信息时是逐行写入。</strong></p>\n<p>存储文章可以分为3个小步骤：</p>\n<p>①根据path打开或创建一个csv文件，同时获取writer</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> csv</div><div class=\"line\"> csvFile = open(<span class=\"string\">\"/Users/jenson/Downloads/js.csv\"</span>, <span class=\"string\">'w+'</span>)    </div><div class=\"line\"> csv_writer = csv.writer(csvFile)</div></pre></td></tr></table></figure>\n<p>②向文件写入头行，用来说明每个被逗号隔断的数据表示的意义</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">csv_writer.writerow([<span class=\"string\">\"作者\"</span>, <span class=\"string\">\"标题\"</span>, <span class=\"string\">\"链接\"</span>])</div></pre></td></tr></table></figure>\n<p>③遍历文章列表存储</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> article <span class=\"keyword\">in</span> articles:                               </div><div class=\"line\">    csv_writer.writerow(                               </div><div class=\"line\">        [article.author, article.title, article.url])</div></pre></td></tr></table></figure>\n<h3 id=\"包装方法\"><a href=\"#包装方法\" class=\"headerlink\" title=\"包装方法\"></a>包装方法</h3><p>包装方法就简单了，直接上代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">()</span>:</span>    </div><div class=\"line\">    <span class=\"string\">\"\"\"           </span></div><div class=\"line\">    包装方法          </div><div class=\"line\">    :return:      </div><div class=\"line\">    \"\"\"           </div><div class=\"line\">    list = getArti</div><div class=\"line\">    saveCSV(list)</div></pre></td></tr></table></figure>\n<h3 id=\"线程调用\"><a href=\"#线程调用\" class=\"headerlink\" title=\"线程调用\"></a>线程调用</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">threading.Thread(target=wrapper).start()</div></pre></td></tr></table></figure>\n<h1 id=\"爬取结果\"><a href=\"#爬取结果\" class=\"headerlink\" title=\"爬取结果\"></a>爬取结果</h1><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%AC%AC%E4%B8%80%E9%A1%B5%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9E%9C.png\" alt=\"爬取结果\"></p>\n<p>通过上面的图片可以看到文章信息已经存储到csv文件中。</p>\n<p>目前为止，一个mini爬虫已经初步完成。当然目前只是爬取第一页信息。</p>\n<p>后面文章会完成分页爬取，请参考<strong>Python爬虫爬取简书首页文章(二)</strong></p>\n"},{"title":"Python爬虫爬取简书首页文章(二)","date":"2017-08-02T03:44:12.000Z","_content":"\n# 前言\n\n在 [Python爬虫爬取简书首页文章(一)](http://www.jensondev.me/2017/08/02/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0-%E4%B8%80/) 中已经完成了一个mini爬虫，完成了基本的爬取和存储工作。\n\n但是还有很多问题需要亟需解决，譬如分页抓取就是本章要解决的。\n\n要实现分页爬取，首先要知道网站如何分页的\n\n# 网站如何分页\n\n这里以简书为例，要想知道简书首页文章如何实现分页，首先打开官网和抓包工具进行监听。\n\n这里的抓包工具我使用的时**Wireshark**。刚开始时数据流是空的：\n\n![空](http://othg5ggzi.bkt.clouddn.com/%E7%A9%BAWireshark.png)\n\n现在开始滑动简书官网，直到页面底部出现**阅读更多**按钮，这滑动期间竟然也发生了两次网络请求：\n\n![滑动期间的两次请求](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BB%91%E5%8A%A8%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82.png)\n\nGET请求的url是这样子的：\n\n/?seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_snote_ids%5B%5D=15290950&seen_snote_ids%5B%5D=15301177&seen_snote_ids%5B%5D=15275389&seen_snote_ids%5B%5D=15266115&seen_snote_ids%5B%5D=15293985&seen_snote_ids%5B%5D=15289824&seen_snote_ids%5B%5D=15276555&seen_snote_ids%5B%5D=15269012&seen_snote_ids%5B%5D=15268330&seen_snote_ids%5B%5D=15285079&seen_snote_ids%5B%5D=15292494&seen_snote_ids%5B%5D=15284369&seen_snote_ids%5B%5D=15299782&seen_snote_ids%5B%5D=15011765&seen_snote_ids%5B%5D=15304980&seen_snote_ids%5B%5D=15287206&seen_snote_ids%5B%5D=15273113&seen_snote_ids%5B%5D=15268608&seen_snote_ids%5B%5D=15220769&seen_snote_ids%5B%5D=15152802&seen_snote_ids%5B%5D=15280804&seen_snote_ids%5B%5D=15229091&seen_snote_ids%5B%5D=15288809&seen_snote_ids%5B%5D=15267285&seen_snote_ids%5B%5D=14630860&seen_snote_ids%5B%5D=15290958&seen_snote_ids%5B%5D=15262258&seen_snote_ids%5B%5D=15299674&seen_snote_ids%5B%5D=15294416&seen_snote_ids%5B%5D=15262595&seen_snote_ids%5B%5D=15271868&seen_snote_ids%5B%5D=15184645&seen_snote_ids%5B%5D=14818734&seen_snote_ids%5B%5D=15254172&page=3\n\n当我点击**阅读更多**时候的请求url是这样子的：\n\n/?page=4&seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_snote_ids%5B%5D=15290950&seen_snote_ids%5B%5D=15301177&seen_snote_ids%5B%5D=15275389&seen_snote_ids%5B%5D=15266115&seen_snote_ids%5B%5D=15293985&seen_snote_ids%5B%5D=15289824&seen_snote_ids%5B%5D=15276555&seen_snote_ids%5B%5D=15269012&seen_snote_ids%5B%5D=15268330&seen_snote_ids%5B%5D=15285079&seen_snote_ids%5B%5D=15292494&seen_snote_ids%5B%5D=15284369&seen_snote_ids%5B%5D=15299782&seen_snote_ids%5B%5D=15011765&seen_snote_ids%5B%5D=15304980&seen_snote_ids%5B%5D=15287206&seen_snote_ids%5B%5D=15273113&seen_snote_ids%5B%5D=15268608&seen_snote_ids%5B%5D=15220769&seen_snote_ids%5B%5D=15152802&seen_snote_ids%5B%5D=15280804&seen_snote_ids%5B%5D=15229091&seen_snote_ids%5B%5D=15288809&seen_snote_ids%5B%5D=15267285&seen_snote_ids%5B%5D=14630860&seen_snote_ids%5B%5D=15290958&seen_snote_ids%5B%5D=15262258&seen_snote_ids%5B%5D=15299674&seen_snote_ids%5B%5D=15294416&seen_snote_ids%5B%5D=15262595&seen_snote_ids%5B%5D=15271868&seen_snote_ids%5B%5D=15184645&seen_snote_ids%5B%5D=14818734&seen_snote_ids%5B%5D=15254172&seen_snote_ids%5B%5D=15272682&seen_snote_ids%5B%5D=15302506&seen_snote_ids%5B%5D=15238434&seen_snote_ids%5B%5D=15302851&seen_snote_ids%5B%5D=15256354&seen_snote_ids%5B%5D=15297896&seen_snote_ids%5B%5D=15246028&seen_snote_ids%5B%5D=15292615&seen_snote_ids%5B%5D=15215522&seen_snote_ids%5B%5D=15295152&seen_snote_ids%5B%5D=15246711&seen_snote_ids%5B%5D=15276820&seen_snote_ids%5B%5D=15274436&seen_snote_ids%5B%5D=15300621&seen_snote_ids%5B%5D=15296525&seen_snote_ids%5B%5D=15297151&seen_snote_ids%5B%5D=15298014&seen_snote_ids%5B%5D=11621895&seen_snote_ids%5B%5D=15268868&seen_snote_ids%5B%5D=15280076\n\n通过这两个url可以看到每次都携带一个page参数，应该是表示请求页数了，\n\n所以可以知道目前简书的分页是这样的：第一次打开时加载几条，在下滑过程中会产生两次请求，分别是page=2和page=3，然后再次滑动到底部时出现**阅读更多**按钮，后面的分页靠按钮点击实现。\n\n综合来讲，简书的分页是下滑和点击共同实现的。\n\n分析完了简书如何分页，下面分析爬虫如何分页抓取数据。\n\n# 爬虫如何分页\n\n一般来说爬虫分页有2种实现方式：①找到网址分页所须参数，通过发起网络请求对应的页数。②模拟人类对浏览器下滑、点击等操作实现分页。\n\n对于简书官网，我最先使用了第一种方法，每次请求携带page和seen_snote_ids参数，但是仍然返回数据有问题。可能服务器还对其他首部信息做了校验。\n\n看下请求信息：\n\n     [truncated]GET /?seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_snote_ids%5B%5D=15290950&seen_snote_\n    Host: www.jianshu.com\\r\\n\n    Connection: keep-alive\\r\\n\n    Accept: text/html, */*; q=0.01\\r\\n\n    X-CSRF-Token: jrzSqMWq+Gqjm66lMiTJQQYSKEZKUYAYV9oOPghKMdJiJs9Oij1Q/bhsdugAnKKEjhsAokQqiog7MnW9ojznxQ==\\r\\n\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\\r\\n\n    X-Requested-With: XMLHttpRequest\\r\\n\n    X-INFINITESCROLL: true\\r\\n\n    Referer: http://www.jianshu.com/\\r\\n\n    Accept-Encoding: gzip, deflate\\r\\n\n    Accept-Language: zh-CN,zh;q=0.8,en;q=0.6\\r\\n\n     [truncated]Cookie: signin_redirect=http%3A%2F%2Fwww.jianshu.com%2F; _ga=GA1.2.508983344.1500518688; _gid=GA1.2.101137453.1501499488; _gat=1; _session_id=NjJQQWdSSEl2cWdtSEc0bmRTQnZXQTVQenNDbTV1V0Z5M2N5OGpxbnhyell5Tnl5UHp6UHZJSncvVzNSeGlEU\n    If-None-Match: W/\"09cd78bd0d8a197d769d2c5b6b1e84e9\"\\r\\n\n    \\r\\n\n    [Full request URI [truncated]: http://www.jianshu.com/?seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_]\n    [HTTP request 1/2]\n    [Next request in frame: 28]\n由于请求信息太多，分析起来比较困难，所以决定采用方法②模拟行为。\n\n要模拟人类下滑、点击浏览器行为需要使用自动化测试库**selenium**。\n\n\n\n# Selenium使用\n\n继续上篇文章的创建的项目，创建JSSpider.py文件\n\n该文件中测试selenium库\n\n我这里使用Chrome浏览器，需要安装ChromeDriver，具体方法见：[Selenium ChromeDriver安装](http://www.jensondev.me/2017/08/02/Selenium-ChromeDriver%E5%AE%89%E8%A3%85/)。\n\n用selenium实现分页，可以分为三步：\n\n①导入所需类：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.remote.webelement import WebElement\nimport time\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait as wait\nfrom selenium.webdriver.common.by import By\n```\n\n②实现窗口下滑：\n\n```python\nbrowser = webdriver.Chrome(executable_path=\"/Users/jenson/Downloads/chromedriver\")\nbrowser.get(\"http://www.jianshu.com\")\nbrowser.maximize_window()\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n# 前三页都已经出来了\n```\n\n通过两次调用`browser.execute_script`，导致窗口两次自动下滑，会自动请求服务器。\n\n③等待阅读更多按钮显示后模拟点击：\n\n```python\ntry:\n    loadMoreEle = wait(browser, 10).until(\n        EC.presence_of_element_located((By.CLASS_NAME, \"load-more\"))\n    )\nexcept RuntimeError as e:\n    print(e)\n# loadMoreEle = browser.find_element_by_class_name(\"load-more\")\nassert isinstance(loadMoreEle, WebElement)\n# time.sleep(5)\nis_displayed = loadMoreEle.is_displayed()\nprint(is_displayed)\ntime.sleep(5)\nif is_displayed:\n    loadMoreEle.click()\n```\n\n插播一条消息：如果selenium启动Chrome浏览器，会有这样一条提示信息：\n\n![selenium控制浏览器提示](http://othg5ggzi.bkt.clouddn.com/selenium%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA.png)\n\n如果上面都已经实现且执行成功，那么可以开始把两个部分代码进行合并了。\n\n\n\n# 实现分页\n\n这里的实现分页只要把上一篇的代码和本节代码合并，基本就可以完成简书首页文章的抓取，下面看下具体实现：\n\n## 首先实现下滑分页爬取部分\n\n\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.remote.webelement import WebElement\nimport time\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait as wait\nfrom selenium.webdriver.common.by import By\nimport main.JS as JS\n\nurl_str = \"http://www.jianshu.com\"\nbrowser = webdriver.Chrome(executable_path=\"/Users/jenson/Downloads/chromedriver\")\nbrowser.get(url_str)\nbrowser.maximize_window()\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n# 前三页都已经出来了,\n\n# 获取前三页内容\ntime.sleep(3)\nlist = JS.getArticles(browser, False)\nJS.saveCSV(list, True)\n```\n\n上一篇中写的`getArticles`方法添加了2个参数，**browser**和**isClick**，去掉了**url**参数。因为内容都已经在**browser**这个selenium启动的浏览器中了，所以不需要在使用**urllib**进行网络请求，也不再使用**bs4**来进行DOM解析，一切都交由**browser**完成。**isClick**为TRUE表示点击翻页，否则表示滑动翻页。\n\n看下目前`getArticles`的实现\n\n```python\ndef getArticles(browser, isClick=False):\n    \"\"\"\n    根据url获取当前页面文章列表\n    :param url:\n    :param isClick:\n    :return:\n    \"\"\"\n\n    article_list = []\n    assert isinstance(browser, webdriver.Chrome)\n    ulEle = browser.find_element_by_class_name(\"note-list\")\n    assert isinstance(ulEle, WebElement)\n    eles = ulEle.find_elements_by_xpath(\"//li[@id]\")\n    print(len(eles))\n    if isClick:\n        return iteratorEle(eles, article_list, len(eles) - 20, len(eles))\n    else:\n        return iteratorEle(eles, article_list, 0, len(eles))\n\n\ndef iteratorEle(eles, article_list, start, end):\n    \"\"\"\n    :param eles:\n    :param article_list:\n    :param start:\n    :param end:\n    :return:\n    \"\"\"\n    for index in range(start, end):\n        item = eles[index]\n        assert isinstance(item, WebElement)\n        article = Article()\n        article.author = item.find_element_by_class_name(\"blue-link\").text\n        titleEle = item.find_element_by_class_name(\"title\")\n        assert isinstance(titleEle, WebElement)\n        article.title = titleEle.text\n        article.url = titleEle.get_attribute(\"href\")\n        article_list.append(article)\n    return article_list\n```\n\n另外保存csv文件的方法`saveCSV`也有改动，添加了一个**setTag**参数。为True表示设置首行的标记。方法实现如下：\n\n```python\ndef saveCSV(articles, setTag=False):\n    \"\"\"\n    保存到csv文件\n    :param articles:\n    :return:\n    \"\"\"\n    csvFile = open(\"/Users/jenson/Downloads/js.csv\", 'a')\n    csv_writer = csv.writer(csvFile)\n    # print(type(csv_writer))\n    # assert isinstance(csv_writer, csv.DictWriter)\n    if setTag:\n        csv_writer.writerow([\"作者\", \"标题\", \"链接\"])\n    for article in articles:\n        csv_writer.writerow(\n            [article.author, article.title, article.url])\n```\n\n\n\n## 其次实现点击分页爬取部分\n\n模拟点击翻页中使用while循环检测**阅读更多**按钮是否可见，如果可见则每次模拟点击实现翻页，代码实现如下：\n\n```python\n# 模拟点击翻页\ntry:\n    loadMoreEle = wait(browser, 10).until(\n        EC.presence_of_element_located((By.CLASS_NAME, \"load-more\"))\n    )\nexcept RuntimeError as e:\n    print(e)\n# loadMoreEle = browser.find_element_by_class_name(\"load-more\")\nassert isinstance(loadMoreEle, WebElement)\n# time.sleep(5)\ntry:\n    while loadMoreEle.is_displayed():\n        loadMoreEle.click()\n        time.sleep(3)\n        list = JS.getArticles(browser, True)\n        JS.saveCSV(list)\nexcept RuntimeError as err:\n    print(err)\n\n```\n\n\n\n经过以上步骤，翻页爬取简书首页文章就已经完成了，最终爬取结果如下：\n\n![简书首页文章爬取到末尾](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%9C%AB%E5%B0%BE%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9D%9F.png)\n\n可以看到文章末尾已经没有了**阅读更多**字样，说明已经翻到底儿了。而CSV文件中内容最后一条也刚好符合简书网站最后一条。可见抓取成功。\n\n\n\n\n\n> 注意：一旦使用了selenium，后面的DOM解析都要使用对应的浏览器Driver进行解析，如果还是使用bs4是获取不到新内容的。\n>\n> ","source":"_posts/Python爬虫爬取简书首页文章-二.md","raw":"---\ntitle: Python爬虫爬取简书首页文章(二)\ndate: 2017-08-02 11:44:12\ntags: [Python, 自己写爬虫]\ncategories: [Python, 自己写爬虫]\n---\n\n# 前言\n\n在 [Python爬虫爬取简书首页文章(一)](http://www.jensondev.me/2017/08/02/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0-%E4%B8%80/) 中已经完成了一个mini爬虫，完成了基本的爬取和存储工作。\n\n但是还有很多问题需要亟需解决，譬如分页抓取就是本章要解决的。\n\n要实现分页爬取，首先要知道网站如何分页的\n\n# 网站如何分页\n\n这里以简书为例，要想知道简书首页文章如何实现分页，首先打开官网和抓包工具进行监听。\n\n这里的抓包工具我使用的时**Wireshark**。刚开始时数据流是空的：\n\n![空](http://othg5ggzi.bkt.clouddn.com/%E7%A9%BAWireshark.png)\n\n现在开始滑动简书官网，直到页面底部出现**阅读更多**按钮，这滑动期间竟然也发生了两次网络请求：\n\n![滑动期间的两次请求](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BB%91%E5%8A%A8%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82.png)\n\nGET请求的url是这样子的：\n\n/?seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_snote_ids%5B%5D=15290950&seen_snote_ids%5B%5D=15301177&seen_snote_ids%5B%5D=15275389&seen_snote_ids%5B%5D=15266115&seen_snote_ids%5B%5D=15293985&seen_snote_ids%5B%5D=15289824&seen_snote_ids%5B%5D=15276555&seen_snote_ids%5B%5D=15269012&seen_snote_ids%5B%5D=15268330&seen_snote_ids%5B%5D=15285079&seen_snote_ids%5B%5D=15292494&seen_snote_ids%5B%5D=15284369&seen_snote_ids%5B%5D=15299782&seen_snote_ids%5B%5D=15011765&seen_snote_ids%5B%5D=15304980&seen_snote_ids%5B%5D=15287206&seen_snote_ids%5B%5D=15273113&seen_snote_ids%5B%5D=15268608&seen_snote_ids%5B%5D=15220769&seen_snote_ids%5B%5D=15152802&seen_snote_ids%5B%5D=15280804&seen_snote_ids%5B%5D=15229091&seen_snote_ids%5B%5D=15288809&seen_snote_ids%5B%5D=15267285&seen_snote_ids%5B%5D=14630860&seen_snote_ids%5B%5D=15290958&seen_snote_ids%5B%5D=15262258&seen_snote_ids%5B%5D=15299674&seen_snote_ids%5B%5D=15294416&seen_snote_ids%5B%5D=15262595&seen_snote_ids%5B%5D=15271868&seen_snote_ids%5B%5D=15184645&seen_snote_ids%5B%5D=14818734&seen_snote_ids%5B%5D=15254172&page=3\n\n当我点击**阅读更多**时候的请求url是这样子的：\n\n/?page=4&seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_snote_ids%5B%5D=15290950&seen_snote_ids%5B%5D=15301177&seen_snote_ids%5B%5D=15275389&seen_snote_ids%5B%5D=15266115&seen_snote_ids%5B%5D=15293985&seen_snote_ids%5B%5D=15289824&seen_snote_ids%5B%5D=15276555&seen_snote_ids%5B%5D=15269012&seen_snote_ids%5B%5D=15268330&seen_snote_ids%5B%5D=15285079&seen_snote_ids%5B%5D=15292494&seen_snote_ids%5B%5D=15284369&seen_snote_ids%5B%5D=15299782&seen_snote_ids%5B%5D=15011765&seen_snote_ids%5B%5D=15304980&seen_snote_ids%5B%5D=15287206&seen_snote_ids%5B%5D=15273113&seen_snote_ids%5B%5D=15268608&seen_snote_ids%5B%5D=15220769&seen_snote_ids%5B%5D=15152802&seen_snote_ids%5B%5D=15280804&seen_snote_ids%5B%5D=15229091&seen_snote_ids%5B%5D=15288809&seen_snote_ids%5B%5D=15267285&seen_snote_ids%5B%5D=14630860&seen_snote_ids%5B%5D=15290958&seen_snote_ids%5B%5D=15262258&seen_snote_ids%5B%5D=15299674&seen_snote_ids%5B%5D=15294416&seen_snote_ids%5B%5D=15262595&seen_snote_ids%5B%5D=15271868&seen_snote_ids%5B%5D=15184645&seen_snote_ids%5B%5D=14818734&seen_snote_ids%5B%5D=15254172&seen_snote_ids%5B%5D=15272682&seen_snote_ids%5B%5D=15302506&seen_snote_ids%5B%5D=15238434&seen_snote_ids%5B%5D=15302851&seen_snote_ids%5B%5D=15256354&seen_snote_ids%5B%5D=15297896&seen_snote_ids%5B%5D=15246028&seen_snote_ids%5B%5D=15292615&seen_snote_ids%5B%5D=15215522&seen_snote_ids%5B%5D=15295152&seen_snote_ids%5B%5D=15246711&seen_snote_ids%5B%5D=15276820&seen_snote_ids%5B%5D=15274436&seen_snote_ids%5B%5D=15300621&seen_snote_ids%5B%5D=15296525&seen_snote_ids%5B%5D=15297151&seen_snote_ids%5B%5D=15298014&seen_snote_ids%5B%5D=11621895&seen_snote_ids%5B%5D=15268868&seen_snote_ids%5B%5D=15280076\n\n通过这两个url可以看到每次都携带一个page参数，应该是表示请求页数了，\n\n所以可以知道目前简书的分页是这样的：第一次打开时加载几条，在下滑过程中会产生两次请求，分别是page=2和page=3，然后再次滑动到底部时出现**阅读更多**按钮，后面的分页靠按钮点击实现。\n\n综合来讲，简书的分页是下滑和点击共同实现的。\n\n分析完了简书如何分页，下面分析爬虫如何分页抓取数据。\n\n# 爬虫如何分页\n\n一般来说爬虫分页有2种实现方式：①找到网址分页所须参数，通过发起网络请求对应的页数。②模拟人类对浏览器下滑、点击等操作实现分页。\n\n对于简书官网，我最先使用了第一种方法，每次请求携带page和seen_snote_ids参数，但是仍然返回数据有问题。可能服务器还对其他首部信息做了校验。\n\n看下请求信息：\n\n     [truncated]GET /?seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_snote_ids%5B%5D=15290950&seen_snote_\n    Host: www.jianshu.com\\r\\n\n    Connection: keep-alive\\r\\n\n    Accept: text/html, */*; q=0.01\\r\\n\n    X-CSRF-Token: jrzSqMWq+Gqjm66lMiTJQQYSKEZKUYAYV9oOPghKMdJiJs9Oij1Q/bhsdugAnKKEjhsAokQqiog7MnW9ojznxQ==\\r\\n\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\\r\\n\n    X-Requested-With: XMLHttpRequest\\r\\n\n    X-INFINITESCROLL: true\\r\\n\n    Referer: http://www.jianshu.com/\\r\\n\n    Accept-Encoding: gzip, deflate\\r\\n\n    Accept-Language: zh-CN,zh;q=0.8,en;q=0.6\\r\\n\n     [truncated]Cookie: signin_redirect=http%3A%2F%2Fwww.jianshu.com%2F; _ga=GA1.2.508983344.1500518688; _gid=GA1.2.101137453.1501499488; _gat=1; _session_id=NjJQQWdSSEl2cWdtSEc0bmRTQnZXQTVQenNDbTV1V0Z5M2N5OGpxbnhyell5Tnl5UHp6UHZJSncvVzNSeGlEU\n    If-None-Match: W/\"09cd78bd0d8a197d769d2c5b6b1e84e9\"\\r\\n\n    \\r\\n\n    [Full request URI [truncated]: http://www.jianshu.com/?seen_snote_ids%5B%5D=15296134&seen_snote_ids%5B%5D=15306523&seen_snote_ids%5B%5D=15298503&seen_snote_ids%5B%5D=15240154&seen_snote_ids%5B%5D=15274107&seen_snote_ids%5B%5D=15256726&seen_]\n    [HTTP request 1/2]\n    [Next request in frame: 28]\n由于请求信息太多，分析起来比较困难，所以决定采用方法②模拟行为。\n\n要模拟人类下滑、点击浏览器行为需要使用自动化测试库**selenium**。\n\n\n\n# Selenium使用\n\n继续上篇文章的创建的项目，创建JSSpider.py文件\n\n该文件中测试selenium库\n\n我这里使用Chrome浏览器，需要安装ChromeDriver，具体方法见：[Selenium ChromeDriver安装](http://www.jensondev.me/2017/08/02/Selenium-ChromeDriver%E5%AE%89%E8%A3%85/)。\n\n用selenium实现分页，可以分为三步：\n\n①导入所需类：\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.remote.webelement import WebElement\nimport time\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait as wait\nfrom selenium.webdriver.common.by import By\n```\n\n②实现窗口下滑：\n\n```python\nbrowser = webdriver.Chrome(executable_path=\"/Users/jenson/Downloads/chromedriver\")\nbrowser.get(\"http://www.jianshu.com\")\nbrowser.maximize_window()\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n# 前三页都已经出来了\n```\n\n通过两次调用`browser.execute_script`，导致窗口两次自动下滑，会自动请求服务器。\n\n③等待阅读更多按钮显示后模拟点击：\n\n```python\ntry:\n    loadMoreEle = wait(browser, 10).until(\n        EC.presence_of_element_located((By.CLASS_NAME, \"load-more\"))\n    )\nexcept RuntimeError as e:\n    print(e)\n# loadMoreEle = browser.find_element_by_class_name(\"load-more\")\nassert isinstance(loadMoreEle, WebElement)\n# time.sleep(5)\nis_displayed = loadMoreEle.is_displayed()\nprint(is_displayed)\ntime.sleep(5)\nif is_displayed:\n    loadMoreEle.click()\n```\n\n插播一条消息：如果selenium启动Chrome浏览器，会有这样一条提示信息：\n\n![selenium控制浏览器提示](http://othg5ggzi.bkt.clouddn.com/selenium%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA.png)\n\n如果上面都已经实现且执行成功，那么可以开始把两个部分代码进行合并了。\n\n\n\n# 实现分页\n\n这里的实现分页只要把上一篇的代码和本节代码合并，基本就可以完成简书首页文章的抓取，下面看下具体实现：\n\n## 首先实现下滑分页爬取部分\n\n\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.remote.webelement import WebElement\nimport time\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.wait import WebDriverWait as wait\nfrom selenium.webdriver.common.by import By\nimport main.JS as JS\n\nurl_str = \"http://www.jianshu.com\"\nbrowser = webdriver.Chrome(executable_path=\"/Users/jenson/Downloads/chromedriver\")\nbrowser.get(url_str)\nbrowser.maximize_window()\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\ntime.sleep(3)\nbrowser.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n# 前三页都已经出来了,\n\n# 获取前三页内容\ntime.sleep(3)\nlist = JS.getArticles(browser, False)\nJS.saveCSV(list, True)\n```\n\n上一篇中写的`getArticles`方法添加了2个参数，**browser**和**isClick**，去掉了**url**参数。因为内容都已经在**browser**这个selenium启动的浏览器中了，所以不需要在使用**urllib**进行网络请求，也不再使用**bs4**来进行DOM解析，一切都交由**browser**完成。**isClick**为TRUE表示点击翻页，否则表示滑动翻页。\n\n看下目前`getArticles`的实现\n\n```python\ndef getArticles(browser, isClick=False):\n    \"\"\"\n    根据url获取当前页面文章列表\n    :param url:\n    :param isClick:\n    :return:\n    \"\"\"\n\n    article_list = []\n    assert isinstance(browser, webdriver.Chrome)\n    ulEle = browser.find_element_by_class_name(\"note-list\")\n    assert isinstance(ulEle, WebElement)\n    eles = ulEle.find_elements_by_xpath(\"//li[@id]\")\n    print(len(eles))\n    if isClick:\n        return iteratorEle(eles, article_list, len(eles) - 20, len(eles))\n    else:\n        return iteratorEle(eles, article_list, 0, len(eles))\n\n\ndef iteratorEle(eles, article_list, start, end):\n    \"\"\"\n    :param eles:\n    :param article_list:\n    :param start:\n    :param end:\n    :return:\n    \"\"\"\n    for index in range(start, end):\n        item = eles[index]\n        assert isinstance(item, WebElement)\n        article = Article()\n        article.author = item.find_element_by_class_name(\"blue-link\").text\n        titleEle = item.find_element_by_class_name(\"title\")\n        assert isinstance(titleEle, WebElement)\n        article.title = titleEle.text\n        article.url = titleEle.get_attribute(\"href\")\n        article_list.append(article)\n    return article_list\n```\n\n另外保存csv文件的方法`saveCSV`也有改动，添加了一个**setTag**参数。为True表示设置首行的标记。方法实现如下：\n\n```python\ndef saveCSV(articles, setTag=False):\n    \"\"\"\n    保存到csv文件\n    :param articles:\n    :return:\n    \"\"\"\n    csvFile = open(\"/Users/jenson/Downloads/js.csv\", 'a')\n    csv_writer = csv.writer(csvFile)\n    # print(type(csv_writer))\n    # assert isinstance(csv_writer, csv.DictWriter)\n    if setTag:\n        csv_writer.writerow([\"作者\", \"标题\", \"链接\"])\n    for article in articles:\n        csv_writer.writerow(\n            [article.author, article.title, article.url])\n```\n\n\n\n## 其次实现点击分页爬取部分\n\n模拟点击翻页中使用while循环检测**阅读更多**按钮是否可见，如果可见则每次模拟点击实现翻页，代码实现如下：\n\n```python\n# 模拟点击翻页\ntry:\n    loadMoreEle = wait(browser, 10).until(\n        EC.presence_of_element_located((By.CLASS_NAME, \"load-more\"))\n    )\nexcept RuntimeError as e:\n    print(e)\n# loadMoreEle = browser.find_element_by_class_name(\"load-more\")\nassert isinstance(loadMoreEle, WebElement)\n# time.sleep(5)\ntry:\n    while loadMoreEle.is_displayed():\n        loadMoreEle.click()\n        time.sleep(3)\n        list = JS.getArticles(browser, True)\n        JS.saveCSV(list)\nexcept RuntimeError as err:\n    print(err)\n\n```\n\n\n\n经过以上步骤，翻页爬取简书首页文章就已经完成了，最终爬取结果如下：\n\n![简书首页文章爬取到末尾](http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%9C%AB%E5%B0%BE%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9D%9F.png)\n\n可以看到文章末尾已经没有了**阅读更多**字样，说明已经翻到底儿了。而CSV文件中内容最后一条也刚好符合简书网站最后一条。可见抓取成功。\n\n\n\n\n\n> 注意：一旦使用了selenium，后面的DOM解析都要使用对应的浏览器Driver进行解析，如果还是使用bs4是获取不到新内容的。\n>\n> ","slug":"Python爬虫爬取简书首页文章-二","published":1,"updated":"2017-08-02T09:32:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjf7003twh9coi7ug4c8","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在 <a href=\"http://www.jensondev.me/2017/08/02/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0-%E4%B8%80/\" target=\"_blank\" rel=\"external\">Python爬虫爬取简书首页文章(一)</a> 中已经完成了一个mini爬虫，完成了基本的爬取和存储工作。</p>\n<p>但是还有很多问题需要亟需解决，譬如分页抓取就是本章要解决的。</p>\n<p>要实现分页爬取，首先要知道网站如何分页的</p>\n<h1 id=\"网站如何分页\"><a href=\"#网站如何分页\" class=\"headerlink\" title=\"网站如何分页\"></a>网站如何分页</h1><p>这里以简书为例，要想知道简书首页文章如何实现分页，首先打开官网和抓包工具进行监听。</p>\n<p>这里的抓包工具我使用的时<strong>Wireshark</strong>。刚开始时数据流是空的：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%A9%BAWireshark.png\" alt=\"空\"></p>\n<p>现在开始滑动简书官网，直到页面底部出现<strong>阅读更多</strong>按钮，这滑动期间竟然也发生了两次网络请求：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BB%91%E5%8A%A8%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82.png\" alt=\"滑动期间的两次请求\"></p>\n<p>GET请求的url是这样子的：</p>\n<p>/?seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_snote_ids%5B%5D=15290950&amp;seen_snote_ids%5B%5D=15301177&amp;seen_snote_ids%5B%5D=15275389&amp;seen_snote_ids%5B%5D=15266115&amp;seen_snote_ids%5B%5D=15293985&amp;seen_snote_ids%5B%5D=15289824&amp;seen_snote_ids%5B%5D=15276555&amp;seen_snote_ids%5B%5D=15269012&amp;seen_snote_ids%5B%5D=15268330&amp;seen_snote_ids%5B%5D=15285079&amp;seen_snote_ids%5B%5D=15292494&amp;seen_snote_ids%5B%5D=15284369&amp;seen_snote_ids%5B%5D=15299782&amp;seen_snote_ids%5B%5D=15011765&amp;seen_snote_ids%5B%5D=15304980&amp;seen_snote_ids%5B%5D=15287206&amp;seen_snote_ids%5B%5D=15273113&amp;seen_snote_ids%5B%5D=15268608&amp;seen_snote_ids%5B%5D=15220769&amp;seen_snote_ids%5B%5D=15152802&amp;seen_snote_ids%5B%5D=15280804&amp;seen_snote_ids%5B%5D=15229091&amp;seen_snote_ids%5B%5D=15288809&amp;seen_snote_ids%5B%5D=15267285&amp;seen_snote_ids%5B%5D=14630860&amp;seen_snote_ids%5B%5D=15290958&amp;seen_snote_ids%5B%5D=15262258&amp;seen_snote_ids%5B%5D=15299674&amp;seen_snote_ids%5B%5D=15294416&amp;seen_snote_ids%5B%5D=15262595&amp;seen_snote_ids%5B%5D=15271868&amp;seen_snote_ids%5B%5D=15184645&amp;seen_snote_ids%5B%5D=14818734&amp;seen_snote_ids%5B%5D=15254172&amp;page=3</p>\n<p>当我点击<strong>阅读更多</strong>时候的请求url是这样子的：</p>\n<p>/?page=4&amp;seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_snote_ids%5B%5D=15290950&amp;seen_snote_ids%5B%5D=15301177&amp;seen_snote_ids%5B%5D=15275389&amp;seen_snote_ids%5B%5D=15266115&amp;seen_snote_ids%5B%5D=15293985&amp;seen_snote_ids%5B%5D=15289824&amp;seen_snote_ids%5B%5D=15276555&amp;seen_snote_ids%5B%5D=15269012&amp;seen_snote_ids%5B%5D=15268330&amp;seen_snote_ids%5B%5D=15285079&amp;seen_snote_ids%5B%5D=15292494&amp;seen_snote_ids%5B%5D=15284369&amp;seen_snote_ids%5B%5D=15299782&amp;seen_snote_ids%5B%5D=15011765&amp;seen_snote_ids%5B%5D=15304980&amp;seen_snote_ids%5B%5D=15287206&amp;seen_snote_ids%5B%5D=15273113&amp;seen_snote_ids%5B%5D=15268608&amp;seen_snote_ids%5B%5D=15220769&amp;seen_snote_ids%5B%5D=15152802&amp;seen_snote_ids%5B%5D=15280804&amp;seen_snote_ids%5B%5D=15229091&amp;seen_snote_ids%5B%5D=15288809&amp;seen_snote_ids%5B%5D=15267285&amp;seen_snote_ids%5B%5D=14630860&amp;seen_snote_ids%5B%5D=15290958&amp;seen_snote_ids%5B%5D=15262258&amp;seen_snote_ids%5B%5D=15299674&amp;seen_snote_ids%5B%5D=15294416&amp;seen_snote_ids%5B%5D=15262595&amp;seen_snote_ids%5B%5D=15271868&amp;seen_snote_ids%5B%5D=15184645&amp;seen_snote_ids%5B%5D=14818734&amp;seen_snote_ids%5B%5D=15254172&amp;seen_snote_ids%5B%5D=15272682&amp;seen_snote_ids%5B%5D=15302506&amp;seen_snote_ids%5B%5D=15238434&amp;seen_snote_ids%5B%5D=15302851&amp;seen_snote_ids%5B%5D=15256354&amp;seen_snote_ids%5B%5D=15297896&amp;seen_snote_ids%5B%5D=15246028&amp;seen_snote_ids%5B%5D=15292615&amp;seen_snote_ids%5B%5D=15215522&amp;seen_snote_ids%5B%5D=15295152&amp;seen_snote_ids%5B%5D=15246711&amp;seen_snote_ids%5B%5D=15276820&amp;seen_snote_ids%5B%5D=15274436&amp;seen_snote_ids%5B%5D=15300621&amp;seen_snote_ids%5B%5D=15296525&amp;seen_snote_ids%5B%5D=15297151&amp;seen_snote_ids%5B%5D=15298014&amp;seen_snote_ids%5B%5D=11621895&amp;seen_snote_ids%5B%5D=15268868&amp;seen_snote_ids%5B%5D=15280076</p>\n<p>通过这两个url可以看到每次都携带一个page参数，应该是表示请求页数了，</p>\n<p>所以可以知道目前简书的分页是这样的：第一次打开时加载几条，在下滑过程中会产生两次请求，分别是page=2和page=3，然后再次滑动到底部时出现<strong>阅读更多</strong>按钮，后面的分页靠按钮点击实现。</p>\n<p>综合来讲，简书的分页是下滑和点击共同实现的。</p>\n<p>分析完了简书如何分页，下面分析爬虫如何分页抓取数据。</p>\n<h1 id=\"爬虫如何分页\"><a href=\"#爬虫如何分页\" class=\"headerlink\" title=\"爬虫如何分页\"></a>爬虫如何分页</h1><p>一般来说爬虫分页有2种实现方式：①找到网址分页所须参数，通过发起网络请求对应的页数。②模拟人类对浏览器下滑、点击等操作实现分页。</p>\n<p>对于简书官网，我最先使用了第一种方法，每次请求携带page和seen_snote_ids参数，但是仍然返回数据有问题。可能服务器还对其他首部信息做了校验。</p>\n<p>看下请求信息：</p>\n<pre><code> [truncated]GET /?seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_snote_ids%5B%5D=15290950&amp;seen_snote_\nHost: www.jianshu.com\\r\\n\nConnection: keep-alive\\r\\n\nAccept: text/html, */*; q=0.01\\r\\n\nX-CSRF-Token: jrzSqMWq+Gqjm66lMiTJQQYSKEZKUYAYV9oOPghKMdJiJs9Oij1Q/bhsdugAnKKEjhsAokQqiog7MnW9ojznxQ==\\r\\n\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\\r\\n\nX-Requested-With: XMLHttpRequest\\r\\n\nX-INFINITESCROLL: true\\r\\n\nReferer: http://www.jianshu.com/\\r\\n\nAccept-Encoding: gzip, deflate\\r\\n\nAccept-Language: zh-CN,zh;q=0.8,en;q=0.6\\r\\n\n [truncated]Cookie: signin_redirect=http%3A%2F%2Fwww.jianshu.com%2F; _ga=GA1.2.508983344.1500518688; _gid=GA1.2.101137453.1501499488; _gat=1; _session_id=NjJQQWdSSEl2cWdtSEc0bmRTQnZXQTVQenNDbTV1V0Z5M2N5OGpxbnhyell5Tnl5UHp6UHZJSncvVzNSeGlEU\nIf-None-Match: W/&quot;09cd78bd0d8a197d769d2c5b6b1e84e9&quot;\\r\\n\n\\r\\n\n[Full request URI [truncated]: http://www.jianshu.com/?seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_]\n[HTTP request 1/2]\n[Next request in frame: 28]\n</code></pre><p>由于请求信息太多，分析起来比较困难，所以决定采用方法②模拟行为。</p>\n<p>要模拟人类下滑、点击浏览器行为需要使用自动化测试库<strong>selenium</strong>。</p>\n<h1 id=\"Selenium使用\"><a href=\"#Selenium使用\" class=\"headerlink\" title=\"Selenium使用\"></a>Selenium使用</h1><p>继续上篇文章的创建的项目，创建JSSpider.py文件</p>\n<p>该文件中测试selenium库</p>\n<p>我这里使用Chrome浏览器，需要安装ChromeDriver，具体方法见：<a href=\"http://www.jensondev.me/2017/08/02/Selenium-ChromeDriver%E5%AE%89%E8%A3%85/\" target=\"_blank\" rel=\"external\">Selenium ChromeDriver安装</a>。</p>\n<p>用selenium实现分页，可以分为三步：</p>\n<p>①导入所需类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.remote.webelement <span class=\"keyword\">import</span> WebElement</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.wait <span class=\"keyword\">import</span> WebDriverWait <span class=\"keyword\">as</span> wait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div></pre></td></tr></table></figure>\n<p>②实现窗口下滑：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">browser = webdriver.Chrome(executable_path=<span class=\"string\">\"/Users/jenson/Downloads/chromedriver\"</span>)</div><div class=\"line\">browser.get(<span class=\"string\">\"http://www.jianshu.com\"</span>)</div><div class=\"line\">browser.maximize_window()</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\"><span class=\"comment\"># 前三页都已经出来了</span></div></pre></td></tr></table></figure>\n<p>通过两次调用<code>browser.execute_script</code>，导致窗口两次自动下滑，会自动请求服务器。</p>\n<p>③等待阅读更多按钮显示后模拟点击：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    loadMoreEle = wait(browser, <span class=\"number\">10</span>).until(</div><div class=\"line\">        EC.presence_of_element_located((By.CLASS_NAME, <span class=\"string\">\"load-more\"</span>))</div><div class=\"line\">    )</div><div class=\"line\"><span class=\"keyword\">except</span> RuntimeError <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div><div class=\"line\"><span class=\"comment\"># loadMoreEle = browser.find_element_by_class_name(\"load-more\")</span></div><div class=\"line\"><span class=\"keyword\">assert</span> isinstance(loadMoreEle, WebElement)</div><div class=\"line\"><span class=\"comment\"># time.sleep(5)</span></div><div class=\"line\">is_displayed = loadMoreEle.is_displayed()</div><div class=\"line\">print(is_displayed)</div><div class=\"line\">time.sleep(<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> is_displayed:</div><div class=\"line\">    loadMoreEle.click()</div></pre></td></tr></table></figure>\n<p>插播一条消息：如果selenium启动Chrome浏览器，会有这样一条提示信息：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/selenium%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA.png\" alt=\"selenium控制浏览器提示\"></p>\n<p>如果上面都已经实现且执行成功，那么可以开始把两个部分代码进行合并了。</p>\n<h1 id=\"实现分页\"><a href=\"#实现分页\" class=\"headerlink\" title=\"实现分页\"></a>实现分页</h1><p>这里的实现分页只要把上一篇的代码和本节代码合并，基本就可以完成简书首页文章的抓取，下面看下具体实现：</p>\n<h2 id=\"首先实现下滑分页爬取部分\"><a href=\"#首先实现下滑分页爬取部分\" class=\"headerlink\" title=\"首先实现下滑分页爬取部分\"></a>首先实现下滑分页爬取部分</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.remote.webelement <span class=\"keyword\">import</span> WebElement</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.wait <span class=\"keyword\">import</span> WebDriverWait <span class=\"keyword\">as</span> wait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div><div class=\"line\"><span class=\"keyword\">import</span> main.JS <span class=\"keyword\">as</span> JS</div><div class=\"line\"></div><div class=\"line\">url_str = <span class=\"string\">\"http://www.jianshu.com\"</span></div><div class=\"line\">browser = webdriver.Chrome(executable_path=<span class=\"string\">\"/Users/jenson/Downloads/chromedriver\"</span>)</div><div class=\"line\">browser.get(url_str)</div><div class=\"line\">browser.maximize_window()</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\"><span class=\"comment\"># 前三页都已经出来了,</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取前三页内容</span></div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">list = JS.getArticles(browser, <span class=\"keyword\">False</span>)</div><div class=\"line\">JS.saveCSV(list, <span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>上一篇中写的<code>getArticles</code>方法添加了2个参数，<strong>browser</strong>和<strong>isClick</strong>，去掉了<strong>url</strong>参数。因为内容都已经在<strong>browser</strong>这个selenium启动的浏览器中了，所以不需要在使用<strong>urllib</strong>进行网络请求，也不再使用<strong>bs4</strong>来进行DOM解析，一切都交由<strong>browser</strong>完成。<strong>isClick</strong>为TRUE表示点击翻页，否则表示滑动翻页。</p>\n<p>看下目前<code>getArticles</code>的实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getArticles</span><span class=\"params\">(browser, isClick=False)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    根据url获取当前页面文章列表</div><div class=\"line\">    :param url:</div><div class=\"line\">    :param isClick:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\"></div><div class=\"line\">    article_list = []</div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(browser, webdriver.Chrome)</div><div class=\"line\">    ulEle = browser.find_element_by_class_name(<span class=\"string\">\"note-list\"</span>)</div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(ulEle, WebElement)</div><div class=\"line\">    eles = ulEle.find_elements_by_xpath(<span class=\"string\">\"//li[@id]\"</span>)</div><div class=\"line\">    print(len(eles))</div><div class=\"line\">    <span class=\"keyword\">if</span> isClick:</div><div class=\"line\">        <span class=\"keyword\">return</span> iteratorEle(eles, article_list, len(eles) - <span class=\"number\">20</span>, len(eles))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> iteratorEle(eles, article_list, <span class=\"number\">0</span>, len(eles))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">iteratorEle</span><span class=\"params\">(eles, article_list, start, end)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    :param eles:</div><div class=\"line\">    :param article_list:</div><div class=\"line\">    :param start:</div><div class=\"line\">    :param end:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> range(start, end):</div><div class=\"line\">        item = eles[index]</div><div class=\"line\">        <span class=\"keyword\">assert</span> isinstance(item, WebElement)</div><div class=\"line\">        article = Article()</div><div class=\"line\">        article.author = item.find_element_by_class_name(<span class=\"string\">\"blue-link\"</span>).text</div><div class=\"line\">        titleEle = item.find_element_by_class_name(<span class=\"string\">\"title\"</span>)</div><div class=\"line\">        <span class=\"keyword\">assert</span> isinstance(titleEle, WebElement)</div><div class=\"line\">        article.title = titleEle.text</div><div class=\"line\">        article.url = titleEle.get_attribute(<span class=\"string\">\"href\"</span>)</div><div class=\"line\">        article_list.append(article)</div><div class=\"line\">    <span class=\"keyword\">return</span> article_list</div></pre></td></tr></table></figure>\n<p>另外保存csv文件的方法<code>saveCSV</code>也有改动，添加了一个<strong>setTag</strong>参数。为True表示设置首行的标记。方法实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">saveCSV</span><span class=\"params\">(articles, setTag=False)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    保存到csv文件</div><div class=\"line\">    :param articles:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    csvFile = open(<span class=\"string\">\"/Users/jenson/Downloads/js.csv\"</span>, <span class=\"string\">'a'</span>)</div><div class=\"line\">    csv_writer = csv.writer(csvFile)</div><div class=\"line\">    <span class=\"comment\"># print(type(csv_writer))</span></div><div class=\"line\">    <span class=\"comment\"># assert isinstance(csv_writer, csv.DictWriter)</span></div><div class=\"line\">    <span class=\"keyword\">if</span> setTag:</div><div class=\"line\">        csv_writer.writerow([<span class=\"string\">\"作者\"</span>, <span class=\"string\">\"标题\"</span>, <span class=\"string\">\"链接\"</span>])</div><div class=\"line\">    <span class=\"keyword\">for</span> article <span class=\"keyword\">in</span> articles:</div><div class=\"line\">        csv_writer.writerow(</div><div class=\"line\">            [article.author, article.title, article.url])</div></pre></td></tr></table></figure>\n<h2 id=\"其次实现点击分页爬取部分\"><a href=\"#其次实现点击分页爬取部分\" class=\"headerlink\" title=\"其次实现点击分页爬取部分\"></a>其次实现点击分页爬取部分</h2><p>模拟点击翻页中使用while循环检测<strong>阅读更多</strong>按钮是否可见，如果可见则每次模拟点击实现翻页，代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 模拟点击翻页</span></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    loadMoreEle = wait(browser, <span class=\"number\">10</span>).until(</div><div class=\"line\">        EC.presence_of_element_located((By.CLASS_NAME, <span class=\"string\">\"load-more\"</span>))</div><div class=\"line\">    )</div><div class=\"line\"><span class=\"keyword\">except</span> RuntimeError <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div><div class=\"line\"><span class=\"comment\"># loadMoreEle = browser.find_element_by_class_name(\"load-more\")</span></div><div class=\"line\"><span class=\"keyword\">assert</span> isinstance(loadMoreEle, WebElement)</div><div class=\"line\"><span class=\"comment\"># time.sleep(5)</span></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    <span class=\"keyword\">while</span> loadMoreEle.is_displayed():</div><div class=\"line\">        loadMoreEle.click()</div><div class=\"line\">        time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">        list = JS.getArticles(browser, <span class=\"keyword\">True</span>)</div><div class=\"line\">        JS.saveCSV(list)</div><div class=\"line\"><span class=\"keyword\">except</span> RuntimeError <span class=\"keyword\">as</span> err:</div><div class=\"line\">    print(err)</div></pre></td></tr></table></figure>\n<p>经过以上步骤，翻页爬取简书首页文章就已经完成了，最终爬取结果如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%9C%AB%E5%B0%BE%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9D%9F.png\" alt=\"简书首页文章爬取到末尾\"></p>\n<p>可以看到文章末尾已经没有了<strong>阅读更多</strong>字样，说明已经翻到底儿了。而CSV文件中内容最后一条也刚好符合简书网站最后一条。可见抓取成功。</p>\n<blockquote>\n<p>注意：一旦使用了selenium，后面的DOM解析都要使用对应的浏览器Driver进行解析，如果还是使用bs4是获取不到新内容的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在 <a href=\"http://www.jensondev.me/2017/08/02/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%96%87%E7%AB%A0-%E4%B8%80/\">Python爬虫爬取简书首页文章(一)</a> 中已经完成了一个mini爬虫，完成了基本的爬取和存储工作。</p>\n<p>但是还有很多问题需要亟需解决，譬如分页抓取就是本章要解决的。</p>\n<p>要实现分页爬取，首先要知道网站如何分页的</p>\n<h1 id=\"网站如何分页\"><a href=\"#网站如何分页\" class=\"headerlink\" title=\"网站如何分页\"></a>网站如何分页</h1><p>这里以简书为例，要想知道简书首页文章如何实现分页，首先打开官网和抓包工具进行监听。</p>\n<p>这里的抓包工具我使用的时<strong>Wireshark</strong>。刚开始时数据流是空的：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%A9%BAWireshark.png\" alt=\"空\"></p>\n<p>现在开始滑动简书官网，直到页面底部出现<strong>阅读更多</strong>按钮，这滑动期间竟然也发生了两次网络请求：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%BB%91%E5%8A%A8%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82.png\" alt=\"滑动期间的两次请求\"></p>\n<p>GET请求的url是这样子的：</p>\n<p>/?seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_snote_ids%5B%5D=15290950&amp;seen_snote_ids%5B%5D=15301177&amp;seen_snote_ids%5B%5D=15275389&amp;seen_snote_ids%5B%5D=15266115&amp;seen_snote_ids%5B%5D=15293985&amp;seen_snote_ids%5B%5D=15289824&amp;seen_snote_ids%5B%5D=15276555&amp;seen_snote_ids%5B%5D=15269012&amp;seen_snote_ids%5B%5D=15268330&amp;seen_snote_ids%5B%5D=15285079&amp;seen_snote_ids%5B%5D=15292494&amp;seen_snote_ids%5B%5D=15284369&amp;seen_snote_ids%5B%5D=15299782&amp;seen_snote_ids%5B%5D=15011765&amp;seen_snote_ids%5B%5D=15304980&amp;seen_snote_ids%5B%5D=15287206&amp;seen_snote_ids%5B%5D=15273113&amp;seen_snote_ids%5B%5D=15268608&amp;seen_snote_ids%5B%5D=15220769&amp;seen_snote_ids%5B%5D=15152802&amp;seen_snote_ids%5B%5D=15280804&amp;seen_snote_ids%5B%5D=15229091&amp;seen_snote_ids%5B%5D=15288809&amp;seen_snote_ids%5B%5D=15267285&amp;seen_snote_ids%5B%5D=14630860&amp;seen_snote_ids%5B%5D=15290958&amp;seen_snote_ids%5B%5D=15262258&amp;seen_snote_ids%5B%5D=15299674&amp;seen_snote_ids%5B%5D=15294416&amp;seen_snote_ids%5B%5D=15262595&amp;seen_snote_ids%5B%5D=15271868&amp;seen_snote_ids%5B%5D=15184645&amp;seen_snote_ids%5B%5D=14818734&amp;seen_snote_ids%5B%5D=15254172&amp;page=3</p>\n<p>当我点击<strong>阅读更多</strong>时候的请求url是这样子的：</p>\n<p>/?page=4&amp;seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_snote_ids%5B%5D=15290950&amp;seen_snote_ids%5B%5D=15301177&amp;seen_snote_ids%5B%5D=15275389&amp;seen_snote_ids%5B%5D=15266115&amp;seen_snote_ids%5B%5D=15293985&amp;seen_snote_ids%5B%5D=15289824&amp;seen_snote_ids%5B%5D=15276555&amp;seen_snote_ids%5B%5D=15269012&amp;seen_snote_ids%5B%5D=15268330&amp;seen_snote_ids%5B%5D=15285079&amp;seen_snote_ids%5B%5D=15292494&amp;seen_snote_ids%5B%5D=15284369&amp;seen_snote_ids%5B%5D=15299782&amp;seen_snote_ids%5B%5D=15011765&amp;seen_snote_ids%5B%5D=15304980&amp;seen_snote_ids%5B%5D=15287206&amp;seen_snote_ids%5B%5D=15273113&amp;seen_snote_ids%5B%5D=15268608&amp;seen_snote_ids%5B%5D=15220769&amp;seen_snote_ids%5B%5D=15152802&amp;seen_snote_ids%5B%5D=15280804&amp;seen_snote_ids%5B%5D=15229091&amp;seen_snote_ids%5B%5D=15288809&amp;seen_snote_ids%5B%5D=15267285&amp;seen_snote_ids%5B%5D=14630860&amp;seen_snote_ids%5B%5D=15290958&amp;seen_snote_ids%5B%5D=15262258&amp;seen_snote_ids%5B%5D=15299674&amp;seen_snote_ids%5B%5D=15294416&amp;seen_snote_ids%5B%5D=15262595&amp;seen_snote_ids%5B%5D=15271868&amp;seen_snote_ids%5B%5D=15184645&amp;seen_snote_ids%5B%5D=14818734&amp;seen_snote_ids%5B%5D=15254172&amp;seen_snote_ids%5B%5D=15272682&amp;seen_snote_ids%5B%5D=15302506&amp;seen_snote_ids%5B%5D=15238434&amp;seen_snote_ids%5B%5D=15302851&amp;seen_snote_ids%5B%5D=15256354&amp;seen_snote_ids%5B%5D=15297896&amp;seen_snote_ids%5B%5D=15246028&amp;seen_snote_ids%5B%5D=15292615&amp;seen_snote_ids%5B%5D=15215522&amp;seen_snote_ids%5B%5D=15295152&amp;seen_snote_ids%5B%5D=15246711&amp;seen_snote_ids%5B%5D=15276820&amp;seen_snote_ids%5B%5D=15274436&amp;seen_snote_ids%5B%5D=15300621&amp;seen_snote_ids%5B%5D=15296525&amp;seen_snote_ids%5B%5D=15297151&amp;seen_snote_ids%5B%5D=15298014&amp;seen_snote_ids%5B%5D=11621895&amp;seen_snote_ids%5B%5D=15268868&amp;seen_snote_ids%5B%5D=15280076</p>\n<p>通过这两个url可以看到每次都携带一个page参数，应该是表示请求页数了，</p>\n<p>所以可以知道目前简书的分页是这样的：第一次打开时加载几条，在下滑过程中会产生两次请求，分别是page=2和page=3，然后再次滑动到底部时出现<strong>阅读更多</strong>按钮，后面的分页靠按钮点击实现。</p>\n<p>综合来讲，简书的分页是下滑和点击共同实现的。</p>\n<p>分析完了简书如何分页，下面分析爬虫如何分页抓取数据。</p>\n<h1 id=\"爬虫如何分页\"><a href=\"#爬虫如何分页\" class=\"headerlink\" title=\"爬虫如何分页\"></a>爬虫如何分页</h1><p>一般来说爬虫分页有2种实现方式：①找到网址分页所须参数，通过发起网络请求对应的页数。②模拟人类对浏览器下滑、点击等操作实现分页。</p>\n<p>对于简书官网，我最先使用了第一种方法，每次请求携带page和seen_snote_ids参数，但是仍然返回数据有问题。可能服务器还对其他首部信息做了校验。</p>\n<p>看下请求信息：</p>\n<pre><code> [truncated]GET /?seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_snote_ids%5B%5D=15290950&amp;seen_snote_\nHost: www.jianshu.com\\r\\n\nConnection: keep-alive\\r\\n\nAccept: text/html, */*; q=0.01\\r\\n\nX-CSRF-Token: jrzSqMWq+Gqjm66lMiTJQQYSKEZKUYAYV9oOPghKMdJiJs9Oij1Q/bhsdugAnKKEjhsAokQqiog7MnW9ojznxQ==\\r\\n\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\\r\\n\nX-Requested-With: XMLHttpRequest\\r\\n\nX-INFINITESCROLL: true\\r\\n\nReferer: http://www.jianshu.com/\\r\\n\nAccept-Encoding: gzip, deflate\\r\\n\nAccept-Language: zh-CN,zh;q=0.8,en;q=0.6\\r\\n\n [truncated]Cookie: signin_redirect=http%3A%2F%2Fwww.jianshu.com%2F; _ga=GA1.2.508983344.1500518688; _gid=GA1.2.101137453.1501499488; _gat=1; _session_id=NjJQQWdSSEl2cWdtSEc0bmRTQnZXQTVQenNDbTV1V0Z5M2N5OGpxbnhyell5Tnl5UHp6UHZJSncvVzNSeGlEU\nIf-None-Match: W/&quot;09cd78bd0d8a197d769d2c5b6b1e84e9&quot;\\r\\n\n\\r\\n\n[Full request URI [truncated]: http://www.jianshu.com/?seen_snote_ids%5B%5D=15296134&amp;seen_snote_ids%5B%5D=15306523&amp;seen_snote_ids%5B%5D=15298503&amp;seen_snote_ids%5B%5D=15240154&amp;seen_snote_ids%5B%5D=15274107&amp;seen_snote_ids%5B%5D=15256726&amp;seen_]\n[HTTP request 1/2]\n[Next request in frame: 28]\n</code></pre><p>由于请求信息太多，分析起来比较困难，所以决定采用方法②模拟行为。</p>\n<p>要模拟人类下滑、点击浏览器行为需要使用自动化测试库<strong>selenium</strong>。</p>\n<h1 id=\"Selenium使用\"><a href=\"#Selenium使用\" class=\"headerlink\" title=\"Selenium使用\"></a>Selenium使用</h1><p>继续上篇文章的创建的项目，创建JSSpider.py文件</p>\n<p>该文件中测试selenium库</p>\n<p>我这里使用Chrome浏览器，需要安装ChromeDriver，具体方法见：<a href=\"http://www.jensondev.me/2017/08/02/Selenium-ChromeDriver%E5%AE%89%E8%A3%85/\">Selenium ChromeDriver安装</a>。</p>\n<p>用selenium实现分页，可以分为三步：</p>\n<p>①导入所需类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.remote.webelement <span class=\"keyword\">import</span> WebElement</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.wait <span class=\"keyword\">import</span> WebDriverWait <span class=\"keyword\">as</span> wait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div></pre></td></tr></table></figure>\n<p>②实现窗口下滑：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">browser = webdriver.Chrome(executable_path=<span class=\"string\">\"/Users/jenson/Downloads/chromedriver\"</span>)</div><div class=\"line\">browser.get(<span class=\"string\">\"http://www.jianshu.com\"</span>)</div><div class=\"line\">browser.maximize_window()</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\"><span class=\"comment\"># 前三页都已经出来了</span></div></pre></td></tr></table></figure>\n<p>通过两次调用<code>browser.execute_script</code>，导致窗口两次自动下滑，会自动请求服务器。</p>\n<p>③等待阅读更多按钮显示后模拟点击：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    loadMoreEle = wait(browser, <span class=\"number\">10</span>).until(</div><div class=\"line\">        EC.presence_of_element_located((By.CLASS_NAME, <span class=\"string\">\"load-more\"</span>))</div><div class=\"line\">    )</div><div class=\"line\"><span class=\"keyword\">except</span> RuntimeError <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div><div class=\"line\"><span class=\"comment\"># loadMoreEle = browser.find_element_by_class_name(\"load-more\")</span></div><div class=\"line\"><span class=\"keyword\">assert</span> isinstance(loadMoreEle, WebElement)</div><div class=\"line\"><span class=\"comment\"># time.sleep(5)</span></div><div class=\"line\">is_displayed = loadMoreEle.is_displayed()</div><div class=\"line\">print(is_displayed)</div><div class=\"line\">time.sleep(<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> is_displayed:</div><div class=\"line\">    loadMoreEle.click()</div></pre></td></tr></table></figure>\n<p>插播一条消息：如果selenium启动Chrome浏览器，会有这样一条提示信息：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/selenium%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA.png\" alt=\"selenium控制浏览器提示\"></p>\n<p>如果上面都已经实现且执行成功，那么可以开始把两个部分代码进行合并了。</p>\n<h1 id=\"实现分页\"><a href=\"#实现分页\" class=\"headerlink\" title=\"实现分页\"></a>实现分页</h1><p>这里的实现分页只要把上一篇的代码和本节代码合并，基本就可以完成简书首页文章的抓取，下面看下具体实现：</p>\n<h2 id=\"首先实现下滑分页爬取部分\"><a href=\"#首先实现下滑分页爬取部分\" class=\"headerlink\" title=\"首先实现下滑分页爬取部分\"></a>首先实现下滑分页爬取部分</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.remote.webelement <span class=\"keyword\">import</span> WebElement</div><div class=\"line\"><span class=\"keyword\">import</span> time</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support <span class=\"keyword\">import</span> expected_conditions <span class=\"keyword\">as</span> EC</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.support.wait <span class=\"keyword\">import</span> WebDriverWait <span class=\"keyword\">as</span> wait</div><div class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.common.by <span class=\"keyword\">import</span> By</div><div class=\"line\"><span class=\"keyword\">import</span> main.JS <span class=\"keyword\">as</span> JS</div><div class=\"line\"></div><div class=\"line\">url_str = <span class=\"string\">\"http://www.jianshu.com\"</span></div><div class=\"line\">browser = webdriver.Chrome(executable_path=<span class=\"string\">\"/Users/jenson/Downloads/chromedriver\"</span>)</div><div class=\"line\">browser.get(url_str)</div><div class=\"line\">browser.maximize_window()</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">browser.execute_script(<span class=\"string\">\"window.scrollTo(0, document.body.scrollHeight);\"</span>)</div><div class=\"line\"><span class=\"comment\"># 前三页都已经出来了,</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 获取前三页内容</span></div><div class=\"line\">time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">list = JS.getArticles(browser, <span class=\"keyword\">False</span>)</div><div class=\"line\">JS.saveCSV(list, <span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>上一篇中写的<code>getArticles</code>方法添加了2个参数，<strong>browser</strong>和<strong>isClick</strong>，去掉了<strong>url</strong>参数。因为内容都已经在<strong>browser</strong>这个selenium启动的浏览器中了，所以不需要在使用<strong>urllib</strong>进行网络请求，也不再使用<strong>bs4</strong>来进行DOM解析，一切都交由<strong>browser</strong>完成。<strong>isClick</strong>为TRUE表示点击翻页，否则表示滑动翻页。</p>\n<p>看下目前<code>getArticles</code>的实现</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getArticles</span><span class=\"params\">(browser, isClick=False)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    根据url获取当前页面文章列表</div><div class=\"line\">    :param url:</div><div class=\"line\">    :param isClick:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\"></div><div class=\"line\">    article_list = []</div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(browser, webdriver.Chrome)</div><div class=\"line\">    ulEle = browser.find_element_by_class_name(<span class=\"string\">\"note-list\"</span>)</div><div class=\"line\">    <span class=\"keyword\">assert</span> isinstance(ulEle, WebElement)</div><div class=\"line\">    eles = ulEle.find_elements_by_xpath(<span class=\"string\">\"//li[@id]\"</span>)</div><div class=\"line\">    print(len(eles))</div><div class=\"line\">    <span class=\"keyword\">if</span> isClick:</div><div class=\"line\">        <span class=\"keyword\">return</span> iteratorEle(eles, article_list, len(eles) - <span class=\"number\">20</span>, len(eles))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> iteratorEle(eles, article_list, <span class=\"number\">0</span>, len(eles))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">iteratorEle</span><span class=\"params\">(eles, article_list, start, end)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    :param eles:</div><div class=\"line\">    :param article_list:</div><div class=\"line\">    :param start:</div><div class=\"line\">    :param end:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> range(start, end):</div><div class=\"line\">        item = eles[index]</div><div class=\"line\">        <span class=\"keyword\">assert</span> isinstance(item, WebElement)</div><div class=\"line\">        article = Article()</div><div class=\"line\">        article.author = item.find_element_by_class_name(<span class=\"string\">\"blue-link\"</span>).text</div><div class=\"line\">        titleEle = item.find_element_by_class_name(<span class=\"string\">\"title\"</span>)</div><div class=\"line\">        <span class=\"keyword\">assert</span> isinstance(titleEle, WebElement)</div><div class=\"line\">        article.title = titleEle.text</div><div class=\"line\">        article.url = titleEle.get_attribute(<span class=\"string\">\"href\"</span>)</div><div class=\"line\">        article_list.append(article)</div><div class=\"line\">    <span class=\"keyword\">return</span> article_list</div></pre></td></tr></table></figure>\n<p>另外保存csv文件的方法<code>saveCSV</code>也有改动，添加了一个<strong>setTag</strong>参数。为True表示设置首行的标记。方法实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">saveCSV</span><span class=\"params\">(articles, setTag=False)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    保存到csv文件</div><div class=\"line\">    :param articles:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    csvFile = open(<span class=\"string\">\"/Users/jenson/Downloads/js.csv\"</span>, <span class=\"string\">'a'</span>)</div><div class=\"line\">    csv_writer = csv.writer(csvFile)</div><div class=\"line\">    <span class=\"comment\"># print(type(csv_writer))</span></div><div class=\"line\">    <span class=\"comment\"># assert isinstance(csv_writer, csv.DictWriter)</span></div><div class=\"line\">    <span class=\"keyword\">if</span> setTag:</div><div class=\"line\">        csv_writer.writerow([<span class=\"string\">\"作者\"</span>, <span class=\"string\">\"标题\"</span>, <span class=\"string\">\"链接\"</span>])</div><div class=\"line\">    <span class=\"keyword\">for</span> article <span class=\"keyword\">in</span> articles:</div><div class=\"line\">        csv_writer.writerow(</div><div class=\"line\">            [article.author, article.title, article.url])</div></pre></td></tr></table></figure>\n<h2 id=\"其次实现点击分页爬取部分\"><a href=\"#其次实现点击分页爬取部分\" class=\"headerlink\" title=\"其次实现点击分页爬取部分\"></a>其次实现点击分页爬取部分</h2><p>模拟点击翻页中使用while循环检测<strong>阅读更多</strong>按钮是否可见，如果可见则每次模拟点击实现翻页，代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 模拟点击翻页</span></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    loadMoreEle = wait(browser, <span class=\"number\">10</span>).until(</div><div class=\"line\">        EC.presence_of_element_located((By.CLASS_NAME, <span class=\"string\">\"load-more\"</span>))</div><div class=\"line\">    )</div><div class=\"line\"><span class=\"keyword\">except</span> RuntimeError <span class=\"keyword\">as</span> e:</div><div class=\"line\">    print(e)</div><div class=\"line\"><span class=\"comment\"># loadMoreEle = browser.find_element_by_class_name(\"load-more\")</span></div><div class=\"line\"><span class=\"keyword\">assert</span> isinstance(loadMoreEle, WebElement)</div><div class=\"line\"><span class=\"comment\"># time.sleep(5)</span></div><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    <span class=\"keyword\">while</span> loadMoreEle.is_displayed():</div><div class=\"line\">        loadMoreEle.click()</div><div class=\"line\">        time.sleep(<span class=\"number\">3</span>)</div><div class=\"line\">        list = JS.getArticles(browser, <span class=\"keyword\">True</span>)</div><div class=\"line\">        JS.saveCSV(list)</div><div class=\"line\"><span class=\"keyword\">except</span> RuntimeError <span class=\"keyword\">as</span> err:</div><div class=\"line\">    print(err)</div></pre></td></tr></table></figure>\n<p>经过以上步骤，翻页爬取简书首页文章就已经完成了，最终爬取结果如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E7%AE%80%E4%B9%A6%E9%A6%96%E9%A1%B5%E6%9C%AB%E5%B0%BE%E6%96%87%E7%AB%A0%E7%88%AC%E5%8F%96%E7%BB%93%E6%9D%9F.png\" alt=\"简书首页文章爬取到末尾\"></p>\n<p>可以看到文章末尾已经没有了<strong>阅读更多</strong>字样，说明已经翻到底儿了。而CSV文件中内容最后一条也刚好符合简书网站最后一条。可见抓取成功。</p>\n<blockquote>\n<p>注意：一旦使用了selenium，后面的DOM解析都要使用对应的浏览器Driver进行解析，如果还是使用bs4是获取不到新内容的。</p>\n</blockquote>\n"},{"title":"UML--类图详解","date":"2017-04-21T13:22:50.000Z","_content":"类图是面向对象系统建模中很常用也很重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口间关系的一种模型。\n类之间的关系主要有泛化、实现、聚合、组合、依赖、关联6种关系。\n\n# 泛化关系(generalization)\n\numl中的泛化关系也就是继承关系。继承关系的2个类可以使用 is-a来表示。继承关系使用实线空心箭头来表示，箭头从子类指向父类。\n\n![屏幕快照 2017-03-02 下午3.39.00.png](http://upload-images.jianshu.io/upload_images/1796052-be6493449edd5912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nPS：泛化关系中的父类为非抽象类,泛化关系为面向对象中耦合度最大的一种关系\n\n#  实现关系(Realization)\n\n实现关系使用空心三角箭头的虚线表示，箭头从实现类指向接口。\n\n![屏幕快照 2017-03-02 下午3.51.25.png](http://upload-images.jianshu.io/upload_images/1796052-92a163450b82adc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不知道为什么在我的osx版的startuml中实现关系只是一条线，不晓得是不是bug\n\n# 聚合关系(Aggregation)\n\n聚合关系表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,如果没有了整体,局部仍然可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形的实线表示，菱形从局部指向整体。\n\n![屏幕快照 2017-03-02 下午3.56.37.png](http://upload-images.jianshu.io/upload_images/1796052-3018f76e4b869260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 组合关系(Composition)\n\n组合关系表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了。在类图使用实心菱形的实线表示，菱形从局部指向整体。\n\n![屏幕快照 2017-03-02 下午3.59.43.png](http://upload-images.jianshu.io/upload_images/1796052-cf5edcf29e224e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 依赖关系(Dependency)\n\n依赖关系是对象关系最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。\n\n![屏幕快照 2017-03-02 下午4.03.48.png](http://upload-images.jianshu.io/upload_images/1796052-77d40f8a95f1f73d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 关联关系(Association)\n\n关联关系是对象之间一种引用关系，比如吃饭时\b客户与餐具类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。\n\n![屏幕快照 2017-03-02 下午4.43.15.png](http://upload-images.jianshu.io/upload_images/1796052-78619e44991e9581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 聚合和组合如何区别？\n\n直白点的理解就是聚合关系的两个类，局部类的生命周期不受整体类的影响，能够剥离整体单独存在。\n而组合关系的两个类，局部类的生命周期受限于整体类，整体类不存在时，局部类也将消亡。\n举个栗子：\n学生去学校上学被分配到x年级：\n其中学生和学校属于聚合关系，学生可以脱离学校独立存在，县里学校不好可以去市里学校。而学校和班级是组合关系，就是说班级存在的前提是要有个学校。\n\n![屏幕快照 2017-03-02 下午4.31.06.png](http://upload-images.jianshu.io/upload_images/1796052-a3572272c2413345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/UML--类图详解.md","raw":"---\ntitle: UML--类图详解\ndate: 2017-04-21 21:22:50\ntags: 设计模式\ncategories: 设计模式\n---\n类图是面向对象系统建模中很常用也很重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口间关系的一种模型。\n类之间的关系主要有泛化、实现、聚合、组合、依赖、关联6种关系。\n\n# 泛化关系(generalization)\n\numl中的泛化关系也就是继承关系。继承关系的2个类可以使用 is-a来表示。继承关系使用实线空心箭头来表示，箭头从子类指向父类。\n\n![屏幕快照 2017-03-02 下午3.39.00.png](http://upload-images.jianshu.io/upload_images/1796052-be6493449edd5912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nPS：泛化关系中的父类为非抽象类,泛化关系为面向对象中耦合度最大的一种关系\n\n#  实现关系(Realization)\n\n实现关系使用空心三角箭头的虚线表示，箭头从实现类指向接口。\n\n![屏幕快照 2017-03-02 下午3.51.25.png](http://upload-images.jianshu.io/upload_images/1796052-92a163450b82adc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不知道为什么在我的osx版的startuml中实现关系只是一条线，不晓得是不是bug\n\n# 聚合关系(Aggregation)\n\n聚合关系表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,如果没有了整体,局部仍然可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形的实线表示，菱形从局部指向整体。\n\n![屏幕快照 2017-03-02 下午3.56.37.png](http://upload-images.jianshu.io/upload_images/1796052-3018f76e4b869260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 组合关系(Composition)\n\n组合关系表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了。在类图使用实心菱形的实线表示，菱形从局部指向整体。\n\n![屏幕快照 2017-03-02 下午3.59.43.png](http://upload-images.jianshu.io/upload_images/1796052-cf5edcf29e224e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 依赖关系(Dependency)\n\n依赖关系是对象关系最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。\n\n![屏幕快照 2017-03-02 下午4.03.48.png](http://upload-images.jianshu.io/upload_images/1796052-77d40f8a95f1f73d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 关联关系(Association)\n\n关联关系是对象之间一种引用关系，比如吃饭时\b客户与餐具类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。\n\n![屏幕快照 2017-03-02 下午4.43.15.png](http://upload-images.jianshu.io/upload_images/1796052-78619e44991e9581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 聚合和组合如何区别？\n\n直白点的理解就是聚合关系的两个类，局部类的生命周期不受整体类的影响，能够剥离整体单独存在。\n而组合关系的两个类，局部类的生命周期受限于整体类，整体类不存在时，局部类也将消亡。\n举个栗子：\n学生去学校上学被分配到x年级：\n其中学生和学校属于聚合关系，学生可以脱离学校独立存在，县里学校不好可以去市里学校。而学校和班级是组合关系，就是说班级存在的前提是要有个学校。\n\n![屏幕快照 2017-03-02 下午4.31.06.png](http://upload-images.jianshu.io/upload_images/1796052-a3572272c2413345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"UML--类图详解","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjfa003xwh9cplnpr6s2","content":"<p>类图是面向对象系统建模中很常用也很重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口间关系的一种模型。<br>类之间的关系主要有泛化、实现、聚合、组合、依赖、关联6种关系。</p>\n<h1 id=\"泛化关系-generalization\"><a href=\"#泛化关系-generalization\" class=\"headerlink\" title=\"泛化关系(generalization)\"></a>泛化关系(generalization)</h1><p>uml中的泛化关系也就是继承关系。继承关系的2个类可以使用 is-a来表示。继承关系使用实线空心箭头来表示，箭头从子类指向父类。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-be6493449edd5912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.39.00.png\"></p>\n<p>PS：泛化关系中的父类为非抽象类,泛化关系为面向对象中耦合度最大的一种关系</p>\n<h1 id=\"实现关系-Realization\"><a href=\"#实现关系-Realization\" class=\"headerlink\" title=\"实现关系(Realization)\"></a>实现关系(Realization)</h1><p>实现关系使用空心三角箭头的虚线表示，箭头从实现类指向接口。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-92a163450b82adc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.51.25.png\"></p>\n<p>不知道为什么在我的osx版的startuml中实现关系只是一条线，不晓得是不是bug</p>\n<h1 id=\"聚合关系-Aggregation\"><a href=\"#聚合关系-Aggregation\" class=\"headerlink\" title=\"聚合关系(Aggregation)\"></a>聚合关系(Aggregation)</h1><p>聚合关系表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,如果没有了整体,局部仍然可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形的实线表示，菱形从局部指向整体。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-3018f76e4b869260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.56.37.png\"></p>\n<h1 id=\"组合关系-Composition\"><a href=\"#组合关系-Composition\" class=\"headerlink\" title=\"组合关系(Composition)\"></a>组合关系(Composition)</h1><p>组合关系表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了。在类图使用实心菱形的实线表示，菱形从局部指向整体。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-cf5edcf29e224e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.59.43.png\"></p>\n<h1 id=\"依赖关系-Dependency\"><a href=\"#依赖关系-Dependency\" class=\"headerlink\" title=\"依赖关系(Dependency)\"></a>依赖关系(Dependency)</h1><p>依赖关系是对象关系最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-77d40f8a95f1f73d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午4.03.48.png\"></p>\n<h1 id=\"关联关系-Association\"><a href=\"#关联关系-Association\" class=\"headerlink\" title=\"关联关系(Association)\"></a>关联关系(Association)</h1><p>关联关系是对象之间一种引用关系，比如吃饭时\b客户与餐具类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-78619e44991e9581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午4.43.15.png\"></p>\n<h1 id=\"聚合和组合如何区别？\"><a href=\"#聚合和组合如何区别？\" class=\"headerlink\" title=\"聚合和组合如何区别？\"></a>聚合和组合如何区别？</h1><p>直白点的理解就是聚合关系的两个类，局部类的生命周期不受整体类的影响，能够剥离整体单独存在。<br>而组合关系的两个类，局部类的生命周期受限于整体类，整体类不存在时，局部类也将消亡。<br>举个栗子：<br>学生去学校上学被分配到x年级：<br>其中学生和学校属于聚合关系，学生可以脱离学校独立存在，县里学校不好可以去市里学校。而学校和班级是组合关系，就是说班级存在的前提是要有个学校。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a3572272c2413345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午4.31.06.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>类图是面向对象系统建模中很常用也很重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口间关系的一种模型。<br>类之间的关系主要有泛化、实现、聚合、组合、依赖、关联6种关系。</p>\n<h1 id=\"泛化关系-generalization\"><a href=\"#泛化关系-generalization\" class=\"headerlink\" title=\"泛化关系(generalization)\"></a>泛化关系(generalization)</h1><p>uml中的泛化关系也就是继承关系。继承关系的2个类可以使用 is-a来表示。继承关系使用实线空心箭头来表示，箭头从子类指向父类。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-be6493449edd5912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.39.00.png\"></p>\n<p>PS：泛化关系中的父类为非抽象类,泛化关系为面向对象中耦合度最大的一种关系</p>\n<h1 id=\"实现关系-Realization\"><a href=\"#实现关系-Realization\" class=\"headerlink\" title=\"实现关系(Realization)\"></a>实现关系(Realization)</h1><p>实现关系使用空心三角箭头的虚线表示，箭头从实现类指向接口。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-92a163450b82adc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.51.25.png\"></p>\n<p>不知道为什么在我的osx版的startuml中实现关系只是一条线，不晓得是不是bug</p>\n<h1 id=\"聚合关系-Aggregation\"><a href=\"#聚合关系-Aggregation\" class=\"headerlink\" title=\"聚合关系(Aggregation)\"></a>聚合关系(Aggregation)</h1><p>聚合关系表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,如果没有了整体,局部仍然可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形的实线表示，菱形从局部指向整体。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-3018f76e4b869260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.56.37.png\"></p>\n<h1 id=\"组合关系-Composition\"><a href=\"#组合关系-Composition\" class=\"headerlink\" title=\"组合关系(Composition)\"></a>组合关系(Composition)</h1><p>组合关系表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了。在类图使用实心菱形的实线表示，菱形从局部指向整体。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-cf5edcf29e224e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午3.59.43.png\"></p>\n<h1 id=\"依赖关系-Dependency\"><a href=\"#依赖关系-Dependency\" class=\"headerlink\" title=\"依赖关系(Dependency)\"></a>依赖关系(Dependency)</h1><p>依赖关系是对象关系最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-77d40f8a95f1f73d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午4.03.48.png\"></p>\n<h1 id=\"关联关系-Association\"><a href=\"#关联关系-Association\" class=\"headerlink\" title=\"关联关系(Association)\"></a>关联关系(Association)</h1><p>关联关系是对象之间一种引用关系，比如吃饭时\b客户与餐具类之间的关系。这种关系通常使用类的属性表达。关联又分为一般关联、聚合关联与组合关联。在类图使用带箭头的实线表示，箭头从使用类指向被关联的类。可以是单向和双向。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-78619e44991e9581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午4.43.15.png\"></p>\n<h1 id=\"聚合和组合如何区别？\"><a href=\"#聚合和组合如何区别？\" class=\"headerlink\" title=\"聚合和组合如何区别？\"></a>聚合和组合如何区别？</h1><p>直白点的理解就是聚合关系的两个类，局部类的生命周期不受整体类的影响，能够剥离整体单独存在。<br>而组合关系的两个类，局部类的生命周期受限于整体类，整体类不存在时，局部类也将消亡。<br>举个栗子：<br>学生去学校上学被分配到x年级：<br>其中学生和学校属于聚合关系，学生可以脱离学校独立存在，县里学校不好可以去市里学校。而学校和班级是组合关系，就是说班级存在的前提是要有个学校。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a3572272c2413345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-02 下午4.31.06.png\"></p>\n"},{"title":"Selenium ChromeDriver安装","date":"2017-08-01T18:57:02.000Z","_content":"\n# 前言\n\nSelenium默认自带了Firefox的驱动，所以如果要使用该框架，要么自己安装Chrome或IE驱动，要么安装FireFox浏览器。\n\n因为我习惯使用Chrome，所以要手动安装驱动。\n\n# 驱动下载\n\n[ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/home)下载地址：https://chromedriver.storage.googleapis.com/index.html?path=2.31/\n\n# 使用\n\nmac端下载完成解压后可直接使用，不过要在代码中声明解压后的文件路径，如：\n\n```python\nbrowser = webdriver.Chrome(executable_path=\"/Users/jenson/Downloads/chromedriver\")\nbrowser.get(\"http://www.jianshu.com\")    \n```\n\n\n\n\n\n\n\n\n\n#  ","source":"_posts/Selenium-ChromeDriver安装.md","raw":"---\ntitle: Selenium ChromeDriver安装\ndate: 2017-08-02 02:57:02\ntags: [Python, 自动化]\ncategories: [Python, 自动化]\n---\n\n# 前言\n\nSelenium默认自带了Firefox的驱动，所以如果要使用该框架，要么自己安装Chrome或IE驱动，要么安装FireFox浏览器。\n\n因为我习惯使用Chrome，所以要手动安装驱动。\n\n# 驱动下载\n\n[ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/home)下载地址：https://chromedriver.storage.googleapis.com/index.html?path=2.31/\n\n# 使用\n\nmac端下载完成解压后可直接使用，不过要在代码中声明解压后的文件路径，如：\n\n```python\nbrowser = webdriver.Chrome(executable_path=\"/Users/jenson/Downloads/chromedriver\")\nbrowser.get(\"http://www.jianshu.com\")    \n```\n\n\n\n\n\n\n\n\n\n#  ","slug":"Selenium-ChromeDriver安装","published":1,"updated":"2017-08-01T19:03:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjfe0041wh9cmg7pteb9","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Selenium默认自带了Firefox的驱动，所以如果要使用该框架，要么自己安装Chrome或IE驱动，要么安装FireFox浏览器。</p>\n<p>因为我习惯使用Chrome，所以要手动安装驱动。</p>\n<h1 id=\"驱动下载\"><a href=\"#驱动下载\" class=\"headerlink\" title=\"驱动下载\"></a>驱动下载</h1><p><a href=\"https://sites.google.com/a/chromium.org/chromedriver/home\" target=\"_blank\" rel=\"external\">ChromeDriver</a>下载地址：<a href=\"https://chromedriver.storage.googleapis.com/index.html?path=2.31/\" target=\"_blank\" rel=\"external\">https://chromedriver.storage.googleapis.com/index.html?path=2.31/</a></p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>mac端下载完成解压后可直接使用，不过要在代码中声明解压后的文件路径，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">browser = webdriver.Chrome(executable_path=<span class=\"string\">\"/Users/jenson/Downloads/chromedriver\"</span>)</div><div class=\"line\">browser.get(<span class=\"string\">\"http://www.jianshu.com\"</span>)</div></pre></td></tr></table></figure>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Selenium默认自带了Firefox的驱动，所以如果要使用该框架，要么自己安装Chrome或IE驱动，要么安装FireFox浏览器。</p>\n<p>因为我习惯使用Chrome，所以要手动安装驱动。</p>\n<h1 id=\"驱动下载\"><a href=\"#驱动下载\" class=\"headerlink\" title=\"驱动下载\"></a>驱动下载</h1><p><a href=\"https://sites.google.com/a/chromium.org/chromedriver/home\">ChromeDriver</a>下载地址：<a href=\"https://chromedriver.storage.googleapis.com/index.html?path=2.31/\">https://chromedriver.storage.googleapis.com/index.html?path=2.31/</a></p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>mac端下载完成解压后可直接使用，不过要在代码中声明解压后的文件路径，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">browser = webdriver.Chrome(executable_path=<span class=\"string\">\"/Users/jenson/Downloads/chromedriver\"</span>)</div><div class=\"line\">browser.get(<span class=\"string\">\"http://www.jianshu.com\"</span>)</div></pre></td></tr></table></figure>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h1>"},{"title":"WireShark the capture session could not be initiated (you don't have permission to capture on that device)异常","date":"2017-08-03T11:07:11.000Z","_content":"\n# 前言\n\n异常信息如下：**the capture session could not be initiated (you don't have permission to capture on that device)**\n\n在WireShark启动后，选择网卡设备时，出现这个异常。\n\n\n\n# 解决\n\n由于是Mac系统，所以直接终端窗口命令行解决：\n\n**sudo chmod 777 /dev/bpf***。\n\n","source":"_posts/WireShark-the-capture-session-could-not-be-initiated-you-don-t-have-permission-to-capture-on-that-device-异常.md","raw":"---\ntitle: >-\n  WireShark the capture session could not be initiated (you don't have\n  permission to capture on that device)异常\ndate: 2017-08-03 19:07:11\ntags: [WireShakr, 网络]\ncategories: [WireShakr, 网络]\n---\n\n# 前言\n\n异常信息如下：**the capture session could not be initiated (you don't have permission to capture on that device)**\n\n在WireShark启动后，选择网卡设备时，出现这个异常。\n\n\n\n# 解决\n\n由于是Mac系统，所以直接终端窗口命令行解决：\n\n**sudo chmod 777 /dev/bpf***。\n\n","slug":"WireShark-the-capture-session-could-not-be-initiated-you-don-t-have-permission-to-capture-on-that-device-异常","published":1,"updated":"2017-08-03T11:10:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjfi0044wh9ck0hug71w","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>异常信息如下：<strong>the capture session could not be initiated (you don’t have permission to capture on that device)</strong></p>\n<p>在WireShark启动后，选择网卡设备时，出现这个异常。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>由于是Mac系统，所以直接终端窗口命令行解决：</p>\n<p><strong>sudo chmod 777 /dev/bpf*</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>异常信息如下：<strong>the capture session could not be initiated (you don’t have permission to capture on that device)</strong></p>\n<p>在WireShark启动后，选择网卡设备时，出现这个异常。</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>由于是Mac系统，所以直接终端窗口命令行解决：</p>\n<p><strong>sudo chmod 777 /dev/bpf*</strong>。</p>\n"},{"title":"WordCloud不显示中文只显示方框问题","date":"2017-07-29T10:59:36.000Z","_content":"\n# 前言\n\n在用词云展示时，发现其他能正常运行，但是启动后的图像中都是方框，后来查找到原因是因为词云默认只支持英文。\n\n如果要支持中文需要自己设置支持中文的字体\n\n# 解决方案\n\n```python\nmy_wordcloud = WordCloud(font_path='/Library/Fonts/Songti.ttc').generate(wl_space_split)\n\n```\n\n手动设置宋体字体，最终就能正常显示了","source":"_posts/WordCloud不显示中文只显示方框问题.md","raw":"---\ntitle: WordCloud不显示中文只显示方框问题\ndate: 2017-07-29 18:59:36\ntags: [Python, WordCloud]\ncategories: [Python, WordCloud]\n---\n\n# 前言\n\n在用词云展示时，发现其他能正常运行，但是启动后的图像中都是方框，后来查找到原因是因为词云默认只支持英文。\n\n如果要支持中文需要自己设置支持中文的字体\n\n# 解决方案\n\n```python\nmy_wordcloud = WordCloud(font_path='/Library/Fonts/Songti.ttc').generate(wl_space_split)\n\n```\n\n手动设置宋体字体，最终就能正常显示了","slug":"WordCloud不显示中文只显示方框问题","published":1,"updated":"2017-08-02T11:06:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjfl0049wh9ctq6xj5qe","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在用词云展示时，发现其他能正常运行，但是启动后的图像中都是方框，后来查找到原因是因为词云默认只支持英文。</p>\n<p>如果要支持中文需要自己设置支持中文的字体</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">my_wordcloud = WordCloud(font_path=<span class=\"string\">'/Library/Fonts/Songti.ttc'</span>).generate(wl_space_split)</div></pre></td></tr></table></figure>\n<p>手动设置宋体字体，最终就能正常显示了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在用词云展示时，发现其他能正常运行，但是启动后的图像中都是方框，后来查找到原因是因为词云默认只支持英文。</p>\n<p>如果要支持中文需要自己设置支持中文的字体</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">my_wordcloud = WordCloud(font_path=<span class=\"string\">'/Library/Fonts/Songti.ttc'</span>).generate(wl_space_split)</div></pre></td></tr></table></figure>\n<p>手动设置宋体字体，最终就能正常显示了</p>\n"},{"title":"hexo网站换电脑后怎么办","date":"2017-05-02T08:31:28.000Z","_content":"\n# 说在前面的话\n\n这两天遇到个问题，在自己的电脑上面搭建的搭建环境发布了几个文章，后来换了个电脑，这个电脑也有环境和几个老的文章，但是我执行了hexo d -g 后，网站中新的文章都被删除了。所以现在的问题是，换电脑后如何保证hexo环境文件的同步。\n\n# 加入版本控制\n\n作为一名开发，实现同步，首先就想到版本控制，而网站又是hexo+github实现的。所以就打算把hexo环境及文章都纳入Git版本控制。\n\n当前项目的master分支中被发布后的静态页面占用，所以要么单独开一个项目，要么新建一个分支，最终采用新建分支办法。\n\n在hexo目录下执行` git init`初始化\n\n然后` git add .`把当前目录及子文件都添加到暂存区\n\n然后 ` git commit -m \"message\"`提交到本地库\n\n最后执行` git push origin branch`推送到分支中。这样以后发布文章后随时push，在其他电脑中把分支内容pull到本地库即可。 ","source":"_posts/hexo博客换电脑后怎么办.md","raw":"---\ntitle: hexo网站换电脑后怎么办\ndate: 2017-05-02 16:31:28\ntags: 网络\ncategories: 网络\n---\n\n# 说在前面的话\n\n这两天遇到个问题，在自己的电脑上面搭建的搭建环境发布了几个文章，后来换了个电脑，这个电脑也有环境和几个老的文章，但是我执行了hexo d -g 后，网站中新的文章都被删除了。所以现在的问题是，换电脑后如何保证hexo环境文件的同步。\n\n# 加入版本控制\n\n作为一名开发，实现同步，首先就想到版本控制，而网站又是hexo+github实现的。所以就打算把hexo环境及文章都纳入Git版本控制。\n\n当前项目的master分支中被发布后的静态页面占用，所以要么单独开一个项目，要么新建一个分支，最终采用新建分支办法。\n\n在hexo目录下执行` git init`初始化\n\n然后` git add .`把当前目录及子文件都添加到暂存区\n\n然后 ` git commit -m \"message\"`提交到本地库\n\n最后执行` git push origin branch`推送到分支中。这样以后发布文章后随时push，在其他电脑中把分支内容pull到本地库即可。 ","slug":"hexo博客换电脑后怎么办","published":1,"updated":"2017-05-02T11:54:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjfp004cwh9cc0i2phzu","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>这两天遇到个问题，在自己的电脑上面搭建的搭建环境发布了几个文章，后来换了个电脑，这个电脑也有环境和几个老的文章，但是我执行了hexo d -g 后，网站中新的文章都被删除了。所以现在的问题是，换电脑后如何保证hexo环境文件的同步。</p>\n<h1 id=\"加入版本控制\"><a href=\"#加入版本控制\" class=\"headerlink\" title=\"加入版本控制\"></a>加入版本控制</h1><p>作为一名开发，实现同步，首先就想到版本控制，而网站又是hexo+github实现的。所以就打算把hexo环境及文章都纳入Git版本控制。</p>\n<p>当前项目的master分支中被发布后的静态页面占用，所以要么单独开一个项目，要么新建一个分支，最终采用新建分支办法。</p>\n<p>在hexo目录下执行<code>git init</code>初始化</p>\n<p>然后<code>git add .</code>把当前目录及子文件都添加到暂存区</p>\n<p>然后 <code>git commit -m &quot;message&quot;</code>提交到本地库</p>\n<p>最后执行<code>git push origin branch</code>推送到分支中。这样以后发布文章后随时push，在其他电脑中把分支内容pull到本地库即可。 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>这两天遇到个问题，在自己的电脑上面搭建的搭建环境发布了几个文章，后来换了个电脑，这个电脑也有环境和几个老的文章，但是我执行了hexo d -g 后，网站中新的文章都被删除了。所以现在的问题是，换电脑后如何保证hexo环境文件的同步。</p>\n<h1 id=\"加入版本控制\"><a href=\"#加入版本控制\" class=\"headerlink\" title=\"加入版本控制\"></a>加入版本控制</h1><p>作为一名开发，实现同步，首先就想到版本控制，而网站又是hexo+github实现的。所以就打算把hexo环境及文章都纳入Git版本控制。</p>\n<p>当前项目的master分支中被发布后的静态页面占用，所以要么单独开一个项目，要么新建一个分支，最终采用新建分支办法。</p>\n<p>在hexo目录下执行<code>git init</code>初始化</p>\n<p>然后<code>git add .</code>把当前目录及子文件都添加到暂存区</p>\n<p>然后 <code>git commit -m &quot;message&quot;</code>提交到本地库</p>\n<p>最后执行<code>git push origin branch</code>推送到分支中。这样以后发布文章后随时push，在其他电脑中把分支内容pull到本地库即可。 </p>\n"},{"title":"hexo更换主题及配置","date":"2017-07-14T02:42:33.000Z","_content":"\n# 0x00 前言\n\n看惯了next样式，这几天想换一款主题换个心情。挑来挑去发现[yilia](https://github.com/litten/hexo-theme-yilia)主题不错，左侧导航和个人信息，还能带头像。so接下来就开始主题切换流程。\n\n# 0x01 下载\n\n- 切换到你的博客根目录下\n\n  如我的是这样子：`cd ~/Downloads/hexo/` \n\n- 下载前进行源文件备份\n\n  首先`hero d -g`把当前博客从新部署，\n\n  然后把源文件全部提交：`git add .`添加临时，`git commit -m \"全部备份\"`提交本地，`git push origin xxx`push到服务器。\n\n- 在根目录下执行clone\n\n  命令：`git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia`\n\n# 0x02 安装\n\n完成了下载和备份，接下来开始主题切换，在未确认完全完成之前不要执行`hexo d -g`部署到服务器，先在本地测试。\n\n- 切换到主题\n\n  打开博客根目录下的`_config.yml`文件，找到`theme: next`栏目把next改为`yilia`后保存。如下：\n\n  ![换主题](hexo更换主题及配置/换主题.png)\n\n  ​\n\n- 运行本地测试\n\n  执行` hexo s -debug`启动本地测试服务，打开`http://localhost:4000/`页面发现主题已经切换过来了，切换就是这么简单，但是还有很多地方要配置。\n\n# 0x03 配置\n\n这里的配置如果没有特殊说明，默认都是`themes/yilia/_config.yml`文件的配置\n\n- menu配置\n\n  默认menu中只有主页和相册，但是我不想要相册，同时还想添加特定的栏目。\n\n  相册不要只要注释掉就好了，但是如何添加特定栏目呢？我们在写文章时头部文件都有类似的格式：\n\n  ```\n  title: hexo更换主题\n  date: 2017-07-14 10:42:33\n  tags: 网络\n  categories: 网络\n  ```\n\n  其中tags和categories都是可以在menu中使用的，比如我想添加Android菜单，只要设置`Android: /tags/Android`即可，前提是我之前的文章中已经存在tags为Android的标签了。当然如果设置categories也可以的，只要之前有设置过这个类型即可，比如`Java: /categories/Java`。我的配置如下：\n\n  ![menu配置](hexo更换主题及配置/menu配置.png)\n\n  这样在点击Android菜单后，右侧都是Android类型的文章列表。\n\n- subnav配置\n\n  subnav主要是个人其他站点相关页面链接，如果没有则直接注释掉，但是为了UI好看还是留了三个：\n\n  ```\n  # SubNav\n  subnav:\n    #github: \"#\"\n    #weibo: \"#\"\n    #rss: \"#\"\n    #zhihu: \"#\"\n    #qq: \"840418528\"\n    #weixin: \"#\"\n    jianshu: \"http://www.jianshu.com/u/1b5cb41384f4\"\n    #douban: \"#\"\n    #segmentfault: \"#\"\n    #bilibili: \"#\"\n    #acfun: \"#\"\n    mail: \"mailto:songjlforever@foxmail.com\"\n    #facebook: \"#\"\n    google: \"https://www.google.com\"\n    #twitter: \"#\"\n    #linkedin: \"#\"\n  ```\n\n  ​\n\n- 头像配置\n\n  在source下新建一个文件夹起个名字比如：image。头像就是一个图片为什么还要单独建个文件夹？因为下面的打赏里面还要微信和支付宝两个二维码图片！将头像图片拷贝到image目录中，在配置文件中找到`avatar:`修改如下：\n\n  ```\n  #你的头像url\n  avatar: /image/avatar.jpg\n  ```\n\n  刷新`http://localhost:4000/`发现头像已经出现了。\n\n- 打赏配置\n\n  把支付宝和微信收款二维码拷贝到上面创建的image文件夹。然后在配置文件中修改如下：\n\n  ```\n  # 打赏\n  # 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\n  reward_type: 2\n  # 打赏wording\n  reward_wording: '谢谢您的支持!'\n  # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg\n  alipay: /image/alipay.jpg\n  # 微信二维码图片地址\n  weixin: /image/weixin.png\n  ```\n\n  显示效果如图：\n\n  ![打赏效果图](hexo更换主题及配置/打赏效果图.png)\n\n  ​\n\n  ​\n\n- 关于我配置\n\n  smart_menu中有关于我的menu，点击后只显示配置文件中的`aboutme: 一个从运维转战开发的程序猿。`这里内容格式样式太少，我想像next主题中关于我是个单独的页面，那样看起来更舒服。\n\n  当然可以实现，\n\n  首先注释掉`smart_menu`中的`aboutme`。\n\n  然后在配置文件顶部`menu`中添加`关于我: /about/`。这是刷新UI后点击关于我，打开新的页面如下：\n\n  ![关于我](hexo更换主题及配置/关于我.png)\n\n  ​\n\n- 点击所有文章提示模块缺失\n\n  问题如下：\n\n  ![模块缺失](hexo更换主题及配置/模块缺失.png)\n\n  首先确保node版本在6.2以上，我的是6.10.2仍然出现这个问题。\n\n  然后在博客根目录下执行`npm i hexo-generator-content --save`\n\n  最后在根目录中的`_config.yml`里添加如下：\n\n  ```\n  jsonContent:\n    meta: false\n    pages: false\n    posts:\n      title: true\n      date: true\n      path: true\n      text: false\n      raw: false\n      content: false\n      slug: false\n      updated: false\n      comments: false\n      link: false\n      permalink: false\n      excerpt: false\n      categories: false\n      tags: true\n  ```\n\n  > 注意这段内容格式，尤其是多余空格，否则可能引发其他错误\n\n","source":"_posts/hexo更换主题及配置.md","raw":"---\ntitle: hexo更换主题及配置\ndate: 2017-07-14 10:42:33\ntags: 网络\ncategories: 网络\n---\n\n# 0x00 前言\n\n看惯了next样式，这几天想换一款主题换个心情。挑来挑去发现[yilia](https://github.com/litten/hexo-theme-yilia)主题不错，左侧导航和个人信息，还能带头像。so接下来就开始主题切换流程。\n\n# 0x01 下载\n\n- 切换到你的博客根目录下\n\n  如我的是这样子：`cd ~/Downloads/hexo/` \n\n- 下载前进行源文件备份\n\n  首先`hero d -g`把当前博客从新部署，\n\n  然后把源文件全部提交：`git add .`添加临时，`git commit -m \"全部备份\"`提交本地，`git push origin xxx`push到服务器。\n\n- 在根目录下执行clone\n\n  命令：`git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia`\n\n# 0x02 安装\n\n完成了下载和备份，接下来开始主题切换，在未确认完全完成之前不要执行`hexo d -g`部署到服务器，先在本地测试。\n\n- 切换到主题\n\n  打开博客根目录下的`_config.yml`文件，找到`theme: next`栏目把next改为`yilia`后保存。如下：\n\n  ![换主题](hexo更换主题及配置/换主题.png)\n\n  ​\n\n- 运行本地测试\n\n  执行` hexo s -debug`启动本地测试服务，打开`http://localhost:4000/`页面发现主题已经切换过来了，切换就是这么简单，但是还有很多地方要配置。\n\n# 0x03 配置\n\n这里的配置如果没有特殊说明，默认都是`themes/yilia/_config.yml`文件的配置\n\n- menu配置\n\n  默认menu中只有主页和相册，但是我不想要相册，同时还想添加特定的栏目。\n\n  相册不要只要注释掉就好了，但是如何添加特定栏目呢？我们在写文章时头部文件都有类似的格式：\n\n  ```\n  title: hexo更换主题\n  date: 2017-07-14 10:42:33\n  tags: 网络\n  categories: 网络\n  ```\n\n  其中tags和categories都是可以在menu中使用的，比如我想添加Android菜单，只要设置`Android: /tags/Android`即可，前提是我之前的文章中已经存在tags为Android的标签了。当然如果设置categories也可以的，只要之前有设置过这个类型即可，比如`Java: /categories/Java`。我的配置如下：\n\n  ![menu配置](hexo更换主题及配置/menu配置.png)\n\n  这样在点击Android菜单后，右侧都是Android类型的文章列表。\n\n- subnav配置\n\n  subnav主要是个人其他站点相关页面链接，如果没有则直接注释掉，但是为了UI好看还是留了三个：\n\n  ```\n  # SubNav\n  subnav:\n    #github: \"#\"\n    #weibo: \"#\"\n    #rss: \"#\"\n    #zhihu: \"#\"\n    #qq: \"840418528\"\n    #weixin: \"#\"\n    jianshu: \"http://www.jianshu.com/u/1b5cb41384f4\"\n    #douban: \"#\"\n    #segmentfault: \"#\"\n    #bilibili: \"#\"\n    #acfun: \"#\"\n    mail: \"mailto:songjlforever@foxmail.com\"\n    #facebook: \"#\"\n    google: \"https://www.google.com\"\n    #twitter: \"#\"\n    #linkedin: \"#\"\n  ```\n\n  ​\n\n- 头像配置\n\n  在source下新建一个文件夹起个名字比如：image。头像就是一个图片为什么还要单独建个文件夹？因为下面的打赏里面还要微信和支付宝两个二维码图片！将头像图片拷贝到image目录中，在配置文件中找到`avatar:`修改如下：\n\n  ```\n  #你的头像url\n  avatar: /image/avatar.jpg\n  ```\n\n  刷新`http://localhost:4000/`发现头像已经出现了。\n\n- 打赏配置\n\n  把支付宝和微信收款二维码拷贝到上面创建的image文件夹。然后在配置文件中修改如下：\n\n  ```\n  # 打赏\n  # 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\n  reward_type: 2\n  # 打赏wording\n  reward_wording: '谢谢您的支持!'\n  # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg\n  alipay: /image/alipay.jpg\n  # 微信二维码图片地址\n  weixin: /image/weixin.png\n  ```\n\n  显示效果如图：\n\n  ![打赏效果图](hexo更换主题及配置/打赏效果图.png)\n\n  ​\n\n  ​\n\n- 关于我配置\n\n  smart_menu中有关于我的menu，点击后只显示配置文件中的`aboutme: 一个从运维转战开发的程序猿。`这里内容格式样式太少，我想像next主题中关于我是个单独的页面，那样看起来更舒服。\n\n  当然可以实现，\n\n  首先注释掉`smart_menu`中的`aboutme`。\n\n  然后在配置文件顶部`menu`中添加`关于我: /about/`。这是刷新UI后点击关于我，打开新的页面如下：\n\n  ![关于我](hexo更换主题及配置/关于我.png)\n\n  ​\n\n- 点击所有文章提示模块缺失\n\n  问题如下：\n\n  ![模块缺失](hexo更换主题及配置/模块缺失.png)\n\n  首先确保node版本在6.2以上，我的是6.10.2仍然出现这个问题。\n\n  然后在博客根目录下执行`npm i hexo-generator-content --save`\n\n  最后在根目录中的`_config.yml`里添加如下：\n\n  ```\n  jsonContent:\n    meta: false\n    pages: false\n    posts:\n      title: true\n      date: true\n      path: true\n      text: false\n      raw: false\n      content: false\n      slug: false\n      updated: false\n      comments: false\n      link: false\n      permalink: false\n      excerpt: false\n      categories: false\n      tags: true\n  ```\n\n  > 注意这段内容格式，尤其是多余空格，否则可能引发其他错误\n\n","slug":"hexo更换主题及配置","published":1,"updated":"2017-07-14T05:57:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjgc004hwh9comvoi62k","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>看惯了next样式，这几天想换一款主题换个心情。挑来挑去发现<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"external\">yilia</a>主题不错，左侧导航和个人信息，还能带头像。so接下来就开始主题切换流程。</p>\n<h1 id=\"0x01-下载\"><a href=\"#0x01-下载\" class=\"headerlink\" title=\"0x01 下载\"></a>0x01 下载</h1><ul>\n<li><p>切换到你的博客根目录下</p>\n<p>如我的是这样子：<code>cd ~/Downloads/hexo/</code> </p>\n</li>\n<li><p>下载前进行源文件备份</p>\n<p>首先<code>hero d -g</code>把当前博客从新部署，</p>\n<p>然后把源文件全部提交：<code>git add .</code>添加临时，<code>git commit -m &quot;全部备份&quot;</code>提交本地，<code>git push origin xxx</code>push到服务器。</p>\n</li>\n<li><p>在根目录下执行clone</p>\n<p>命令：<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p>\n</li>\n</ul>\n<h1 id=\"0x02-安装\"><a href=\"#0x02-安装\" class=\"headerlink\" title=\"0x02 安装\"></a>0x02 安装</h1><p>完成了下载和备份，接下来开始主题切换，在未确认完全完成之前不要执行<code>hexo d -g</code>部署到服务器，先在本地测试。</p>\n<ul>\n<li><p>切换到主题</p>\n<p>打开博客根目录下的<code>_config.yml</code>文件，找到<code>theme: next</code>栏目把next改为<code>yilia</code>后保存。如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/换主题.png\" alt=\"换主题\"></p>\n<p>​</p>\n</li>\n<li><p>运行本地测试</p>\n<p>执行<code>hexo s -debug</code>启动本地测试服务，打开<code>http://localhost:4000/</code>页面发现主题已经切换过来了，切换就是这么简单，但是还有很多地方要配置。</p>\n</li>\n</ul>\n<h1 id=\"0x03-配置\"><a href=\"#0x03-配置\" class=\"headerlink\" title=\"0x03 配置\"></a>0x03 配置</h1><p>这里的配置如果没有特殊说明，默认都是<code>themes/yilia/_config.yml</code>文件的配置</p>\n<ul>\n<li><p>menu配置</p>\n<p>默认menu中只有主页和相册，但是我不想要相册，同时还想添加特定的栏目。</p>\n<p>相册不要只要注释掉就好了，但是如何添加特定栏目呢？我们在写文章时头部文件都有类似的格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: hexo更换主题</div><div class=\"line\">date: 2017-07-14 10:42:33</div><div class=\"line\">tags: 网络</div><div class=\"line\">categories: 网络</div></pre></td></tr></table></figure>\n<p>其中tags和categories都是可以在menu中使用的，比如我想添加Android菜单，只要设置<code>Android: /tags/Android</code>即可，前提是我之前的文章中已经存在tags为Android的标签了。当然如果设置categories也可以的，只要之前有设置过这个类型即可，比如<code>Java: /categories/Java</code>。我的配置如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/menu配置.png\" alt=\"menu配置\"></p>\n<p>这样在点击Android菜单后，右侧都是Android类型的文章列表。</p>\n</li>\n<li><p>subnav配置</p>\n<p>subnav主要是个人其他站点相关页面链接，如果没有则直接注释掉，但是为了UI好看还是留了三个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># SubNav</div><div class=\"line\">subnav:</div><div class=\"line\">  #github: &quot;#&quot;</div><div class=\"line\">  #weibo: &quot;#&quot;</div><div class=\"line\">  #rss: &quot;#&quot;</div><div class=\"line\">  #zhihu: &quot;#&quot;</div><div class=\"line\">  #qq: &quot;840418528&quot;</div><div class=\"line\">  #weixin: &quot;#&quot;</div><div class=\"line\">  jianshu: &quot;http://www.jianshu.com/u/1b5cb41384f4&quot;</div><div class=\"line\">  #douban: &quot;#&quot;</div><div class=\"line\">  #segmentfault: &quot;#&quot;</div><div class=\"line\">  #bilibili: &quot;#&quot;</div><div class=\"line\">  #acfun: &quot;#&quot;</div><div class=\"line\">  mail: &quot;mailto:songjlforever@foxmail.com&quot;</div><div class=\"line\">  #facebook: &quot;#&quot;</div><div class=\"line\">  google: &quot;https://www.google.com&quot;</div><div class=\"line\">  #twitter: &quot;#&quot;</div><div class=\"line\">  #linkedin: &quot;#&quot;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>头像配置</p>\n<p>在source下新建一个文件夹起个名字比如：image。头像就是一个图片为什么还要单独建个文件夹？因为下面的打赏里面还要微信和支付宝两个二维码图片！将头像图片拷贝到image目录中，在配置文件中找到<code>avatar:</code>修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#你的头像url</div><div class=\"line\">avatar: /image/avatar.jpg</div></pre></td></tr></table></figure>\n<p>刷新<code>http://localhost:4000/</code>发现头像已经出现了。</p>\n</li>\n<li><p>打赏配置</p>\n<p>把支付宝和微信收款二维码拷贝到上面创建的image文件夹。然后在配置文件中修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 打赏</div><div class=\"line\"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</div><div class=\"line\">reward_type: 2</div><div class=\"line\"># 打赏wording</div><div class=\"line\">reward_wording: &apos;谢谢您的支持!&apos;</div><div class=\"line\"># 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</div><div class=\"line\">alipay: /image/alipay.jpg</div><div class=\"line\"># 微信二维码图片地址</div><div class=\"line\">weixin: /image/weixin.png</div></pre></td></tr></table></figure>\n<p>显示效果如图：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/打赏效果图.png\" alt=\"打赏效果图\"></p>\n<p>​</p>\n<p>​</p>\n</li>\n<li><p>关于我配置</p>\n<p>smart_menu中有关于我的menu，点击后只显示配置文件中的<code>aboutme: 一个从运维转战开发的程序猿。</code>这里内容格式样式太少，我想像next主题中关于我是个单独的页面，那样看起来更舒服。</p>\n<p>当然可以实现，</p>\n<p>首先注释掉<code>smart_menu</code>中的<code>aboutme</code>。</p>\n<p>然后在配置文件顶部<code>menu</code>中添加<code>关于我: /about/</code>。这是刷新UI后点击关于我，打开新的页面如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/关于我.png\" alt=\"关于我\"></p>\n<p>​</p>\n</li>\n<li><p>点击所有文章提示模块缺失</p>\n<p>问题如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/模块缺失.png\" alt=\"模块缺失\"></p>\n<p>首先确保node版本在6.2以上，我的是6.10.2仍然出现这个问题。</p>\n<p>然后在博客根目录下执行<code>npm i hexo-generator-content --save</code></p>\n<p>最后在根目录中的<code>_config.yml</code>里添加如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">jsonContent:</div><div class=\"line\">  meta: false</div><div class=\"line\">  pages: false</div><div class=\"line\">  posts:</div><div class=\"line\">    title: true</div><div class=\"line\">    date: true</div><div class=\"line\">    path: true</div><div class=\"line\">    text: false</div><div class=\"line\">    raw: false</div><div class=\"line\">    content: false</div><div class=\"line\">    slug: false</div><div class=\"line\">    updated: false</div><div class=\"line\">    comments: false</div><div class=\"line\">    link: false</div><div class=\"line\">    permalink: false</div><div class=\"line\">    excerpt: false</div><div class=\"line\">    categories: false</div><div class=\"line\">    tags: true</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意这段内容格式，尤其是多余空格，否则可能引发其他错误</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>看惯了next样式，这几天想换一款主题换个心情。挑来挑去发现<a href=\"https://github.com/litten/hexo-theme-yilia\">yilia</a>主题不错，左侧导航和个人信息，还能带头像。so接下来就开始主题切换流程。</p>\n<h1 id=\"0x01-下载\"><a href=\"#0x01-下载\" class=\"headerlink\" title=\"0x01 下载\"></a>0x01 下载</h1><ul>\n<li><p>切换到你的博客根目录下</p>\n<p>如我的是这样子：<code>cd ~/Downloads/hexo/</code> </p>\n</li>\n<li><p>下载前进行源文件备份</p>\n<p>首先<code>hero d -g</code>把当前博客从新部署，</p>\n<p>然后把源文件全部提交：<code>git add .</code>添加临时，<code>git commit -m &quot;全部备份&quot;</code>提交本地，<code>git push origin xxx</code>push到服务器。</p>\n</li>\n<li><p>在根目录下执行clone</p>\n<p>命令：<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p>\n</li>\n</ul>\n<h1 id=\"0x02-安装\"><a href=\"#0x02-安装\" class=\"headerlink\" title=\"0x02 安装\"></a>0x02 安装</h1><p>完成了下载和备份，接下来开始主题切换，在未确认完全完成之前不要执行<code>hexo d -g</code>部署到服务器，先在本地测试。</p>\n<ul>\n<li><p>切换到主题</p>\n<p>打开博客根目录下的<code>_config.yml</code>文件，找到<code>theme: next</code>栏目把next改为<code>yilia</code>后保存。如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/换主题.png\" alt=\"换主题\"></p>\n<p>​</p>\n</li>\n<li><p>运行本地测试</p>\n<p>执行<code>hexo s -debug</code>启动本地测试服务，打开<code>http://localhost:4000/</code>页面发现主题已经切换过来了，切换就是这么简单，但是还有很多地方要配置。</p>\n</li>\n</ul>\n<h1 id=\"0x03-配置\"><a href=\"#0x03-配置\" class=\"headerlink\" title=\"0x03 配置\"></a>0x03 配置</h1><p>这里的配置如果没有特殊说明，默认都是<code>themes/yilia/_config.yml</code>文件的配置</p>\n<ul>\n<li><p>menu配置</p>\n<p>默认menu中只有主页和相册，但是我不想要相册，同时还想添加特定的栏目。</p>\n<p>相册不要只要注释掉就好了，但是如何添加特定栏目呢？我们在写文章时头部文件都有类似的格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: hexo更换主题</div><div class=\"line\">date: 2017-07-14 10:42:33</div><div class=\"line\">tags: 网络</div><div class=\"line\">categories: 网络</div></pre></td></tr></table></figure>\n<p>其中tags和categories都是可以在menu中使用的，比如我想添加Android菜单，只要设置<code>Android: /tags/Android</code>即可，前提是我之前的文章中已经存在tags为Android的标签了。当然如果设置categories也可以的，只要之前有设置过这个类型即可，比如<code>Java: /categories/Java</code>。我的配置如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/menu配置.png\" alt=\"menu配置\"></p>\n<p>这样在点击Android菜单后，右侧都是Android类型的文章列表。</p>\n</li>\n<li><p>subnav配置</p>\n<p>subnav主要是个人其他站点相关页面链接，如果没有则直接注释掉，但是为了UI好看还是留了三个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># SubNav</div><div class=\"line\">subnav:</div><div class=\"line\">  #github: &quot;#&quot;</div><div class=\"line\">  #weibo: &quot;#&quot;</div><div class=\"line\">  #rss: &quot;#&quot;</div><div class=\"line\">  #zhihu: &quot;#&quot;</div><div class=\"line\">  #qq: &quot;840418528&quot;</div><div class=\"line\">  #weixin: &quot;#&quot;</div><div class=\"line\">  jianshu: &quot;http://www.jianshu.com/u/1b5cb41384f4&quot;</div><div class=\"line\">  #douban: &quot;#&quot;</div><div class=\"line\">  #segmentfault: &quot;#&quot;</div><div class=\"line\">  #bilibili: &quot;#&quot;</div><div class=\"line\">  #acfun: &quot;#&quot;</div><div class=\"line\">  mail: &quot;mailto:songjlforever@foxmail.com&quot;</div><div class=\"line\">  #facebook: &quot;#&quot;</div><div class=\"line\">  google: &quot;https://www.google.com&quot;</div><div class=\"line\">  #twitter: &quot;#&quot;</div><div class=\"line\">  #linkedin: &quot;#&quot;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n<li><p>头像配置</p>\n<p>在source下新建一个文件夹起个名字比如：image。头像就是一个图片为什么还要单独建个文件夹？因为下面的打赏里面还要微信和支付宝两个二维码图片！将头像图片拷贝到image目录中，在配置文件中找到<code>avatar:</code>修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#你的头像url</div><div class=\"line\">avatar: /image/avatar.jpg</div></pre></td></tr></table></figure>\n<p>刷新<code>http://localhost:4000/</code>发现头像已经出现了。</p>\n</li>\n<li><p>打赏配置</p>\n<p>把支付宝和微信收款二维码拷贝到上面创建的image文件夹。然后在配置文件中修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 打赏</div><div class=\"line\"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</div><div class=\"line\">reward_type: 2</div><div class=\"line\"># 打赏wording</div><div class=\"line\">reward_wording: &apos;谢谢您的支持!&apos;</div><div class=\"line\"># 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</div><div class=\"line\">alipay: /image/alipay.jpg</div><div class=\"line\"># 微信二维码图片地址</div><div class=\"line\">weixin: /image/weixin.png</div></pre></td></tr></table></figure>\n<p>显示效果如图：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/打赏效果图.png\" alt=\"打赏效果图\"></p>\n<p>​</p>\n<p>​</p>\n</li>\n<li><p>关于我配置</p>\n<p>smart_menu中有关于我的menu，点击后只显示配置文件中的<code>aboutme: 一个从运维转战开发的程序猿。</code>这里内容格式样式太少，我想像next主题中关于我是个单独的页面，那样看起来更舒服。</p>\n<p>当然可以实现，</p>\n<p>首先注释掉<code>smart_menu</code>中的<code>aboutme</code>。</p>\n<p>然后在配置文件顶部<code>menu</code>中添加<code>关于我: /about/</code>。这是刷新UI后点击关于我，打开新的页面如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/关于我.png\" alt=\"关于我\"></p>\n<p>​</p>\n</li>\n<li><p>点击所有文章提示模块缺失</p>\n<p>问题如下：</p>\n<p><img src=\"/2017/07/14/hexo更换主题及配置/模块缺失.png\" alt=\"模块缺失\"></p>\n<p>首先确保node版本在6.2以上，我的是6.10.2仍然出现这个问题。</p>\n<p>然后在博客根目录下执行<code>npm i hexo-generator-content --save</code></p>\n<p>最后在根目录中的<code>_config.yml</code>里添加如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">jsonContent:</div><div class=\"line\">  meta: false</div><div class=\"line\">  pages: false</div><div class=\"line\">  posts:</div><div class=\"line\">    title: true</div><div class=\"line\">    date: true</div><div class=\"line\">    path: true</div><div class=\"line\">    text: false</div><div class=\"line\">    raw: false</div><div class=\"line\">    content: false</div><div class=\"line\">    slug: false</div><div class=\"line\">    updated: false</div><div class=\"line\">    comments: false</div><div class=\"line\">    link: false</div><div class=\"line\">    permalink: false</div><div class=\"line\">    excerpt: false</div><div class=\"line\">    categories: false</div><div class=\"line\">    tags: true</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意这段内容格式，尤其是多余空格，否则可能引发其他错误</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"Python自动化之hexo自动发布和提交源码","date":"2017-07-26T08:43:38.000Z","_content":"\n# 0x00 前言\n\n现在的博客系统是使用hexo+github搭建的静态页面系统。\n\n博客文章页面和源码都由github托管。所以每次发布文章时要跳转到相应目录下，执行`hexo d -g`命令发布新文章。如果要同步源码方便其他机器也能写文章，那么还要使用`git add .`添加暂存，`git commit -m message`添加本地和`git push`推送远程分支。\n\n# 0x01 自动化设想\n\n开始因为新鲜感这些操作都还好，顺便练手。但是时间久了就觉得每次都操作这么多次太浪费时间了。\n\n这时候就萌生了自动化命令的想法，一步操作完成所有这些命令，该多省心！\n\n# 0x02 自动化设计\n\n实现自动化首先想到的是Python，而且最近也学了不久，练练手也刚好。\n\n由于都是终端命令，所以要先实现让Python执行终端命令的方法：\n\n①通过`os.system`方法\n\n②通过`subprocess.Popen`方法\n\n通过使用发现都可以执行命令，但是如果命令分开执行，命令之间的前后结果不会关联起来，比如我第一个命令执行`cd /jenson/`，再执行第二个命令`pwd`时时发现路径仍然是旧路径。\n\n所以现在面临新的问题：多个命令一起执行。如何一起执行呢？\n\n其实上面①和②都支持多命令一起，譬如：\n\n如果多个命令共同执行，不管前一个命令是否成功，都要执行后一个则使用**&&**连接命令：\n\n- `os.system('cmd1 && cmd2')`\n- `subprocess.Popen('cmd1 && cmd2', shell=True)`\n\n如果前一个命令执行成功才执行后一个命令，则使用**;**连接：\n\n- `os.system('cmd1 ; cmd2')`\n- `subprocess.Popen('cmd1 ; cmd2', shell=True)`\n\n接下来代码实现：\n\n# 0x03 自动化实现\n\n创建`AutoCommit.py`文件\n\n```python\nimport subprocess\n\n# 跳转工作目录\nto_path = 'cd ~/Downloads/hexo/'\n# 发布命令\nto_deploy = 'hexo d -g'\n# git add命令\nto_add = 'git add .'\n# git commit命令\nto_commit = 'git commit -m 新添加文章' \n# git push命令\nto_push = 'git push origin hexoSource'\ntmp = subprocess.Popen(to_path + '&&' +\n                       to_deploy + '&&' +\n                       to_add + '&&' +\n                       to_commit + '&&' +\n                       to_push, shell=True)\n```\n\n这就算完成了，运行`python3 AutoCommit.py `时候也能正常提交。\n\n但是这样感觉还能再完善些，继续改造：\n\n# 0x04 自动化优化\n\n首先关于git commit的信息，我想实现自定义，而不是每次都固定这几个内容，这样不容易区分每次版本提交了哪些内容。\n\n现在的初步想法是在终端执行`python3 AutoCommit.py`命令时，同时接收命令行参数作为提交的内容，比如这样`python3 AutoCommit.py  message`。\n\nPython文件要接收命令行参数，需要使用`sys`模块，接收参数：\n\n`message = sys.argv[1]`。\n\n这里argv[0]表示脚本名，argv[1]开始才表示后面的参数\n\n同时接收message后判断是否为空，如果为空在使用默认提交信息，所以封装一个方法\n\n```python\ndef isNullMessage(message):\n    \"\"\"\n    判断消息是否为空,如果为空赋默认值\n    :param message:\n    :return:\n    \"\"\"\n    if len(message.strip()) == 0:\n        message = '提交新文章'\n    return message\n```\n\n既然判断提交信息都封装到方法了，那么这一些列命令也应该封装到方法中：\n\n```python\ndef deployAndGitPush(message):\n    \"\"\"\n    hexo静态页面发布和源码push git服务器\n    :return:\n    \"\"\"\n    # 跳转工作目录\n    to_path = 'cd ~/Downloads/hexo/'\n    # 发布命令\n    to_deploy = 'hexo d -g'\n    # git add命令\n    to_add = 'git add .'\n    # git commit命令\n    to_commit = 'git commit -m ' + message\n    # git push命令\n    to_push = 'git push origin hexoSource'\n    tmp = subprocess.Popen(to_path + '&&' +\n                           to_deploy + '&&' +\n                           to_add + '&&' +\n                           to_commit + '&&' +\n                           to_push, shell=True)\n```\n\n最终调用如下：\n\n```python\ndeployAndGitPush(message=isNullMessage(message=message))\n```\n\n\n\nOK，自动化优化完成。执行`python3 AutpCommit.py Android文章提交`。\n\n","source":"_posts/Python自动化之hexo自动发布和提交源码.md","raw":"---\ntitle: Python自动化之hexo自动发布和提交源码\ndate: 2017-07-26 16:43:38\ntags: [Python,自动化]\ncategories: [Python,自动化]\n---\n\n# 0x00 前言\n\n现在的博客系统是使用hexo+github搭建的静态页面系统。\n\n博客文章页面和源码都由github托管。所以每次发布文章时要跳转到相应目录下，执行`hexo d -g`命令发布新文章。如果要同步源码方便其他机器也能写文章，那么还要使用`git add .`添加暂存，`git commit -m message`添加本地和`git push`推送远程分支。\n\n# 0x01 自动化设想\n\n开始因为新鲜感这些操作都还好，顺便练手。但是时间久了就觉得每次都操作这么多次太浪费时间了。\n\n这时候就萌生了自动化命令的想法，一步操作完成所有这些命令，该多省心！\n\n# 0x02 自动化设计\n\n实现自动化首先想到的是Python，而且最近也学了不久，练练手也刚好。\n\n由于都是终端命令，所以要先实现让Python执行终端命令的方法：\n\n①通过`os.system`方法\n\n②通过`subprocess.Popen`方法\n\n通过使用发现都可以执行命令，但是如果命令分开执行，命令之间的前后结果不会关联起来，比如我第一个命令执行`cd /jenson/`，再执行第二个命令`pwd`时时发现路径仍然是旧路径。\n\n所以现在面临新的问题：多个命令一起执行。如何一起执行呢？\n\n其实上面①和②都支持多命令一起，譬如：\n\n如果多个命令共同执行，不管前一个命令是否成功，都要执行后一个则使用**&&**连接命令：\n\n- `os.system('cmd1 && cmd2')`\n- `subprocess.Popen('cmd1 && cmd2', shell=True)`\n\n如果前一个命令执行成功才执行后一个命令，则使用**;**连接：\n\n- `os.system('cmd1 ; cmd2')`\n- `subprocess.Popen('cmd1 ; cmd2', shell=True)`\n\n接下来代码实现：\n\n# 0x03 自动化实现\n\n创建`AutoCommit.py`文件\n\n```python\nimport subprocess\n\n# 跳转工作目录\nto_path = 'cd ~/Downloads/hexo/'\n# 发布命令\nto_deploy = 'hexo d -g'\n# git add命令\nto_add = 'git add .'\n# git commit命令\nto_commit = 'git commit -m 新添加文章' \n# git push命令\nto_push = 'git push origin hexoSource'\ntmp = subprocess.Popen(to_path + '&&' +\n                       to_deploy + '&&' +\n                       to_add + '&&' +\n                       to_commit + '&&' +\n                       to_push, shell=True)\n```\n\n这就算完成了，运行`python3 AutoCommit.py `时候也能正常提交。\n\n但是这样感觉还能再完善些，继续改造：\n\n# 0x04 自动化优化\n\n首先关于git commit的信息，我想实现自定义，而不是每次都固定这几个内容，这样不容易区分每次版本提交了哪些内容。\n\n现在的初步想法是在终端执行`python3 AutoCommit.py`命令时，同时接收命令行参数作为提交的内容，比如这样`python3 AutoCommit.py  message`。\n\nPython文件要接收命令行参数，需要使用`sys`模块，接收参数：\n\n`message = sys.argv[1]`。\n\n这里argv[0]表示脚本名，argv[1]开始才表示后面的参数\n\n同时接收message后判断是否为空，如果为空在使用默认提交信息，所以封装一个方法\n\n```python\ndef isNullMessage(message):\n    \"\"\"\n    判断消息是否为空,如果为空赋默认值\n    :param message:\n    :return:\n    \"\"\"\n    if len(message.strip()) == 0:\n        message = '提交新文章'\n    return message\n```\n\n既然判断提交信息都封装到方法了，那么这一些列命令也应该封装到方法中：\n\n```python\ndef deployAndGitPush(message):\n    \"\"\"\n    hexo静态页面发布和源码push git服务器\n    :return:\n    \"\"\"\n    # 跳转工作目录\n    to_path = 'cd ~/Downloads/hexo/'\n    # 发布命令\n    to_deploy = 'hexo d -g'\n    # git add命令\n    to_add = 'git add .'\n    # git commit命令\n    to_commit = 'git commit -m ' + message\n    # git push命令\n    to_push = 'git push origin hexoSource'\n    tmp = subprocess.Popen(to_path + '&&' +\n                           to_deploy + '&&' +\n                           to_add + '&&' +\n                           to_commit + '&&' +\n                           to_push, shell=True)\n```\n\n最终调用如下：\n\n```python\ndeployAndGitPush(message=isNullMessage(message=message))\n```\n\n\n\nOK，自动化优化完成。执行`python3 AutpCommit.py Android文章提交`。\n\n","slug":"Python自动化之hexo自动发布和提交源码","published":1,"updated":"2017-07-26T09:38:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjgf004kwh9c1cvuvn6g","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>现在的博客系统是使用hexo+github搭建的静态页面系统。</p>\n<p>博客文章页面和源码都由github托管。所以每次发布文章时要跳转到相应目录下，执行<code>hexo d -g</code>命令发布新文章。如果要同步源码方便其他机器也能写文章，那么还要使用<code>git add .</code>添加暂存，<code>git commit -m message</code>添加本地和<code>git push</code>推送远程分支。</p>\n<h1 id=\"0x01-自动化设想\"><a href=\"#0x01-自动化设想\" class=\"headerlink\" title=\"0x01 自动化设想\"></a>0x01 自动化设想</h1><p>开始因为新鲜感这些操作都还好，顺便练手。但是时间久了就觉得每次都操作这么多次太浪费时间了。</p>\n<p>这时候就萌生了自动化命令的想法，一步操作完成所有这些命令，该多省心！</p>\n<h1 id=\"0x02-自动化设计\"><a href=\"#0x02-自动化设计\" class=\"headerlink\" title=\"0x02 自动化设计\"></a>0x02 自动化设计</h1><p>实现自动化首先想到的是Python，而且最近也学了不久，练练手也刚好。</p>\n<p>由于都是终端命令，所以要先实现让Python执行终端命令的方法：</p>\n<p>①通过<code>os.system</code>方法</p>\n<p>②通过<code>subprocess.Popen</code>方法</p>\n<p>通过使用发现都可以执行命令，但是如果命令分开执行，命令之间的前后结果不会关联起来，比如我第一个命令执行<code>cd /jenson/</code>，再执行第二个命令<code>pwd</code>时时发现路径仍然是旧路径。</p>\n<p>所以现在面临新的问题：多个命令一起执行。如何一起执行呢？</p>\n<p>其实上面①和②都支持多命令一起，譬如：</p>\n<p>如果多个命令共同执行，不管前一个命令是否成功，都要执行后一个则使用<strong>&amp;&amp;</strong>连接命令：</p>\n<ul>\n<li><code>os.system(&#39;cmd1 &amp;&amp; cmd2&#39;)</code></li>\n<li><code>subprocess.Popen(&#39;cmd1 &amp;&amp; cmd2&#39;, shell=True)</code></li>\n</ul>\n<p>如果前一个命令执行成功才执行后一个命令，则使用<strong>;</strong>连接：</p>\n<ul>\n<li><code>os.system(&#39;cmd1 ; cmd2&#39;)</code></li>\n<li><code>subprocess.Popen(&#39;cmd1 ; cmd2&#39;, shell=True)</code></li>\n</ul>\n<p>接下来代码实现：</p>\n<h1 id=\"0x03-自动化实现\"><a href=\"#0x03-自动化实现\" class=\"headerlink\" title=\"0x03 自动化实现\"></a>0x03 自动化实现</h1><p>创建<code>AutoCommit.py</code>文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> subprocess</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 跳转工作目录</span></div><div class=\"line\">to_path = <span class=\"string\">'cd ~/Downloads/hexo/'</span></div><div class=\"line\"><span class=\"comment\"># 发布命令</span></div><div class=\"line\">to_deploy = <span class=\"string\">'hexo d -g'</span></div><div class=\"line\"><span class=\"comment\"># git add命令</span></div><div class=\"line\">to_add = <span class=\"string\">'git add .'</span></div><div class=\"line\"><span class=\"comment\"># git commit命令</span></div><div class=\"line\">to_commit = <span class=\"string\">'git commit -m 新添加文章'</span> </div><div class=\"line\"><span class=\"comment\"># git push命令</span></div><div class=\"line\">to_push = <span class=\"string\">'git push origin hexoSource'</span></div><div class=\"line\">tmp = subprocess.Popen(to_path + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_deploy + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_add + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_commit + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_push, shell=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>这就算完成了，运行<code>python3 AutoCommit.py</code>时候也能正常提交。</p>\n<p>但是这样感觉还能再完善些，继续改造：</p>\n<h1 id=\"0x04-自动化优化\"><a href=\"#0x04-自动化优化\" class=\"headerlink\" title=\"0x04 自动化优化\"></a>0x04 自动化优化</h1><p>首先关于git commit的信息，我想实现自定义，而不是每次都固定这几个内容，这样不容易区分每次版本提交了哪些内容。</p>\n<p>现在的初步想法是在终端执行<code>python3 AutoCommit.py</code>命令时，同时接收命令行参数作为提交的内容，比如这样<code>python3 AutoCommit.py  message</code>。</p>\n<p>Python文件要接收命令行参数，需要使用<code>sys</code>模块，接收参数：</p>\n<p><code>message = sys.argv[1]</code>。</p>\n<p>这里argv[0]表示脚本名，argv[1]开始才表示后面的参数</p>\n<p>同时接收message后判断是否为空，如果为空在使用默认提交信息，所以封装一个方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNullMessage</span><span class=\"params\">(message)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    判断消息是否为空,如果为空赋默认值</div><div class=\"line\">    :param message:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> len(message.strip()) == <span class=\"number\">0</span>:</div><div class=\"line\">        message = <span class=\"string\">'提交新文章'</span></div><div class=\"line\">    <span class=\"keyword\">return</span> message</div></pre></td></tr></table></figure>\n<p>既然判断提交信息都封装到方法了，那么这一些列命令也应该封装到方法中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deployAndGitPush</span><span class=\"params\">(message)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    hexo静态页面发布和源码push git服务器</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"comment\"># 跳转工作目录</span></div><div class=\"line\">    to_path = <span class=\"string\">'cd ~/Downloads/hexo/'</span></div><div class=\"line\">    <span class=\"comment\"># 发布命令</span></div><div class=\"line\">    to_deploy = <span class=\"string\">'hexo d -g'</span></div><div class=\"line\">    <span class=\"comment\"># git add命令</span></div><div class=\"line\">    to_add = <span class=\"string\">'git add .'</span></div><div class=\"line\">    <span class=\"comment\"># git commit命令</span></div><div class=\"line\">    to_commit = <span class=\"string\">'git commit -m '</span> + message</div><div class=\"line\">    <span class=\"comment\"># git push命令</span></div><div class=\"line\">    to_push = <span class=\"string\">'git push origin hexoSource'</span></div><div class=\"line\">    tmp = subprocess.Popen(to_path + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_deploy + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_add + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_commit + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_push, shell=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>最终调用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deployAndGitPush(message=isNullMessage(message=message))</div></pre></td></tr></table></figure>\n<p>OK，自动化优化完成。执行<code>python3 AutpCommit.py Android文章提交</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>现在的博客系统是使用hexo+github搭建的静态页面系统。</p>\n<p>博客文章页面和源码都由github托管。所以每次发布文章时要跳转到相应目录下，执行<code>hexo d -g</code>命令发布新文章。如果要同步源码方便其他机器也能写文章，那么还要使用<code>git add .</code>添加暂存，<code>git commit -m message</code>添加本地和<code>git push</code>推送远程分支。</p>\n<h1 id=\"0x01-自动化设想\"><a href=\"#0x01-自动化设想\" class=\"headerlink\" title=\"0x01 自动化设想\"></a>0x01 自动化设想</h1><p>开始因为新鲜感这些操作都还好，顺便练手。但是时间久了就觉得每次都操作这么多次太浪费时间了。</p>\n<p>这时候就萌生了自动化命令的想法，一步操作完成所有这些命令，该多省心！</p>\n<h1 id=\"0x02-自动化设计\"><a href=\"#0x02-自动化设计\" class=\"headerlink\" title=\"0x02 自动化设计\"></a>0x02 自动化设计</h1><p>实现自动化首先想到的是Python，而且最近也学了不久，练练手也刚好。</p>\n<p>由于都是终端命令，所以要先实现让Python执行终端命令的方法：</p>\n<p>①通过<code>os.system</code>方法</p>\n<p>②通过<code>subprocess.Popen</code>方法</p>\n<p>通过使用发现都可以执行命令，但是如果命令分开执行，命令之间的前后结果不会关联起来，比如我第一个命令执行<code>cd /jenson/</code>，再执行第二个命令<code>pwd</code>时时发现路径仍然是旧路径。</p>\n<p>所以现在面临新的问题：多个命令一起执行。如何一起执行呢？</p>\n<p>其实上面①和②都支持多命令一起，譬如：</p>\n<p>如果多个命令共同执行，不管前一个命令是否成功，都要执行后一个则使用<strong>&amp;&amp;</strong>连接命令：</p>\n<ul>\n<li><code>os.system(&#39;cmd1 &amp;&amp; cmd2&#39;)</code></li>\n<li><code>subprocess.Popen(&#39;cmd1 &amp;&amp; cmd2&#39;, shell=True)</code></li>\n</ul>\n<p>如果前一个命令执行成功才执行后一个命令，则使用<strong>;</strong>连接：</p>\n<ul>\n<li><code>os.system(&#39;cmd1 ; cmd2&#39;)</code></li>\n<li><code>subprocess.Popen(&#39;cmd1 ; cmd2&#39;, shell=True)</code></li>\n</ul>\n<p>接下来代码实现：</p>\n<h1 id=\"0x03-自动化实现\"><a href=\"#0x03-自动化实现\" class=\"headerlink\" title=\"0x03 自动化实现\"></a>0x03 自动化实现</h1><p>创建<code>AutoCommit.py</code>文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> subprocess</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 跳转工作目录</span></div><div class=\"line\">to_path = <span class=\"string\">'cd ~/Downloads/hexo/'</span></div><div class=\"line\"><span class=\"comment\"># 发布命令</span></div><div class=\"line\">to_deploy = <span class=\"string\">'hexo d -g'</span></div><div class=\"line\"><span class=\"comment\"># git add命令</span></div><div class=\"line\">to_add = <span class=\"string\">'git add .'</span></div><div class=\"line\"><span class=\"comment\"># git commit命令</span></div><div class=\"line\">to_commit = <span class=\"string\">'git commit -m 新添加文章'</span> </div><div class=\"line\"><span class=\"comment\"># git push命令</span></div><div class=\"line\">to_push = <span class=\"string\">'git push origin hexoSource'</span></div><div class=\"line\">tmp = subprocess.Popen(to_path + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_deploy + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_add + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_commit + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                       to_push, shell=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>这就算完成了，运行<code>python3 AutoCommit.py</code>时候也能正常提交。</p>\n<p>但是这样感觉还能再完善些，继续改造：</p>\n<h1 id=\"0x04-自动化优化\"><a href=\"#0x04-自动化优化\" class=\"headerlink\" title=\"0x04 自动化优化\"></a>0x04 自动化优化</h1><p>首先关于git commit的信息，我想实现自定义，而不是每次都固定这几个内容，这样不容易区分每次版本提交了哪些内容。</p>\n<p>现在的初步想法是在终端执行<code>python3 AutoCommit.py</code>命令时，同时接收命令行参数作为提交的内容，比如这样<code>python3 AutoCommit.py  message</code>。</p>\n<p>Python文件要接收命令行参数，需要使用<code>sys</code>模块，接收参数：</p>\n<p><code>message = sys.argv[1]</code>。</p>\n<p>这里argv[0]表示脚本名，argv[1]开始才表示后面的参数</p>\n<p>同时接收message后判断是否为空，如果为空在使用默认提交信息，所以封装一个方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isNullMessage</span><span class=\"params\">(message)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    判断消息是否为空,如果为空赋默认值</div><div class=\"line\">    :param message:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> len(message.strip()) == <span class=\"number\">0</span>:</div><div class=\"line\">        message = <span class=\"string\">'提交新文章'</span></div><div class=\"line\">    <span class=\"keyword\">return</span> message</div></pre></td></tr></table></figure>\n<p>既然判断提交信息都封装到方法了，那么这一些列命令也应该封装到方法中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deployAndGitPush</span><span class=\"params\">(message)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    hexo静态页面发布和源码push git服务器</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"comment\"># 跳转工作目录</span></div><div class=\"line\">    to_path = <span class=\"string\">'cd ~/Downloads/hexo/'</span></div><div class=\"line\">    <span class=\"comment\"># 发布命令</span></div><div class=\"line\">    to_deploy = <span class=\"string\">'hexo d -g'</span></div><div class=\"line\">    <span class=\"comment\"># git add命令</span></div><div class=\"line\">    to_add = <span class=\"string\">'git add .'</span></div><div class=\"line\">    <span class=\"comment\"># git commit命令</span></div><div class=\"line\">    to_commit = <span class=\"string\">'git commit -m '</span> + message</div><div class=\"line\">    <span class=\"comment\"># git push命令</span></div><div class=\"line\">    to_push = <span class=\"string\">'git push origin hexoSource'</span></div><div class=\"line\">    tmp = subprocess.Popen(to_path + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_deploy + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_add + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_commit + <span class=\"string\">'&amp;&amp;'</span> +</div><div class=\"line\">                           to_push, shell=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<p>最终调用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">deployAndGitPush(message=isNullMessage(message=message))</div></pre></td></tr></table></figure>\n<p>OK，自动化优化完成。执行<code>python3 AutpCommit.py Android文章提交</code>。</p>\n"},{"title":"hexo文章tags添加多标签","date":"2017-07-01T05:52:19.000Z","_content":"\nhexo博客在给文章添加标签tags时，如果只添加一个，冒号后面空格跟上标签名称即可，\n\n但是如果想要添加多个标签，需要使用[tag1,tag2]格式来表示，\n\ncategories也同理。","source":"_posts/hexo文章tags添加多标签.md","raw":"---\ntitle: hexo文章tags添加多标签\ndate: 2017-07-1 13:52:19\ntags: 网络\ncategories: 网络\n---\n\nhexo博客在给文章添加标签tags时，如果只添加一个，冒号后面空格跟上标签名称即可，\n\n但是如果想要添加多个标签，需要使用[tag1,tag2]格式来表示，\n\ncategories也同理。","slug":"hexo文章tags添加多标签","published":1,"updated":"2017-07-19T05:55:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjgi004pwh9cnsm2dql9","content":"<p>hexo博客在给文章添加标签tags时，如果只添加一个，冒号后面空格跟上标签名称即可，</p>\n<p>但是如果想要添加多个标签，需要使用[tag1,tag2]格式来表示，</p>\n<p>categories也同理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hexo博客在给文章添加标签tags时，如果只添加一个，冒号后面空格跟上标签名称即可，</p>\n<p>但是如果想要添加多个标签，需要使用[tag1,tag2]格式来表示，</p>\n<p>categories也同理。</p>\n"},{"title":"osx下pip3安装matplotlib时 The following required packages can not be built freetype","date":"2017-04-22T10:55:54.000Z","_content":"'The following required packages can not be built: * freetype'\n出现这个提示，乍一看以为没有安装freetype的原因，后来找其安装方法。使用brew install freetype  ，有提示already installed。然后又看了很多文章，照着改了很多都没有办法。后来胡乱一通查找看到了这个[问答](http://stackoverflow.com/questions/12363557/matplotlib-install-failure-on-mac-osx-10-8-mountain-lion)\n```\nI think the other answers are on the right track, but I encountered this same problem and can attest that:\nbrew install pkg-config\nbrew install freetype\npip install matplotlib\n```\n上面意思说这哥们遇到过同样的问题，下面的能解决。所以试了下```brew install pkg-config```然后自动安装了，因为freetype已经提示安装了。最后又安装了一次```pip3 install matplotlib```成功了","source":"_posts/osx下pip3安装matplotlib时The following required packages can not be built freetype.md","raw":"---\ntitle: osx下pip3安装matplotlib时 The following required packages can not be built freetype\ndate: 2017-04-22 18:55:54\ntags: Python\ncategories: Python\n---\n'The following required packages can not be built: * freetype'\n出现这个提示，乍一看以为没有安装freetype的原因，后来找其安装方法。使用brew install freetype  ，有提示already installed。然后又看了很多文章，照着改了很多都没有办法。后来胡乱一通查找看到了这个[问答](http://stackoverflow.com/questions/12363557/matplotlib-install-failure-on-mac-osx-10-8-mountain-lion)\n```\nI think the other answers are on the right track, but I encountered this same problem and can attest that:\nbrew install pkg-config\nbrew install freetype\npip install matplotlib\n```\n上面意思说这哥们遇到过同样的问题，下面的能解决。所以试了下```brew install pkg-config```然后自动安装了，因为freetype已经提示安装了。最后又安装了一次```pip3 install matplotlib```成功了","slug":"osx下pip3安装matplotlib时The following required packages can not be built freetype","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjgp004swh9c5nzadn4q","content":"<p>‘The following required packages can not be built: * freetype’<br>出现这个提示，乍一看以为没有安装freetype的原因，后来找其安装方法。使用brew install freetype  ，有提示already installed。然后又看了很多文章，照着改了很多都没有办法。后来胡乱一通查找看到了这个<a href=\"http://stackoverflow.com/questions/12363557/matplotlib-install-failure-on-mac-osx-10-8-mountain-lion\" target=\"_blank\" rel=\"external\">问答</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">I think the other answers are on the right track, but I encountered this same problem and can attest that:</div><div class=\"line\">brew install pkg-config</div><div class=\"line\">brew install freetype</div><div class=\"line\">pip install matplotlib</div></pre></td></tr></table></figure></p>\n<p>上面意思说这哥们遇到过同样的问题，下面的能解决。所以试了下<code>brew install pkg-config</code>然后自动安装了，因为freetype已经提示安装了。最后又安装了一次<code>pip3 install matplotlib</code>成功了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>‘The following required packages can not be built: * freetype’<br>出现这个提示，乍一看以为没有安装freetype的原因，后来找其安装方法。使用brew install freetype  ，有提示already installed。然后又看了很多文章，照着改了很多都没有办法。后来胡乱一通查找看到了这个<a href=\"http://stackoverflow.com/questions/12363557/matplotlib-install-failure-on-mac-osx-10-8-mountain-lion\">问答</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">I think the other answers are on the right track, but I encountered this same problem and can attest that:</div><div class=\"line\">brew install pkg-config</div><div class=\"line\">brew install freetype</div><div class=\"line\">pip install matplotlib</div></pre></td></tr></table></figure></p>\n<p>上面意思说这哥们遇到过同样的问题，下面的能解决。所以试了下<code>brew install pkg-config</code>然后自动安装了，因为freetype已经提示安装了。最后又安装了一次<code>pip3 install matplotlib</code>成功了</p>\n"},{"title":"osx下如何使用SublimeText阅读Android系统源码","date":"2017-04-22T10:55:54.000Z","_content":"\n>以前用win系统时使用sourceinsight阅读源码方便至极，但是自从换到mac下，尝试了很多方法很多工具，比如understand、比如vscode、比如wine下安装sourceinsight。总是有各种问题，所以这次尝试使用SublimeText\n\n平时使用Sublimetext都是打开单个文件，这次要导入几万个文件，这在一些ide中称为project。同样在Sublime中也是如此。\n\n#### 1. 创建工程\n\n　　Project > Add Folder to Project 选择源码目录即可\n　　这时在\b窗口左边栏中将出现刚刚添加的文件目录，如果还需要添加其他目录，则重复这一操作即可。\n\n#### 2. 保存工程\n\n　　Project > Save Project As\n　　点击保存后Sublime Text将自动生成两个文件：\nproject_name.sumlime-project：包含工程定义，该文件会被记录到版本控制里。\nproject_name.sublim-workspace：包含了用户的工程数据，例如打开的文件和修改等，该文件不会被记录到版本控制里。\n　　在*.sublime-project文件中，你可以定义工程配置。例如你可以定义多个目录路径，或者哪些目录或文件需要排除在外。例如：\n　　以上*.sublime-project文件中定义了两个目录，而“name”标签是该目录在Sublime Text的\b左边栏中显示的名字。通过定义“name”，你可以将一些长路径或者名字很长的目录以更简洁的名称显示在\b左边栏中。\n\n#### 3、添加索引\n\n- 安装Package Control插件\n  1.打开控制台\n       方法1：View->show console \n       方法2：ctrl+~\n    2.输入代码：\n  python2.x代码:\n\n```\nimport urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())  \n```\npython3.x代码：\n\n```\nimport urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())\n```\n- 安装CTags\n  - 1. 首先 Preference -> Browser Packages... 查看是否已经安装了CTags Package，如果没有则继续下面步骤\n  - 2. Preference -> Package control, 输入“install package”，它会找出你可以安装的插件，在列表中选择ctag插件进行安装\n\n   - 3.创建索引\n  \n![屏幕快照 2017-03-22 下午2.55.23.png](http://upload-images.jianshu.io/upload_images/1796052-38f35a1199d9e85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 4、异常处理\n\n- 期间出现Package Control:There are no packages available for installation弹窗提示\n选择Preference->Browser Packages打开文件夹后\n删除Package Control目录、删除User目录下相关Package Control名称文件等，再次安装。\n- ctag rebuild时弹窗异常如图：\n\n![屏幕快照 2017-03-22 下午3.01.14.png](http://upload-images.jianshu.io/upload_images/1796052-ad6b9e4b667a7b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这是因为我们还没有安装和配置ctags\n下载ctags-5.8.tar.gz解压并编译，依次执行如下命令：\ntar xzvf ctags-5.8.tar.gz\ncd ctags-5.8\n./configure\nmake\nsudo make install\n打开Preference ->Package settings->ctags->settings-user和settings-default\n把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径/usr/local/bin/ctags（可以通过which ctags命令查看ctags路径）\n#### 5、快捷键\n- 修改跳转\n默认函数跳转：Ctrl+shift+左键; 跳转返回：Ctrl+shift+右键。修改方法：\n Perference->Package Settings->CTags->Mouse Binding Default->复制到Mouse Binding User，把里面的\"ctrl+shift\"，修改为“command”，这样就可以用“command+左键”跳转了：\n\n```\n        Command+P：查找文件\n        Command+R：查找方法\n        Command+左键：文件或函数跳转        \n        Command+右键：返回文件或函数跳转的原始位置\n```\n\n至此Android源码项目创建完成并创建索引，代码跳转也反应迅速。","source":"_posts/osx下如何使用SublimeText阅读Android系统源码.md","raw":"---\ntitle: osx下如何使用SublimeText阅读Android系统源码\ndate: 2017-04-22 18:55:54\ntags: 工具\ncategories: 工具\n---\n\n>以前用win系统时使用sourceinsight阅读源码方便至极，但是自从换到mac下，尝试了很多方法很多工具，比如understand、比如vscode、比如wine下安装sourceinsight。总是有各种问题，所以这次尝试使用SublimeText\n\n平时使用Sublimetext都是打开单个文件，这次要导入几万个文件，这在一些ide中称为project。同样在Sublime中也是如此。\n\n#### 1. 创建工程\n\n　　Project > Add Folder to Project 选择源码目录即可\n　　这时在\b窗口左边栏中将出现刚刚添加的文件目录，如果还需要添加其他目录，则重复这一操作即可。\n\n#### 2. 保存工程\n\n　　Project > Save Project As\n　　点击保存后Sublime Text将自动生成两个文件：\nproject_name.sumlime-project：包含工程定义，该文件会被记录到版本控制里。\nproject_name.sublim-workspace：包含了用户的工程数据，例如打开的文件和修改等，该文件不会被记录到版本控制里。\n　　在*.sublime-project文件中，你可以定义工程配置。例如你可以定义多个目录路径，或者哪些目录或文件需要排除在外。例如：\n　　以上*.sublime-project文件中定义了两个目录，而“name”标签是该目录在Sublime Text的\b左边栏中显示的名字。通过定义“name”，你可以将一些长路径或者名字很长的目录以更简洁的名称显示在\b左边栏中。\n\n#### 3、添加索引\n\n- 安装Package Control插件\n  1.打开控制台\n       方法1：View->show console \n       方法2：ctrl+~\n    2.输入代码：\n  python2.x代码:\n\n```\nimport urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())  \n```\npython3.x代码：\n\n```\nimport urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())\n```\n- 安装CTags\n  - 1. 首先 Preference -> Browser Packages... 查看是否已经安装了CTags Package，如果没有则继续下面步骤\n  - 2. Preference -> Package control, 输入“install package”，它会找出你可以安装的插件，在列表中选择ctag插件进行安装\n\n   - 3.创建索引\n  \n![屏幕快照 2017-03-22 下午2.55.23.png](http://upload-images.jianshu.io/upload_images/1796052-38f35a1199d9e85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 4、异常处理\n\n- 期间出现Package Control:There are no packages available for installation弹窗提示\n选择Preference->Browser Packages打开文件夹后\n删除Package Control目录、删除User目录下相关Package Control名称文件等，再次安装。\n- ctag rebuild时弹窗异常如图：\n\n![屏幕快照 2017-03-22 下午3.01.14.png](http://upload-images.jianshu.io/upload_images/1796052-ad6b9e4b667a7b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这是因为我们还没有安装和配置ctags\n下载ctags-5.8.tar.gz解压并编译，依次执行如下命令：\ntar xzvf ctags-5.8.tar.gz\ncd ctags-5.8\n./configure\nmake\nsudo make install\n打开Preference ->Package settings->ctags->settings-user和settings-default\n把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径/usr/local/bin/ctags（可以通过which ctags命令查看ctags路径）\n#### 5、快捷键\n- 修改跳转\n默认函数跳转：Ctrl+shift+左键; 跳转返回：Ctrl+shift+右键。修改方法：\n Perference->Package Settings->CTags->Mouse Binding Default->复制到Mouse Binding User，把里面的\"ctrl+shift\"，修改为“command”，这样就可以用“command+左键”跳转了：\n\n```\n        Command+P：查找文件\n        Command+R：查找方法\n        Command+左键：文件或函数跳转        \n        Command+右键：返回文件或函数跳转的原始位置\n```\n\n至此Android源码项目创建完成并创建索引，代码跳转也反应迅速。","slug":"osx下如何使用SublimeText阅读Android系统源码","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjgw004xwh9ctm499ko9","content":"<blockquote>\n<p>以前用win系统时使用sourceinsight阅读源码方便至极，但是自从换到mac下，尝试了很多方法很多工具，比如understand、比如vscode、比如wine下安装sourceinsight。总是有各种问题，所以这次尝试使用SublimeText</p>\n</blockquote>\n<p>平时使用Sublimetext都是打开单个文件，这次要导入几万个文件，这在一些ide中称为project。同样在Sublime中也是如此。</p>\n<h4 id=\"1-创建工程\"><a href=\"#1-创建工程\" class=\"headerlink\" title=\"1. 创建工程\"></a>1. 创建工程</h4><p>　　Project &gt; Add Folder to Project 选择源码目录即可<br>　　这时在\b窗口左边栏中将出现刚刚添加的文件目录，如果还需要添加其他目录，则重复这一操作即可。</p>\n<h4 id=\"2-保存工程\"><a href=\"#2-保存工程\" class=\"headerlink\" title=\"2. 保存工程\"></a>2. 保存工程</h4><p>　　Project &gt; Save Project As<br>　　点击保存后Sublime Text将自动生成两个文件：<br>project_name.sumlime-project：包含工程定义，该文件会被记录到版本控制里。<br>project_name.sublim-workspace：包含了用户的工程数据，例如打开的文件和修改等，该文件不会被记录到版本控制里。<br>　　在<em>.sublime-project文件中，你可以定义工程配置。例如你可以定义多个目录路径，或者哪些目录或文件需要排除在外。例如：<br>　　以上</em>.sublime-project文件中定义了两个目录，而“name”标签是该目录在Sublime Text的\b左边栏中显示的名字。通过定义“name”，你可以将一些长路径或者名字很长的目录以更简洁的名称显示在\b左边栏中。</p>\n<h4 id=\"3、添加索引\"><a href=\"#3、添加索引\" class=\"headerlink\" title=\"3、添加索引\"></a>3、添加索引</h4><ul>\n<li>安装Package Control插件<br>1.打开控制台<pre><code>方法1：View-&gt;show console \n方法2：ctrl+~\n</code></pre>  2.输入代码：<br>python2.x代码:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</div></pre></td></tr></table></figure>\n<p>python3.x代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</div></pre></td></tr></table></figure>\n<ul>\n<li><p>安装CTags</p>\n<ul>\n<li><ol>\n<li>首先 Preference -&gt; Browser Packages… 查看是否已经安装了CTags Package，如果没有则继续下面步骤</li>\n</ol>\n</li>\n<li><ol>\n<li>Preference -&gt; Package control, 输入“install package”，它会找出你可以安装的插件，在列表中选择ctag插件进行安装</li>\n</ol>\n<ul>\n<li>3.创建索引</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-38f35a1199d9e85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-22 下午2.55.23.png\"></p>\n<h4 id=\"4、异常处理\"><a href=\"#4、异常处理\" class=\"headerlink\" title=\"4、异常处理\"></a>4、异常处理</h4><ul>\n<li>期间出现Package Control:There are no packages available for installation弹窗提示<br>选择Preference-&gt;Browser Packages打开文件夹后<br>删除Package Control目录、删除User目录下相关Package Control名称文件等，再次安装。</li>\n<li>ctag rebuild时弹窗异常如图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-ad6b9e4b667a7b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-22 下午3.01.14.png\"></p>\n<p>这是因为我们还没有安装和配置ctags<br>下载ctags-5.8.tar.gz解压并编译，依次执行如下命令：<br>tar xzvf ctags-5.8.tar.gz<br>cd ctags-5.8<br>./configure<br>make<br>sudo make install<br>打开Preference -&gt;Package settings-&gt;ctags-&gt;settings-user和settings-default<br>把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径/usr/local/bin/ctags（可以通过which ctags命令查看ctags路径）</p>\n<h4 id=\"5、快捷键\"><a href=\"#5、快捷键\" class=\"headerlink\" title=\"5、快捷键\"></a>5、快捷键</h4><ul>\n<li>修改跳转<br>默认函数跳转：Ctrl+shift+左键; 跳转返回：Ctrl+shift+右键。修改方法：<br>Perference-&gt;Package Settings-&gt;CTags-&gt;Mouse Binding Default-&gt;复制到Mouse Binding User，把里面的”ctrl+shift”，修改为“command”，这样就可以用“command+左键”跳转了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command+P：查找文件</div><div class=\"line\">Command+R：查找方法</div><div class=\"line\">Command+左键：文件或函数跳转        </div><div class=\"line\">Command+右键：返回文件或函数跳转的原始位置</div></pre></td></tr></table></figure>\n<p>至此Android源码项目创建完成并创建索引，代码跳转也反应迅速。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>以前用win系统时使用sourceinsight阅读源码方便至极，但是自从换到mac下，尝试了很多方法很多工具，比如understand、比如vscode、比如wine下安装sourceinsight。总是有各种问题，所以这次尝试使用SublimeText</p>\n</blockquote>\n<p>平时使用Sublimetext都是打开单个文件，这次要导入几万个文件，这在一些ide中称为project。同样在Sublime中也是如此。</p>\n<h4 id=\"1-创建工程\"><a href=\"#1-创建工程\" class=\"headerlink\" title=\"1. 创建工程\"></a>1. 创建工程</h4><p>　　Project &gt; Add Folder to Project 选择源码目录即可<br>　　这时在\b窗口左边栏中将出现刚刚添加的文件目录，如果还需要添加其他目录，则重复这一操作即可。</p>\n<h4 id=\"2-保存工程\"><a href=\"#2-保存工程\" class=\"headerlink\" title=\"2. 保存工程\"></a>2. 保存工程</h4><p>　　Project &gt; Save Project As<br>　　点击保存后Sublime Text将自动生成两个文件：<br>project_name.sumlime-project：包含工程定义，该文件会被记录到版本控制里。<br>project_name.sublim-workspace：包含了用户的工程数据，例如打开的文件和修改等，该文件不会被记录到版本控制里。<br>　　在<em>.sublime-project文件中，你可以定义工程配置。例如你可以定义多个目录路径，或者哪些目录或文件需要排除在外。例如：<br>　　以上</em>.sublime-project文件中定义了两个目录，而“name”标签是该目录在Sublime Text的\b左边栏中显示的名字。通过定义“name”，你可以将一些长路径或者名字很长的目录以更简洁的名称显示在\b左边栏中。</p>\n<h4 id=\"3、添加索引\"><a href=\"#3、添加索引\" class=\"headerlink\" title=\"3、添加索引\"></a>3、添加索引</h4><ul>\n<li>安装Package Control插件<br>1.打开控制台<pre><code>方法1：View-&gt;show console \n方法2：ctrl+~\n</code></pre>  2.输入代码：<br>python2.x代码:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</div></pre></td></tr></table></figure>\n<p>python3.x代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</div></pre></td></tr></table></figure>\n<ul>\n<li><p>安装CTags</p>\n<ul>\n<li><ol>\n<li>首先 Preference -&gt; Browser Packages… 查看是否已经安装了CTags Package，如果没有则继续下面步骤</li>\n</ol>\n</li>\n<li><ol>\n<li>Preference -&gt; Package control, 输入“install package”，它会找出你可以安装的插件，在列表中选择ctag插件进行安装</li>\n</ol>\n<ul>\n<li>3.创建索引</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-38f35a1199d9e85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-22 下午2.55.23.png\"></p>\n<h4 id=\"4、异常处理\"><a href=\"#4、异常处理\" class=\"headerlink\" title=\"4、异常处理\"></a>4、异常处理</h4><ul>\n<li>期间出现Package Control:There are no packages available for installation弹窗提示<br>选择Preference-&gt;Browser Packages打开文件夹后<br>删除Package Control目录、删除User目录下相关Package Control名称文件等，再次安装。</li>\n<li>ctag rebuild时弹窗异常如图：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-ad6b9e4b667a7b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-22 下午3.01.14.png\"></p>\n<p>这是因为我们还没有安装和配置ctags<br>下载ctags-5.8.tar.gz解压并编译，依次执行如下命令：<br>tar xzvf ctags-5.8.tar.gz<br>cd ctags-5.8<br>./configure<br>make<br>sudo make install<br>打开Preference -&gt;Package settings-&gt;ctags-&gt;settings-user和settings-default<br>把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径/usr/local/bin/ctags（可以通过which ctags命令查看ctags路径）</p>\n<h4 id=\"5、快捷键\"><a href=\"#5、快捷键\" class=\"headerlink\" title=\"5、快捷键\"></a>5、快捷键</h4><ul>\n<li>修改跳转<br>默认函数跳转：Ctrl+shift+左键; 跳转返回：Ctrl+shift+右键。修改方法：<br>Perference-&gt;Package Settings-&gt;CTags-&gt;Mouse Binding Default-&gt;复制到Mouse Binding User，把里面的”ctrl+shift”，修改为“command”，这样就可以用“command+左键”跳转了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Command+P：查找文件</div><div class=\"line\">Command+R：查找方法</div><div class=\"line\">Command+左键：文件或函数跳转        </div><div class=\"line\">Command+右键：返回文件或函数跳转的原始位置</div></pre></td></tr></table></figure>\n<p>至此Android源码项目创建完成并创建索引，代码跳转也反应迅速。</p>\n"},{"title":"hexo添加网易云音乐播放器","date":"2017-07-14T06:47:05.000Z","_content":"\n# 0x00 拿到网易云音乐外链\n\n因为版权问题有一些音乐不能设置外链，所以要先找到合适的音乐，然后点击生成外链播放器，音乐界面如下：\n\n![音乐界面](hexo添加网易云音乐播放器/音乐界面.png)\n\n如果没有权限会弹出提示，如果有权限就会跳转对应页面[外链页面](http://music.163.com/#/outchain/2/114442/)。\n\n\n\n# 0x01 给文章添加播放器\n\n给文章添加外链很简单，直接复制上面的外链到x.md文件中即可。运行后就会在对应的发布后的文章中显示出播放器。\n\n\n\n# 0x02 给主题yilia添加播放器\n\n- 找到对应布局ejs文件添加外链\n\n  找到`theme/yilia/layout/_partial/left-col.ejs`文件，在末尾header标签前添加外链：\n\n  ```html\n  \t\t<!-- 添加网易云音乐插件-->\n  \t\t<nav class=\"header_music\">\n  \t\t\t<iframe frameborder=\"no\" border=\"0\" \tmarginwidth=\"0\" marginheight=\"0\" width=250 height=86 src=\"//music.163.com/outchain/player?type=2&id=114442&auto=0&height=66\"></iframe>\n  \t\t</nav>\n  \t</header>\n  ```\n\n  `auto=0`为关闭自动播放，`auto=1`为开启自动播放。\n\n- 找到对应css文件添加格式\n\n  找到`theme/yilia/source/main.266c1c.css`文件。如果你的目录下没有这个文件，那就在同目录下找到类似`main.xxx.css`文件。不同版本名称可能有不同，格式都一样。\n\n  在最后添加代码：\n\n  ```css\n  .header_music {\n    margin-top: 140px;\n  }\n\n  ```\n\n  最后如果当时没有刷新过来，\n\n  就执行`hexo clean`清除缓存，\n\n  然后在`hexo d -g`。","source":"_posts/hexo添加网易云音乐播放器.md","raw":"---\ntitle: hexo添加网易云音乐播放器\ndate: 2017-07-14 14:47:05\ntags: 网络\ncategories: 网络\n---\n\n# 0x00 拿到网易云音乐外链\n\n因为版权问题有一些音乐不能设置外链，所以要先找到合适的音乐，然后点击生成外链播放器，音乐界面如下：\n\n![音乐界面](hexo添加网易云音乐播放器/音乐界面.png)\n\n如果没有权限会弹出提示，如果有权限就会跳转对应页面[外链页面](http://music.163.com/#/outchain/2/114442/)。\n\n\n\n# 0x01 给文章添加播放器\n\n给文章添加外链很简单，直接复制上面的外链到x.md文件中即可。运行后就会在对应的发布后的文章中显示出播放器。\n\n\n\n# 0x02 给主题yilia添加播放器\n\n- 找到对应布局ejs文件添加外链\n\n  找到`theme/yilia/layout/_partial/left-col.ejs`文件，在末尾header标签前添加外链：\n\n  ```html\n  \t\t<!-- 添加网易云音乐插件-->\n  \t\t<nav class=\"header_music\">\n  \t\t\t<iframe frameborder=\"no\" border=\"0\" \tmarginwidth=\"0\" marginheight=\"0\" width=250 height=86 src=\"//music.163.com/outchain/player?type=2&id=114442&auto=0&height=66\"></iframe>\n  \t\t</nav>\n  \t</header>\n  ```\n\n  `auto=0`为关闭自动播放，`auto=1`为开启自动播放。\n\n- 找到对应css文件添加格式\n\n  找到`theme/yilia/source/main.266c1c.css`文件。如果你的目录下没有这个文件，那就在同目录下找到类似`main.xxx.css`文件。不同版本名称可能有不同，格式都一样。\n\n  在最后添加代码：\n\n  ```css\n  .header_music {\n    margin-top: 140px;\n  }\n\n  ```\n\n  最后如果当时没有刷新过来，\n\n  就执行`hexo clean`清除缓存，\n\n  然后在`hexo d -g`。","slug":"hexo添加网易云音乐播放器","published":1,"updated":"2017-07-14T07:10:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjgz0050wh9cn4ob401j","content":"<h1 id=\"0x00-拿到网易云音乐外链\"><a href=\"#0x00-拿到网易云音乐外链\" class=\"headerlink\" title=\"0x00 拿到网易云音乐外链\"></a>0x00 拿到网易云音乐外链</h1><p>因为版权问题有一些音乐不能设置外链，所以要先找到合适的音乐，然后点击生成外链播放器，音乐界面如下：</p>\n<p><img src=\"/2017/07/14/hexo添加网易云音乐播放器/音乐界面.png\" alt=\"音乐界面\"></p>\n<p>如果没有权限会弹出提示，如果有权限就会跳转对应页面<a href=\"http://music.163.com/#/outchain/2/114442/\" target=\"_blank\" rel=\"external\">外链页面</a>。</p>\n<h1 id=\"0x01-给文章添加播放器\"><a href=\"#0x01-给文章添加播放器\" class=\"headerlink\" title=\"0x01 给文章添加播放器\"></a>0x01 给文章添加播放器</h1><p>给文章添加外链很简单，直接复制上面的外链到x.md文件中即可。运行后就会在对应的发布后的文章中显示出播放器。</p>\n<h1 id=\"0x02-给主题yilia添加播放器\"><a href=\"#0x02-给主题yilia添加播放器\" class=\"headerlink\" title=\"0x02 给主题yilia添加播放器\"></a>0x02 给主题yilia添加播放器</h1><ul>\n<li><p>找到对应布局ejs文件添加外链</p>\n<p>找到<code>theme/yilia/layout/_partial/left-col.ejs</code>文件，在末尾header标签前添加外链：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"comment\">&lt;!-- 添加网易云音乐插件--&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header_music\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"0\"</span> \t<span class=\"attr\">marginwidth</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginheight</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">width</span>=<span class=\"string\">250</span> <span class=\"attr\">height</span>=<span class=\"string\">86</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//music.163.com/outchain/player?type=2&amp;id=114442&amp;auto=0&amp;height=66\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>auto=0</code>为关闭自动播放，<code>auto=1</code>为开启自动播放。</p>\n</li>\n<li><p>找到对应css文件添加格式</p>\n<p>找到<code>theme/yilia/source/main.266c1c.css</code>文件。如果你的目录下没有这个文件，那就在同目录下找到类似<code>main.xxx.css</code>文件。不同版本名称可能有不同，格式都一样。</p>\n<p>在最后添加代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.header_music</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">140px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后如果当时没有刷新过来，</p>\n<p>就执行<code>hexo clean</code>清除缓存，</p>\n<p>然后在<code>hexo d -g</code>。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-拿到网易云音乐外链\"><a href=\"#0x00-拿到网易云音乐外链\" class=\"headerlink\" title=\"0x00 拿到网易云音乐外链\"></a>0x00 拿到网易云音乐外链</h1><p>因为版权问题有一些音乐不能设置外链，所以要先找到合适的音乐，然后点击生成外链播放器，音乐界面如下：</p>\n<p><img src=\"/2017/07/14/hexo添加网易云音乐播放器/音乐界面.png\" alt=\"音乐界面\"></p>\n<p>如果没有权限会弹出提示，如果有权限就会跳转对应页面<a href=\"http://music.163.com/#/outchain/2/114442/\">外链页面</a>。</p>\n<h1 id=\"0x01-给文章添加播放器\"><a href=\"#0x01-给文章添加播放器\" class=\"headerlink\" title=\"0x01 给文章添加播放器\"></a>0x01 给文章添加播放器</h1><p>给文章添加外链很简单，直接复制上面的外链到x.md文件中即可。运行后就会在对应的发布后的文章中显示出播放器。</p>\n<h1 id=\"0x02-给主题yilia添加播放器\"><a href=\"#0x02-给主题yilia添加播放器\" class=\"headerlink\" title=\"0x02 给主题yilia添加播放器\"></a>0x02 给主题yilia添加播放器</h1><ul>\n<li><p>找到对应布局ejs文件添加外链</p>\n<p>找到<code>theme/yilia/layout/_partial/left-col.ejs</code>文件，在末尾header标签前添加外链：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t<span class=\"comment\">&lt;!-- 添加网易云音乐插件--&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header_music\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"0\"</span> \t<span class=\"attr\">marginwidth</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginheight</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">width</span>=<span class=\"string\">250</span> <span class=\"attr\">height</span>=<span class=\"string\">86</span> <span class=\"attr\">src</span>=<span class=\"string\">\"//music.163.com/outchain/player?type=2&amp;id=114442&amp;auto=0&amp;height=66\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>auto=0</code>为关闭自动播放，<code>auto=1</code>为开启自动播放。</p>\n</li>\n<li><p>找到对应css文件添加格式</p>\n<p>找到<code>theme/yilia/source/main.266c1c.css</code>文件。如果你的目录下没有这个文件，那就在同目录下找到类似<code>main.xxx.css</code>文件。不同版本名称可能有不同，格式都一样。</p>\n<p>在最后添加代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.header_music</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">140px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后如果当时没有刷新过来，</p>\n<p>就执行<code>hexo clean</code>清除缓存，</p>\n<p>然后在<code>hexo d -g</code>。</p>\n</li>\n</ul>\n"},{"title":"hexo本地图片发布后不能显示的问题","date":"2017-04-25T07:16:33.000Z","_content":"\n# 说在前面的话\n\n工作好几年，终于花了点时间搞了个自己的网站，基于Hexo+Github+个性域名，玩的不亦乐乎。但是这两天发现个问题比较蛋疼。就是Hexo基于MarkDown文本的。如果在写文章时想加入图片，如果你的图片来自其他网站，那么当你发布后是没有问题的，因为其url就是那个图片网址。但是如果你的图片来自你的本地、这样在你预览时是没有问题的，但是细心看下就会发现，markdown中的本地图片是url地址是本地地址。这样如果你发布文章后，别人肯定是看不到你的图片的。这样体验很不好。最开始的想法就是先在简书发布，发布后图片url都是来自简书网站url，而非本地，这样是没问题的，但是这样自己的网站显示个图片还要依赖简书平台，可能代码写多了，总感觉耦合性太强啊~~所以就在找怎么把两个平台独立开来，而自己网站又能发布图片的方法。\n\n经过查找发现hexo-asset-image插件可以比较好的支持本地图片发布。\n\n# 开启资源文件支持\n\n在hexo目录下的_config.yml配置文件中找到这个配置：\n\n```\npost_asset_folder: false\n```\n\n把这里的false改为true。开启hexo的媒体文件支持。\n\n# 安装插件\n\n在命令行中，跳转到hexo目录下，执行：\n\n```\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n会自动安装插件，插件会安装到node_moudules目录下，![屏幕快照 2017-04-25 下午3.33.13](hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.33.13.png)\n\n同时还会自动在hexo目录下package.json中添加一行：\n\n```\n\"hexo-asset-image\": \"git+https://github.com/CodeFalling/hexo-asset-image.git\",\n```\n\n> 说这些就是想告诉你，不用的时候如何卸载：删掉那个文件夹和那一行就行了。\n\n以上执行完毕后，在命令行执行：hexo new \"文件\"时，会在_post文件夹下同时生成md文件和同名文件夹，这个同名文件夹就是用来放图片的，把你在该文章中需要显示的图片放进去，然后在markdown中选择该目录下的图片使用，这样当md编译生成html文件时，会把图片拷贝到html文件同目录中。最后执行hexo d -g 部署到服务器时，图片也就被部署到服务器中了。\n\n\n\n注意：如果直接把图片拖动到markdown编辑器中，其路径可能为绝对路径，需要改下：\n\n![屏幕快照 2017-04-25 下午3.34.46](hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.34.46.png)\n\n修改为相对路径：\n\n![屏幕快照 2017-04-25 下午3.45.37](hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.45.37.png)\n\n\n\n# 结尾\n\n上面说了hexo new \"名称\" ，这样每次同时生成文件和文件夹，当然也可以不使用命令行，直接在_post目录下手动创建md文件和文件夹亦可，手动创建的好处时如果你的文章不需要图片，那么你可以不创建对应的文件夹。","source":"_posts/hexo本地图片发布后不能显示的问题.md","raw":"---\ntitle: hexo本地图片发布后不能显示的问题\ndate: 2017-04-25 15:16:33\ntags: 网络\ncategories: 网络\n---\n\n# 说在前面的话\n\n工作好几年，终于花了点时间搞了个自己的网站，基于Hexo+Github+个性域名，玩的不亦乐乎。但是这两天发现个问题比较蛋疼。就是Hexo基于MarkDown文本的。如果在写文章时想加入图片，如果你的图片来自其他网站，那么当你发布后是没有问题的，因为其url就是那个图片网址。但是如果你的图片来自你的本地、这样在你预览时是没有问题的，但是细心看下就会发现，markdown中的本地图片是url地址是本地地址。这样如果你发布文章后，别人肯定是看不到你的图片的。这样体验很不好。最开始的想法就是先在简书发布，发布后图片url都是来自简书网站url，而非本地，这样是没问题的，但是这样自己的网站显示个图片还要依赖简书平台，可能代码写多了，总感觉耦合性太强啊~~所以就在找怎么把两个平台独立开来，而自己网站又能发布图片的方法。\n\n经过查找发现hexo-asset-image插件可以比较好的支持本地图片发布。\n\n# 开启资源文件支持\n\n在hexo目录下的_config.yml配置文件中找到这个配置：\n\n```\npost_asset_folder: false\n```\n\n把这里的false改为true。开启hexo的媒体文件支持。\n\n# 安装插件\n\n在命令行中，跳转到hexo目录下，执行：\n\n```\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n会自动安装插件，插件会安装到node_moudules目录下，![屏幕快照 2017-04-25 下午3.33.13](hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.33.13.png)\n\n同时还会自动在hexo目录下package.json中添加一行：\n\n```\n\"hexo-asset-image\": \"git+https://github.com/CodeFalling/hexo-asset-image.git\",\n```\n\n> 说这些就是想告诉你，不用的时候如何卸载：删掉那个文件夹和那一行就行了。\n\n以上执行完毕后，在命令行执行：hexo new \"文件\"时，会在_post文件夹下同时生成md文件和同名文件夹，这个同名文件夹就是用来放图片的，把你在该文章中需要显示的图片放进去，然后在markdown中选择该目录下的图片使用，这样当md编译生成html文件时，会把图片拷贝到html文件同目录中。最后执行hexo d -g 部署到服务器时，图片也就被部署到服务器中了。\n\n\n\n注意：如果直接把图片拖动到markdown编辑器中，其路径可能为绝对路径，需要改下：\n\n![屏幕快照 2017-04-25 下午3.34.46](hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.34.46.png)\n\n修改为相对路径：\n\n![屏幕快照 2017-04-25 下午3.45.37](hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.45.37.png)\n\n\n\n# 结尾\n\n上面说了hexo new \"名称\" ，这样每次同时生成文件和文件夹，当然也可以不使用命令行，直接在_post目录下手动创建md文件和文件夹亦可，手动创建的好处时如果你的文章不需要图片，那么你可以不创建对应的文件夹。","slug":"hexo本地图片发布后不能显示的问题","published":1,"updated":"2017-04-25T08:18:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjh30054wh9c880ff3xc","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>工作好几年，终于花了点时间搞了个自己的网站，基于Hexo+Github+个性域名，玩的不亦乐乎。但是这两天发现个问题比较蛋疼。就是Hexo基于MarkDown文本的。如果在写文章时想加入图片，如果你的图片来自其他网站，那么当你发布后是没有问题的，因为其url就是那个图片网址。但是如果你的图片来自你的本地、这样在你预览时是没有问题的，但是细心看下就会发现，markdown中的本地图片是url地址是本地地址。这样如果你发布文章后，别人肯定是看不到你的图片的。这样体验很不好。最开始的想法就是先在简书发布，发布后图片url都是来自简书网站url，而非本地，这样是没问题的，但是这样自己的网站显示个图片还要依赖简书平台，可能代码写多了，总感觉耦合性太强啊~~所以就在找怎么把两个平台独立开来，而自己网站又能发布图片的方法。</p>\n<p>经过查找发现hexo-asset-image插件可以比较好的支持本地图片发布。</p>\n<h1 id=\"开启资源文件支持\"><a href=\"#开启资源文件支持\" class=\"headerlink\" title=\"开启资源文件支持\"></a>开启资源文件支持</h1><p>在hexo目录下的_config.yml配置文件中找到这个配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">post_asset_folder: false</div></pre></td></tr></table></figure>\n<p>把这里的false改为true。开启hexo的媒体文件支持。</p>\n<h1 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h1><p>在命令行中，跳转到hexo目录下，执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install https://github.com/CodeFalling/hexo-asset-image --save</div></pre></td></tr></table></figure>\n<p>会自动安装插件，插件会安装到node_moudules目录下，<img src=\"/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.33.13.png\" alt=\"屏幕快照 2017-04-25 下午3.33.13\"></p>\n<p>同时还会自动在hexo目录下package.json中添加一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;hexo-asset-image&quot;: &quot;git+https://github.com/CodeFalling/hexo-asset-image.git&quot;,</div></pre></td></tr></table></figure>\n<blockquote>\n<p>说这些就是想告诉你，不用的时候如何卸载：删掉那个文件夹和那一行就行了。</p>\n</blockquote>\n<p>以上执行完毕后，在命令行执行：hexo new “文件”时，会在_post文件夹下同时生成md文件和同名文件夹，这个同名文件夹就是用来放图片的，把你在该文章中需要显示的图片放进去，然后在markdown中选择该目录下的图片使用，这样当md编译生成html文件时，会把图片拷贝到html文件同目录中。最后执行hexo d -g 部署到服务器时，图片也就被部署到服务器中了。</p>\n<p>注意：如果直接把图片拖动到markdown编辑器中，其路径可能为绝对路径，需要改下：</p>\n<p><img src=\"/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.34.46.png\" alt=\"屏幕快照 2017-04-25 下午3.34.46\"></p>\n<p>修改为相对路径：</p>\n<p><img src=\"/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.45.37.png\" alt=\"屏幕快照 2017-04-25 下午3.45.37\"></p>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>上面说了hexo new “名称” ，这样每次同时生成文件和文件夹，当然也可以不使用命令行，直接在_post目录下手动创建md文件和文件夹亦可，手动创建的好处时如果你的文章不需要图片，那么你可以不创建对应的文件夹。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>工作好几年，终于花了点时间搞了个自己的网站，基于Hexo+Github+个性域名，玩的不亦乐乎。但是这两天发现个问题比较蛋疼。就是Hexo基于MarkDown文本的。如果在写文章时想加入图片，如果你的图片来自其他网站，那么当你发布后是没有问题的，因为其url就是那个图片网址。但是如果你的图片来自你的本地、这样在你预览时是没有问题的，但是细心看下就会发现，markdown中的本地图片是url地址是本地地址。这样如果你发布文章后，别人肯定是看不到你的图片的。这样体验很不好。最开始的想法就是先在简书发布，发布后图片url都是来自简书网站url，而非本地，这样是没问题的，但是这样自己的网站显示个图片还要依赖简书平台，可能代码写多了，总感觉耦合性太强啊~~所以就在找怎么把两个平台独立开来，而自己网站又能发布图片的方法。</p>\n<p>经过查找发现hexo-asset-image插件可以比较好的支持本地图片发布。</p>\n<h1 id=\"开启资源文件支持\"><a href=\"#开启资源文件支持\" class=\"headerlink\" title=\"开启资源文件支持\"></a>开启资源文件支持</h1><p>在hexo目录下的_config.yml配置文件中找到这个配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">post_asset_folder: false</div></pre></td></tr></table></figure>\n<p>把这里的false改为true。开启hexo的媒体文件支持。</p>\n<h1 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h1><p>在命令行中，跳转到hexo目录下，执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install https://github.com/CodeFalling/hexo-asset-image --save</div></pre></td></tr></table></figure>\n<p>会自动安装插件，插件会安装到node_moudules目录下，<img src=\"/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.33.13.png\" alt=\"屏幕快照 2017-04-25 下午3.33.13\"></p>\n<p>同时还会自动在hexo目录下package.json中添加一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;hexo-asset-image&quot;: &quot;git+https://github.com/CodeFalling/hexo-asset-image.git&quot;,</div></pre></td></tr></table></figure>\n<blockquote>\n<p>说这些就是想告诉你，不用的时候如何卸载：删掉那个文件夹和那一行就行了。</p>\n</blockquote>\n<p>以上执行完毕后，在命令行执行：hexo new “文件”时，会在_post文件夹下同时生成md文件和同名文件夹，这个同名文件夹就是用来放图片的，把你在该文章中需要显示的图片放进去，然后在markdown中选择该目录下的图片使用，这样当md编译生成html文件时，会把图片拷贝到html文件同目录中。最后执行hexo d -g 部署到服务器时，图片也就被部署到服务器中了。</p>\n<p>注意：如果直接把图片拖动到markdown编辑器中，其路径可能为绝对路径，需要改下：</p>\n<p><img src=\"/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.34.46.png\" alt=\"屏幕快照 2017-04-25 下午3.34.46\"></p>\n<p>修改为相对路径：</p>\n<p><img src=\"/2017/04/25/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.45.37.png\" alt=\"屏幕快照 2017-04-25 下午3.45.37\"></p>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>上面说了hexo new “名称” ，这样每次同时生成文件和文件夹，当然也可以不使用命令行，直接在_post目录下手动创建md文件和文件夹亦可，手动创建的好处时如果你的文章不需要图片，那么你可以不创建对应的文件夹。</p>\n"},{"title":"Python读取文件出现UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc9 in position 0: invalid continuation byte异常","date":"2017-07-29T11:00:48.000Z","_content":"\n# 前言\n\n在用python读取文本时出现了如下异常：\n\n`UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte`。\n\n\n\n在读取的时候注意统一编码，因为文本文档设置的时GBK，\n\n所以读取的时候也要设置GBK，而没有设置时默认使用的UTF-8。\n\n```python\ntext_from_file_with_apath = open('/Users/jenson/Downloads/炮灰修仙记事.txt',encoding='GBK').read()\n\n```\n\n**读取时设置统一编码即可**\n\n\n\n","source":"_posts/Python读取文件出现UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte异常.md","raw":"---\ntitle: >-\n  Python读取文件出现UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc9 in\n  position 0: invalid continuation byte异常\ndate: 2017-07-29 19:00:48\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n在用python读取文本时出现了如下异常：\n\n`UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte`。\n\n\n\n在读取的时候注意统一编码，因为文本文档设置的时GBK，\n\n所以读取的时候也要设置GBK，而没有设置时默认使用的UTF-8。\n\n```python\ntext_from_file_with_apath = open('/Users/jenson/Downloads/炮灰修仙记事.txt',encoding='GBK').read()\n\n```\n\n**读取时设置统一编码即可**\n\n\n\n","slug":"Python读取文件出现UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte异常","published":1,"updated":"2017-08-02T11:14:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjh60058wh9ceer6nz7b","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在用python读取文本时出现了如下异常：</p>\n<p><code>UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte</code>。</p>\n<p>在读取的时候注意统一编码，因为文本文档设置的时GBK，</p>\n<p>所以读取的时候也要设置GBK，而没有设置时默认使用的UTF-8。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">text_from_file_with_apath = open(<span class=\"string\">'/Users/jenson/Downloads/炮灰修仙记事.txt'</span>,encoding=<span class=\"string\">'GBK'</span>).read()</div></pre></td></tr></table></figure>\n<p><strong>读取时设置统一编码即可</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在用python读取文本时出现了如下异常：</p>\n<p><code>UnicodeDecodeError-utf-8-codec-can-t-decode-byte-0xc9-in-position-0-invalid-continuation-byte</code>。</p>\n<p>在读取的时候注意统一编码，因为文本文档设置的时GBK，</p>\n<p>所以读取的时候也要设置GBK，而没有设置时默认使用的UTF-8。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">text_from_file_with_apath = open(<span class=\"string\">'/Users/jenson/Downloads/炮灰修仙记事.txt'</span>,encoding=<span class=\"string\">'GBK'</span>).read()</div></pre></td></tr></table></figure>\n<p><strong>读取时设置统一编码即可</strong></p>\n"},{"title":"pycharm黄线问题","date":"2017-04-22T10:55:54.000Z","_content":"如下图打开文件时出现很多黄色波浪警告的线条让人眼花缭乱。\n![屏幕快照 2017-01-08 下午2.29.57.png](http://upload-images.jianshu.io/upload_images/1796052-f36e7a1fd5ffa11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开pycharm的设置然后找到Editor->Colors & Fonts ->  General.在右边找到警告线类型，点击后会自动选中对应的文本提示。\n![屏幕快照 2017-01-08 下午2.32.01.png](http://upload-images.jianshu.io/upload_images/1796052-a5f70acfb13e6fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n图中可以看到weak waring 去掉effects的勾选保存即可。搞定！","source":"_posts/pycharm黄线问题.md","raw":"---\ntitle: pycharm黄线问题\ndate: 2017-04-22 18:55:54\ntags: Python\ncategories: Python\n---\n如下图打开文件时出现很多黄色波浪警告的线条让人眼花缭乱。\n![屏幕快照 2017-01-08 下午2.29.57.png](http://upload-images.jianshu.io/upload_images/1796052-f36e7a1fd5ffa11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开pycharm的设置然后找到Editor->Colors & Fonts ->  General.在右边找到警告线类型，点击后会自动选中对应的文本提示。\n![屏幕快照 2017-01-08 下午2.32.01.png](http://upload-images.jianshu.io/upload_images/1796052-a5f70acfb13e6fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n图中可以看到weak waring 去掉effects的勾选保存即可。搞定！","slug":"pycharm黄线问题","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjha005bwh9ccca1ktm0","content":"<p>如下图打开文件时出现很多黄色波浪警告的线条让人眼花缭乱。<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-f36e7a1fd5ffa11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-08 下午2.29.57.png\"></p>\n<p>打开pycharm的设置然后找到Editor-&gt;Colors &amp; Fonts -&gt;  General.在右边找到警告线类型，点击后会自动选中对应的文本提示。<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a5f70acfb13e6fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-08 下午2.32.01.png\"><br>图中可以看到weak waring 去掉effects的勾选保存即可。搞定！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如下图打开文件时出现很多黄色波浪警告的线条让人眼花缭乱。<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-f36e7a1fd5ffa11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-08 下午2.29.57.png\"></p>\n<p>打开pycharm的设置然后找到Editor-&gt;Colors &amp; Fonts -&gt;  General.在右边找到警告线类型，点击后会自动选中对应的文本提示。<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a5f70acfb13e6fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-08 下午2.32.01.png\"><br>图中可以看到weak waring 去掉effects的勾选保存即可。搞定！</p>\n"},{"title":"osx如何安装Homrbrew","date":"2017-04-22T10:55:54.000Z","_content":"- 1.homebrew依赖于xcode，所以在终端先执行 ```xcode-select --install``` 期间弹窗一直确定即可，根据网络速度不同，可能稍有延迟\n\n- 2.上一步完成了，终端继续输入\n```ruby -e \"$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)\"```直到看到终端中显示install successful字样\n- 3.执行执行```brew help```看是否有提示\n","source":"_posts/osx如何安装Homrbrew.md","raw":"---\ntitle: osx如何安装Homrbrew\ndate: 2017-04-22 18:55:54\ntags: Python\ncategories: Python\n---\n- 1.homebrew依赖于xcode，所以在终端先执行 ```xcode-select --install``` 期间弹窗一直确定即可，根据网络速度不同，可能稍有延迟\n\n- 2.上一步完成了，终端继续输入\n```ruby -e \"$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)\"```直到看到终端中显示install successful字样\n- 3.执行执行```brew help```看是否有提示\n","slug":"osx如何安装Homrbrew","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjhj005gwh9c8bhgj2l9","content":"<ul>\n<li><p>1.homebrew依赖于xcode，所以在终端先执行 <code>xcode-select --install</code> 期间弹窗一直确定即可，根据网络速度不同，可能稍有延迟</p>\n</li>\n<li><p>2.上一步完成了，终端继续输入<br><code>ruby -e &quot;$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>直到看到终端中显示install successful字样</p>\n</li>\n<li>3.执行执行<code>brew help</code>看是否有提示</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>1.homebrew依赖于xcode，所以在终端先执行 <code>xcode-select --install</code> 期间弹窗一直确定即可，根据网络速度不同，可能稍有延迟</p>\n</li>\n<li><p>2.上一步完成了，终端继续输入<br><code>ruby -e &quot;$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>直到看到终端中显示install successful字样</p>\n</li>\n<li>3.执行执行<code>brew help</code>看是否有提示</li>\n</ul>\n"},{"title":"为什么我在工作线程刷新UI没报错？","date":"2017-04-21T12:55:54.000Z","_content":"\n>从做Android开发以来就一直被灌输“只能在主线程刷新UI”的思想，但是这两天发现个问题，在onCreate中创建工作线程并刷新UI没有报错。代码是这样的：\n\n```\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n       final TextView tv = (TextView) findViewById(R.id.sample_text);\n       new Thread(new Runnable() {\n           @Override\n           public void run() {\n               tv.setText(\"来自\"+Thread.currentThread().getName()+\"线程的更新\");\n           }\n       }).start();\n    }\n```\n期待已久的crash没有出现，反而页面是这样显示的：\n\n![屏幕快照 2017-03-26 下午7.14.46.png](http://upload-images.jianshu.io/upload_images/1796052-7be6319d0fc94867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不禁让人陷入深思···\n![思考.jpg](http://upload-images.jianshu.io/upload_images/1796052-8a0ce88639c31d1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第一步，分析问题原因。以前工作线程刷新UI会出现异常并提示只能在UI线程刷新UI。所以假设有个地方(函数)会在刷新UI前判断当前线程是不是主线程，那么现在问题就是验证下是否真的存在这么个地方。问题是从setText引起的，那就从这里出发看看。\n点进去看下发现又调用了其重载函数：\n```\n    @android.view.RemotableViewMethod\n    public final void setText(CharSequence text) {\n        setText(text, mBufferType);\n    }\n```\n继续深入发现这个方法代码挺多的，但是不用过于关注细节，粗略浏览下不难发现前面大部分代码大多是对text文本格式的一些处理判断，无关刷新UI，直到            checkForRelayout()方法执行，从名字看是“从新布局”，根据view绘制流程测量、布局、绘制，那布局完了不是就绘制刷新了吗？所以决定去checkForRelayout方法看看。\n\n```\n    private void setText(CharSequence text, BufferType type,\n                         boolean notifyBefore, int oldlen) {\n        if (text == null) {\n            text = \"\";\n        }\n\n        // If suggestions are not enabled, remove the suggestion spans from the text\n        if (!isSuggestionsEnabled()) {\n            text = removeSuggestionSpans(text);\n        }\n\n        if (!mUserSetTextScaleX) mTextPaint.setTextScaleX(1.0f);\n\n        if (text instanceof Spanned &&\n            ((Spanned) text).getSpanStart(TextUtils.TruncateAt.MARQUEE) >= 0) {\n            if (ViewConfiguration.get(mContext).isFadingMarqueeEnabled()) {\n                setHorizontalFadingEdgeEnabled(true);\n                mMarqueeFadeMode = MARQUEE_FADE_NORMAL;\n            } else {\n                setHorizontalFadingEdgeEnabled(false);\n                mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;\n            }\n            setEllipsize(TextUtils.TruncateAt.MARQUEE);\n        }\n\n        int n = mFilters.length;\n        for (int i = 0; i < n; i++) {\n            CharSequence out = mFilters[i].filter(text, 0, text.length(), EMPTY_SPANNED, 0, 0);\n            if (out != null) {\n                text = out;\n            }\n        }\n\n        if (notifyBefore) {\n            if (mText != null) {\n                oldlen = mText.length();\n                sendBeforeTextChanged(mText, 0, oldlen, text.length());\n            } else {\n                sendBeforeTextChanged(\"\", 0, 0, text.length());\n            }\n        }\n\n        boolean needEditableForNotification = false;\n\n        if (mListeners != null && mListeners.size() != 0) {\n            needEditableForNotification = true;\n        }\n\n        if (type == BufferType.EDITABLE || getKeyListener() != null ||\n                needEditableForNotification) {\n            createEditorIfNeeded();\n            Editable t = mEditableFactory.newEditable(text);\n            text = t;\n            setFilters(t, mFilters);\n            InputMethodManager imm = InputMethodManager.peekInstance();\n            if (imm != null) imm.restartInput(this);\n        } else if (type == BufferType.SPANNABLE || mMovement != null) {\n            text = mSpannableFactory.newSpannable(text);\n        } else if (!(text instanceof CharWrapper)) {\n            text = TextUtils.stringOrSpannedString(text);\n        }\n\n        if (mAutoLinkMask != 0) {\n            Spannable s2;\n\n            if (type == BufferType.EDITABLE || text instanceof Spannable) {\n                s2 = (Spannable) text;\n            } else {\n                s2 = mSpannableFactory.newSpannable(text);\n            }\n\n            if (Linkify.addLinks(s2, mAutoLinkMask)) {\n                text = s2;\n                type = (type == BufferType.EDITABLE) ? BufferType.EDITABLE : BufferType.SPANNABLE;\n\n                /*\n                 * We must go ahead and set the text before changing the\n                 * movement method, because setMovementMethod() may call\n                 * setText() again to try to upgrade the buffer type.\n                 */\n                mText = text;\n\n                // Do not change the movement method for text that support text selection as it\n                // would prevent an arbitrary cursor displacement.\n                if (mLinksClickable && !textCanBeSelected()) {\n                    setMovementMethod(LinkMovementMethod.getInstance());\n                }\n            }\n        }\n\n        mBufferType = type;\n        mText = text;\n\n        if (mTransformation == null) {\n            mTransformed = text;\n        } else {\n            mTransformed = mTransformation.getTransformation(text, this);\n        }\n\n        final int textLength = text.length();\n\n        if (text instanceof Spannable && !mAllowTransformationLengthChange) {\n            Spannable sp = (Spannable) text;\n\n            // Remove any ChangeWatchers that might have come from other TextViews.\n            final ChangeWatcher[] watchers = sp.getSpans(0, sp.length(), ChangeWatcher.class);\n            final int count = watchers.length;\n            for (int i = 0; i < count; i++) {\n                sp.removeSpan(watchers[i]);\n            }\n\n            if (mChangeWatcher == null) mChangeWatcher = new ChangeWatcher();\n\n            sp.setSpan(mChangeWatcher, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE |\n                       (CHANGE_WATCHER_PRIORITY << Spanned.SPAN_PRIORITY_SHIFT));\n\n            if (mEditor != null) mEditor.addSpanWatchers(sp);\n\n            if (mTransformation != null) {\n                sp.setSpan(mTransformation, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE);\n            }\n\n            if (mMovement != null) {\n                mMovement.initialize(this, (Spannable) text);\n\n                /*\n                 * Initializing the movement method will have set the\n                 * selection, so reset mSelectionMoved to keep that from\n                 * interfering with the normal on-focus selection-setting.\n                 */\n                if (mEditor != null) mEditor.mSelectionMoved = false;\n            }\n        }\n\n        if (mLayout != null) {\n            checkForRelayout();\n        }\n\n        sendOnTextChanged(text, 0, oldlen, textLength);\n        onTextChanged(text, 0, oldlen, textLength);\n\n        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT);\n\n        if (needEditableForNotification) {\n            sendAfterTextChanged((Editable) text);\n        }\n\n        // SelectionModifierCursorController depends on textCanBeSelected, which depends on text\n        if (mEditor != null) mEditor.prepareCursorControllers();\n    }\n```\n\n找到checkForRelayout方法查看：\n\n```\n    private void checkForRelayout() {\n        // If we have a fixed width, we can just swap in a new text layout\n        // if the text height stays the same or if the view height is fixed.\n\n        if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT ||\n                (mMaxWidthMode == mMinWidthMode && mMaxWidth == mMinWidth)) &&\n                (mHint == null || mHintLayout != null) &&\n                (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() > 0)) {\n            // Static width, so try making a new text layout.\n\n            int oldht = mLayout.getHeight();\n            int want = mLayout.getWidth();\n            int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth();\n\n            /*\n             * No need to bring the text into view, since the size is not\n             * changing (unless we do the requestLayout(), in which case it\n             * will happen at measure).\n             */\n            makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,\n                          mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),\n                          false);\n\n            if (mEllipsize != TextUtils.TruncateAt.MARQUEE) {\n                // In a fixed-height view, so use our new text layout.\n                if (mLayoutParams.height != LayoutParams.WRAP_CONTENT &&\n                    mLayoutParams.height != LayoutParams.MATCH_PARENT) {\n                    invalidate();\n                    return;\n                }\n\n                // Dynamic height, but height has stayed the same,\n                // so use our new text layout.\n                if (mLayout.getHeight() == oldht &&\n                    (mHintLayout == null || mHintLayout.getHeight() == oldht)) {\n                    invalidate();\n                    return;\n                }\n            }\n\n            // We lose: the height has changed and we have a dynamic height.\n            // Request a new view layout using our new text layout.\n            requestLayout();\n            invalidate();\n        } else {\n            // Dynamic width, so we have no choice but to request a new\n            // view layout with a new text layout.\n            nullLayouts();\n            requestLayout();\n            invalidate();\n        }\n    }\n```\n发现不管是if还是else，都要执行invalidate()，那就进去看看，一路进展比较顺利，好像离真理更进一步了。经过连续的三连调跳转到了invalidateInternal方法：\n\n```\n public void invalidate() {\n        invalidate(true);\n    }\n\n    /**\n     * This is where the invalidate() work actually happens. A full invalidate()\n     * causes the drawing cache to be invalidated, but this function can be\n     * called with invalidateCache set to false to skip that invalidation step\n     * for cases that do not need it (for example, a component that remains at\n     * the same dimensions with the same content).\n     *\n     * @param invalidateCache Whether the drawing cache for this view should be\n     *            invalidated as well. This is usually true for a full\n     *            invalidate, but may be set to false if the View's contents or\n     *            dimensions have not changed.\n     */\n    void invalidate(boolean invalidateCache) {\n        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);\n    }\n\n   void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,\n            boolean fullInvalidate) {\n        if (mGhostView != null) {\n            mGhostView.invalidate(true);\n            return;\n        }\n\n        if (skipInvalidate()) {\n            return;\n        }\n\n        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)\n                || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)\n                || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED\n                || (fullInvalidate && isOpaque() != mLastIsOpaque)) {\n            if (fullInvalidate) {\n                mLastIsOpaque = isOpaque();\n                mPrivateFlags &= ~PFLAG_DRAWN;\n            }\n\n            mPrivateFlags |= PFLAG_DIRTY;\n\n            if (invalidateCache) {\n                mPrivateFlags |= PFLAG_INVALIDATED;\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n            }\n\n            // Propagate the damage rectangle to the parent view.\n            final AttachInfo ai = mAttachInfo;\n            final ViewParent p = mParent;\n            if (p != null && ai != null && l < r && t < b) {\n                final Rect damage = ai.mTmpInvalRect;\n                damage.set(l, t, r, b);\n                p.invalidateChild(this, damage);\n            }\n\n            // Damage the entire projection receiver, if necessary.\n            if (mBackground != null && mBackground.isProjected()) {\n                final View receiver = getProjectionReceiver();\n                if (receiver != null) {\n                    receiver.damageInParent();\n                }\n            }\n\n            // Damage the entire IsolatedZVolume receiving this view's shadow.\n            if (isHardwareAccelerated() && getZ() != 0) {\n                damageShadowReceiver();\n            }\n        }\n    }\n```\n重点看invalidateChild()这个方法，方法里面有do while循环，每次循环出当前view的parent，最后一次循环返回的parent时ViewRootImpl类实例：\n\n```\n public final void invalidateChild(View child, final Rect dirty) {\n        ViewParent parent = this;\n\n        final AttachInfo attachInfo = mAttachInfo;\n        if (attachInfo != null) {\n            // If the child is drawing an animation, we want to copy this flag onto\n            // ourselves and the parent to make sure the invalidate request goes\n            // through\n            final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION)\n                    == PFLAG_DRAW_ANIMATION;\n\n            // Check whether the child that requests the invalidate is fully opaque\n            // Views being animated or transformed are not considered opaque because we may\n            // be invalidating their old position and need the parent to paint behind them.\n            Matrix childMatrix = child.getMatrix();\n            final boolean isOpaque = child.isOpaque() && !drawAnimation &&\n                    child.getAnimation() == null && childMatrix.isIdentity();\n            // Mark the child as dirty, using the appropriate flag\n            // Make sure we do not set both flags at the same time\n            int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;\n\n            if (child.mLayerType != LAYER_TYPE_NONE) {\n                mPrivateFlags |= PFLAG_INVALIDATED;\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n            }\n\n            final int[] location = attachInfo.mInvalidateChildLocation;\n            location[CHILD_LEFT_INDEX] = child.mLeft;\n            location[CHILD_TOP_INDEX] = child.mTop;\n            if (!childMatrix.isIdentity() ||\n                    (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\n                RectF boundingRect = attachInfo.mTmpTransformRect;\n                boundingRect.set(dirty);\n                Matrix transformMatrix;\n                if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\n                    Transformation t = attachInfo.mTmpTransformation;\n                    boolean transformed = getChildStaticTransformation(child, t);\n                    if (transformed) {\n                        transformMatrix = attachInfo.mTmpMatrix;\n                        transformMatrix.set(t.getMatrix());\n                        if (!childMatrix.isIdentity()) {\n                            transformMatrix.preConcat(childMatrix);\n                        }\n                    } else {\n                        transformMatrix = childMatrix;\n                    }\n                } else {\n                    transformMatrix = childMatrix;\n                }\n                transformMatrix.mapRect(boundingRect);\n                dirty.set((int) (boundingRect.left - 0.5f),\n                        (int) (boundingRect.top - 0.5f),\n                        (int) (boundingRect.right + 0.5f),\n                        (int) (boundingRect.bottom + 0.5f));\n            }\n\n            do {\n                View view = null;\n                if (parent instanceof View) {\n                    view = (View) parent;\n                }\n\n                if (drawAnimation) {\n                    if (view != null) {\n                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;\n                    } else if (parent instanceof ViewRootImpl) {\n                        ((ViewRootImpl) parent).mIsAnimating = true;\n                    }\n                }\n\n                // If the parent is dirty opaque or not dirty, mark it dirty with the opaque\n                // flag coming from the child that initiated the invalidate\n                if (view != null) {\n                    if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&\n                            view.getSolidColor() == 0) {\n                        opaqueFlag = PFLAG_DIRTY;\n                    }\n                    if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {\n                        view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;\n                    }\n                }\n\n                parent = parent.invalidateChildInParent(location, dirty);\n                if (view != null) {\n                    // Account for transform on current parent\n                    Matrix m = view.getMatrix();\n                    if (!m.isIdentity()) {\n                        RectF boundingRect = attachInfo.mTmpTransformRect;\n                        boundingRect.set(dirty);\n                        m.mapRect(boundingRect);\n                        dirty.set((int) (boundingRect.left - 0.5f),\n                                (int) (boundingRect.top - 0.5f),\n                                (int) (boundingRect.right + 0.5f),\n                                (int) (boundingRect.bottom + 0.5f));\n                    }\n                }\n            } while (parent != null);\n        }\n    }\n```\n现在查看ViewRootImpl类的invalidateChildInParent()方法：\n\n```\n    @Override\n    public ViewParent invalidateChildInParent(int[] location, Rect dirty) {\n        checkThread();\n        if (DEBUG_DRAW) Log.v(TAG, \"Invalidate child: \" + dirty);\n\n        if (dirty == null) {\n            invalidate();\n            return null;\n        } else if (dirty.isEmpty() && !mIsAnimating) {\n            return null;\n        }\n\n        if (mCurScrollY != 0 || mTranslator != null) {\n            mTempRect.set(dirty);\n            dirty = mTempRect;\n            if (mCurScrollY != 0) {\n                dirty.offset(0, -mCurScrollY);\n            }\n            if (mTranslator != null) {\n                mTranslator.translateRectInAppWindowToScreen(dirty);\n            }\n            if (mAttachInfo.mScalingRequired) {\n                dirty.inset(-1, -1);\n            }\n        }\n\n        final Rect localDirty = mDirty;\n        if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {\n            mAttachInfo.mSetIgnoreDirtyState = true;\n            mAttachInfo.mIgnoreDirtyState = true;\n        }\n\n        // Add the new dirty rect to the current one\n        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);\n        // Intersect with the bounds of the window to skip\n        // updates that lie outside of the visible region\n        final float appScale = mAttachInfo.mApplicationScale;\n        final boolean intersected = localDirty.intersect(0, 0,\n                (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));\n        if (!intersected) {\n            localDirty.setEmpty();\n        }\n        if (!mWillDrawSoon && (intersected || mIsAnimating)) {\n            scheduleTraversals();\n        }\n\n        return null;\n    }\n```\n方法块的第一行好像就是我们要找的验证线程的地方checkThread()，而该方法内容也很简单，看到抛出的异常就很熟悉了：\n\n```\n    void checkThread() {\n        if (mThread != Thread.currentThread()) {\n            throw new CalledFromWrongThreadException(\n                    \"Only the original thread that created a view hierarchy can touch its views.\");\n        }\n    }\n```\n第二步，验证线程地方已经找到了，假设得到了证实，那么为什么该有的异常没有出现呢？现在再次假设是不是因为某些原因导致checkThread()没有执行呢？\n\n有人可能会问会不会是mThread == Thread.currentThread()？其实这是不可能的 ，先看下mThread赋值：\n\n```\n    public ViewRootImpl(Context context, Display display) {\n        mContext = context;\n        mWindowSession = WindowManagerGlobal.getWindowSession();\n        mDisplay = display;\n        mBasePackageName = context.getBasePackageName();\n\n        mDisplayAdjustments = display.getDisplayAdjustments();\n\n        mThread = Thread.currentThread();\n```\nViewRootImpl类实例化是在Activity启动时的主线程创建的，所以mThread是主线程实例，而checkThread()中的Thread.currentThread()，最初是由textView.setText()调用的一系列方法栈，并且setText是在子线程调用。\n\n继续刚才的假设，不过现在要逆推回去，checkThread()方法没有执行，可以认为ViewRootImpl的invalidateChildInParent()方法没有执行，它又是在ViewGroup中invalidateChild()方法里的do while中调用，要使do while不被调用，继续往上看，如果attachInfo为null，进不去if语句块也就不会执行checkThread()了，这是第一个可能的原因。记录下，继续逆推。\n\nView中的invalidateInternal()方法：\n\n```\n      // Propagate the damage rectangle to the parent view.\n            final AttachInfo ai = mAttachInfo;\n            final ViewParent p = mParent;\n            if (p != null && ai != null && l < r && t < b) {\n                final Rect damage = ai.mTmpInvalRect;\n                damage.set(l, t, r, b);\n                p.invalidateChild(this, damage);\n            }\n```\n根据判断条件，如果p即mParent或者ai即mAttachInfo 任一为null，都不会执行invalidateChild，这是第二个可能原因，这里的ai和第一个原因的attachInfo是一样的，所以第一个原因可能忽略，精力关注在第二个原因上。\n\n>现在的关注点是实例p和ai是什么时候创建的，有没有为null的现象？\n\n```\n     final AttachInfo ai = mAttachInfo;\n```\n而mAttachInfo是在View的dispatchAttachedToWindow()方法中赋值的：\n\n```\n void dispatchAttachedToWindow(AttachInfo info, int visibility) {\n        //System.out.println(\"Attached! \" + this);\n        mAttachInfo = info;\n}\n```\nView的dispatchAttachedToWindow()方法是在ViewRootImpl中的performTraversals()方法调用，这个方法是遍历View Tree\n\n```\n private void performTraversals() {\n        // cache mView since it is used so much below...\n        final View host = mView;\n        ·······\n        host.dispatchAttachedToWindow(mAttachInfo, 0);\n\n```\n可见View中的mAttachInfo来自ViewrootImpl的mAttachInfo，而ViewrootImpl的mAttachInfo是在其构造方法中被赋值的：\n\n```\n\n    public ViewRootImpl(Context context, Display display) {\n        mContext = context;\n        mWindowSession = WindowManagerGlobal.getWindowSession();\n        mDisplay = display;\n        mBasePackageName = context.getBasePackageName();\n\n        mDisplayAdjustments = display.getDisplayAdjustments();\n\n        mThread = Thread.currentThread();\n        mLocation = new WindowLeaked(null);\n        mLocation.fillInStackTrace();\n        mWidth = -1;\n        mHeight = -1;\n        mDirty = new Rect();\n        mTempRect = new Rect();\n        mVisRect = new Rect();\n        mWinFrame = new Rect();\n        mWindow = new W(this);\n        mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;\n        mViewVisibility = View.GONE;\n        mTransparentRegion = new Region();\n        mPreviousTransparentRegion = new Region();\n        mFirst = true; // true for the first time the view is added\n        mAdded = false;\n        mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);\n       \n    }\n```\n\n之前说了ViewRootImpl实例是在Activity启动时创建的，现在看看具体是启动的什么时候:在向window添加view的时候即：WindowManagerGlobal的addView方法中创建ViewrootImpl实例：\n\n```\n public void addView(View view, ViewGroup.LayoutParams params,\n            Display display, Window parentWindow) {\n        if (view == null) {\n            throw new IllegalArgumentException(\"view must not be null\");\n        }\n        if (display == null) {\n            throw new IllegalArgumentException(\"display must not be null\");\n        }\n        if (!(params instanceof WindowManager.LayoutParams)) {\n            throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\");\n        }\n\n        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;\n        if (parentWindow != null) {\n            parentWindow.adjustLayoutParamsForSubWindow(wparams);\n        } else {\n            // If there's no parent and we're running on L or above (or in the\n            // system context), assume we want hardware acceleration.\n            final Context context = view.getContext();\n            if (context != null\n                    && context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {\n                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;\n            }\n        }\n\n        ViewRootImpl root;\n        View panelParentView = null;\n\n        synchronized (mLock) {\n            // Start watching for system property changes.\n            if (mSystemPropertyUpdater == null) {\n                mSystemPropertyUpdater = new Runnable() {\n                    @Override public void run() {\n                        synchronized (mLock) {\n                            for (int i = mRoots.size() - 1; i >= 0; --i) {\n                                mRoots.get(i).loadSystemProperties();\n                            }\n                        }\n                    }\n                };\n                SystemProperties.addChangeCallback(mSystemPropertyUpdater);\n            }\n\n            int index = findViewLocked(view, false);\n            if (index >= 0) {\n                if (mDyingViews.contains(view)) {\n                    // Don't wait for MSG_DIE to make it's way through root's queue.\n                    mRoots.get(index).doDie();\n                } else {\n                    throw new IllegalStateException(\"View \" + view\n                            + \" has already been added to the window manager.\");\n                }\n                // The previous removeView() had not completed executing. Now it has.\n            }\n\n            // If this is a panel window, then find the window it is being\n            // attached to for future reference.\n            if (wparams.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&\n                    wparams.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {\n                final int count = mViews.size();\n                for (int i = 0; i < count; i++) {\n                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {\n                        panelParentView = mViews.get(i);\n                    }\n                }\n            }\n\n            root = new ViewRootImpl(view.getContext(), display);\n\n            view.setLayoutParams(wparams);\n\n            mViews.add(view);\n            mRoots.add(root);\n            mParams.add(wparams);\n        }\n\n        // do this last because it fires off messages to start doing things\n        try {\n            root.setView(view, wparams, panelParentView);\n        } catch (RuntimeException e) {\n            // BadTokenException or InvalidDisplayException, clean up.\n            synchronized (mLock) {\n                final int index = findViewLocked(view, false);\n                if (index >= 0) {\n                    removeViewLocked(index, true);\n                }\n            }\n            throw e;\n        }\n    }\n\n```\n\n而调用addView()方法是在ActivityThread类的handleResumeActivity()方法：\n\n```\n\n    final void handleResumeActivity(IBinder token,\n            boolean clearHide, boolean isForward, boolean reallyResume) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n        mSomeActivitiesChanged = true;\n\n        // TODO Push resumeArgs into the activity for consideration\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\n\n        if (r != null) {\n            final Activity a = r.activity;\n\n            if (localLOGV) Slog.v(\n                TAG, \"Resume \" + r + \" started activity: \" +\n                a.mStartedActivity + \", hideForNow: \" + r.hideForNow\n                + \", finished: \" + a.mFinished);\n\n            final int forwardBit = isForward ?\n                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\n\n            // If the window hasn't yet been added to the window manager,\n            // and this guy didn't finish itself or start another activity,\n            // then go ahead and add the window.\n            boolean willBeVisible = !a.mStartedActivity;\n            if (!willBeVisible) {\n                try {\n                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(\n                            a.getActivityToken());\n                } catch (RemoteException e) {\n                }\n            }\n            if (r.window == null && !a.mFinished && willBeVisible) {\n                r.window = r.activity.getWindow();\n                View decor = r.window.getDecorView();\n                decor.setVisibility(View.INVISIBLE);\n                ViewManager wm = a.getWindowManager();\n                WindowManager.LayoutParams l = r.window.getAttributes();\n                a.mDecor = decor;\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n                l.softInputMode |= forwardBit;\n                if (a.mVisibleFromClient) {\n                    a.mWindowAdded = true;\n                    wm.addView(decor, l);\n                }\n\n            // If the window has already been added, but during resume\n            // we started another activity, then don't yet make the\n            // window visible.\n            } else if (!willBeVisible) {\n                if (localLOGV) Slog.v(\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\n                r.hideForNow = true;\n            }\n\n            // Get rid of anything left hanging around.\n            cleanUpPendingRemoveWindows(r);\n\n            // The window is now visible if it has been added, we are not\n            // simply finishing, and we are not starting another activity.\n            if (!r.activity.mFinished && willBeVisible\n                    && r.activity.mDecor != null && !r.hideForNow) {\n                if (r.newConfig != null) {\n                    if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \"\n                            + r.activityInfo.name + \" with newConfig \" + r.newConfig);\n                    performConfigurationChanged(r.activity, r.newConfig);\n                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig));\n                    r.newConfig = null;\n                }\n                if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\"\n                        + isForward);\n                WindowManager.LayoutParams l = r.window.getAttributes();\n                if ((l.softInputMode\n                        & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)\n                        != forwardBit) {\n                    l.softInputMode = (l.softInputMode\n                            & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))\n                            | forwardBit;\n                    if (r.activity.mVisibleFromClient) {\n                        ViewManager wm = a.getWindowManager();\n                        View decor = r.window.getDecorView();\n                        wm.updateViewLayout(decor, l);\n                    }\n                }\n                r.activity.mVisibleFromServer = true;\n                mNumVisibleActivities++;\n                if (r.activity.mVisibleFromClient) {\n                    r.activity.makeVisible();\n                }\n            }\n\n            if (!r.onlyLocalRequest) {\n                r.nextIdle = mNewActivities;\n                mNewActivities = r;\n                if (localLOGV) Slog.v(\n                    TAG, \"Scheduling idle handler for \" + r);\n                Looper.myQueue().addIdleHandler(new Idler());\n            }\n            r.onlyLocalRequest = false;\n\n            // Tell the activity manager we have resumed.\n            if (reallyResume) {\n                try {\n                    ActivityManagerNative.getDefault().activityResumed(token);\n                } catch (RemoteException ex) {\n                }\n            }\n\n        } else {\n            // If an exception was thrown when trying to resume, then\n            // just end this activity.\n            try {\n                ActivityManagerNative.getDefault()\n                    .finishActivity(token, Activity.RESULT_CANCELED, null, false);\n            } catch (RemoteException ex) {\n            }\n        }\n    }\n```\n\n看到上面的方法有些人心里可能有底儿了，handleResumeActivity()方法是不是让Activity回调onResume？如果是的话一切就都明了了，因为ViewrootImpl是在onReume期间创建，而AttachInfo是在ViewRootImpl实例化时创建，我们的工作线程是在onCreate时刷新UI的，那时候还没有实例化AttachInfo，导致mAttachInfo为null，最终if条件判断失败没有进入。然而这一切都是在YY，实践才是检验真理的唯一标准，动起来：\n\n看到这一行代码```\nActivityClientRecord r = performResumeActivity(token, clearHide);\n```微微一笑，点进去看看，\n\n```\n    public final ActivityClientRecord performResumeActivity(IBinder token,\n            boolean clearHide) {\n        ActivityClientRecord r = mActivities.get(token);\n        if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r\n                + \" finished=\" + r.activity.mFinished);\n        if (r != null && !r.activity.mFinished) {\n            if (clearHide) {\n                r.hideForNow = false;\n                r.activity.mStartedActivity = false;\n            }\n            try {\n                r.activity.mFragments.noteStateNotSaved();\n                if (r.pendingIntents != null) {\n                    deliverNewIntents(r, r.pendingIntents);\n                    r.pendingIntents = null;\n                }\n                if (r.pendingResults != null) {\n                    deliverResults(r, r.pendingResults);\n                    r.pendingResults = null;\n                }\n                r.activity.performResume();\n\n                EventLog.writeEvent(LOG_ON_RESUME_CALLED,\n                        UserHandle.myUserId(), r.activity.getComponentName().getClassName());\n\n                r.paused = false;\n                r.stopped = false;\n                r.state = null;\n                r.persistentState = null;\n            } catch (Exception e) {\n                if (!mInstrumentation.onException(r.activity, e)) {\n                    throw new RuntimeException(\n                        \"Unable to resume activity \"\n                        + r.intent.getComponent().toShortString()\n                        + \": \" + e.toString(), e);\n                }\n            }\n        }\n        return r;\n    }\n```\n代码很短，很容易提取有用信息：``` r.activity.performResume();```在进去看看：\n\n```\n\n    final void performResume() {\n        performRestart();\n\n        mFragments.execPendingActions();\n\n        mLastNonConfigurationInstances = null;\n\n        mCalled = false;\n        // mResumed is set by the instrumentation\n        mInstrumentation.callActivityOnResume(this);\n        if (!mCalled) {\n            throw new SuperNotCalledException(\n                \"Activity \" + mComponent.toShortString() +\n                \" did not call through to super.onResume()\");\n        }\n\n        // Now really resume, and install the current status bar and menu.\n        mCalled = false;\n\n        mFragments.dispatchResume();\n        mFragments.execPendingActions();\n\n        onPostResume();\n        if (!mCalled) {\n            throw new SuperNotCalledException(\n                \"Activity \" + mComponent.toShortString() +\n                \" did not call through to super.onPostResume()\");\n        }\n    }\n```\n看到```mInstrumentation```这个属性就能感觉到越来越接近SDK API层了，看看它的```callActivityOnResume()```方法做了什么：\n\n```\n    public void callActivityOnResume(Activity activity) {\n        activity.mResumed = true;\n        activity.onResume();\n        \n        if (mActivityMonitors != null) {\n            synchronized (mSync) {\n                final int N = mActivityMonitors.size();\n                for (int i=0; i<N; i++) {\n                    final ActivityMonitor am = mActivityMonitors.get(i);\n                    am.match(activity, activity, activity.getIntent());\n                }\n            }\n        }\n    }\n```\n\n一行```activity.onResume();```已经水落石出。\n回到handleResumeActivity代码中，我精简下：\n\n```\n final void handleResumeActivity(IBinder token,\n            boolean clearHide, boolean isForward, boolean reallyResume) {\n   //这里是最终回调Activity的onResume()方法\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\n//省略若干\n        if (r != null) {\n            final Activity a = r.activity;\n            final int forwardBit = isForward ?\n            WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\n            boolean willBeVisible = !a.mStartedActivity;\n\n            if (r.window == null && !a.mFinished && willBeVisible) {\n                r.window = r.activity.getWindow();\n                View decor = r.window.getDecorView();\n                decor.setVisibility(View.INVISIBLE);\n                ViewManager wm = a.getWindowManager();\n                WindowManager.LayoutParams l = r.window.getAttributes();\n                a.mDecor = decor;\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n                l.softInputMode |= forwardBit;\n                if (a.mVisibleFromClient) {\n                    a.mWindowAdded = true;\n//这里是调用WindowManagerGlobal的addView()方法最终实例化ViewRootImpl，进而实例化AttachInfo\n                    wm.addView(decor, l);\n                }\n       \n            } else if (!willBeVisible) {\n                if (localLOGV) Slog.v(\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\n                r.hideForNow = true;\n            }\n        }\n    }\n```\n\n\n另外关于阅读源码问题，win下当然使用SourceInsight不二选，如果是在mac下可以参考我的[osx下如何使用SublimeText阅读Android系统源码](http://www.jianshu.com/p/c295d2729ecf).。","source":"_posts/为什么我在工作线程刷新UI没报错.md","raw":"---\ntitle: 为什么我在工作线程刷新UI没报错？\ndate: 2017-04-21 20:55:54\ntags: Android\ncategories: Android\n---\n\n>从做Android开发以来就一直被灌输“只能在主线程刷新UI”的思想，但是这两天发现个问题，在onCreate中创建工作线程并刷新UI没有报错。代码是这样的：\n\n```\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n       final TextView tv = (TextView) findViewById(R.id.sample_text);\n       new Thread(new Runnable() {\n           @Override\n           public void run() {\n               tv.setText(\"来自\"+Thread.currentThread().getName()+\"线程的更新\");\n           }\n       }).start();\n    }\n```\n期待已久的crash没有出现，反而页面是这样显示的：\n\n![屏幕快照 2017-03-26 下午7.14.46.png](http://upload-images.jianshu.io/upload_images/1796052-7be6319d0fc94867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不禁让人陷入深思···\n![思考.jpg](http://upload-images.jianshu.io/upload_images/1796052-8a0ce88639c31d1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第一步，分析问题原因。以前工作线程刷新UI会出现异常并提示只能在UI线程刷新UI。所以假设有个地方(函数)会在刷新UI前判断当前线程是不是主线程，那么现在问题就是验证下是否真的存在这么个地方。问题是从setText引起的，那就从这里出发看看。\n点进去看下发现又调用了其重载函数：\n```\n    @android.view.RemotableViewMethod\n    public final void setText(CharSequence text) {\n        setText(text, mBufferType);\n    }\n```\n继续深入发现这个方法代码挺多的，但是不用过于关注细节，粗略浏览下不难发现前面大部分代码大多是对text文本格式的一些处理判断，无关刷新UI，直到            checkForRelayout()方法执行，从名字看是“从新布局”，根据view绘制流程测量、布局、绘制，那布局完了不是就绘制刷新了吗？所以决定去checkForRelayout方法看看。\n\n```\n    private void setText(CharSequence text, BufferType type,\n                         boolean notifyBefore, int oldlen) {\n        if (text == null) {\n            text = \"\";\n        }\n\n        // If suggestions are not enabled, remove the suggestion spans from the text\n        if (!isSuggestionsEnabled()) {\n            text = removeSuggestionSpans(text);\n        }\n\n        if (!mUserSetTextScaleX) mTextPaint.setTextScaleX(1.0f);\n\n        if (text instanceof Spanned &&\n            ((Spanned) text).getSpanStart(TextUtils.TruncateAt.MARQUEE) >= 0) {\n            if (ViewConfiguration.get(mContext).isFadingMarqueeEnabled()) {\n                setHorizontalFadingEdgeEnabled(true);\n                mMarqueeFadeMode = MARQUEE_FADE_NORMAL;\n            } else {\n                setHorizontalFadingEdgeEnabled(false);\n                mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;\n            }\n            setEllipsize(TextUtils.TruncateAt.MARQUEE);\n        }\n\n        int n = mFilters.length;\n        for (int i = 0; i < n; i++) {\n            CharSequence out = mFilters[i].filter(text, 0, text.length(), EMPTY_SPANNED, 0, 0);\n            if (out != null) {\n                text = out;\n            }\n        }\n\n        if (notifyBefore) {\n            if (mText != null) {\n                oldlen = mText.length();\n                sendBeforeTextChanged(mText, 0, oldlen, text.length());\n            } else {\n                sendBeforeTextChanged(\"\", 0, 0, text.length());\n            }\n        }\n\n        boolean needEditableForNotification = false;\n\n        if (mListeners != null && mListeners.size() != 0) {\n            needEditableForNotification = true;\n        }\n\n        if (type == BufferType.EDITABLE || getKeyListener() != null ||\n                needEditableForNotification) {\n            createEditorIfNeeded();\n            Editable t = mEditableFactory.newEditable(text);\n            text = t;\n            setFilters(t, mFilters);\n            InputMethodManager imm = InputMethodManager.peekInstance();\n            if (imm != null) imm.restartInput(this);\n        } else if (type == BufferType.SPANNABLE || mMovement != null) {\n            text = mSpannableFactory.newSpannable(text);\n        } else if (!(text instanceof CharWrapper)) {\n            text = TextUtils.stringOrSpannedString(text);\n        }\n\n        if (mAutoLinkMask != 0) {\n            Spannable s2;\n\n            if (type == BufferType.EDITABLE || text instanceof Spannable) {\n                s2 = (Spannable) text;\n            } else {\n                s2 = mSpannableFactory.newSpannable(text);\n            }\n\n            if (Linkify.addLinks(s2, mAutoLinkMask)) {\n                text = s2;\n                type = (type == BufferType.EDITABLE) ? BufferType.EDITABLE : BufferType.SPANNABLE;\n\n                /*\n                 * We must go ahead and set the text before changing the\n                 * movement method, because setMovementMethod() may call\n                 * setText() again to try to upgrade the buffer type.\n                 */\n                mText = text;\n\n                // Do not change the movement method for text that support text selection as it\n                // would prevent an arbitrary cursor displacement.\n                if (mLinksClickable && !textCanBeSelected()) {\n                    setMovementMethod(LinkMovementMethod.getInstance());\n                }\n            }\n        }\n\n        mBufferType = type;\n        mText = text;\n\n        if (mTransformation == null) {\n            mTransformed = text;\n        } else {\n            mTransformed = mTransformation.getTransformation(text, this);\n        }\n\n        final int textLength = text.length();\n\n        if (text instanceof Spannable && !mAllowTransformationLengthChange) {\n            Spannable sp = (Spannable) text;\n\n            // Remove any ChangeWatchers that might have come from other TextViews.\n            final ChangeWatcher[] watchers = sp.getSpans(0, sp.length(), ChangeWatcher.class);\n            final int count = watchers.length;\n            for (int i = 0; i < count; i++) {\n                sp.removeSpan(watchers[i]);\n            }\n\n            if (mChangeWatcher == null) mChangeWatcher = new ChangeWatcher();\n\n            sp.setSpan(mChangeWatcher, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE |\n                       (CHANGE_WATCHER_PRIORITY << Spanned.SPAN_PRIORITY_SHIFT));\n\n            if (mEditor != null) mEditor.addSpanWatchers(sp);\n\n            if (mTransformation != null) {\n                sp.setSpan(mTransformation, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE);\n            }\n\n            if (mMovement != null) {\n                mMovement.initialize(this, (Spannable) text);\n\n                /*\n                 * Initializing the movement method will have set the\n                 * selection, so reset mSelectionMoved to keep that from\n                 * interfering with the normal on-focus selection-setting.\n                 */\n                if (mEditor != null) mEditor.mSelectionMoved = false;\n            }\n        }\n\n        if (mLayout != null) {\n            checkForRelayout();\n        }\n\n        sendOnTextChanged(text, 0, oldlen, textLength);\n        onTextChanged(text, 0, oldlen, textLength);\n\n        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT);\n\n        if (needEditableForNotification) {\n            sendAfterTextChanged((Editable) text);\n        }\n\n        // SelectionModifierCursorController depends on textCanBeSelected, which depends on text\n        if (mEditor != null) mEditor.prepareCursorControllers();\n    }\n```\n\n找到checkForRelayout方法查看：\n\n```\n    private void checkForRelayout() {\n        // If we have a fixed width, we can just swap in a new text layout\n        // if the text height stays the same or if the view height is fixed.\n\n        if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT ||\n                (mMaxWidthMode == mMinWidthMode && mMaxWidth == mMinWidth)) &&\n                (mHint == null || mHintLayout != null) &&\n                (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() > 0)) {\n            // Static width, so try making a new text layout.\n\n            int oldht = mLayout.getHeight();\n            int want = mLayout.getWidth();\n            int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth();\n\n            /*\n             * No need to bring the text into view, since the size is not\n             * changing (unless we do the requestLayout(), in which case it\n             * will happen at measure).\n             */\n            makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,\n                          mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),\n                          false);\n\n            if (mEllipsize != TextUtils.TruncateAt.MARQUEE) {\n                // In a fixed-height view, so use our new text layout.\n                if (mLayoutParams.height != LayoutParams.WRAP_CONTENT &&\n                    mLayoutParams.height != LayoutParams.MATCH_PARENT) {\n                    invalidate();\n                    return;\n                }\n\n                // Dynamic height, but height has stayed the same,\n                // so use our new text layout.\n                if (mLayout.getHeight() == oldht &&\n                    (mHintLayout == null || mHintLayout.getHeight() == oldht)) {\n                    invalidate();\n                    return;\n                }\n            }\n\n            // We lose: the height has changed and we have a dynamic height.\n            // Request a new view layout using our new text layout.\n            requestLayout();\n            invalidate();\n        } else {\n            // Dynamic width, so we have no choice but to request a new\n            // view layout with a new text layout.\n            nullLayouts();\n            requestLayout();\n            invalidate();\n        }\n    }\n```\n发现不管是if还是else，都要执行invalidate()，那就进去看看，一路进展比较顺利，好像离真理更进一步了。经过连续的三连调跳转到了invalidateInternal方法：\n\n```\n public void invalidate() {\n        invalidate(true);\n    }\n\n    /**\n     * This is where the invalidate() work actually happens. A full invalidate()\n     * causes the drawing cache to be invalidated, but this function can be\n     * called with invalidateCache set to false to skip that invalidation step\n     * for cases that do not need it (for example, a component that remains at\n     * the same dimensions with the same content).\n     *\n     * @param invalidateCache Whether the drawing cache for this view should be\n     *            invalidated as well. This is usually true for a full\n     *            invalidate, but may be set to false if the View's contents or\n     *            dimensions have not changed.\n     */\n    void invalidate(boolean invalidateCache) {\n        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);\n    }\n\n   void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,\n            boolean fullInvalidate) {\n        if (mGhostView != null) {\n            mGhostView.invalidate(true);\n            return;\n        }\n\n        if (skipInvalidate()) {\n            return;\n        }\n\n        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)\n                || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)\n                || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED\n                || (fullInvalidate && isOpaque() != mLastIsOpaque)) {\n            if (fullInvalidate) {\n                mLastIsOpaque = isOpaque();\n                mPrivateFlags &= ~PFLAG_DRAWN;\n            }\n\n            mPrivateFlags |= PFLAG_DIRTY;\n\n            if (invalidateCache) {\n                mPrivateFlags |= PFLAG_INVALIDATED;\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n            }\n\n            // Propagate the damage rectangle to the parent view.\n            final AttachInfo ai = mAttachInfo;\n            final ViewParent p = mParent;\n            if (p != null && ai != null && l < r && t < b) {\n                final Rect damage = ai.mTmpInvalRect;\n                damage.set(l, t, r, b);\n                p.invalidateChild(this, damage);\n            }\n\n            // Damage the entire projection receiver, if necessary.\n            if (mBackground != null && mBackground.isProjected()) {\n                final View receiver = getProjectionReceiver();\n                if (receiver != null) {\n                    receiver.damageInParent();\n                }\n            }\n\n            // Damage the entire IsolatedZVolume receiving this view's shadow.\n            if (isHardwareAccelerated() && getZ() != 0) {\n                damageShadowReceiver();\n            }\n        }\n    }\n```\n重点看invalidateChild()这个方法，方法里面有do while循环，每次循环出当前view的parent，最后一次循环返回的parent时ViewRootImpl类实例：\n\n```\n public final void invalidateChild(View child, final Rect dirty) {\n        ViewParent parent = this;\n\n        final AttachInfo attachInfo = mAttachInfo;\n        if (attachInfo != null) {\n            // If the child is drawing an animation, we want to copy this flag onto\n            // ourselves and the parent to make sure the invalidate request goes\n            // through\n            final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION)\n                    == PFLAG_DRAW_ANIMATION;\n\n            // Check whether the child that requests the invalidate is fully opaque\n            // Views being animated or transformed are not considered opaque because we may\n            // be invalidating their old position and need the parent to paint behind them.\n            Matrix childMatrix = child.getMatrix();\n            final boolean isOpaque = child.isOpaque() && !drawAnimation &&\n                    child.getAnimation() == null && childMatrix.isIdentity();\n            // Mark the child as dirty, using the appropriate flag\n            // Make sure we do not set both flags at the same time\n            int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;\n\n            if (child.mLayerType != LAYER_TYPE_NONE) {\n                mPrivateFlags |= PFLAG_INVALIDATED;\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n            }\n\n            final int[] location = attachInfo.mInvalidateChildLocation;\n            location[CHILD_LEFT_INDEX] = child.mLeft;\n            location[CHILD_TOP_INDEX] = child.mTop;\n            if (!childMatrix.isIdentity() ||\n                    (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\n                RectF boundingRect = attachInfo.mTmpTransformRect;\n                boundingRect.set(dirty);\n                Matrix transformMatrix;\n                if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\n                    Transformation t = attachInfo.mTmpTransformation;\n                    boolean transformed = getChildStaticTransformation(child, t);\n                    if (transformed) {\n                        transformMatrix = attachInfo.mTmpMatrix;\n                        transformMatrix.set(t.getMatrix());\n                        if (!childMatrix.isIdentity()) {\n                            transformMatrix.preConcat(childMatrix);\n                        }\n                    } else {\n                        transformMatrix = childMatrix;\n                    }\n                } else {\n                    transformMatrix = childMatrix;\n                }\n                transformMatrix.mapRect(boundingRect);\n                dirty.set((int) (boundingRect.left - 0.5f),\n                        (int) (boundingRect.top - 0.5f),\n                        (int) (boundingRect.right + 0.5f),\n                        (int) (boundingRect.bottom + 0.5f));\n            }\n\n            do {\n                View view = null;\n                if (parent instanceof View) {\n                    view = (View) parent;\n                }\n\n                if (drawAnimation) {\n                    if (view != null) {\n                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;\n                    } else if (parent instanceof ViewRootImpl) {\n                        ((ViewRootImpl) parent).mIsAnimating = true;\n                    }\n                }\n\n                // If the parent is dirty opaque or not dirty, mark it dirty with the opaque\n                // flag coming from the child that initiated the invalidate\n                if (view != null) {\n                    if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&\n                            view.getSolidColor() == 0) {\n                        opaqueFlag = PFLAG_DIRTY;\n                    }\n                    if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {\n                        view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;\n                    }\n                }\n\n                parent = parent.invalidateChildInParent(location, dirty);\n                if (view != null) {\n                    // Account for transform on current parent\n                    Matrix m = view.getMatrix();\n                    if (!m.isIdentity()) {\n                        RectF boundingRect = attachInfo.mTmpTransformRect;\n                        boundingRect.set(dirty);\n                        m.mapRect(boundingRect);\n                        dirty.set((int) (boundingRect.left - 0.5f),\n                                (int) (boundingRect.top - 0.5f),\n                                (int) (boundingRect.right + 0.5f),\n                                (int) (boundingRect.bottom + 0.5f));\n                    }\n                }\n            } while (parent != null);\n        }\n    }\n```\n现在查看ViewRootImpl类的invalidateChildInParent()方法：\n\n```\n    @Override\n    public ViewParent invalidateChildInParent(int[] location, Rect dirty) {\n        checkThread();\n        if (DEBUG_DRAW) Log.v(TAG, \"Invalidate child: \" + dirty);\n\n        if (dirty == null) {\n            invalidate();\n            return null;\n        } else if (dirty.isEmpty() && !mIsAnimating) {\n            return null;\n        }\n\n        if (mCurScrollY != 0 || mTranslator != null) {\n            mTempRect.set(dirty);\n            dirty = mTempRect;\n            if (mCurScrollY != 0) {\n                dirty.offset(0, -mCurScrollY);\n            }\n            if (mTranslator != null) {\n                mTranslator.translateRectInAppWindowToScreen(dirty);\n            }\n            if (mAttachInfo.mScalingRequired) {\n                dirty.inset(-1, -1);\n            }\n        }\n\n        final Rect localDirty = mDirty;\n        if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {\n            mAttachInfo.mSetIgnoreDirtyState = true;\n            mAttachInfo.mIgnoreDirtyState = true;\n        }\n\n        // Add the new dirty rect to the current one\n        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);\n        // Intersect with the bounds of the window to skip\n        // updates that lie outside of the visible region\n        final float appScale = mAttachInfo.mApplicationScale;\n        final boolean intersected = localDirty.intersect(0, 0,\n                (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));\n        if (!intersected) {\n            localDirty.setEmpty();\n        }\n        if (!mWillDrawSoon && (intersected || mIsAnimating)) {\n            scheduleTraversals();\n        }\n\n        return null;\n    }\n```\n方法块的第一行好像就是我们要找的验证线程的地方checkThread()，而该方法内容也很简单，看到抛出的异常就很熟悉了：\n\n```\n    void checkThread() {\n        if (mThread != Thread.currentThread()) {\n            throw new CalledFromWrongThreadException(\n                    \"Only the original thread that created a view hierarchy can touch its views.\");\n        }\n    }\n```\n第二步，验证线程地方已经找到了，假设得到了证实，那么为什么该有的异常没有出现呢？现在再次假设是不是因为某些原因导致checkThread()没有执行呢？\n\n有人可能会问会不会是mThread == Thread.currentThread()？其实这是不可能的 ，先看下mThread赋值：\n\n```\n    public ViewRootImpl(Context context, Display display) {\n        mContext = context;\n        mWindowSession = WindowManagerGlobal.getWindowSession();\n        mDisplay = display;\n        mBasePackageName = context.getBasePackageName();\n\n        mDisplayAdjustments = display.getDisplayAdjustments();\n\n        mThread = Thread.currentThread();\n```\nViewRootImpl类实例化是在Activity启动时的主线程创建的，所以mThread是主线程实例，而checkThread()中的Thread.currentThread()，最初是由textView.setText()调用的一系列方法栈，并且setText是在子线程调用。\n\n继续刚才的假设，不过现在要逆推回去，checkThread()方法没有执行，可以认为ViewRootImpl的invalidateChildInParent()方法没有执行，它又是在ViewGroup中invalidateChild()方法里的do while中调用，要使do while不被调用，继续往上看，如果attachInfo为null，进不去if语句块也就不会执行checkThread()了，这是第一个可能的原因。记录下，继续逆推。\n\nView中的invalidateInternal()方法：\n\n```\n      // Propagate the damage rectangle to the parent view.\n            final AttachInfo ai = mAttachInfo;\n            final ViewParent p = mParent;\n            if (p != null && ai != null && l < r && t < b) {\n                final Rect damage = ai.mTmpInvalRect;\n                damage.set(l, t, r, b);\n                p.invalidateChild(this, damage);\n            }\n```\n根据判断条件，如果p即mParent或者ai即mAttachInfo 任一为null，都不会执行invalidateChild，这是第二个可能原因，这里的ai和第一个原因的attachInfo是一样的，所以第一个原因可能忽略，精力关注在第二个原因上。\n\n>现在的关注点是实例p和ai是什么时候创建的，有没有为null的现象？\n\n```\n     final AttachInfo ai = mAttachInfo;\n```\n而mAttachInfo是在View的dispatchAttachedToWindow()方法中赋值的：\n\n```\n void dispatchAttachedToWindow(AttachInfo info, int visibility) {\n        //System.out.println(\"Attached! \" + this);\n        mAttachInfo = info;\n}\n```\nView的dispatchAttachedToWindow()方法是在ViewRootImpl中的performTraversals()方法调用，这个方法是遍历View Tree\n\n```\n private void performTraversals() {\n        // cache mView since it is used so much below...\n        final View host = mView;\n        ·······\n        host.dispatchAttachedToWindow(mAttachInfo, 0);\n\n```\n可见View中的mAttachInfo来自ViewrootImpl的mAttachInfo，而ViewrootImpl的mAttachInfo是在其构造方法中被赋值的：\n\n```\n\n    public ViewRootImpl(Context context, Display display) {\n        mContext = context;\n        mWindowSession = WindowManagerGlobal.getWindowSession();\n        mDisplay = display;\n        mBasePackageName = context.getBasePackageName();\n\n        mDisplayAdjustments = display.getDisplayAdjustments();\n\n        mThread = Thread.currentThread();\n        mLocation = new WindowLeaked(null);\n        mLocation.fillInStackTrace();\n        mWidth = -1;\n        mHeight = -1;\n        mDirty = new Rect();\n        mTempRect = new Rect();\n        mVisRect = new Rect();\n        mWinFrame = new Rect();\n        mWindow = new W(this);\n        mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;\n        mViewVisibility = View.GONE;\n        mTransparentRegion = new Region();\n        mPreviousTransparentRegion = new Region();\n        mFirst = true; // true for the first time the view is added\n        mAdded = false;\n        mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);\n       \n    }\n```\n\n之前说了ViewRootImpl实例是在Activity启动时创建的，现在看看具体是启动的什么时候:在向window添加view的时候即：WindowManagerGlobal的addView方法中创建ViewrootImpl实例：\n\n```\n public void addView(View view, ViewGroup.LayoutParams params,\n            Display display, Window parentWindow) {\n        if (view == null) {\n            throw new IllegalArgumentException(\"view must not be null\");\n        }\n        if (display == null) {\n            throw new IllegalArgumentException(\"display must not be null\");\n        }\n        if (!(params instanceof WindowManager.LayoutParams)) {\n            throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\");\n        }\n\n        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;\n        if (parentWindow != null) {\n            parentWindow.adjustLayoutParamsForSubWindow(wparams);\n        } else {\n            // If there's no parent and we're running on L or above (or in the\n            // system context), assume we want hardware acceleration.\n            final Context context = view.getContext();\n            if (context != null\n                    && context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {\n                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;\n            }\n        }\n\n        ViewRootImpl root;\n        View panelParentView = null;\n\n        synchronized (mLock) {\n            // Start watching for system property changes.\n            if (mSystemPropertyUpdater == null) {\n                mSystemPropertyUpdater = new Runnable() {\n                    @Override public void run() {\n                        synchronized (mLock) {\n                            for (int i = mRoots.size() - 1; i >= 0; --i) {\n                                mRoots.get(i).loadSystemProperties();\n                            }\n                        }\n                    }\n                };\n                SystemProperties.addChangeCallback(mSystemPropertyUpdater);\n            }\n\n            int index = findViewLocked(view, false);\n            if (index >= 0) {\n                if (mDyingViews.contains(view)) {\n                    // Don't wait for MSG_DIE to make it's way through root's queue.\n                    mRoots.get(index).doDie();\n                } else {\n                    throw new IllegalStateException(\"View \" + view\n                            + \" has already been added to the window manager.\");\n                }\n                // The previous removeView() had not completed executing. Now it has.\n            }\n\n            // If this is a panel window, then find the window it is being\n            // attached to for future reference.\n            if (wparams.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&\n                    wparams.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {\n                final int count = mViews.size();\n                for (int i = 0; i < count; i++) {\n                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {\n                        panelParentView = mViews.get(i);\n                    }\n                }\n            }\n\n            root = new ViewRootImpl(view.getContext(), display);\n\n            view.setLayoutParams(wparams);\n\n            mViews.add(view);\n            mRoots.add(root);\n            mParams.add(wparams);\n        }\n\n        // do this last because it fires off messages to start doing things\n        try {\n            root.setView(view, wparams, panelParentView);\n        } catch (RuntimeException e) {\n            // BadTokenException or InvalidDisplayException, clean up.\n            synchronized (mLock) {\n                final int index = findViewLocked(view, false);\n                if (index >= 0) {\n                    removeViewLocked(index, true);\n                }\n            }\n            throw e;\n        }\n    }\n\n```\n\n而调用addView()方法是在ActivityThread类的handleResumeActivity()方法：\n\n```\n\n    final void handleResumeActivity(IBinder token,\n            boolean clearHide, boolean isForward, boolean reallyResume) {\n        // If we are getting ready to gc after going to the background, well\n        // we are back active so skip it.\n        unscheduleGcIdler();\n        mSomeActivitiesChanged = true;\n\n        // TODO Push resumeArgs into the activity for consideration\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\n\n        if (r != null) {\n            final Activity a = r.activity;\n\n            if (localLOGV) Slog.v(\n                TAG, \"Resume \" + r + \" started activity: \" +\n                a.mStartedActivity + \", hideForNow: \" + r.hideForNow\n                + \", finished: \" + a.mFinished);\n\n            final int forwardBit = isForward ?\n                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\n\n            // If the window hasn't yet been added to the window manager,\n            // and this guy didn't finish itself or start another activity,\n            // then go ahead and add the window.\n            boolean willBeVisible = !a.mStartedActivity;\n            if (!willBeVisible) {\n                try {\n                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(\n                            a.getActivityToken());\n                } catch (RemoteException e) {\n                }\n            }\n            if (r.window == null && !a.mFinished && willBeVisible) {\n                r.window = r.activity.getWindow();\n                View decor = r.window.getDecorView();\n                decor.setVisibility(View.INVISIBLE);\n                ViewManager wm = a.getWindowManager();\n                WindowManager.LayoutParams l = r.window.getAttributes();\n                a.mDecor = decor;\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n                l.softInputMode |= forwardBit;\n                if (a.mVisibleFromClient) {\n                    a.mWindowAdded = true;\n                    wm.addView(decor, l);\n                }\n\n            // If the window has already been added, but during resume\n            // we started another activity, then don't yet make the\n            // window visible.\n            } else if (!willBeVisible) {\n                if (localLOGV) Slog.v(\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\n                r.hideForNow = true;\n            }\n\n            // Get rid of anything left hanging around.\n            cleanUpPendingRemoveWindows(r);\n\n            // The window is now visible if it has been added, we are not\n            // simply finishing, and we are not starting another activity.\n            if (!r.activity.mFinished && willBeVisible\n                    && r.activity.mDecor != null && !r.hideForNow) {\n                if (r.newConfig != null) {\n                    if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \"\n                            + r.activityInfo.name + \" with newConfig \" + r.newConfig);\n                    performConfigurationChanged(r.activity, r.newConfig);\n                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig));\n                    r.newConfig = null;\n                }\n                if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\"\n                        + isForward);\n                WindowManager.LayoutParams l = r.window.getAttributes();\n                if ((l.softInputMode\n                        & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)\n                        != forwardBit) {\n                    l.softInputMode = (l.softInputMode\n                            & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))\n                            | forwardBit;\n                    if (r.activity.mVisibleFromClient) {\n                        ViewManager wm = a.getWindowManager();\n                        View decor = r.window.getDecorView();\n                        wm.updateViewLayout(decor, l);\n                    }\n                }\n                r.activity.mVisibleFromServer = true;\n                mNumVisibleActivities++;\n                if (r.activity.mVisibleFromClient) {\n                    r.activity.makeVisible();\n                }\n            }\n\n            if (!r.onlyLocalRequest) {\n                r.nextIdle = mNewActivities;\n                mNewActivities = r;\n                if (localLOGV) Slog.v(\n                    TAG, \"Scheduling idle handler for \" + r);\n                Looper.myQueue().addIdleHandler(new Idler());\n            }\n            r.onlyLocalRequest = false;\n\n            // Tell the activity manager we have resumed.\n            if (reallyResume) {\n                try {\n                    ActivityManagerNative.getDefault().activityResumed(token);\n                } catch (RemoteException ex) {\n                }\n            }\n\n        } else {\n            // If an exception was thrown when trying to resume, then\n            // just end this activity.\n            try {\n                ActivityManagerNative.getDefault()\n                    .finishActivity(token, Activity.RESULT_CANCELED, null, false);\n            } catch (RemoteException ex) {\n            }\n        }\n    }\n```\n\n看到上面的方法有些人心里可能有底儿了，handleResumeActivity()方法是不是让Activity回调onResume？如果是的话一切就都明了了，因为ViewrootImpl是在onReume期间创建，而AttachInfo是在ViewRootImpl实例化时创建，我们的工作线程是在onCreate时刷新UI的，那时候还没有实例化AttachInfo，导致mAttachInfo为null，最终if条件判断失败没有进入。然而这一切都是在YY，实践才是检验真理的唯一标准，动起来：\n\n看到这一行代码```\nActivityClientRecord r = performResumeActivity(token, clearHide);\n```微微一笑，点进去看看，\n\n```\n    public final ActivityClientRecord performResumeActivity(IBinder token,\n            boolean clearHide) {\n        ActivityClientRecord r = mActivities.get(token);\n        if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r\n                + \" finished=\" + r.activity.mFinished);\n        if (r != null && !r.activity.mFinished) {\n            if (clearHide) {\n                r.hideForNow = false;\n                r.activity.mStartedActivity = false;\n            }\n            try {\n                r.activity.mFragments.noteStateNotSaved();\n                if (r.pendingIntents != null) {\n                    deliverNewIntents(r, r.pendingIntents);\n                    r.pendingIntents = null;\n                }\n                if (r.pendingResults != null) {\n                    deliverResults(r, r.pendingResults);\n                    r.pendingResults = null;\n                }\n                r.activity.performResume();\n\n                EventLog.writeEvent(LOG_ON_RESUME_CALLED,\n                        UserHandle.myUserId(), r.activity.getComponentName().getClassName());\n\n                r.paused = false;\n                r.stopped = false;\n                r.state = null;\n                r.persistentState = null;\n            } catch (Exception e) {\n                if (!mInstrumentation.onException(r.activity, e)) {\n                    throw new RuntimeException(\n                        \"Unable to resume activity \"\n                        + r.intent.getComponent().toShortString()\n                        + \": \" + e.toString(), e);\n                }\n            }\n        }\n        return r;\n    }\n```\n代码很短，很容易提取有用信息：``` r.activity.performResume();```在进去看看：\n\n```\n\n    final void performResume() {\n        performRestart();\n\n        mFragments.execPendingActions();\n\n        mLastNonConfigurationInstances = null;\n\n        mCalled = false;\n        // mResumed is set by the instrumentation\n        mInstrumentation.callActivityOnResume(this);\n        if (!mCalled) {\n            throw new SuperNotCalledException(\n                \"Activity \" + mComponent.toShortString() +\n                \" did not call through to super.onResume()\");\n        }\n\n        // Now really resume, and install the current status bar and menu.\n        mCalled = false;\n\n        mFragments.dispatchResume();\n        mFragments.execPendingActions();\n\n        onPostResume();\n        if (!mCalled) {\n            throw new SuperNotCalledException(\n                \"Activity \" + mComponent.toShortString() +\n                \" did not call through to super.onPostResume()\");\n        }\n    }\n```\n看到```mInstrumentation```这个属性就能感觉到越来越接近SDK API层了，看看它的```callActivityOnResume()```方法做了什么：\n\n```\n    public void callActivityOnResume(Activity activity) {\n        activity.mResumed = true;\n        activity.onResume();\n        \n        if (mActivityMonitors != null) {\n            synchronized (mSync) {\n                final int N = mActivityMonitors.size();\n                for (int i=0; i<N; i++) {\n                    final ActivityMonitor am = mActivityMonitors.get(i);\n                    am.match(activity, activity, activity.getIntent());\n                }\n            }\n        }\n    }\n```\n\n一行```activity.onResume();```已经水落石出。\n回到handleResumeActivity代码中，我精简下：\n\n```\n final void handleResumeActivity(IBinder token,\n            boolean clearHide, boolean isForward, boolean reallyResume) {\n   //这里是最终回调Activity的onResume()方法\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\n//省略若干\n        if (r != null) {\n            final Activity a = r.activity;\n            final int forwardBit = isForward ?\n            WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\n            boolean willBeVisible = !a.mStartedActivity;\n\n            if (r.window == null && !a.mFinished && willBeVisible) {\n                r.window = r.activity.getWindow();\n                View decor = r.window.getDecorView();\n                decor.setVisibility(View.INVISIBLE);\n                ViewManager wm = a.getWindowManager();\n                WindowManager.LayoutParams l = r.window.getAttributes();\n                a.mDecor = decor;\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n                l.softInputMode |= forwardBit;\n                if (a.mVisibleFromClient) {\n                    a.mWindowAdded = true;\n//这里是调用WindowManagerGlobal的addView()方法最终实例化ViewRootImpl，进而实例化AttachInfo\n                    wm.addView(decor, l);\n                }\n       \n            } else if (!willBeVisible) {\n                if (localLOGV) Slog.v(\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\n                r.hideForNow = true;\n            }\n        }\n    }\n```\n\n\n另外关于阅读源码问题，win下当然使用SourceInsight不二选，如果是在mac下可以参考我的[osx下如何使用SublimeText阅读Android系统源码](http://www.jianshu.com/p/c295d2729ecf).。","slug":"为什么我在工作线程刷新UI没报错","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjhn005jwh9cms5lrqmx","content":"<blockquote>\n<p>从做Android开发以来就一直被灌输“只能在主线程刷新UI”的思想，但是这两天发现个问题，在onCreate中创建工作线程并刷新UI没有报错。代码是这样的：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">    super.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.activity_main);</div><div class=\"line\">   final TextView tv = (TextView) findViewById(R.id.sample_text);</div><div class=\"line\">   new Thread(new Runnable() &#123;</div><div class=\"line\">       @Override</div><div class=\"line\">       public void run() &#123;</div><div class=\"line\">           tv.setText(&quot;来自&quot;+Thread.currentThread().getName()+&quot;线程的更新&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;).start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>期待已久的crash没有出现，反而页面是这样显示的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-7be6319d0fc94867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-26 下午7.14.46.png\"><br>不禁让人陷入深思···<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-8a0ce88639c31d1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"思考.jpg\"></p>\n<p>第一步，分析问题原因。以前工作线程刷新UI会出现异常并提示只能在UI线程刷新UI。所以假设有个地方(函数)会在刷新UI前判断当前线程是不是主线程，那么现在问题就是验证下是否真的存在这么个地方。问题是从setText引起的，那就从这里出发看看。<br>点进去看下发现又调用了其重载函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@android.view.RemotableViewMethod</div><div class=\"line\">public final void setText(CharSequence text) &#123;</div><div class=\"line\">    setText(text, mBufferType);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>继续深入发现这个方法代码挺多的，但是不用过于关注细节，粗略浏览下不难发现前面大部分代码大多是对text文本格式的一些处理判断，无关刷新UI，直到            checkForRelayout()方法执行，从名字看是“从新布局”，根据view绘制流程测量、布局、绘制，那布局完了不是就绘制刷新了吗？所以决定去checkForRelayout方法看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setText(CharSequence text, BufferType type,</div><div class=\"line\">                     boolean notifyBefore, int oldlen) &#123;</div><div class=\"line\">    if (text == null) &#123;</div><div class=\"line\">        text = &quot;&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If suggestions are not enabled, remove the suggestion spans from the text</div><div class=\"line\">    if (!isSuggestionsEnabled()) &#123;</div><div class=\"line\">        text = removeSuggestionSpans(text);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!mUserSetTextScaleX) mTextPaint.setTextScaleX(1.0f);</div><div class=\"line\"></div><div class=\"line\">    if (text instanceof Spanned &amp;&amp;</div><div class=\"line\">        ((Spanned) text).getSpanStart(TextUtils.TruncateAt.MARQUEE) &gt;= 0) &#123;</div><div class=\"line\">        if (ViewConfiguration.get(mContext).isFadingMarqueeEnabled()) &#123;</div><div class=\"line\">            setHorizontalFadingEdgeEnabled(true);</div><div class=\"line\">            mMarqueeFadeMode = MARQUEE_FADE_NORMAL;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            setHorizontalFadingEdgeEnabled(false);</div><div class=\"line\">            mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;</div><div class=\"line\">        &#125;</div><div class=\"line\">        setEllipsize(TextUtils.TruncateAt.MARQUEE);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int n = mFilters.length;</div><div class=\"line\">    for (int i = 0; i &lt; n; i++) &#123;</div><div class=\"line\">        CharSequence out = mFilters[i].filter(text, 0, text.length(), EMPTY_SPANNED, 0, 0);</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            text = out;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (notifyBefore) &#123;</div><div class=\"line\">        if (mText != null) &#123;</div><div class=\"line\">            oldlen = mText.length();</div><div class=\"line\">            sendBeforeTextChanged(mText, 0, oldlen, text.length());</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            sendBeforeTextChanged(&quot;&quot;, 0, 0, text.length());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    boolean needEditableForNotification = false;</div><div class=\"line\"></div><div class=\"line\">    if (mListeners != null &amp;&amp; mListeners.size() != 0) &#123;</div><div class=\"line\">        needEditableForNotification = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (type == BufferType.EDITABLE || getKeyListener() != null ||</div><div class=\"line\">            needEditableForNotification) &#123;</div><div class=\"line\">        createEditorIfNeeded();</div><div class=\"line\">        Editable t = mEditableFactory.newEditable(text);</div><div class=\"line\">        text = t;</div><div class=\"line\">        setFilters(t, mFilters);</div><div class=\"line\">        InputMethodManager imm = InputMethodManager.peekInstance();</div><div class=\"line\">        if (imm != null) imm.restartInput(this);</div><div class=\"line\">    &#125; else if (type == BufferType.SPANNABLE || mMovement != null) &#123;</div><div class=\"line\">        text = mSpannableFactory.newSpannable(text);</div><div class=\"line\">    &#125; else if (!(text instanceof CharWrapper)) &#123;</div><div class=\"line\">        text = TextUtils.stringOrSpannedString(text);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mAutoLinkMask != 0) &#123;</div><div class=\"line\">        Spannable s2;</div><div class=\"line\"></div><div class=\"line\">        if (type == BufferType.EDITABLE || text instanceof Spannable) &#123;</div><div class=\"line\">            s2 = (Spannable) text;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            s2 = mSpannableFactory.newSpannable(text);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (Linkify.addLinks(s2, mAutoLinkMask)) &#123;</div><div class=\"line\">            text = s2;</div><div class=\"line\">            type = (type == BufferType.EDITABLE) ? BufferType.EDITABLE : BufferType.SPANNABLE;</div><div class=\"line\"></div><div class=\"line\">            /*</div><div class=\"line\">             * We must go ahead and set the text before changing the</div><div class=\"line\">             * movement method, because setMovementMethod() may call</div><div class=\"line\">             * setText() again to try to upgrade the buffer type.</div><div class=\"line\">             */</div><div class=\"line\">            mText = text;</div><div class=\"line\"></div><div class=\"line\">            // Do not change the movement method for text that support text selection as it</div><div class=\"line\">            // would prevent an arbitrary cursor displacement.</div><div class=\"line\">            if (mLinksClickable &amp;&amp; !textCanBeSelected()) &#123;</div><div class=\"line\">                setMovementMethod(LinkMovementMethod.getInstance());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mBufferType = type;</div><div class=\"line\">    mText = text;</div><div class=\"line\"></div><div class=\"line\">    if (mTransformation == null) &#123;</div><div class=\"line\">        mTransformed = text;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mTransformed = mTransformation.getTransformation(text, this);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final int textLength = text.length();</div><div class=\"line\"></div><div class=\"line\">    if (text instanceof Spannable &amp;&amp; !mAllowTransformationLengthChange) &#123;</div><div class=\"line\">        Spannable sp = (Spannable) text;</div><div class=\"line\"></div><div class=\"line\">        // Remove any ChangeWatchers that might have come from other TextViews.</div><div class=\"line\">        final ChangeWatcher[] watchers = sp.getSpans(0, sp.length(), ChangeWatcher.class);</div><div class=\"line\">        final int count = watchers.length;</div><div class=\"line\">        for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\">            sp.removeSpan(watchers[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (mChangeWatcher == null) mChangeWatcher = new ChangeWatcher();</div><div class=\"line\"></div><div class=\"line\">        sp.setSpan(mChangeWatcher, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE |</div><div class=\"line\">                   (CHANGE_WATCHER_PRIORITY &lt;&lt; Spanned.SPAN_PRIORITY_SHIFT));</div><div class=\"line\"></div><div class=\"line\">        if (mEditor != null) mEditor.addSpanWatchers(sp);</div><div class=\"line\"></div><div class=\"line\">        if (mTransformation != null) &#123;</div><div class=\"line\">            sp.setSpan(mTransformation, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (mMovement != null) &#123;</div><div class=\"line\">            mMovement.initialize(this, (Spannable) text);</div><div class=\"line\"></div><div class=\"line\">            /*</div><div class=\"line\">             * Initializing the movement method will have set the</div><div class=\"line\">             * selection, so reset mSelectionMoved to keep that from</div><div class=\"line\">             * interfering with the normal on-focus selection-setting.</div><div class=\"line\">             */</div><div class=\"line\">            if (mEditor != null) mEditor.mSelectionMoved = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mLayout != null) &#123;</div><div class=\"line\">        checkForRelayout();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sendOnTextChanged(text, 0, oldlen, textLength);</div><div class=\"line\">    onTextChanged(text, 0, oldlen, textLength);</div><div class=\"line\"></div><div class=\"line\">    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT);</div><div class=\"line\"></div><div class=\"line\">    if (needEditableForNotification) &#123;</div><div class=\"line\">        sendAfterTextChanged((Editable) text);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // SelectionModifierCursorController depends on textCanBeSelected, which depends on text</div><div class=\"line\">    if (mEditor != null) mEditor.prepareCursorControllers();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找到checkForRelayout方法查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void checkForRelayout() &#123;</div><div class=\"line\">    // If we have a fixed width, we can just swap in a new text layout</div><div class=\"line\">    // if the text height stays the same or if the view height is fixed.</div><div class=\"line\"></div><div class=\"line\">    if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT ||</div><div class=\"line\">            (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth)) &amp;&amp;</div><div class=\"line\">            (mHint == null || mHintLayout != null) &amp;&amp;</div><div class=\"line\">            (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; 0)) &#123;</div><div class=\"line\">        // Static width, so try making a new text layout.</div><div class=\"line\"></div><div class=\"line\">        int oldht = mLayout.getHeight();</div><div class=\"line\">        int want = mLayout.getWidth();</div><div class=\"line\">        int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth();</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * No need to bring the text into view, since the size is not</div><div class=\"line\">         * changing (unless we do the requestLayout(), in which case it</div><div class=\"line\">         * will happen at measure).</div><div class=\"line\">         */</div><div class=\"line\">        makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,</div><div class=\"line\">                      mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),</div><div class=\"line\">                      false);</div><div class=\"line\"></div><div class=\"line\">        if (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123;</div><div class=\"line\">            // In a fixed-height view, so use our new text layout.</div><div class=\"line\">            if (mLayoutParams.height != LayoutParams.WRAP_CONTENT &amp;&amp;</div><div class=\"line\">                mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                invalidate();</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Dynamic height, but height has stayed the same,</div><div class=\"line\">            // so use our new text layout.</div><div class=\"line\">            if (mLayout.getHeight() == oldht &amp;&amp;</div><div class=\"line\">                (mHintLayout == null || mHintLayout.getHeight() == oldht)) &#123;</div><div class=\"line\">                invalidate();</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We lose: the height has changed and we have a dynamic height.</div><div class=\"line\">        // Request a new view layout using our new text layout.</div><div class=\"line\">        requestLayout();</div><div class=\"line\">        invalidate();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Dynamic width, so we have no choice but to request a new</div><div class=\"line\">        // view layout with a new text layout.</div><div class=\"line\">        nullLayouts();</div><div class=\"line\">        requestLayout();</div><div class=\"line\">        invalidate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发现不管是if还是else，都要执行invalidate()，那就进去看看，一路进展比较顺利，好像离真理更进一步了。经过连续的三连调跳转到了invalidateInternal方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void invalidate() &#123;</div><div class=\"line\">       invalidate(true);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   /**</div><div class=\"line\">    * This is where the invalidate() work actually happens. A full invalidate()</div><div class=\"line\">    * causes the drawing cache to be invalidated, but this function can be</div><div class=\"line\">    * called with invalidateCache set to false to skip that invalidation step</div><div class=\"line\">    * for cases that do not need it (for example, a component that remains at</div><div class=\"line\">    * the same dimensions with the same content).</div><div class=\"line\">    *</div><div class=\"line\">    * @param invalidateCache Whether the drawing cache for this view should be</div><div class=\"line\">    *            invalidated as well. This is usually true for a full</div><div class=\"line\">    *            invalidate, but may be set to false if the View&apos;s contents or</div><div class=\"line\">    *            dimensions have not changed.</div><div class=\"line\">    */</div><div class=\"line\">   void invalidate(boolean invalidateCache) &#123;</div><div class=\"line\">       invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</div><div class=\"line\">           boolean fullInvalidate) &#123;</div><div class=\"line\">       if (mGhostView != null) &#123;</div><div class=\"line\">           mGhostView.invalidate(true);</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       if (skipInvalidate()) &#123;</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</div><div class=\"line\">               || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</div><div class=\"line\">               || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</div><div class=\"line\">               || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</div><div class=\"line\">           if (fullInvalidate) &#123;</div><div class=\"line\">               mLastIsOpaque = isOpaque();</div><div class=\"line\">               mPrivateFlags &amp;= ~PFLAG_DRAWN;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           mPrivateFlags |= PFLAG_DIRTY;</div><div class=\"line\"></div><div class=\"line\">           if (invalidateCache) &#123;</div><div class=\"line\">               mPrivateFlags |= PFLAG_INVALIDATED;</div><div class=\"line\">               mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Propagate the damage rectangle to the parent view.</div><div class=\"line\">           final AttachInfo ai = mAttachInfo;</div><div class=\"line\">           final ViewParent p = mParent;</div><div class=\"line\">           if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class=\"line\">               final Rect damage = ai.mTmpInvalRect;</div><div class=\"line\">               damage.set(l, t, r, b);</div><div class=\"line\">               p.invalidateChild(this, damage);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Damage the entire projection receiver, if necessary.</div><div class=\"line\">           if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123;</div><div class=\"line\">               final View receiver = getProjectionReceiver();</div><div class=\"line\">               if (receiver != null) &#123;</div><div class=\"line\">                   receiver.damageInParent();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Damage the entire IsolatedZVolume receiving this view&apos;s shadow.</div><div class=\"line\">           if (isHardwareAccelerated() &amp;&amp; getZ() != 0) &#123;</div><div class=\"line\">               damageShadowReceiver();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>重点看invalidateChild()这个方法，方法里面有do while循环，每次循环出当前view的parent，最后一次循环返回的parent时ViewRootImpl类实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class=\"line\">       ViewParent parent = this;</div><div class=\"line\"></div><div class=\"line\">       final AttachInfo attachInfo = mAttachInfo;</div><div class=\"line\">       if (attachInfo != null) &#123;</div><div class=\"line\">           // If the child is drawing an animation, we want to copy this flag onto</div><div class=\"line\">           // ourselves and the parent to make sure the invalidate request goes</div><div class=\"line\">           // through</div><div class=\"line\">           final boolean drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION)</div><div class=\"line\">                   == PFLAG_DRAW_ANIMATION;</div><div class=\"line\"></div><div class=\"line\">           // Check whether the child that requests the invalidate is fully opaque</div><div class=\"line\">           // Views being animated or transformed are not considered opaque because we may</div><div class=\"line\">           // be invalidating their old position and need the parent to paint behind them.</div><div class=\"line\">           Matrix childMatrix = child.getMatrix();</div><div class=\"line\">           final boolean isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp;</div><div class=\"line\">                   child.getAnimation() == null &amp;&amp; childMatrix.isIdentity();</div><div class=\"line\">           // Mark the child as dirty, using the appropriate flag</div><div class=\"line\">           // Make sure we do not set both flags at the same time</div><div class=\"line\">           int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</div><div class=\"line\"></div><div class=\"line\">           if (child.mLayerType != LAYER_TYPE_NONE) &#123;</div><div class=\"line\">               mPrivateFlags |= PFLAG_INVALIDATED;</div><div class=\"line\">               mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           final int[] location = attachInfo.mInvalidateChildLocation;</div><div class=\"line\">           location[CHILD_LEFT_INDEX] = child.mLeft;</div><div class=\"line\">           location[CHILD_TOP_INDEX] = child.mTop;</div><div class=\"line\">           if (!childMatrix.isIdentity() ||</div><div class=\"line\">                   (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123;</div><div class=\"line\">               RectF boundingRect = attachInfo.mTmpTransformRect;</div><div class=\"line\">               boundingRect.set(dirty);</div><div class=\"line\">               Matrix transformMatrix;</div><div class=\"line\">               if ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123;</div><div class=\"line\">                   Transformation t = attachInfo.mTmpTransformation;</div><div class=\"line\">                   boolean transformed = getChildStaticTransformation(child, t);</div><div class=\"line\">                   if (transformed) &#123;</div><div class=\"line\">                       transformMatrix = attachInfo.mTmpMatrix;</div><div class=\"line\">                       transformMatrix.set(t.getMatrix());</div><div class=\"line\">                       if (!childMatrix.isIdentity()) &#123;</div><div class=\"line\">                           transformMatrix.preConcat(childMatrix);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125; else &#123;</div><div class=\"line\">                       transformMatrix = childMatrix;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   transformMatrix = childMatrix;</div><div class=\"line\">               &#125;</div><div class=\"line\">               transformMatrix.mapRect(boundingRect);</div><div class=\"line\">               dirty.set((int) (boundingRect.left - 0.5f),</div><div class=\"line\">                       (int) (boundingRect.top - 0.5f),</div><div class=\"line\">                       (int) (boundingRect.right + 0.5f),</div><div class=\"line\">                       (int) (boundingRect.bottom + 0.5f));</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           do &#123;</div><div class=\"line\">               View view = null;</div><div class=\"line\">               if (parent instanceof View) &#123;</div><div class=\"line\">                   view = (View) parent;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (drawAnimation) &#123;</div><div class=\"line\">                   if (view != null) &#123;</div><div class=\"line\">                       view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class=\"line\">                   &#125; else if (parent instanceof ViewRootImpl) &#123;</div><div class=\"line\">                       ((ViewRootImpl) parent).mIsAnimating = true;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               // If the parent is dirty opaque or not dirty, mark it dirty with the opaque</div><div class=\"line\">               // flag coming from the child that initiated the invalidate</div><div class=\"line\">               if (view != null) &#123;</div><div class=\"line\">                   if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp;</div><div class=\"line\">                           view.getSolidColor() == 0) &#123;</div><div class=\"line\">                       opaqueFlag = PFLAG_DIRTY;</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</div><div class=\"line\">                       view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               parent = parent.invalidateChildInParent(location, dirty);</div><div class=\"line\">               if (view != null) &#123;</div><div class=\"line\">                   // Account for transform on current parent</div><div class=\"line\">                   Matrix m = view.getMatrix();</div><div class=\"line\">                   if (!m.isIdentity()) &#123;</div><div class=\"line\">                       RectF boundingRect = attachInfo.mTmpTransformRect;</div><div class=\"line\">                       boundingRect.set(dirty);</div><div class=\"line\">                       m.mapRect(boundingRect);</div><div class=\"line\">                       dirty.set((int) (boundingRect.left - 0.5f),</div><div class=\"line\">                               (int) (boundingRect.top - 0.5f),</div><div class=\"line\">                               (int) (boundingRect.right + 0.5f),</div><div class=\"line\">                               (int) (boundingRect.bottom + 0.5f));</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; while (parent != null);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>现在查看ViewRootImpl类的invalidateChildInParent()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</div><div class=\"line\">    checkThread();</div><div class=\"line\">    if (DEBUG_DRAW) Log.v(TAG, &quot;Invalidate child: &quot; + dirty);</div><div class=\"line\"></div><div class=\"line\">    if (dirty == null) &#123;</div><div class=\"line\">        invalidate();</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mCurScrollY != 0 || mTranslator != null) &#123;</div><div class=\"line\">        mTempRect.set(dirty);</div><div class=\"line\">        dirty = mTempRect;</div><div class=\"line\">        if (mCurScrollY != 0) &#123;</div><div class=\"line\">            dirty.offset(0, -mCurScrollY);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mTranslator != null) &#123;</div><div class=\"line\">            mTranslator.translateRectInAppWindowToScreen(dirty);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mAttachInfo.mScalingRequired) &#123;</div><div class=\"line\">            dirty.inset(-1, -1);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final Rect localDirty = mDirty;</div><div class=\"line\">    if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</div><div class=\"line\">        mAttachInfo.mSetIgnoreDirtyState = true;</div><div class=\"line\">        mAttachInfo.mIgnoreDirtyState = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Add the new dirty rect to the current one</div><div class=\"line\">    localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</div><div class=\"line\">    // Intersect with the bounds of the window to skip</div><div class=\"line\">    // updates that lie outside of the visible region</div><div class=\"line\">    final float appScale = mAttachInfo.mApplicationScale;</div><div class=\"line\">    final boolean intersected = localDirty.intersect(0, 0,</div><div class=\"line\">            (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));</div><div class=\"line\">    if (!intersected) &#123;</div><div class=\"line\">        localDirty.setEmpty();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</div><div class=\"line\">        scheduleTraversals();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法块的第一行好像就是我们要找的验证线程的地方checkThread()，而该方法内容也很简单，看到抛出的异常就很熟悉了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">void checkThread() &#123;</div><div class=\"line\">    if (mThread != Thread.currentThread()) &#123;</div><div class=\"line\">        throw new CalledFromWrongThreadException(</div><div class=\"line\">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二步，验证线程地方已经找到了，假设得到了证实，那么为什么该有的异常没有出现呢？现在再次假设是不是因为某些原因导致checkThread()没有执行呢？</p>\n<p>有人可能会问会不会是mThread == Thread.currentThread()？其实这是不可能的 ，先看下mThread赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ViewRootImpl(Context context, Display display) &#123;</div><div class=\"line\">    mContext = context;</div><div class=\"line\">    mWindowSession = WindowManagerGlobal.getWindowSession();</div><div class=\"line\">    mDisplay = display;</div><div class=\"line\">    mBasePackageName = context.getBasePackageName();</div><div class=\"line\"></div><div class=\"line\">    mDisplayAdjustments = display.getDisplayAdjustments();</div><div class=\"line\"></div><div class=\"line\">    mThread = Thread.currentThread();</div></pre></td></tr></table></figure>\n<p>ViewRootImpl类实例化是在Activity启动时的主线程创建的，所以mThread是主线程实例，而checkThread()中的Thread.currentThread()，最初是由textView.setText()调用的一系列方法栈，并且setText是在子线程调用。</p>\n<p>继续刚才的假设，不过现在要逆推回去，checkThread()方法没有执行，可以认为ViewRootImpl的invalidateChildInParent()方法没有执行，它又是在ViewGroup中invalidateChild()方法里的do while中调用，要使do while不被调用，继续往上看，如果attachInfo为null，进不去if语句块也就不会执行checkThread()了，这是第一个可能的原因。记录下，继续逆推。</p>\n<p>View中的invalidateInternal()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Propagate the damage rectangle to the parent view.</div><div class=\"line\">      final AttachInfo ai = mAttachInfo;</div><div class=\"line\">      final ViewParent p = mParent;</div><div class=\"line\">      if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class=\"line\">          final Rect damage = ai.mTmpInvalRect;</div><div class=\"line\">          damage.set(l, t, r, b);</div><div class=\"line\">          p.invalidateChild(this, damage);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>根据判断条件，如果p即mParent或者ai即mAttachInfo 任一为null，都不会执行invalidateChild，这是第二个可能原因，这里的ai和第一个原因的attachInfo是一样的，所以第一个原因可能忽略，精力关注在第二个原因上。</p>\n<blockquote>\n<p>现在的关注点是实例p和ai是什么时候创建的，有没有为null的现象？</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AttachInfo ai = mAttachInfo;</div></pre></td></tr></table></figure>\n<p>而mAttachInfo是在View的dispatchAttachedToWindow()方法中赋值的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</div><div class=\"line\">        //System.out.println(&quot;Attached! &quot; + this);</div><div class=\"line\">        mAttachInfo = info;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>View的dispatchAttachedToWindow()方法是在ViewRootImpl中的performTraversals()方法调用，这个方法是遍历View Tree</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void performTraversals() &#123;</div><div class=\"line\">       // cache mView since it is used so much below...</div><div class=\"line\">       final View host = mView;</div><div class=\"line\">       ·······</div><div class=\"line\">       host.dispatchAttachedToWindow(mAttachInfo, 0);</div></pre></td></tr></table></figure>\n<p>可见View中的mAttachInfo来自ViewrootImpl的mAttachInfo，而ViewrootImpl的mAttachInfo是在其构造方法中被赋值的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public ViewRootImpl(Context context, Display display) &#123;</div><div class=\"line\">    mContext = context;</div><div class=\"line\">    mWindowSession = WindowManagerGlobal.getWindowSession();</div><div class=\"line\">    mDisplay = display;</div><div class=\"line\">    mBasePackageName = context.getBasePackageName();</div><div class=\"line\"></div><div class=\"line\">    mDisplayAdjustments = display.getDisplayAdjustments();</div><div class=\"line\"></div><div class=\"line\">    mThread = Thread.currentThread();</div><div class=\"line\">    mLocation = new WindowLeaked(null);</div><div class=\"line\">    mLocation.fillInStackTrace();</div><div class=\"line\">    mWidth = -1;</div><div class=\"line\">    mHeight = -1;</div><div class=\"line\">    mDirty = new Rect();</div><div class=\"line\">    mTempRect = new Rect();</div><div class=\"line\">    mVisRect = new Rect();</div><div class=\"line\">    mWinFrame = new Rect();</div><div class=\"line\">    mWindow = new W(this);</div><div class=\"line\">    mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;</div><div class=\"line\">    mViewVisibility = View.GONE;</div><div class=\"line\">    mTransparentRegion = new Region();</div><div class=\"line\">    mPreviousTransparentRegion = new Region();</div><div class=\"line\">    mFirst = true; // true for the first time the view is added</div><div class=\"line\">    mAdded = false;</div><div class=\"line\">    mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);</div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>之前说了ViewRootImpl实例是在Activity启动时创建的，现在看看具体是启动的什么时候:在向window添加view的时候即：WindowManagerGlobal的addView方法中创建ViewrootImpl实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void addView(View view, ViewGroup.LayoutParams params,</div><div class=\"line\">           Display display, Window parentWindow) &#123;</div><div class=\"line\">       if (view == null) &#123;</div><div class=\"line\">           throw new IllegalArgumentException(&quot;view must not be null&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (display == null) &#123;</div><div class=\"line\">           throw new IllegalArgumentException(&quot;display must not be null&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!(params instanceof WindowManager.LayoutParams)) &#123;</div><div class=\"line\">           throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</div><div class=\"line\">       if (parentWindow != null) &#123;</div><div class=\"line\">           parentWindow.adjustLayoutParamsForSubWindow(wparams);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           // If there&apos;s no parent and we&apos;re running on L or above (or in the</div><div class=\"line\">           // system context), assume we want hardware acceleration.</div><div class=\"line\">           final Context context = view.getContext();</div><div class=\"line\">           if (context != null</div><div class=\"line\">                   &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class=\"line\">               wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       ViewRootImpl root;</div><div class=\"line\">       View panelParentView = null;</div><div class=\"line\"></div><div class=\"line\">       synchronized (mLock) &#123;</div><div class=\"line\">           // Start watching for system property changes.</div><div class=\"line\">           if (mSystemPropertyUpdater == null) &#123;</div><div class=\"line\">               mSystemPropertyUpdater = new Runnable() &#123;</div><div class=\"line\">                   @Override public void run() &#123;</div><div class=\"line\">                       synchronized (mLock) &#123;</div><div class=\"line\">                           for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">                               mRoots.get(i).loadSystemProperties();</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;;</div><div class=\"line\">               SystemProperties.addChangeCallback(mSystemPropertyUpdater);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           int index = findViewLocked(view, false);</div><div class=\"line\">           if (index &gt;= 0) &#123;</div><div class=\"line\">               if (mDyingViews.contains(view)) &#123;</div><div class=\"line\">                   // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue.</div><div class=\"line\">                   mRoots.get(index).doDie();</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   throw new IllegalStateException(&quot;View &quot; + view</div><div class=\"line\">                           + &quot; has already been added to the window manager.&quot;);</div><div class=\"line\">               &#125;</div><div class=\"line\">               // The previous removeView() had not completed executing. Now it has.</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // If this is a panel window, then find the window it is being</div><div class=\"line\">           // attached to for future reference.</div><div class=\"line\">           if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</div><div class=\"line\">                   wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</div><div class=\"line\">               final int count = mViews.size();</div><div class=\"line\">               for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\">                   if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</div><div class=\"line\">                       panelParentView = mViews.get(i);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           root = new ViewRootImpl(view.getContext(), display);</div><div class=\"line\"></div><div class=\"line\">           view.setLayoutParams(wparams);</div><div class=\"line\"></div><div class=\"line\">           mViews.add(view);</div><div class=\"line\">           mRoots.add(root);</div><div class=\"line\">           mParams.add(wparams);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       // do this last because it fires off messages to start doing things</div><div class=\"line\">       try &#123;</div><div class=\"line\">           root.setView(view, wparams, panelParentView);</div><div class=\"line\">       &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">           // BadTokenException or InvalidDisplayException, clean up.</div><div class=\"line\">           synchronized (mLock) &#123;</div><div class=\"line\">               final int index = findViewLocked(view, false);</div><div class=\"line\">               if (index &gt;= 0) &#123;</div><div class=\"line\">                   removeViewLocked(index, true);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           throw e;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>而调用addView()方法是在ActivityThread类的handleResumeActivity()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">final void handleResumeActivity(IBinder token,</div><div class=\"line\">        boolean clearHide, boolean isForward, boolean reallyResume) &#123;</div><div class=\"line\">    // If we are getting ready to gc after going to the background, well</div><div class=\"line\">    // we are back active so skip it.</div><div class=\"line\">    unscheduleGcIdler();</div><div class=\"line\">    mSomeActivitiesChanged = true;</div><div class=\"line\"></div><div class=\"line\">    // TODO Push resumeArgs into the activity for consideration</div><div class=\"line\">    ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class=\"line\"></div><div class=\"line\">    if (r != null) &#123;</div><div class=\"line\">        final Activity a = r.activity;</div><div class=\"line\"></div><div class=\"line\">        if (localLOGV) Slog.v(</div><div class=\"line\">            TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</div><div class=\"line\">            a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</div><div class=\"line\">            + &quot;, finished: &quot; + a.mFinished);</div><div class=\"line\"></div><div class=\"line\">        final int forwardBit = isForward ?</div><div class=\"line\">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</div><div class=\"line\"></div><div class=\"line\">        // If the window hasn&apos;t yet been added to the window manager,</div><div class=\"line\">        // and this guy didn&apos;t finish itself or start another activity,</div><div class=\"line\">        // then go ahead and add the window.</div><div class=\"line\">        boolean willBeVisible = !a.mStartedActivity;</div><div class=\"line\">        if (!willBeVisible) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(</div><div class=\"line\">                        a.getActivityToken());</div><div class=\"line\">            &#125; catch (RemoteException e) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class=\"line\">            r.window = r.activity.getWindow();</div><div class=\"line\">            View decor = r.window.getDecorView();</div><div class=\"line\">            decor.setVisibility(View.INVISIBLE);</div><div class=\"line\">            ViewManager wm = a.getWindowManager();</div><div class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</div><div class=\"line\">            a.mDecor = decor;</div><div class=\"line\">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class=\"line\">            l.softInputMode |= forwardBit;</div><div class=\"line\">            if (a.mVisibleFromClient) &#123;</div><div class=\"line\">                a.mWindowAdded = true;</div><div class=\"line\">                wm.addView(decor, l);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the window has already been added, but during resume</div><div class=\"line\">        // we started another activity, then don&apos;t yet make the</div><div class=\"line\">        // window visible.</div><div class=\"line\">        &#125; else if (!willBeVisible) &#123;</div><div class=\"line\">            if (localLOGV) Slog.v(</div><div class=\"line\">                TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</div><div class=\"line\">            r.hideForNow = true;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Get rid of anything left hanging around.</div><div class=\"line\">        cleanUpPendingRemoveWindows(r);</div><div class=\"line\"></div><div class=\"line\">        // The window is now visible if it has been added, we are not</div><div class=\"line\">        // simply finishing, and we are not starting another activity.</div><div class=\"line\">        if (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class=\"line\">                &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</div><div class=\"line\">            if (r.newConfig != null) &#123;</div><div class=\"line\">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</div><div class=\"line\">                        + r.activityInfo.name + &quot; with newConfig &quot; + r.newConfig);</div><div class=\"line\">                performConfigurationChanged(r.activity, r.newConfig);</div><div class=\"line\">                freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig));</div><div class=\"line\">                r.newConfig = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;</div><div class=\"line\">                    + isForward);</div><div class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</div><div class=\"line\">            if ((l.softInputMode</div><div class=\"line\">                    &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</div><div class=\"line\">                    != forwardBit) &#123;</div><div class=\"line\">                l.softInputMode = (l.softInputMode</div><div class=\"line\">                        &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</div><div class=\"line\">                        | forwardBit;</div><div class=\"line\">                if (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                    ViewManager wm = a.getWindowManager();</div><div class=\"line\">                    View decor = r.window.getDecorView();</div><div class=\"line\">                    wm.updateViewLayout(decor, l);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            r.activity.mVisibleFromServer = true;</div><div class=\"line\">            mNumVisibleActivities++;</div><div class=\"line\">            if (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                r.activity.makeVisible();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!r.onlyLocalRequest) &#123;</div><div class=\"line\">            r.nextIdle = mNewActivities;</div><div class=\"line\">            mNewActivities = r;</div><div class=\"line\">            if (localLOGV) Slog.v(</div><div class=\"line\">                TAG, &quot;Scheduling idle handler for &quot; + r);</div><div class=\"line\">            Looper.myQueue().addIdleHandler(new Idler());</div><div class=\"line\">        &#125;</div><div class=\"line\">        r.onlyLocalRequest = false;</div><div class=\"line\"></div><div class=\"line\">        // Tell the activity manager we have resumed.</div><div class=\"line\">        if (reallyResume) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ActivityManagerNative.getDefault().activityResumed(token);</div><div class=\"line\">            &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // If an exception was thrown when trying to resume, then</div><div class=\"line\">        // just end this activity.</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ActivityManagerNative.getDefault()</div><div class=\"line\">                .finishActivity(token, Activity.RESULT_CANCELED, null, false);</div><div class=\"line\">        &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看到上面的方法有些人心里可能有底儿了，handleResumeActivity()方法是不是让Activity回调onResume？如果是的话一切就都明了了，因为ViewrootImpl是在onReume期间创建，而AttachInfo是在ViewRootImpl实例化时创建，我们的工作线程是在onCreate时刷新UI的，那时候还没有实例化AttachInfo，导致mAttachInfo为null，最终if条件判断失败没有进入。然而这一切都是在YY，实践才是检验真理的唯一标准，动起来：</p>\n<p>看到这一行代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class=\"line\">```微微一笑，点进去看看，</div></pre></td></tr></table></figure></p>\n<pre><code>public final ActivityClientRecord performResumeActivity(IBinder token,\n        boolean clearHide) {\n    ActivityClientRecord r = mActivities.get(token);\n    if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r\n            + &quot; finished=&quot; + r.activity.mFinished);\n    if (r != null &amp;&amp; !r.activity.mFinished) {\n        if (clearHide) {\n            r.hideForNow = false;\n            r.activity.mStartedActivity = false;\n        }\n        try {\n            r.activity.mFragments.noteStateNotSaved();\n            if (r.pendingIntents != null) {\n                deliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            if (r.pendingResults != null) {\n                deliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            r.activity.performResume();\n\n            EventLog.writeEvent(LOG_ON_RESUME_CALLED,\n                    UserHandle.myUserId(), r.activity.getComponentName().getClassName());\n\n            r.paused = false;\n            r.stopped = false;\n            r.state = null;\n            r.persistentState = null;\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(r.activity, e)) {\n                throw new RuntimeException(\n                    &quot;Unable to resume activity &quot;\n                    + r.intent.getComponent().toShortString()\n                    + &quot;: &quot; + e.toString(), e);\n            }\n        }\n    }\n    return r;\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">代码很短，很容易提取有用信息：``` r.activity.performResume();```在进去看看：</div></pre></td></tr></table></figure>\n<pre><code>final void performResume() {\n    performRestart();\n\n    mFragments.execPendingActions();\n\n    mLastNonConfigurationInstances = null;\n\n    mCalled = false;\n    // mResumed is set by the instrumentation\n    mInstrumentation.callActivityOnResume(this);\n    if (!mCalled) {\n        throw new SuperNotCalledException(\n            &quot;Activity &quot; + mComponent.toShortString() +\n            &quot; did not call through to super.onResume()&quot;);\n    }\n\n    // Now really resume, and install the current status bar and menu.\n    mCalled = false;\n\n    mFragments.dispatchResume();\n    mFragments.execPendingActions();\n\n    onPostResume();\n    if (!mCalled) {\n        throw new SuperNotCalledException(\n            &quot;Activity &quot; + mComponent.toShortString() +\n            &quot; did not call through to super.onPostResume()&quot;);\n    }\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">看到```mInstrumentation```这个属性就能感觉到越来越接近SDK API层了，看看它的```callActivityOnResume()```方法做了什么：</div></pre></td></tr></table></figure>\n<pre><code>public void callActivityOnResume(Activity activity) {\n    activity.mResumed = true;\n    activity.onResume();\n\n    if (mActivityMonitors != null) {\n        synchronized (mSync) {\n            final int N = mActivityMonitors.size();\n            for (int i=0; i&lt;N; i++) {\n                final ActivityMonitor am = mActivityMonitors.get(i);\n                am.match(activity, activity, activity.getIntent());\n            }\n        }\n    }\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">一行```activity.onResume();```已经水落石出。</div><div class=\"line\">回到handleResumeActivity代码中，我精简下：</div></pre></td></tr></table></figure>\n<p> final void handleResumeActivity(IBinder token,<br>            boolean clearHide, boolean isForward, boolean reallyResume) {<br>   //这里是最终回调Activity的onResume()方法<br>        ActivityClientRecord r = performResumeActivity(token, clearHide);<br>//省略若干<br>        if (r != null) {<br>            final Activity a = r.activity;<br>            final int forwardBit = isForward ?<br>            WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;<br>            boolean willBeVisible = !a.mStartedActivity;</p>\n<pre><code>if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {\n    r.window = r.activity.getWindow();\n    View decor = r.window.getDecorView();\n    decor.setVisibility(View.INVISIBLE);\n    ViewManager wm = a.getWindowManager();\n    WindowManager.LayoutParams l = r.window.getAttributes();\n    a.mDecor = decor;\n    l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n    l.softInputMode |= forwardBit;\n    if (a.mVisibleFromClient) {\n        a.mWindowAdded = true;\n</code></pre><p>//这里是调用WindowManagerGlobal的addView()方法最终实例化ViewRootImpl，进而实例化AttachInfo<br>                    wm.addView(decor, l);<br>                }</p>\n<pre><code>        } else if (!willBeVisible) {\n            if (localLOGV) Slog.v(\n                TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);\n            r.hideForNow = true;\n        }\n    }\n}\n</code></pre><p>```</p>\n<p>另外关于阅读源码问题，win下当然使用SourceInsight不二选，如果是在mac下可以参考我的<a href=\"http://www.jianshu.com/p/c295d2729ecf\" target=\"_blank\" rel=\"external\">osx下如何使用SublimeText阅读Android系统源码</a>.。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>从做Android开发以来就一直被灌输“只能在主线程刷新UI”的思想，但是这两天发现个问题，在onCreate中创建工作线程并刷新UI没有报错。代码是这样的：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">    super.onCreate(savedInstanceState);</div><div class=\"line\">    setContentView(R.layout.activity_main);</div><div class=\"line\">   final TextView tv = (TextView) findViewById(R.id.sample_text);</div><div class=\"line\">   new Thread(new Runnable() &#123;</div><div class=\"line\">       @Override</div><div class=\"line\">       public void run() &#123;</div><div class=\"line\">           tv.setText(&quot;来自&quot;+Thread.currentThread().getName()+&quot;线程的更新&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;).start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>期待已久的crash没有出现，反而页面是这样显示的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-7be6319d0fc94867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-03-26 下午7.14.46.png\"><br>不禁让人陷入深思···<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-8a0ce88639c31d1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"思考.jpg\"></p>\n<p>第一步，分析问题原因。以前工作线程刷新UI会出现异常并提示只能在UI线程刷新UI。所以假设有个地方(函数)会在刷新UI前判断当前线程是不是主线程，那么现在问题就是验证下是否真的存在这么个地方。问题是从setText引起的，那就从这里出发看看。<br>点进去看下发现又调用了其重载函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@android.view.RemotableViewMethod</div><div class=\"line\">public final void setText(CharSequence text) &#123;</div><div class=\"line\">    setText(text, mBufferType);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>继续深入发现这个方法代码挺多的，但是不用过于关注细节，粗略浏览下不难发现前面大部分代码大多是对text文本格式的一些处理判断，无关刷新UI，直到            checkForRelayout()方法执行，从名字看是“从新布局”，根据view绘制流程测量、布局、绘制，那布局完了不是就绘制刷新了吗？所以决定去checkForRelayout方法看看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setText(CharSequence text, BufferType type,</div><div class=\"line\">                     boolean notifyBefore, int oldlen) &#123;</div><div class=\"line\">    if (text == null) &#123;</div><div class=\"line\">        text = &quot;&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // If suggestions are not enabled, remove the suggestion spans from the text</div><div class=\"line\">    if (!isSuggestionsEnabled()) &#123;</div><div class=\"line\">        text = removeSuggestionSpans(text);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (!mUserSetTextScaleX) mTextPaint.setTextScaleX(1.0f);</div><div class=\"line\"></div><div class=\"line\">    if (text instanceof Spanned &amp;&amp;</div><div class=\"line\">        ((Spanned) text).getSpanStart(TextUtils.TruncateAt.MARQUEE) &gt;= 0) &#123;</div><div class=\"line\">        if (ViewConfiguration.get(mContext).isFadingMarqueeEnabled()) &#123;</div><div class=\"line\">            setHorizontalFadingEdgeEnabled(true);</div><div class=\"line\">            mMarqueeFadeMode = MARQUEE_FADE_NORMAL;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            setHorizontalFadingEdgeEnabled(false);</div><div class=\"line\">            mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;</div><div class=\"line\">        &#125;</div><div class=\"line\">        setEllipsize(TextUtils.TruncateAt.MARQUEE);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int n = mFilters.length;</div><div class=\"line\">    for (int i = 0; i &lt; n; i++) &#123;</div><div class=\"line\">        CharSequence out = mFilters[i].filter(text, 0, text.length(), EMPTY_SPANNED, 0, 0);</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            text = out;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (notifyBefore) &#123;</div><div class=\"line\">        if (mText != null) &#123;</div><div class=\"line\">            oldlen = mText.length();</div><div class=\"line\">            sendBeforeTextChanged(mText, 0, oldlen, text.length());</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            sendBeforeTextChanged(&quot;&quot;, 0, 0, text.length());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    boolean needEditableForNotification = false;</div><div class=\"line\"></div><div class=\"line\">    if (mListeners != null &amp;&amp; mListeners.size() != 0) &#123;</div><div class=\"line\">        needEditableForNotification = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (type == BufferType.EDITABLE || getKeyListener() != null ||</div><div class=\"line\">            needEditableForNotification) &#123;</div><div class=\"line\">        createEditorIfNeeded();</div><div class=\"line\">        Editable t = mEditableFactory.newEditable(text);</div><div class=\"line\">        text = t;</div><div class=\"line\">        setFilters(t, mFilters);</div><div class=\"line\">        InputMethodManager imm = InputMethodManager.peekInstance();</div><div class=\"line\">        if (imm != null) imm.restartInput(this);</div><div class=\"line\">    &#125; else if (type == BufferType.SPANNABLE || mMovement != null) &#123;</div><div class=\"line\">        text = mSpannableFactory.newSpannable(text);</div><div class=\"line\">    &#125; else if (!(text instanceof CharWrapper)) &#123;</div><div class=\"line\">        text = TextUtils.stringOrSpannedString(text);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mAutoLinkMask != 0) &#123;</div><div class=\"line\">        Spannable s2;</div><div class=\"line\"></div><div class=\"line\">        if (type == BufferType.EDITABLE || text instanceof Spannable) &#123;</div><div class=\"line\">            s2 = (Spannable) text;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            s2 = mSpannableFactory.newSpannable(text);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (Linkify.addLinks(s2, mAutoLinkMask)) &#123;</div><div class=\"line\">            text = s2;</div><div class=\"line\">            type = (type == BufferType.EDITABLE) ? BufferType.EDITABLE : BufferType.SPANNABLE;</div><div class=\"line\"></div><div class=\"line\">            /*</div><div class=\"line\">             * We must go ahead and set the text before changing the</div><div class=\"line\">             * movement method, because setMovementMethod() may call</div><div class=\"line\">             * setText() again to try to upgrade the buffer type.</div><div class=\"line\">             */</div><div class=\"line\">            mText = text;</div><div class=\"line\"></div><div class=\"line\">            // Do not change the movement method for text that support text selection as it</div><div class=\"line\">            // would prevent an arbitrary cursor displacement.</div><div class=\"line\">            if (mLinksClickable &amp;&amp; !textCanBeSelected()) &#123;</div><div class=\"line\">                setMovementMethod(LinkMovementMethod.getInstance());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mBufferType = type;</div><div class=\"line\">    mText = text;</div><div class=\"line\"></div><div class=\"line\">    if (mTransformation == null) &#123;</div><div class=\"line\">        mTransformed = text;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        mTransformed = mTransformation.getTransformation(text, this);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final int textLength = text.length();</div><div class=\"line\"></div><div class=\"line\">    if (text instanceof Spannable &amp;&amp; !mAllowTransformationLengthChange) &#123;</div><div class=\"line\">        Spannable sp = (Spannable) text;</div><div class=\"line\"></div><div class=\"line\">        // Remove any ChangeWatchers that might have come from other TextViews.</div><div class=\"line\">        final ChangeWatcher[] watchers = sp.getSpans(0, sp.length(), ChangeWatcher.class);</div><div class=\"line\">        final int count = watchers.length;</div><div class=\"line\">        for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\">            sp.removeSpan(watchers[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (mChangeWatcher == null) mChangeWatcher = new ChangeWatcher();</div><div class=\"line\"></div><div class=\"line\">        sp.setSpan(mChangeWatcher, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE |</div><div class=\"line\">                   (CHANGE_WATCHER_PRIORITY &lt;&lt; Spanned.SPAN_PRIORITY_SHIFT));</div><div class=\"line\"></div><div class=\"line\">        if (mEditor != null) mEditor.addSpanWatchers(sp);</div><div class=\"line\"></div><div class=\"line\">        if (mTransformation != null) &#123;</div><div class=\"line\">            sp.setSpan(mTransformation, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (mMovement != null) &#123;</div><div class=\"line\">            mMovement.initialize(this, (Spannable) text);</div><div class=\"line\"></div><div class=\"line\">            /*</div><div class=\"line\">             * Initializing the movement method will have set the</div><div class=\"line\">             * selection, so reset mSelectionMoved to keep that from</div><div class=\"line\">             * interfering with the normal on-focus selection-setting.</div><div class=\"line\">             */</div><div class=\"line\">            if (mEditor != null) mEditor.mSelectionMoved = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mLayout != null) &#123;</div><div class=\"line\">        checkForRelayout();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sendOnTextChanged(text, 0, oldlen, textLength);</div><div class=\"line\">    onTextChanged(text, 0, oldlen, textLength);</div><div class=\"line\"></div><div class=\"line\">    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT);</div><div class=\"line\"></div><div class=\"line\">    if (needEditableForNotification) &#123;</div><div class=\"line\">        sendAfterTextChanged((Editable) text);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // SelectionModifierCursorController depends on textCanBeSelected, which depends on text</div><div class=\"line\">    if (mEditor != null) mEditor.prepareCursorControllers();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>找到checkForRelayout方法查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void checkForRelayout() &#123;</div><div class=\"line\">    // If we have a fixed width, we can just swap in a new text layout</div><div class=\"line\">    // if the text height stays the same or if the view height is fixed.</div><div class=\"line\"></div><div class=\"line\">    if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT ||</div><div class=\"line\">            (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth)) &amp;&amp;</div><div class=\"line\">            (mHint == null || mHintLayout != null) &amp;&amp;</div><div class=\"line\">            (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; 0)) &#123;</div><div class=\"line\">        // Static width, so try making a new text layout.</div><div class=\"line\"></div><div class=\"line\">        int oldht = mLayout.getHeight();</div><div class=\"line\">        int want = mLayout.getWidth();</div><div class=\"line\">        int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth();</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * No need to bring the text into view, since the size is not</div><div class=\"line\">         * changing (unless we do the requestLayout(), in which case it</div><div class=\"line\">         * will happen at measure).</div><div class=\"line\">         */</div><div class=\"line\">        makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,</div><div class=\"line\">                      mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),</div><div class=\"line\">                      false);</div><div class=\"line\"></div><div class=\"line\">        if (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123;</div><div class=\"line\">            // In a fixed-height view, so use our new text layout.</div><div class=\"line\">            if (mLayoutParams.height != LayoutParams.WRAP_CONTENT &amp;&amp;</div><div class=\"line\">                mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">                invalidate();</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Dynamic height, but height has stayed the same,</div><div class=\"line\">            // so use our new text layout.</div><div class=\"line\">            if (mLayout.getHeight() == oldht &amp;&amp;</div><div class=\"line\">                (mHintLayout == null || mHintLayout.getHeight() == oldht)) &#123;</div><div class=\"line\">                invalidate();</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // We lose: the height has changed and we have a dynamic height.</div><div class=\"line\">        // Request a new view layout using our new text layout.</div><div class=\"line\">        requestLayout();</div><div class=\"line\">        invalidate();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Dynamic width, so we have no choice but to request a new</div><div class=\"line\">        // view layout with a new text layout.</div><div class=\"line\">        nullLayouts();</div><div class=\"line\">        requestLayout();</div><div class=\"line\">        invalidate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>发现不管是if还是else，都要执行invalidate()，那就进去看看，一路进展比较顺利，好像离真理更进一步了。经过连续的三连调跳转到了invalidateInternal方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void invalidate() &#123;</div><div class=\"line\">       invalidate(true);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   /**</div><div class=\"line\">    * This is where the invalidate() work actually happens. A full invalidate()</div><div class=\"line\">    * causes the drawing cache to be invalidated, but this function can be</div><div class=\"line\">    * called with invalidateCache set to false to skip that invalidation step</div><div class=\"line\">    * for cases that do not need it (for example, a component that remains at</div><div class=\"line\">    * the same dimensions with the same content).</div><div class=\"line\">    *</div><div class=\"line\">    * @param invalidateCache Whether the drawing cache for this view should be</div><div class=\"line\">    *            invalidated as well. This is usually true for a full</div><div class=\"line\">    *            invalidate, but may be set to false if the View&apos;s contents or</div><div class=\"line\">    *            dimensions have not changed.</div><div class=\"line\">    */</div><div class=\"line\">   void invalidate(boolean invalidateCache) &#123;</div><div class=\"line\">       invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">  void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</div><div class=\"line\">           boolean fullInvalidate) &#123;</div><div class=\"line\">       if (mGhostView != null) &#123;</div><div class=\"line\">           mGhostView.invalidate(true);</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       if (skipInvalidate()) &#123;</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</div><div class=\"line\">               || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</div><div class=\"line\">               || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</div><div class=\"line\">               || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</div><div class=\"line\">           if (fullInvalidate) &#123;</div><div class=\"line\">               mLastIsOpaque = isOpaque();</div><div class=\"line\">               mPrivateFlags &amp;= ~PFLAG_DRAWN;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           mPrivateFlags |= PFLAG_DIRTY;</div><div class=\"line\"></div><div class=\"line\">           if (invalidateCache) &#123;</div><div class=\"line\">               mPrivateFlags |= PFLAG_INVALIDATED;</div><div class=\"line\">               mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Propagate the damage rectangle to the parent view.</div><div class=\"line\">           final AttachInfo ai = mAttachInfo;</div><div class=\"line\">           final ViewParent p = mParent;</div><div class=\"line\">           if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class=\"line\">               final Rect damage = ai.mTmpInvalRect;</div><div class=\"line\">               damage.set(l, t, r, b);</div><div class=\"line\">               p.invalidateChild(this, damage);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Damage the entire projection receiver, if necessary.</div><div class=\"line\">           if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123;</div><div class=\"line\">               final View receiver = getProjectionReceiver();</div><div class=\"line\">               if (receiver != null) &#123;</div><div class=\"line\">                   receiver.damageInParent();</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // Damage the entire IsolatedZVolume receiving this view&apos;s shadow.</div><div class=\"line\">           if (isHardwareAccelerated() &amp;&amp; getZ() != 0) &#123;</div><div class=\"line\">               damageShadowReceiver();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>重点看invalidateChild()这个方法，方法里面有do while循环，每次循环出当前view的parent，最后一次循环返回的parent时ViewRootImpl类实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class=\"line\">       ViewParent parent = this;</div><div class=\"line\"></div><div class=\"line\">       final AttachInfo attachInfo = mAttachInfo;</div><div class=\"line\">       if (attachInfo != null) &#123;</div><div class=\"line\">           // If the child is drawing an animation, we want to copy this flag onto</div><div class=\"line\">           // ourselves and the parent to make sure the invalidate request goes</div><div class=\"line\">           // through</div><div class=\"line\">           final boolean drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION)</div><div class=\"line\">                   == PFLAG_DRAW_ANIMATION;</div><div class=\"line\"></div><div class=\"line\">           // Check whether the child that requests the invalidate is fully opaque</div><div class=\"line\">           // Views being animated or transformed are not considered opaque because we may</div><div class=\"line\">           // be invalidating their old position and need the parent to paint behind them.</div><div class=\"line\">           Matrix childMatrix = child.getMatrix();</div><div class=\"line\">           final boolean isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp;</div><div class=\"line\">                   child.getAnimation() == null &amp;&amp; childMatrix.isIdentity();</div><div class=\"line\">           // Mark the child as dirty, using the appropriate flag</div><div class=\"line\">           // Make sure we do not set both flags at the same time</div><div class=\"line\">           int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</div><div class=\"line\"></div><div class=\"line\">           if (child.mLayerType != LAYER_TYPE_NONE) &#123;</div><div class=\"line\">               mPrivateFlags |= PFLAG_INVALIDATED;</div><div class=\"line\">               mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           final int[] location = attachInfo.mInvalidateChildLocation;</div><div class=\"line\">           location[CHILD_LEFT_INDEX] = child.mLeft;</div><div class=\"line\">           location[CHILD_TOP_INDEX] = child.mTop;</div><div class=\"line\">           if (!childMatrix.isIdentity() ||</div><div class=\"line\">                   (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123;</div><div class=\"line\">               RectF boundingRect = attachInfo.mTmpTransformRect;</div><div class=\"line\">               boundingRect.set(dirty);</div><div class=\"line\">               Matrix transformMatrix;</div><div class=\"line\">               if ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123;</div><div class=\"line\">                   Transformation t = attachInfo.mTmpTransformation;</div><div class=\"line\">                   boolean transformed = getChildStaticTransformation(child, t);</div><div class=\"line\">                   if (transformed) &#123;</div><div class=\"line\">                       transformMatrix = attachInfo.mTmpMatrix;</div><div class=\"line\">                       transformMatrix.set(t.getMatrix());</div><div class=\"line\">                       if (!childMatrix.isIdentity()) &#123;</div><div class=\"line\">                           transformMatrix.preConcat(childMatrix);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125; else &#123;</div><div class=\"line\">                       transformMatrix = childMatrix;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   transformMatrix = childMatrix;</div><div class=\"line\">               &#125;</div><div class=\"line\">               transformMatrix.mapRect(boundingRect);</div><div class=\"line\">               dirty.set((int) (boundingRect.left - 0.5f),</div><div class=\"line\">                       (int) (boundingRect.top - 0.5f),</div><div class=\"line\">                       (int) (boundingRect.right + 0.5f),</div><div class=\"line\">                       (int) (boundingRect.bottom + 0.5f));</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           do &#123;</div><div class=\"line\">               View view = null;</div><div class=\"line\">               if (parent instanceof View) &#123;</div><div class=\"line\">                   view = (View) parent;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               if (drawAnimation) &#123;</div><div class=\"line\">                   if (view != null) &#123;</div><div class=\"line\">                       view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</div><div class=\"line\">                   &#125; else if (parent instanceof ViewRootImpl) &#123;</div><div class=\"line\">                       ((ViewRootImpl) parent).mIsAnimating = true;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               // If the parent is dirty opaque or not dirty, mark it dirty with the opaque</div><div class=\"line\">               // flag coming from the child that initiated the invalidate</div><div class=\"line\">               if (view != null) &#123;</div><div class=\"line\">                   if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp;</div><div class=\"line\">                           view.getSolidColor() == 0) &#123;</div><div class=\"line\">                       opaqueFlag = PFLAG_DIRTY;</div><div class=\"line\">                   &#125;</div><div class=\"line\">                   if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</div><div class=\"line\">                       view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\"></div><div class=\"line\">               parent = parent.invalidateChildInParent(location, dirty);</div><div class=\"line\">               if (view != null) &#123;</div><div class=\"line\">                   // Account for transform on current parent</div><div class=\"line\">                   Matrix m = view.getMatrix();</div><div class=\"line\">                   if (!m.isIdentity()) &#123;</div><div class=\"line\">                       RectF boundingRect = attachInfo.mTmpTransformRect;</div><div class=\"line\">                       boundingRect.set(dirty);</div><div class=\"line\">                       m.mapRect(boundingRect);</div><div class=\"line\">                       dirty.set((int) (boundingRect.left - 0.5f),</div><div class=\"line\">                               (int) (boundingRect.top - 0.5f),</div><div class=\"line\">                               (int) (boundingRect.right + 0.5f),</div><div class=\"line\">                               (int) (boundingRect.bottom + 0.5f));</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; while (parent != null);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>现在查看ViewRootImpl类的invalidateChildInParent()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</div><div class=\"line\">    checkThread();</div><div class=\"line\">    if (DEBUG_DRAW) Log.v(TAG, &quot;Invalidate child: &quot; + dirty);</div><div class=\"line\"></div><div class=\"line\">    if (dirty == null) &#123;</div><div class=\"line\">        invalidate();</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (mCurScrollY != 0 || mTranslator != null) &#123;</div><div class=\"line\">        mTempRect.set(dirty);</div><div class=\"line\">        dirty = mTempRect;</div><div class=\"line\">        if (mCurScrollY != 0) &#123;</div><div class=\"line\">            dirty.offset(0, -mCurScrollY);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mTranslator != null) &#123;</div><div class=\"line\">            mTranslator.translateRectInAppWindowToScreen(dirty);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (mAttachInfo.mScalingRequired) &#123;</div><div class=\"line\">            dirty.inset(-1, -1);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final Rect localDirty = mDirty;</div><div class=\"line\">    if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</div><div class=\"line\">        mAttachInfo.mSetIgnoreDirtyState = true;</div><div class=\"line\">        mAttachInfo.mIgnoreDirtyState = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Add the new dirty rect to the current one</div><div class=\"line\">    localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</div><div class=\"line\">    // Intersect with the bounds of the window to skip</div><div class=\"line\">    // updates that lie outside of the visible region</div><div class=\"line\">    final float appScale = mAttachInfo.mApplicationScale;</div><div class=\"line\">    final boolean intersected = localDirty.intersect(0, 0,</div><div class=\"line\">            (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));</div><div class=\"line\">    if (!intersected) &#123;</div><div class=\"line\">        localDirty.setEmpty();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</div><div class=\"line\">        scheduleTraversals();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法块的第一行好像就是我们要找的验证线程的地方checkThread()，而该方法内容也很简单，看到抛出的异常就很熟悉了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">void checkThread() &#123;</div><div class=\"line\">    if (mThread != Thread.currentThread()) &#123;</div><div class=\"line\">        throw new CalledFromWrongThreadException(</div><div class=\"line\">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二步，验证线程地方已经找到了，假设得到了证实，那么为什么该有的异常没有出现呢？现在再次假设是不是因为某些原因导致checkThread()没有执行呢？</p>\n<p>有人可能会问会不会是mThread == Thread.currentThread()？其实这是不可能的 ，先看下mThread赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ViewRootImpl(Context context, Display display) &#123;</div><div class=\"line\">    mContext = context;</div><div class=\"line\">    mWindowSession = WindowManagerGlobal.getWindowSession();</div><div class=\"line\">    mDisplay = display;</div><div class=\"line\">    mBasePackageName = context.getBasePackageName();</div><div class=\"line\"></div><div class=\"line\">    mDisplayAdjustments = display.getDisplayAdjustments();</div><div class=\"line\"></div><div class=\"line\">    mThread = Thread.currentThread();</div></pre></td></tr></table></figure>\n<p>ViewRootImpl类实例化是在Activity启动时的主线程创建的，所以mThread是主线程实例，而checkThread()中的Thread.currentThread()，最初是由textView.setText()调用的一系列方法栈，并且setText是在子线程调用。</p>\n<p>继续刚才的假设，不过现在要逆推回去，checkThread()方法没有执行，可以认为ViewRootImpl的invalidateChildInParent()方法没有执行，它又是在ViewGroup中invalidateChild()方法里的do while中调用，要使do while不被调用，继续往上看，如果attachInfo为null，进不去if语句块也就不会执行checkThread()了，这是第一个可能的原因。记录下，继续逆推。</p>\n<p>View中的invalidateInternal()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Propagate the damage rectangle to the parent view.</div><div class=\"line\">      final AttachInfo ai = mAttachInfo;</div><div class=\"line\">      final ViewParent p = mParent;</div><div class=\"line\">      if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class=\"line\">          final Rect damage = ai.mTmpInvalRect;</div><div class=\"line\">          damage.set(l, t, r, b);</div><div class=\"line\">          p.invalidateChild(this, damage);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>根据判断条件，如果p即mParent或者ai即mAttachInfo 任一为null，都不会执行invalidateChild，这是第二个可能原因，这里的ai和第一个原因的attachInfo是一样的，所以第一个原因可能忽略，精力关注在第二个原因上。</p>\n<blockquote>\n<p>现在的关注点是实例p和ai是什么时候创建的，有没有为null的现象？</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AttachInfo ai = mAttachInfo;</div></pre></td></tr></table></figure>\n<p>而mAttachInfo是在View的dispatchAttachedToWindow()方法中赋值的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123;</div><div class=\"line\">        //System.out.println(&quot;Attached! &quot; + this);</div><div class=\"line\">        mAttachInfo = info;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>View的dispatchAttachedToWindow()方法是在ViewRootImpl中的performTraversals()方法调用，这个方法是遍历View Tree</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void performTraversals() &#123;</div><div class=\"line\">       // cache mView since it is used so much below...</div><div class=\"line\">       final View host = mView;</div><div class=\"line\">       ·······</div><div class=\"line\">       host.dispatchAttachedToWindow(mAttachInfo, 0);</div></pre></td></tr></table></figure>\n<p>可见View中的mAttachInfo来自ViewrootImpl的mAttachInfo，而ViewrootImpl的mAttachInfo是在其构造方法中被赋值的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public ViewRootImpl(Context context, Display display) &#123;</div><div class=\"line\">    mContext = context;</div><div class=\"line\">    mWindowSession = WindowManagerGlobal.getWindowSession();</div><div class=\"line\">    mDisplay = display;</div><div class=\"line\">    mBasePackageName = context.getBasePackageName();</div><div class=\"line\"></div><div class=\"line\">    mDisplayAdjustments = display.getDisplayAdjustments();</div><div class=\"line\"></div><div class=\"line\">    mThread = Thread.currentThread();</div><div class=\"line\">    mLocation = new WindowLeaked(null);</div><div class=\"line\">    mLocation.fillInStackTrace();</div><div class=\"line\">    mWidth = -1;</div><div class=\"line\">    mHeight = -1;</div><div class=\"line\">    mDirty = new Rect();</div><div class=\"line\">    mTempRect = new Rect();</div><div class=\"line\">    mVisRect = new Rect();</div><div class=\"line\">    mWinFrame = new Rect();</div><div class=\"line\">    mWindow = new W(this);</div><div class=\"line\">    mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;</div><div class=\"line\">    mViewVisibility = View.GONE;</div><div class=\"line\">    mTransparentRegion = new Region();</div><div class=\"line\">    mPreviousTransparentRegion = new Region();</div><div class=\"line\">    mFirst = true; // true for the first time the view is added</div><div class=\"line\">    mAdded = false;</div><div class=\"line\">    mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);</div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>之前说了ViewRootImpl实例是在Activity启动时创建的，现在看看具体是启动的什么时候:在向window添加view的时候即：WindowManagerGlobal的addView方法中创建ViewrootImpl实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void addView(View view, ViewGroup.LayoutParams params,</div><div class=\"line\">           Display display, Window parentWindow) &#123;</div><div class=\"line\">       if (view == null) &#123;</div><div class=\"line\">           throw new IllegalArgumentException(&quot;view must not be null&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (display == null) &#123;</div><div class=\"line\">           throw new IllegalArgumentException(&quot;display must not be null&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!(params instanceof WindowManager.LayoutParams)) &#123;</div><div class=\"line\">           throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</div><div class=\"line\">       if (parentWindow != null) &#123;</div><div class=\"line\">           parentWindow.adjustLayoutParamsForSubWindow(wparams);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           // If there&apos;s no parent and we&apos;re running on L or above (or in the</div><div class=\"line\">           // system context), assume we want hardware acceleration.</div><div class=\"line\">           final Context context = view.getContext();</div><div class=\"line\">           if (context != null</div><div class=\"line\">                   &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class=\"line\">               wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       ViewRootImpl root;</div><div class=\"line\">       View panelParentView = null;</div><div class=\"line\"></div><div class=\"line\">       synchronized (mLock) &#123;</div><div class=\"line\">           // Start watching for system property changes.</div><div class=\"line\">           if (mSystemPropertyUpdater == null) &#123;</div><div class=\"line\">               mSystemPropertyUpdater = new Runnable() &#123;</div><div class=\"line\">                   @Override public void run() &#123;</div><div class=\"line\">                       synchronized (mLock) &#123;</div><div class=\"line\">                           for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">                               mRoots.get(i).loadSystemProperties();</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;;</div><div class=\"line\">               SystemProperties.addChangeCallback(mSystemPropertyUpdater);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           int index = findViewLocked(view, false);</div><div class=\"line\">           if (index &gt;= 0) &#123;</div><div class=\"line\">               if (mDyingViews.contains(view)) &#123;</div><div class=\"line\">                   // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue.</div><div class=\"line\">                   mRoots.get(index).doDie();</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   throw new IllegalStateException(&quot;View &quot; + view</div><div class=\"line\">                           + &quot; has already been added to the window manager.&quot;);</div><div class=\"line\">               &#125;</div><div class=\"line\">               // The previous removeView() had not completed executing. Now it has.</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           // If this is a panel window, then find the window it is being</div><div class=\"line\">           // attached to for future reference.</div><div class=\"line\">           if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</div><div class=\"line\">                   wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</div><div class=\"line\">               final int count = mViews.size();</div><div class=\"line\">               for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\">                   if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</div><div class=\"line\">                       panelParentView = mViews.get(i);</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           root = new ViewRootImpl(view.getContext(), display);</div><div class=\"line\"></div><div class=\"line\">           view.setLayoutParams(wparams);</div><div class=\"line\"></div><div class=\"line\">           mViews.add(view);</div><div class=\"line\">           mRoots.add(root);</div><div class=\"line\">           mParams.add(wparams);</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       // do this last because it fires off messages to start doing things</div><div class=\"line\">       try &#123;</div><div class=\"line\">           root.setView(view, wparams, panelParentView);</div><div class=\"line\">       &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">           // BadTokenException or InvalidDisplayException, clean up.</div><div class=\"line\">           synchronized (mLock) &#123;</div><div class=\"line\">               final int index = findViewLocked(view, false);</div><div class=\"line\">               if (index &gt;= 0) &#123;</div><div class=\"line\">                   removeViewLocked(index, true);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           throw e;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>而调用addView()方法是在ActivityThread类的handleResumeActivity()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">final void handleResumeActivity(IBinder token,</div><div class=\"line\">        boolean clearHide, boolean isForward, boolean reallyResume) &#123;</div><div class=\"line\">    // If we are getting ready to gc after going to the background, well</div><div class=\"line\">    // we are back active so skip it.</div><div class=\"line\">    unscheduleGcIdler();</div><div class=\"line\">    mSomeActivitiesChanged = true;</div><div class=\"line\"></div><div class=\"line\">    // TODO Push resumeArgs into the activity for consideration</div><div class=\"line\">    ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class=\"line\"></div><div class=\"line\">    if (r != null) &#123;</div><div class=\"line\">        final Activity a = r.activity;</div><div class=\"line\"></div><div class=\"line\">        if (localLOGV) Slog.v(</div><div class=\"line\">            TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</div><div class=\"line\">            a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</div><div class=\"line\">            + &quot;, finished: &quot; + a.mFinished);</div><div class=\"line\"></div><div class=\"line\">        final int forwardBit = isForward ?</div><div class=\"line\">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</div><div class=\"line\"></div><div class=\"line\">        // If the window hasn&apos;t yet been added to the window manager,</div><div class=\"line\">        // and this guy didn&apos;t finish itself or start another activity,</div><div class=\"line\">        // then go ahead and add the window.</div><div class=\"line\">        boolean willBeVisible = !a.mStartedActivity;</div><div class=\"line\">        if (!willBeVisible) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(</div><div class=\"line\">                        a.getActivityToken());</div><div class=\"line\">            &#125; catch (RemoteException e) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class=\"line\">            r.window = r.activity.getWindow();</div><div class=\"line\">            View decor = r.window.getDecorView();</div><div class=\"line\">            decor.setVisibility(View.INVISIBLE);</div><div class=\"line\">            ViewManager wm = a.getWindowManager();</div><div class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</div><div class=\"line\">            a.mDecor = decor;</div><div class=\"line\">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class=\"line\">            l.softInputMode |= forwardBit;</div><div class=\"line\">            if (a.mVisibleFromClient) &#123;</div><div class=\"line\">                a.mWindowAdded = true;</div><div class=\"line\">                wm.addView(decor, l);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        // If the window has already been added, but during resume</div><div class=\"line\">        // we started another activity, then don&apos;t yet make the</div><div class=\"line\">        // window visible.</div><div class=\"line\">        &#125; else if (!willBeVisible) &#123;</div><div class=\"line\">            if (localLOGV) Slog.v(</div><div class=\"line\">                TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</div><div class=\"line\">            r.hideForNow = true;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Get rid of anything left hanging around.</div><div class=\"line\">        cleanUpPendingRemoveWindows(r);</div><div class=\"line\"></div><div class=\"line\">        // The window is now visible if it has been added, we are not</div><div class=\"line\">        // simply finishing, and we are not starting another activity.</div><div class=\"line\">        if (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class=\"line\">                &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</div><div class=\"line\">            if (r.newConfig != null) &#123;</div><div class=\"line\">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</div><div class=\"line\">                        + r.activityInfo.name + &quot; with newConfig &quot; + r.newConfig);</div><div class=\"line\">                performConfigurationChanged(r.activity, r.newConfig);</div><div class=\"line\">                freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig));</div><div class=\"line\">                r.newConfig = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;</div><div class=\"line\">                    + isForward);</div><div class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</div><div class=\"line\">            if ((l.softInputMode</div><div class=\"line\">                    &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</div><div class=\"line\">                    != forwardBit) &#123;</div><div class=\"line\">                l.softInputMode = (l.softInputMode</div><div class=\"line\">                        &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</div><div class=\"line\">                        | forwardBit;</div><div class=\"line\">                if (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                    ViewManager wm = a.getWindowManager();</div><div class=\"line\">                    View decor = r.window.getDecorView();</div><div class=\"line\">                    wm.updateViewLayout(decor, l);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            r.activity.mVisibleFromServer = true;</div><div class=\"line\">            mNumVisibleActivities++;</div><div class=\"line\">            if (r.activity.mVisibleFromClient) &#123;</div><div class=\"line\">                r.activity.makeVisible();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (!r.onlyLocalRequest) &#123;</div><div class=\"line\">            r.nextIdle = mNewActivities;</div><div class=\"line\">            mNewActivities = r;</div><div class=\"line\">            if (localLOGV) Slog.v(</div><div class=\"line\">                TAG, &quot;Scheduling idle handler for &quot; + r);</div><div class=\"line\">            Looper.myQueue().addIdleHandler(new Idler());</div><div class=\"line\">        &#125;</div><div class=\"line\">        r.onlyLocalRequest = false;</div><div class=\"line\"></div><div class=\"line\">        // Tell the activity manager we have resumed.</div><div class=\"line\">        if (reallyResume) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ActivityManagerNative.getDefault().activityResumed(token);</div><div class=\"line\">            &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // If an exception was thrown when trying to resume, then</div><div class=\"line\">        // just end this activity.</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ActivityManagerNative.getDefault()</div><div class=\"line\">                .finishActivity(token, Activity.RESULT_CANCELED, null, false);</div><div class=\"line\">        &#125; catch (RemoteException ex) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看到上面的方法有些人心里可能有底儿了，handleResumeActivity()方法是不是让Activity回调onResume？如果是的话一切就都明了了，因为ViewrootImpl是在onReume期间创建，而AttachInfo是在ViewRootImpl实例化时创建，我们的工作线程是在onCreate时刷新UI的，那时候还没有实例化AttachInfo，导致mAttachInfo为null，最终if条件判断失败没有进入。然而这一切都是在YY，实践才是检验真理的唯一标准，动起来：</p>\n<p>看到这一行代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class=\"line\">```微微一笑，点进去看看，</div></pre></td></tr></table></figure></p>\n<pre><code>public final ActivityClientRecord performResumeActivity(IBinder token,\n        boolean clearHide) {\n    ActivityClientRecord r = mActivities.get(token);\n    if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r\n            + &quot; finished=&quot; + r.activity.mFinished);\n    if (r != null &amp;&amp; !r.activity.mFinished) {\n        if (clearHide) {\n            r.hideForNow = false;\n            r.activity.mStartedActivity = false;\n        }\n        try {\n            r.activity.mFragments.noteStateNotSaved();\n            if (r.pendingIntents != null) {\n                deliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            if (r.pendingResults != null) {\n                deliverResults(r, r.pendingResults);\n                r.pendingResults = null;\n            }\n            r.activity.performResume();\n\n            EventLog.writeEvent(LOG_ON_RESUME_CALLED,\n                    UserHandle.myUserId(), r.activity.getComponentName().getClassName());\n\n            r.paused = false;\n            r.stopped = false;\n            r.state = null;\n            r.persistentState = null;\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(r.activity, e)) {\n                throw new RuntimeException(\n                    &quot;Unable to resume activity &quot;\n                    + r.intent.getComponent().toShortString()\n                    + &quot;: &quot; + e.toString(), e);\n            }\n        }\n    }\n    return r;\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">代码很短，很容易提取有用信息：``` r.activity.performResume();```在进去看看：</div></pre></td></tr></table></figure>\n<pre><code>final void performResume() {\n    performRestart();\n\n    mFragments.execPendingActions();\n\n    mLastNonConfigurationInstances = null;\n\n    mCalled = false;\n    // mResumed is set by the instrumentation\n    mInstrumentation.callActivityOnResume(this);\n    if (!mCalled) {\n        throw new SuperNotCalledException(\n            &quot;Activity &quot; + mComponent.toShortString() +\n            &quot; did not call through to super.onResume()&quot;);\n    }\n\n    // Now really resume, and install the current status bar and menu.\n    mCalled = false;\n\n    mFragments.dispatchResume();\n    mFragments.execPendingActions();\n\n    onPostResume();\n    if (!mCalled) {\n        throw new SuperNotCalledException(\n            &quot;Activity &quot; + mComponent.toShortString() +\n            &quot; did not call through to super.onPostResume()&quot;);\n    }\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">看到```mInstrumentation```这个属性就能感觉到越来越接近SDK API层了，看看它的```callActivityOnResume()```方法做了什么：</div></pre></td></tr></table></figure>\n<pre><code>public void callActivityOnResume(Activity activity) {\n    activity.mResumed = true;\n    activity.onResume();\n\n    if (mActivityMonitors != null) {\n        synchronized (mSync) {\n            final int N = mActivityMonitors.size();\n            for (int i=0; i&lt;N; i++) {\n                final ActivityMonitor am = mActivityMonitors.get(i);\n                am.match(activity, activity, activity.getIntent());\n            }\n        }\n    }\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">一行```activity.onResume();```已经水落石出。</div><div class=\"line\">回到handleResumeActivity代码中，我精简下：</div></pre></td></tr></table></figure>\n<p> final void handleResumeActivity(IBinder token,<br>            boolean clearHide, boolean isForward, boolean reallyResume) {<br>   //这里是最终回调Activity的onResume()方法<br>        ActivityClientRecord r = performResumeActivity(token, clearHide);<br>//省略若干<br>        if (r != null) {<br>            final Activity a = r.activity;<br>            final int forwardBit = isForward ?<br>            WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;<br>            boolean willBeVisible = !a.mStartedActivity;</p>\n<pre><code>if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {\n    r.window = r.activity.getWindow();\n    View decor = r.window.getDecorView();\n    decor.setVisibility(View.INVISIBLE);\n    ViewManager wm = a.getWindowManager();\n    WindowManager.LayoutParams l = r.window.getAttributes();\n    a.mDecor = decor;\n    l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n    l.softInputMode |= forwardBit;\n    if (a.mVisibleFromClient) {\n        a.mWindowAdded = true;\n</code></pre><p>//这里是调用WindowManagerGlobal的addView()方法最终实例化ViewRootImpl，进而实例化AttachInfo<br>                    wm.addView(decor, l);<br>                }</p>\n<pre><code>        } else if (!willBeVisible) {\n            if (localLOGV) Slog.v(\n                TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);\n            r.hideForNow = true;\n        }\n    }\n}\n</code></pre><p>```</p>\n<p>另外关于阅读源码问题，win下当然使用SourceInsight不二选，如果是在mac下可以参考我的<a href=\"http://www.jianshu.com/p/c295d2729ecf\">osx下如何使用SublimeText阅读Android系统源码</a>.。</p>\n"},{"title":"使用Sublime text编译python3时中文打印异常问题","date":"2017-04-22T10:55:54.000Z","_content":"\n按照网上的一些方法改了几个地方都是没有效果，就又都给还原回来了。后来发现只要修改先前配置的环境即可\n```\n{\n\t\"cmd\": [\"/Library/Frameworks/Python.framework/Versions/3.5/bin/python3\",\"-u\",\"$file\"],\n\t\"env\": {\"LANG\": \"en_US.UTF-8\"}\n}\n```\n加上一句env的配置就可以了。\n什么？不知道去哪里找配置文件了？\n\n![屏幕快照 2017-01-07 上午11.35.31.png](http://upload-images.jianshu.io/upload_images/1796052-06e6c7cff8200bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开Preferences -> Browse Packages -> 会自动打开一个新的窗口-打开user编辑之前的文件保存即可。\n![屏幕快照 2017-01-07 上午11.36.46.png](http://upload-images.jianshu.io/upload_images/1796052-a48410d9dd488b78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![屏幕快照 2017-01-07 上午11.37.09.png](http://upload-images.jianshu.io/upload_images/1796052-50806a0e72ca3dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nmark一下","source":"_posts/使用Sublime text编译python3时中文打印异常问题.md","raw":"---\ntitle: 使用Sublime text编译python3时中文打印异常问题\ndate: 2017-04-22 18:55:54\ntags: Python\ncategories: Python\n---\n\n按照网上的一些方法改了几个地方都是没有效果，就又都给还原回来了。后来发现只要修改先前配置的环境即可\n```\n{\n\t\"cmd\": [\"/Library/Frameworks/Python.framework/Versions/3.5/bin/python3\",\"-u\",\"$file\"],\n\t\"env\": {\"LANG\": \"en_US.UTF-8\"}\n}\n```\n加上一句env的配置就可以了。\n什么？不知道去哪里找配置文件了？\n\n![屏幕快照 2017-01-07 上午11.35.31.png](http://upload-images.jianshu.io/upload_images/1796052-06e6c7cff8200bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开Preferences -> Browse Packages -> 会自动打开一个新的窗口-打开user编辑之前的文件保存即可。\n![屏幕快照 2017-01-07 上午11.36.46.png](http://upload-images.jianshu.io/upload_images/1796052-a48410d9dd488b78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![屏幕快照 2017-01-07 上午11.37.09.png](http://upload-images.jianshu.io/upload_images/1796052-50806a0e72ca3dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nmark一下","slug":"使用Sublime text编译python3时中文打印异常问题","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjhq005nwh9cgl9i1yf6","content":"<p>按照网上的一些方法改了几个地方都是没有效果，就又都给还原回来了。后来发现只要修改先前配置的环境即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t&quot;cmd&quot;: [&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin/python3&quot;,&quot;-u&quot;,&quot;$file&quot;],</div><div class=\"line\">\t&quot;env&quot;: &#123;&quot;LANG&quot;: &quot;en_US.UTF-8&quot;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>加上一句env的配置就可以了。<br>什么？不知道去哪里找配置文件了？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-06e6c7cff8200bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-07 上午11.35.31.png\"></p>\n<p>打开Preferences -&gt; Browse Packages -&gt; 会自动打开一个新的窗口-打开user编辑之前的文件保存即可。<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a48410d9dd488b78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-07 上午11.36.46.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-50806a0e72ca3dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-07 上午11.37.09.png\"></p>\n<p>mark一下</p>\n","site":{"data":{}},"excerpt":"","more":"<p>按照网上的一些方法改了几个地方都是没有效果，就又都给还原回来了。后来发现只要修改先前配置的环境即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t&quot;cmd&quot;: [&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin/python3&quot;,&quot;-u&quot;,&quot;$file&quot;],</div><div class=\"line\">\t&quot;env&quot;: &#123;&quot;LANG&quot;: &quot;en_US.UTF-8&quot;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>加上一句env的配置就可以了。<br>什么？不知道去哪里找配置文件了？</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-06e6c7cff8200bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-07 上午11.35.31.png\"></p>\n<p>打开Preferences -&gt; Browse Packages -&gt; 会自动打开一个新的窗口-打开user编辑之前的文件保存即可。<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a48410d9dd488b78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-07 上午11.36.46.png\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-50806a0e72ca3dc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-01-07 上午11.37.09.png\"></p>\n<p>mark一下</p>\n"},{"title":"typeerror module.__init__() takes at most 2 arguments (3 given)","date":"2017-07-31T12:21:33.000Z","_content":"\n#  前言\n\n代码如下：\n\n```python\nfrom scrapy.selector import Selector\nfrom scrapy import spiders , item\nfrom scrapy.utils import response\n\nfrom daobanSpider.items import Article\n\n\nclass articleSpider(spiders):\n    name = \"article\"\n    allowed_domains = [\"en.wikipedia.org\"]\n    start_urls = [\"http://en.wikipedia.org/wiki/Main_Page\",\n                  \"http://en.wikipedia.org/wiki/Python_%28programming_language%29\"]\n\n\ndef parse(self, response):\n    item = Article()\n    title = response.xpath('//h1/text()')[0].extract()\n    print(\"Title is: \" + title)\n    item['title'] = title\n    return item\n```\n\n`class articleSpider(spiders):`这一行出现异常，信息如下：\n\nTypeError: module.__init__() takes at most 2 arguments (3 given)\n\n\n\n\n\n# 解决\n\n我这是定义的一个class继承spider。但是这里提示类型错误，竟然还出现了module.__init__() 。。\n\n查找后才明白过来`from scrapy import spiders`导入的spiders不是类，而是从scrapy框架导入spiders模块，如要使用某些类，需要再通过module.class格式引入\n\n所以异常的那一行改为：`class articleSpider(spiders.CrawlSpider):`。\n\n\n\n\n\n","source":"_posts/typeerror-module-init-takes-at-most-2-arguments-3-given.md","raw":"---\ntitle: typeerror module.__init__() takes at most 2 arguments (3 given)\ndate: 2017-07-31 20:21:33\ntags: Python\ncategories: Python\n---\n\n#  前言\n\n代码如下：\n\n```python\nfrom scrapy.selector import Selector\nfrom scrapy import spiders , item\nfrom scrapy.utils import response\n\nfrom daobanSpider.items import Article\n\n\nclass articleSpider(spiders):\n    name = \"article\"\n    allowed_domains = [\"en.wikipedia.org\"]\n    start_urls = [\"http://en.wikipedia.org/wiki/Main_Page\",\n                  \"http://en.wikipedia.org/wiki/Python_%28programming_language%29\"]\n\n\ndef parse(self, response):\n    item = Article()\n    title = response.xpath('//h1/text()')[0].extract()\n    print(\"Title is: \" + title)\n    item['title'] = title\n    return item\n```\n\n`class articleSpider(spiders):`这一行出现异常，信息如下：\n\nTypeError: module.__init__() takes at most 2 arguments (3 given)\n\n\n\n\n\n# 解决\n\n我这是定义的一个class继承spider。但是这里提示类型错误，竟然还出现了module.__init__() 。。\n\n查找后才明白过来`from scrapy import spiders`导入的spiders不是类，而是从scrapy框架导入spiders模块，如要使用某些类，需要再通过module.class格式引入\n\n所以异常的那一行改为：`class articleSpider(spiders.CrawlSpider):`。\n\n\n\n\n\n","slug":"typeerror-module-init-takes-at-most-2-arguments-3-given","published":1,"updated":"2017-07-31T12:30:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjhs005qwh9c6xlb2nd9","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> scrapy.selector <span class=\"keyword\">import</span> Selector</div><div class=\"line\"><span class=\"keyword\">from</span> scrapy <span class=\"keyword\">import</span> spiders , item</div><div class=\"line\"><span class=\"keyword\">from</span> scrapy.utils <span class=\"keyword\">import</span> response</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> daobanSpider.items <span class=\"keyword\">import</span> Article</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">articleSpider</span><span class=\"params\">(spiders)</span>:</span></div><div class=\"line\">    name = <span class=\"string\">\"article\"</span></div><div class=\"line\">    allowed_domains = [<span class=\"string\">\"en.wikipedia.org\"</span>]</div><div class=\"line\">    start_urls = [<span class=\"string\">\"http://en.wikipedia.org/wiki/Main_Page\"</span>,</div><div class=\"line\">                  <span class=\"string\">\"http://en.wikipedia.org/wiki/Python_%28programming_language%29\"</span>]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></div><div class=\"line\">    item = Article()</div><div class=\"line\">    title = response.xpath(<span class=\"string\">'//h1/text()'</span>)[<span class=\"number\">0</span>].extract()</div><div class=\"line\">    print(<span class=\"string\">\"Title is: \"</span> + title)</div><div class=\"line\">    item[<span class=\"string\">'title'</span>] = title</div><div class=\"line\">    <span class=\"keyword\">return</span> item</div></pre></td></tr></table></figure>\n<p><code>class articleSpider(spiders):</code>这一行出现异常，信息如下：</p>\n<p>TypeError: module.<strong>init</strong>() takes at most 2 arguments (3 given)</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>我这是定义的一个class继承spider。但是这里提示类型错误，竟然还出现了module.<strong>init</strong>() 。。</p>\n<p>查找后才明白过来<code>from scrapy import spiders</code>导入的spiders不是类，而是从scrapy框架导入spiders模块，如要使用某些类，需要再通过module.class格式引入</p>\n<p>所以异常的那一行改为：<code>class articleSpider(spiders.CrawlSpider):</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> scrapy.selector <span class=\"keyword\">import</span> Selector</div><div class=\"line\"><span class=\"keyword\">from</span> scrapy <span class=\"keyword\">import</span> spiders , item</div><div class=\"line\"><span class=\"keyword\">from</span> scrapy.utils <span class=\"keyword\">import</span> response</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> daobanSpider.items <span class=\"keyword\">import</span> Article</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">articleSpider</span><span class=\"params\">(spiders)</span>:</span></div><div class=\"line\">    name = <span class=\"string\">\"article\"</span></div><div class=\"line\">    allowed_domains = [<span class=\"string\">\"en.wikipedia.org\"</span>]</div><div class=\"line\">    start_urls = [<span class=\"string\">\"http://en.wikipedia.org/wiki/Main_Page\"</span>,</div><div class=\"line\">                  <span class=\"string\">\"http://en.wikipedia.org/wiki/Python_%28programming_language%29\"</span>]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></div><div class=\"line\">    item = Article()</div><div class=\"line\">    title = response.xpath(<span class=\"string\">'//h1/text()'</span>)[<span class=\"number\">0</span>].extract()</div><div class=\"line\">    print(<span class=\"string\">\"Title is: \"</span> + title)</div><div class=\"line\">    item[<span class=\"string\">'title'</span>] = title</div><div class=\"line\">    <span class=\"keyword\">return</span> item</div></pre></td></tr></table></figure>\n<p><code>class articleSpider(spiders):</code>这一行出现异常，信息如下：</p>\n<p>TypeError: module.<strong>init</strong>() takes at most 2 arguments (3 given)</p>\n<h1 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h1><p>我这是定义的一个class继承spider。但是这里提示类型错误，竟然还出现了module.<strong>init</strong>() 。。</p>\n<p>查找后才明白过来<code>from scrapy import spiders</code>导入的spiders不是类，而是从scrapy框架导入spiders模块，如要使用某些类，需要再通过module.class格式引入</p>\n<p>所以异常的那一行改为：<code>class articleSpider(spiders.CrawlSpider):</code>。</p>\n"},{"title":"两个栈实现队列功能","date":"2017-05-18T08:28:16.000Z","_content":"\n# 0x00 前言\n\n用2个栈实现队列，首先要明白栈和队列的区别：栈是FILO，队列是FIFO。明白了这两点就比较容易实现了。\n\n\n\n# 0x01 分析 \n\n栈是一端开口，队列是两端开口，如果要让栈实现队列功能，需要2个栈一个负责进数据，一个负责出数据。为了保证出数据的顺序，在出数据栈不为空时，入数据的栈中数据不能往出数据的栈里存。\n\n\n\n# 0x02 实现\n\n在2个栈数据都为空时注意抛出异常。\n\n```\n\nimport java.util.Stack;\n\n/**\n * 两个栈实现队列功能\n * @author jenson\n */\npublic class StackToQueue {\n\tprivate Stack<Integer> inStack = new Stack<>();\n\tprivate Stack<Integer> outStack = new Stack<>();\n\n\t/**\n\t * 添加元素\n\t * @param value\n\t */\n\tpublic void add(int value) {\n\t\tinStack.push(value);\n\t}\n\n\t/**\n\t * 出队列\n\t * @return\n\t */\n\tpublic int poll() {\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\n\t\t\tqueueEmptyException();\n\t\t} else {\n\t\t\tif (outStack.isEmpty()) {\n\t\t\t\treverse();\n\t\t\t}\n\t\t}\n\t\treturn outStack.pop();\n\t}\n\n\t/**\n\t * 查看队列头的元素 </br>\n\t * 注意一点：如果出栈队列为空，则把入栈数据倒入到处栈，然后从出栈取<br>\n\t * 如果两个栈都为空抛异常\n\t * \n\t */\n\tpublic int peek() {\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\n\t\t\tqueueEmptyException();\n\t\t} else {\n\t\t\tif (outStack.isEmpty()) {\n\t\t\t\treverse();\n\t\t\t}\n\t\t}\n\t\treturn outStack.peek();\n\n\t}\n\n\t/**\n\t * 入栈数据倒入到出栈\n\t */\n\tprivate void reverse() {\n\t\twhile (!inStack.isEmpty()) {\n\t\t\toutStack.push(inStack.pop());\n\t\t}\n\t}\n\n\tprivate void queueEmptyException() {\n\t\tthrow new RuntimeException(\"队列为空\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStackToQueue stackToQueue = new StackToQueue();\n\t\tstackToQueue.add(9);\n\t\tstackToQueue.add(5);\n\t\tstackToQueue.add(2);\n\t\tstackToQueue.add(7);\n\n\t\tSystem.out.println(stackToQueue.peek());\n\t\tSystem.out.println(stackToQueue.poll());\n\t}\n}\n\n```\n\n\n\n","source":"_posts/两个栈实现队列功能.md","raw":"---\ntitle: 两个栈实现队列功能\ndate: 2017-05-18 16:28:16\ntags: 算法\ncategories: 算法\n---\n\n# 0x00 前言\n\n用2个栈实现队列，首先要明白栈和队列的区别：栈是FILO，队列是FIFO。明白了这两点就比较容易实现了。\n\n\n\n# 0x01 分析 \n\n栈是一端开口，队列是两端开口，如果要让栈实现队列功能，需要2个栈一个负责进数据，一个负责出数据。为了保证出数据的顺序，在出数据栈不为空时，入数据的栈中数据不能往出数据的栈里存。\n\n\n\n# 0x02 实现\n\n在2个栈数据都为空时注意抛出异常。\n\n```\n\nimport java.util.Stack;\n\n/**\n * 两个栈实现队列功能\n * @author jenson\n */\npublic class StackToQueue {\n\tprivate Stack<Integer> inStack = new Stack<>();\n\tprivate Stack<Integer> outStack = new Stack<>();\n\n\t/**\n\t * 添加元素\n\t * @param value\n\t */\n\tpublic void add(int value) {\n\t\tinStack.push(value);\n\t}\n\n\t/**\n\t * 出队列\n\t * @return\n\t */\n\tpublic int poll() {\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\n\t\t\tqueueEmptyException();\n\t\t} else {\n\t\t\tif (outStack.isEmpty()) {\n\t\t\t\treverse();\n\t\t\t}\n\t\t}\n\t\treturn outStack.pop();\n\t}\n\n\t/**\n\t * 查看队列头的元素 </br>\n\t * 注意一点：如果出栈队列为空，则把入栈数据倒入到处栈，然后从出栈取<br>\n\t * 如果两个栈都为空抛异常\n\t * \n\t */\n\tpublic int peek() {\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\n\t\t\tqueueEmptyException();\n\t\t} else {\n\t\t\tif (outStack.isEmpty()) {\n\t\t\t\treverse();\n\t\t\t}\n\t\t}\n\t\treturn outStack.peek();\n\n\t}\n\n\t/**\n\t * 入栈数据倒入到出栈\n\t */\n\tprivate void reverse() {\n\t\twhile (!inStack.isEmpty()) {\n\t\t\toutStack.push(inStack.pop());\n\t\t}\n\t}\n\n\tprivate void queueEmptyException() {\n\t\tthrow new RuntimeException(\"队列为空\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStackToQueue stackToQueue = new StackToQueue();\n\t\tstackToQueue.add(9);\n\t\tstackToQueue.add(5);\n\t\tstackToQueue.add(2);\n\t\tstackToQueue.add(7);\n\n\t\tSystem.out.println(stackToQueue.peek());\n\t\tSystem.out.println(stackToQueue.poll());\n\t}\n}\n\n```\n\n\n\n","slug":"两个栈实现队列功能","published":1,"updated":"2017-05-18T10:36:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjht005twh9cqwhuiy5c","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>用2个栈实现队列，首先要明白栈和队列的区别：栈是FILO，队列是FIFO。明白了这两点就比较容易实现了。</p>\n<h1 id=\"0x01-分析\"><a href=\"#0x01-分析\" class=\"headerlink\" title=\"0x01 分析\"></a>0x01 分析</h1><p>栈是一端开口，队列是两端开口，如果要让栈实现队列功能，需要2个栈一个负责进数据，一个负责出数据。为了保证出数据的顺序，在出数据栈不为空时，入数据的栈中数据不能往出数据的栈里存。</p>\n<h1 id=\"0x02-实现\"><a href=\"#0x02-实现\" class=\"headerlink\" title=\"0x02 实现\"></a>0x02 实现</h1><p>在2个栈数据都为空时注意抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import java.util.Stack;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 两个栈实现队列功能</div><div class=\"line\"> * @author jenson</div><div class=\"line\"> */</div><div class=\"line\">public class StackToQueue &#123;</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; inStack = new Stack&lt;&gt;();</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; outStack = new Stack&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 添加元素</div><div class=\"line\">\t * @param value</div><div class=\"line\">\t */</div><div class=\"line\">\tpublic void add(int value) &#123;</div><div class=\"line\">\t\tinStack.push(value);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 出队列</div><div class=\"line\">\t * @return</div><div class=\"line\">\t */</div><div class=\"line\">\tpublic int poll() &#123;</div><div class=\"line\">\t\tif (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tqueueEmptyException();</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tif (outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\t\treverse();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn outStack.pop();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 查看队列头的元素 &lt;/br&gt;</div><div class=\"line\">\t * 注意一点：如果出栈队列为空，则把入栈数据倒入到处栈，然后从出栈取&lt;br&gt;</div><div class=\"line\">\t * 如果两个栈都为空抛异常</div><div class=\"line\">\t * </div><div class=\"line\">\t */</div><div class=\"line\">\tpublic int peek() &#123;</div><div class=\"line\">\t\tif (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tqueueEmptyException();</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tif (outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\t\treverse();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn outStack.peek();</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 入栈数据倒入到出栈</div><div class=\"line\">\t */</div><div class=\"line\">\tprivate void reverse() &#123;</div><div class=\"line\">\t\twhile (!inStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\toutStack.push(inStack.pop());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate void queueEmptyException() &#123;</div><div class=\"line\">\t\tthrow new RuntimeException(&quot;队列为空&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tStackToQueue stackToQueue = new StackToQueue();</div><div class=\"line\">\t\tstackToQueue.add(9);</div><div class=\"line\">\t\tstackToQueue.add(5);</div><div class=\"line\">\t\tstackToQueue.add(2);</div><div class=\"line\">\t\tstackToQueue.add(7);</div><div class=\"line\"></div><div class=\"line\">\t\tSystem.out.println(stackToQueue.peek());</div><div class=\"line\">\t\tSystem.out.println(stackToQueue.poll());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>用2个栈实现队列，首先要明白栈和队列的区别：栈是FILO，队列是FIFO。明白了这两点就比较容易实现了。</p>\n<h1 id=\"0x01-分析\"><a href=\"#0x01-分析\" class=\"headerlink\" title=\"0x01 分析\"></a>0x01 分析</h1><p>栈是一端开口，队列是两端开口，如果要让栈实现队列功能，需要2个栈一个负责进数据，一个负责出数据。为了保证出数据的顺序，在出数据栈不为空时，入数据的栈中数据不能往出数据的栈里存。</p>\n<h1 id=\"0x02-实现\"><a href=\"#0x02-实现\" class=\"headerlink\" title=\"0x02 实现\"></a>0x02 实现</h1><p>在2个栈数据都为空时注意抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import java.util.Stack;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 两个栈实现队列功能</div><div class=\"line\"> * @author jenson</div><div class=\"line\"> */</div><div class=\"line\">public class StackToQueue &#123;</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; inStack = new Stack&lt;&gt;();</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; outStack = new Stack&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 添加元素</div><div class=\"line\">\t * @param value</div><div class=\"line\">\t */</div><div class=\"line\">\tpublic void add(int value) &#123;</div><div class=\"line\">\t\tinStack.push(value);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 出队列</div><div class=\"line\">\t * @return</div><div class=\"line\">\t */</div><div class=\"line\">\tpublic int poll() &#123;</div><div class=\"line\">\t\tif (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tqueueEmptyException();</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tif (outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\t\treverse();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn outStack.pop();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 查看队列头的元素 &lt;/br&gt;</div><div class=\"line\">\t * 注意一点：如果出栈队列为空，则把入栈数据倒入到处栈，然后从出栈取&lt;br&gt;</div><div class=\"line\">\t * 如果两个栈都为空抛异常</div><div class=\"line\">\t * </div><div class=\"line\">\t */</div><div class=\"line\">\tpublic int peek() &#123;</div><div class=\"line\">\t\tif (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tqueueEmptyException();</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tif (outStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\t\treverse();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn outStack.peek();</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 入栈数据倒入到出栈</div><div class=\"line\">\t */</div><div class=\"line\">\tprivate void reverse() &#123;</div><div class=\"line\">\t\twhile (!inStack.isEmpty()) &#123;</div><div class=\"line\">\t\t\toutStack.push(inStack.pop());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tprivate void queueEmptyException() &#123;</div><div class=\"line\">\t\tthrow new RuntimeException(&quot;队列为空&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tStackToQueue stackToQueue = new StackToQueue();</div><div class=\"line\">\t\tstackToQueue.add(9);</div><div class=\"line\">\t\tstackToQueue.add(5);</div><div class=\"line\">\t\tstackToQueue.add(2);</div><div class=\"line\">\t\tstackToQueue.add(7);</div><div class=\"line\"></div><div class=\"line\">\t\tSystem.out.println(stackToQueue.peek());</div><div class=\"line\">\t\tSystem.out.println(stackToQueue.poll());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"使用sychronized注意事项","date":"2017-08-10T13:43:15.000Z","_content":"\n# 0x00 前言\n\nJava编程中多线程并发是一个举足轻重的模块，所以加深对这一块的理解是很有必要的。\n\n# 0x01锁定对象而非函数或代码块 \n\n- 当sychronized修饰实例方法时，锁定的是调用该方法的对象\n\n  如下代码：\n\n  ```java\n  class Text{\n    public sychronized void method1(){\n    }\n  }\n  ```\n\n- 当sychronized锁定this时，锁定的也是当前对象\n\n  ```java\n  class Text{\n    public void method2(){\n      sychronized(this){ \n      }\n    }\n  }\n  ```\n\n  **既然锁定的是对象，也就意味着调用该函数的线程A会获得该对象lock，同样的，线程B在调用该对象的函数时也要获得该对象的lock，但是该对象的lock此时被线程A持有，所以线程B就要处于阻塞状态，直到lock被线程A释放。**\n\n  看看下面代码有何问题：\n\n  ```java\n  static class TThread extends Thread {\n  \t\tprivate int key;\n\n  \t\tpublic TThread(int key) {\n  \t\t\tthis.key = key;\n  \t\t}\n\n  \t\t@Override\n  \t\tpublic void run() {\n  \t\t\tgo(this.key);\n  \t\t}\n\n  \t\tpublic synchronized void go(int key) {\n  \t\t\twhile (true) {\n  \t\t\t\tSystem.out.println(key);\n  \t\t\t\ttry {\n  \t\t\t\t\tThread.currentThread().sleep(1000);\n  \t\t\t\t} catch (InterruptedException e) {\n  \t\t\t\t\te.printStackTrace();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tstatic class SecondThread extends Thread {\n  \t\tTThread tt;\n\n  \t\tpublic SecondThread(TThread tt) {\n  \t\t\tthis.tt = tt;\n  \t\t}\n\n  \t\t@Override\n  \t\tpublic void run() {\n  \t\t\tthis.tt.go(3);\n  \t\t}\n  \t}\n\n  \tpublic static void main(String[] args) {\n  \t\tTThread t1 = new TThread(1);\n  \t\tt1.start();\n  \t\tSecondThread st = new SecondThread(t1);\n  \t\tst.start();\n  \t\tTThread t2 = new TThread(2);\n  \t\tt2.start();\n  \t}\n  ```\n\n  上述代码会打印1和2，但是却不会打印3。因为synchronized锁定的是线程对象，而t1和t2是两个不同的对象，所以可以并发执行。而实例st中run方法实际执行的是t1的同步方法，因而1和3不会同时打印。\n\n  **另一方面，既然是锁定对象，意味着每个对象都有自己的lock，如果是同一个类的不同实例在多个线程间调用时，仍然会并发执行。**\n\n# 0x02 锁定类Class对象\n\n- 当sychronized修饰static方法时，锁定的是该class的Class对象\n\n  ```java\n  class Text{\n    public sychronized static void method1(){\n    }\n  }\n  ```\n\n- 当sychronized锁定xx.class时，锁定的也是该class的Class对象\n\n  ```java\n  class Text{\n    public void method2(){\n      sychronized(Text.class){\n      }\n    }\n  }\n  ```\n\n  如下代码有何问题：\n\n  ```java\n  \tstatic class TThread extends Thread {\n\n  \t\t@Override\n  \t\tpublic void run() {\n  \t\t\tgo1();\n  \t\t}\n\n  \t\tprivate synchronized void go1() {\n  \t\t\twhile (true) {\n  \t\t\t\tSystem.out.println(1);\n  \t\t\t\ttry {\n  \t\t\t\t\tThread.currentThread().sleep(1000);\n  \t\t\t\t} catch (InterruptedException e) {\n  \t\t\t\t\te.printStackTrace();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tpublic synchronized static void go2() {\n  \t\t\twhile (true) {\n  \t\t\t\tSystem.out.println(2);\n  \t\t\t\ttry {\n  \t\t\t\t\tThread.currentThread().sleep(1000);\n  \t\t\t\t} catch (InterruptedException e) {\n  \t\t\t\t\te.printStackTrace();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tpublic static void main(String[] args) {\n  \t\tTThread t1 = new TThread();\n  \t\tt1.start();\n  \t\tt1.go2();\n  \t}\n  ```\n\n  go1函数是实例函数，go2是类函数。尽管上述两个函数都声明为synchronized，它们并非线程安全的。因为两个线程获取的是不同的lock。\n\n  因此上述代码执行时，打印1和2交替执行。\n\n  **时刻注意对象锁和类锁的区分，不要为了实现某些数据同步而同时使用两种方法。因为这两种方法获取的是不同的锁**\n\n# 0x03 避免因权限导致锁无效\n\n直接看如下代码有何问题：\n\n```java\n\tpublic int[] intArr = new int[10];\n\n\tpublic synchronized void addArr(int[] arr) {\n\t\tint len = intArr.length;\n\t\tif (len == arr.length) {\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tintArr[i] += arr[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic synchronized void subtrackArr(int[] arr) {\n\t\tint len = intArr.length;\n\t\tif (len == arr.length) {\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tintArr[i] -= arr[i];\n\t\t\t}\n\t\t}\n\t}\n```\n\n上面代码是线程安全的吗？\n\n当然不是。虽然两个实例方法实现了线程同步，但是还有其他漏洞。\n\n首先要明白同步的目的是保证**intArr**的准确性。但是因为该实例属性权限是**public**状态。这导致无须通过同步方法，也能修改数组。所以应该修改权限为私有状态。\n\n**有时看似添加了同步方法就以为万无一失了，但是就因为权限开放导致线程安全没有生效**\n\n# 0x04 避免无谓的同步导致性能降低\n\n看看如下代码正确吗：\n\n```Java\n\tprivate int[] arr1;\n\tprivate int[] arr2;\n\tprivate int[] arr3;\n\tprivate int[] arr4;\n\n\tpublic synchronized void method1() {\n\t\t// 操作arr1和arr2\n\t}\n\n\tpublic synchronized void method2() {\n\t\t// 操作arr1和arr2\n\t}\n\n\tpublic synchronized void method3() {\n\t\t// 操作arr3和arr4\n\t}\n\n\tpublic synchronized void method4() {\n\t\t// 操作arr3和arr4\n\t}\n```\n\n上述操作无疑是线程安全的，但是这种方法同步带来了很大的性能问题。\n\n因为同步所以互斥，这也就决定了四个方法不能并发，但是逻辑上，method1和method2由于都操作了arr1和arr2，所以应该互斥，但是不应该和method3、method4互斥。\n\n但是现在的结果是操作arr1和arr2的时候就不能操作arr3和arr4。造成了性能下降。\n\n要避免这种情况可以缩小锁范围，**创建专门的对象锁以替代方法所属对象的锁**\n\n如下修改：\n\n```java\n\tprivate int[] arr1;\n\tprivate int[] arr2;\n\tprivate int[] arr3;\n\tprivate int[] arr4;\n\tprivate byte[] lock1 = new byte[0];\n\tprivate byte[] lock2 = new byte[0];\n\n\tpublic void method1() {\n\t\t// 操作arr1和arr2\n\t\tsynchronized (lock1) {\n\t\t}\n\t}\n\n\tpublic void method2() {\n\t\t// 操作arr1和arr2\n\t\tsynchronized (lock1) {\n\t\t}\n\t}\n\n\tpublic void method3() {\n\t\t// 操作arr3和arr4\n\t\tsynchronized (lock2) {\n\t\t}\n\t}\n\n\tpublic void method4() {\n\t\t// 操作arr3和arr4\n\t\tsynchronized (lock2) {\n\t\t}\n\t}\n```\n\n# 0x05 避免多个锁顺序不同导致死锁\n\n要避免死锁首先要知道什么是死锁，以及死锁如何发生得。\n\n**线程A申请一个对象锁，但是对象锁被线程B持有了，而线程B申请的对象锁又被线程A持有了，这样导致两个线程分别阻塞了对方，这就是死锁。**\n\n死锁是如何形成的？\n\n**死锁一般是由于多个锁对象在不同的线程中获取对象锁顺序不同造成的**\n\n看如下代码：\n\n```java\n\tstatic class TT {\n\t\tpublic void method1(int[] arr1, int[] arr2) {\n\t\t\t// 操作arr1和arr2\n\t\t\tsynchronized (arr1) {\n\t\t\t\tsynchronized (arr2) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tTT tt = new TT();\n\t\tint[] arr1 = new int[10];\n\t\tint[] arr2 = new int[10];\n\t\ttt.method1(arr1, arr2);\n\t\ttt.method1(arr2, arr1);\n\n\t}\n```\n\n在method1的方法调用中，因为两个数组参数的顺序调换，导致了多线程情况下获取对象锁顺序不同，导致死锁发生。\n\n如何解决死锁？\n\n**一种简单的方法就是保证不同线程中多个锁对象获取锁的顺序是相同的。**\n\n\n\n","source":"_posts/使用sychronized注意事项.md","raw":"---\ntitle: 使用sychronized注意事项\ndate: 2017-08-10 21:43:15\ntags: Java\ncategories: Java\n---\n\n# 0x00 前言\n\nJava编程中多线程并发是一个举足轻重的模块，所以加深对这一块的理解是很有必要的。\n\n# 0x01锁定对象而非函数或代码块 \n\n- 当sychronized修饰实例方法时，锁定的是调用该方法的对象\n\n  如下代码：\n\n  ```java\n  class Text{\n    public sychronized void method1(){\n    }\n  }\n  ```\n\n- 当sychronized锁定this时，锁定的也是当前对象\n\n  ```java\n  class Text{\n    public void method2(){\n      sychronized(this){ \n      }\n    }\n  }\n  ```\n\n  **既然锁定的是对象，也就意味着调用该函数的线程A会获得该对象lock，同样的，线程B在调用该对象的函数时也要获得该对象的lock，但是该对象的lock此时被线程A持有，所以线程B就要处于阻塞状态，直到lock被线程A释放。**\n\n  看看下面代码有何问题：\n\n  ```java\n  static class TThread extends Thread {\n  \t\tprivate int key;\n\n  \t\tpublic TThread(int key) {\n  \t\t\tthis.key = key;\n  \t\t}\n\n  \t\t@Override\n  \t\tpublic void run() {\n  \t\t\tgo(this.key);\n  \t\t}\n\n  \t\tpublic synchronized void go(int key) {\n  \t\t\twhile (true) {\n  \t\t\t\tSystem.out.println(key);\n  \t\t\t\ttry {\n  \t\t\t\t\tThread.currentThread().sleep(1000);\n  \t\t\t\t} catch (InterruptedException e) {\n  \t\t\t\t\te.printStackTrace();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tstatic class SecondThread extends Thread {\n  \t\tTThread tt;\n\n  \t\tpublic SecondThread(TThread tt) {\n  \t\t\tthis.tt = tt;\n  \t\t}\n\n  \t\t@Override\n  \t\tpublic void run() {\n  \t\t\tthis.tt.go(3);\n  \t\t}\n  \t}\n\n  \tpublic static void main(String[] args) {\n  \t\tTThread t1 = new TThread(1);\n  \t\tt1.start();\n  \t\tSecondThread st = new SecondThread(t1);\n  \t\tst.start();\n  \t\tTThread t2 = new TThread(2);\n  \t\tt2.start();\n  \t}\n  ```\n\n  上述代码会打印1和2，但是却不会打印3。因为synchronized锁定的是线程对象，而t1和t2是两个不同的对象，所以可以并发执行。而实例st中run方法实际执行的是t1的同步方法，因而1和3不会同时打印。\n\n  **另一方面，既然是锁定对象，意味着每个对象都有自己的lock，如果是同一个类的不同实例在多个线程间调用时，仍然会并发执行。**\n\n# 0x02 锁定类Class对象\n\n- 当sychronized修饰static方法时，锁定的是该class的Class对象\n\n  ```java\n  class Text{\n    public sychronized static void method1(){\n    }\n  }\n  ```\n\n- 当sychronized锁定xx.class时，锁定的也是该class的Class对象\n\n  ```java\n  class Text{\n    public void method2(){\n      sychronized(Text.class){\n      }\n    }\n  }\n  ```\n\n  如下代码有何问题：\n\n  ```java\n  \tstatic class TThread extends Thread {\n\n  \t\t@Override\n  \t\tpublic void run() {\n  \t\t\tgo1();\n  \t\t}\n\n  \t\tprivate synchronized void go1() {\n  \t\t\twhile (true) {\n  \t\t\t\tSystem.out.println(1);\n  \t\t\t\ttry {\n  \t\t\t\t\tThread.currentThread().sleep(1000);\n  \t\t\t\t} catch (InterruptedException e) {\n  \t\t\t\t\te.printStackTrace();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tpublic synchronized static void go2() {\n  \t\t\twhile (true) {\n  \t\t\t\tSystem.out.println(2);\n  \t\t\t\ttry {\n  \t\t\t\t\tThread.currentThread().sleep(1000);\n  \t\t\t\t} catch (InterruptedException e) {\n  \t\t\t\t\te.printStackTrace();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tpublic static void main(String[] args) {\n  \t\tTThread t1 = new TThread();\n  \t\tt1.start();\n  \t\tt1.go2();\n  \t}\n  ```\n\n  go1函数是实例函数，go2是类函数。尽管上述两个函数都声明为synchronized，它们并非线程安全的。因为两个线程获取的是不同的lock。\n\n  因此上述代码执行时，打印1和2交替执行。\n\n  **时刻注意对象锁和类锁的区分，不要为了实现某些数据同步而同时使用两种方法。因为这两种方法获取的是不同的锁**\n\n# 0x03 避免因权限导致锁无效\n\n直接看如下代码有何问题：\n\n```java\n\tpublic int[] intArr = new int[10];\n\n\tpublic synchronized void addArr(int[] arr) {\n\t\tint len = intArr.length;\n\t\tif (len == arr.length) {\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tintArr[i] += arr[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic synchronized void subtrackArr(int[] arr) {\n\t\tint len = intArr.length;\n\t\tif (len == arr.length) {\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tintArr[i] -= arr[i];\n\t\t\t}\n\t\t}\n\t}\n```\n\n上面代码是线程安全的吗？\n\n当然不是。虽然两个实例方法实现了线程同步，但是还有其他漏洞。\n\n首先要明白同步的目的是保证**intArr**的准确性。但是因为该实例属性权限是**public**状态。这导致无须通过同步方法，也能修改数组。所以应该修改权限为私有状态。\n\n**有时看似添加了同步方法就以为万无一失了，但是就因为权限开放导致线程安全没有生效**\n\n# 0x04 避免无谓的同步导致性能降低\n\n看看如下代码正确吗：\n\n```Java\n\tprivate int[] arr1;\n\tprivate int[] arr2;\n\tprivate int[] arr3;\n\tprivate int[] arr4;\n\n\tpublic synchronized void method1() {\n\t\t// 操作arr1和arr2\n\t}\n\n\tpublic synchronized void method2() {\n\t\t// 操作arr1和arr2\n\t}\n\n\tpublic synchronized void method3() {\n\t\t// 操作arr3和arr4\n\t}\n\n\tpublic synchronized void method4() {\n\t\t// 操作arr3和arr4\n\t}\n```\n\n上述操作无疑是线程安全的，但是这种方法同步带来了很大的性能问题。\n\n因为同步所以互斥，这也就决定了四个方法不能并发，但是逻辑上，method1和method2由于都操作了arr1和arr2，所以应该互斥，但是不应该和method3、method4互斥。\n\n但是现在的结果是操作arr1和arr2的时候就不能操作arr3和arr4。造成了性能下降。\n\n要避免这种情况可以缩小锁范围，**创建专门的对象锁以替代方法所属对象的锁**\n\n如下修改：\n\n```java\n\tprivate int[] arr1;\n\tprivate int[] arr2;\n\tprivate int[] arr3;\n\tprivate int[] arr4;\n\tprivate byte[] lock1 = new byte[0];\n\tprivate byte[] lock2 = new byte[0];\n\n\tpublic void method1() {\n\t\t// 操作arr1和arr2\n\t\tsynchronized (lock1) {\n\t\t}\n\t}\n\n\tpublic void method2() {\n\t\t// 操作arr1和arr2\n\t\tsynchronized (lock1) {\n\t\t}\n\t}\n\n\tpublic void method3() {\n\t\t// 操作arr3和arr4\n\t\tsynchronized (lock2) {\n\t\t}\n\t}\n\n\tpublic void method4() {\n\t\t// 操作arr3和arr4\n\t\tsynchronized (lock2) {\n\t\t}\n\t}\n```\n\n# 0x05 避免多个锁顺序不同导致死锁\n\n要避免死锁首先要知道什么是死锁，以及死锁如何发生得。\n\n**线程A申请一个对象锁，但是对象锁被线程B持有了，而线程B申请的对象锁又被线程A持有了，这样导致两个线程分别阻塞了对方，这就是死锁。**\n\n死锁是如何形成的？\n\n**死锁一般是由于多个锁对象在不同的线程中获取对象锁顺序不同造成的**\n\n看如下代码：\n\n```java\n\tstatic class TT {\n\t\tpublic void method1(int[] arr1, int[] arr2) {\n\t\t\t// 操作arr1和arr2\n\t\t\tsynchronized (arr1) {\n\t\t\t\tsynchronized (arr2) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tTT tt = new TT();\n\t\tint[] arr1 = new int[10];\n\t\tint[] arr2 = new int[10];\n\t\ttt.method1(arr1, arr2);\n\t\ttt.method1(arr2, arr1);\n\n\t}\n```\n\n在method1的方法调用中，因为两个数组参数的顺序调换，导致了多线程情况下获取对象锁顺序不同，导致死锁发生。\n\n如何解决死锁？\n\n**一种简单的方法就是保证不同线程中多个锁对象获取锁的顺序是相同的。**\n\n\n\n","slug":"使用sychronized注意事项","published":1,"updated":"2017-08-10T16:31:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjhv005wwh9coqhuu78x","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Java编程中多线程并发是一个举足轻重的模块，所以加深对这一块的理解是很有必要的。</p>\n<h1 id=\"0x01锁定对象而非函数或代码块\"><a href=\"#0x01锁定对象而非函数或代码块\" class=\"headerlink\" title=\"0x01锁定对象而非函数或代码块\"></a>0x01锁定对象而非函数或代码块</h1><ul>\n<li><p>当sychronized修饰实例方法时，锁定的是调用该方法的对象</p>\n<p>如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>当sychronized锁定this时，锁定的也是当前对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    sychronized(<span class=\"keyword\">this</span>)&#123; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>既然锁定的是对象，也就意味着调用该函数的线程A会获得该对象lock，同样的，线程B在调用该对象的函数时也要获得该对象的lock，但是该对象的lock此时被线程A持有，所以线程B就要处于阻塞状态，直到lock被线程A释放。</strong></p>\n<p>看看下面代码有何问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> key;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TThread</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\tgo(<span class=\"keyword\">this</span>.key);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(key);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tThread.currentThread().sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t\tTThread tt;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SecondThread</span><span class=\"params\">(TThread tt)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.tt = tt;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.tt.go(<span class=\"number\">3</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTThread t1 = <span class=\"keyword\">new</span> TThread(<span class=\"number\">1</span>);</div><div class=\"line\">\t\tt1.start();</div><div class=\"line\">\t\tSecondThread st = <span class=\"keyword\">new</span> SecondThread(t1);</div><div class=\"line\">\t\tst.start();</div><div class=\"line\">\t\tTThread t2 = <span class=\"keyword\">new</span> TThread(<span class=\"number\">2</span>);</div><div class=\"line\">\t\tt2.start();</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>上述代码会打印1和2，但是却不会打印3。因为synchronized锁定的是线程对象，而t1和t2是两个不同的对象，所以可以并发执行。而实例st中run方法实际执行的是t1的同步方法，因而1和3不会同时打印。</p>\n<p><strong>另一方面，既然是锁定对象，意味着每个对象都有自己的lock，如果是同一个类的不同实例在多个线程间调用时，仍然会并发执行。</strong></p>\n</li>\n</ul>\n<h1 id=\"0x02-锁定类Class对象\"><a href=\"#0x02-锁定类Class对象\" class=\"headerlink\" title=\"0x02 锁定类Class对象\"></a>0x02 锁定类Class对象</h1><ul>\n<li><p>当sychronized修饰static方法时，锁定的是该class的Class对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>当sychronized锁定xx.class时，锁定的也是该class的Class对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    sychronized(Text.class)&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下代码有何问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tgo1();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">go1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"number\">1</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.currentThread().sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">go2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"number\">2</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.currentThread().sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTThread t1 = <span class=\"keyword\">new</span> TThread();</div><div class=\"line\">\tt1.start();</div><div class=\"line\">\tt1.go2();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>go1函数是实例函数，go2是类函数。尽管上述两个函数都声明为synchronized，它们并非线程安全的。因为两个线程获取的是不同的lock。</p>\n<p>因此上述代码执行时，打印1和2交替执行。</p>\n<p><strong>时刻注意对象锁和类锁的区分，不要为了实现某些数据同步而同时使用两种方法。因为这两种方法获取的是不同的锁</strong></p>\n</li>\n</ul>\n<h1 id=\"0x03-避免因权限导致锁无效\"><a href=\"#0x03-避免因权限导致锁无效\" class=\"headerlink\" title=\"0x03 避免因权限导致锁无效\"></a>0x03 避免因权限导致锁无效</h1><p>直接看如下代码有何问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intArr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addArr</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> len = intArr.length;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (len == arr.length) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">\t\t\tintArr[i] += arr[i];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">subtrackArr</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> len = intArr.length;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (len == arr.length) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">\t\t\tintArr[i] -= arr[i];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码是线程安全的吗？</p>\n<p>当然不是。虽然两个实例方法实现了线程同步，但是还有其他漏洞。</p>\n<p>首先要明白同步的目的是保证<strong>intArr</strong>的准确性。但是因为该实例属性权限是<strong>public</strong>状态。这导致无须通过同步方法，也能修改数组。所以应该修改权限为私有状态。</p>\n<p><strong>有时看似添加了同步方法就以为万无一失了，但是就因为权限开放导致线程安全没有生效</strong></p>\n<h1 id=\"0x04-避免无谓的同步导致性能降低\"><a href=\"#0x04-避免无谓的同步导致性能降低\" class=\"headerlink\" title=\"0x04 避免无谓的同步导致性能降低\"></a>0x04 避免无谓的同步导致性能降低</h1><p>看看如下代码正确吗：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr1;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr2;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr3;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr4;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method4</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述操作无疑是线程安全的，但是这种方法同步带来了很大的性能问题。</p>\n<p>因为同步所以互斥，这也就决定了四个方法不能并发，但是逻辑上，method1和method2由于都操作了arr1和arr2，所以应该互斥，但是不应该和method3、method4互斥。</p>\n<p>但是现在的结果是操作arr1和arr2的时候就不能操作arr3和arr4。造成了性能下降。</p>\n<p>要避免这种情况可以缩小锁范围，<strong>创建专门的对象锁以替代方法所属对象的锁</strong></p>\n<p>如下修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr1;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr2;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr3;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr4;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] lock1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] lock2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock1) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock1) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock2) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method4</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock2) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"0x05-避免多个锁顺序不同导致死锁\"><a href=\"#0x05-避免多个锁顺序不同导致死锁\" class=\"headerlink\" title=\"0x05 避免多个锁顺序不同导致死锁\"></a>0x05 避免多个锁顺序不同导致死锁</h1><p>要避免死锁首先要知道什么是死锁，以及死锁如何发生得。</p>\n<p><strong>线程A申请一个对象锁，但是对象锁被线程B持有了，而线程B申请的对象锁又被线程A持有了，这样导致两个线程分别阻塞了对方，这就是死锁。</strong></p>\n<p>死锁是如何形成的？</p>\n<p><strong>死锁一般是由于多个锁对象在不同的线程中获取对象锁顺序不同造成的</strong></p>\n<p>看如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr1, <span class=\"keyword\">int</span>[] arr2)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (arr1) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (arr2) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTT tt = <span class=\"keyword\">new</span> TT();</div><div class=\"line\">\t<span class=\"keyword\">int</span>[] arr1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</div><div class=\"line\">\t<span class=\"keyword\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</div><div class=\"line\">\ttt.method1(arr1, arr2);</div><div class=\"line\">\ttt.method1(arr2, arr1);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在method1的方法调用中，因为两个数组参数的顺序调换，导致了多线程情况下获取对象锁顺序不同，导致死锁发生。</p>\n<p>如何解决死锁？</p>\n<p><strong>一种简单的方法就是保证不同线程中多个锁对象获取锁的顺序是相同的。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Java编程中多线程并发是一个举足轻重的模块，所以加深对这一块的理解是很有必要的。</p>\n<h1 id=\"0x01锁定对象而非函数或代码块\"><a href=\"#0x01锁定对象而非函数或代码块\" class=\"headerlink\" title=\"0x01锁定对象而非函数或代码块\"></a>0x01锁定对象而非函数或代码块</h1><ul>\n<li><p>当sychronized修饰实例方法时，锁定的是调用该方法的对象</p>\n<p>如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>当sychronized锁定this时，锁定的也是当前对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    sychronized(<span class=\"keyword\">this</span>)&#123; </div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>既然锁定的是对象，也就意味着调用该函数的线程A会获得该对象lock，同样的，线程B在调用该对象的函数时也要获得该对象的lock，但是该对象的lock此时被线程A持有，所以线程B就要处于阻塞状态，直到lock被线程A释放。</strong></p>\n<p>看看下面代码有何问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> key;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TThread</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\tgo(<span class=\"keyword\">this</span>.key);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">go</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\t\tSystem.out.println(key);</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tThread.currentThread().sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\">\t\tTThread tt;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SecondThread</span><span class=\"params\">(TThread tt)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.tt = tt;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.tt.go(<span class=\"number\">3</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tTThread t1 = <span class=\"keyword\">new</span> TThread(<span class=\"number\">1</span>);</div><div class=\"line\">\t\tt1.start();</div><div class=\"line\">\t\tSecondThread st = <span class=\"keyword\">new</span> SecondThread(t1);</div><div class=\"line\">\t\tst.start();</div><div class=\"line\">\t\tTThread t2 = <span class=\"keyword\">new</span> TThread(<span class=\"number\">2</span>);</div><div class=\"line\">\t\tt2.start();</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>上述代码会打印1和2，但是却不会打印3。因为synchronized锁定的是线程对象，而t1和t2是两个不同的对象，所以可以并发执行。而实例st中run方法实际执行的是t1的同步方法，因而1和3不会同时打印。</p>\n<p><strong>另一方面，既然是锁定对象，意味着每个对象都有自己的lock，如果是同一个类的不同实例在多个线程间调用时，仍然会并发执行。</strong></p>\n</li>\n</ul>\n<h1 id=\"0x02-锁定类Class对象\"><a href=\"#0x02-锁定类Class对象\" class=\"headerlink\" title=\"0x02 锁定类Class对象\"></a>0x02 锁定类Class对象</h1><ul>\n<li><p>当sychronized修饰static方法时，锁定的是该class的Class对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>当sychronized锁定xx.class时，锁定的也是该class的Class对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span></span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    sychronized(Text.class)&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下代码有何问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tgo1();</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">go1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"number\">1</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.currentThread().sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">go2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"number\">2</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tThread.currentThread().sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTThread t1 = <span class=\"keyword\">new</span> TThread();</div><div class=\"line\">\tt1.start();</div><div class=\"line\">\tt1.go2();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>go1函数是实例函数，go2是类函数。尽管上述两个函数都声明为synchronized，它们并非线程安全的。因为两个线程获取的是不同的lock。</p>\n<p>因此上述代码执行时，打印1和2交替执行。</p>\n<p><strong>时刻注意对象锁和类锁的区分，不要为了实现某些数据同步而同时使用两种方法。因为这两种方法获取的是不同的锁</strong></p>\n</li>\n</ul>\n<h1 id=\"0x03-避免因权限导致锁无效\"><a href=\"#0x03-避免因权限导致锁无效\" class=\"headerlink\" title=\"0x03 避免因权限导致锁无效\"></a>0x03 避免因权限导致锁无效</h1><p>直接看如下代码有何问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] intArr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addArr</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> len = intArr.length;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (len == arr.length) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">\t\t\tintArr[i] += arr[i];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">subtrackArr</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> len = intArr.length;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (len == arr.length) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">\t\t\tintArr[i] -= arr[i];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码是线程安全的吗？</p>\n<p>当然不是。虽然两个实例方法实现了线程同步，但是还有其他漏洞。</p>\n<p>首先要明白同步的目的是保证<strong>intArr</strong>的准确性。但是因为该实例属性权限是<strong>public</strong>状态。这导致无须通过同步方法，也能修改数组。所以应该修改权限为私有状态。</p>\n<p><strong>有时看似添加了同步方法就以为万无一失了，但是就因为权限开放导致线程安全没有生效</strong></p>\n<h1 id=\"0x04-避免无谓的同步导致性能降低\"><a href=\"#0x04-避免无谓的同步导致性能降低\" class=\"headerlink\" title=\"0x04 避免无谓的同步导致性能降低\"></a>0x04 避免无谓的同步导致性能降低</h1><p>看看如下代码正确吗：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr1;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr2;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr3;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr4;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method4</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述操作无疑是线程安全的，但是这种方法同步带来了很大的性能问题。</p>\n<p>因为同步所以互斥，这也就决定了四个方法不能并发，但是逻辑上，method1和method2由于都操作了arr1和arr2，所以应该互斥，但是不应该和method3、method4互斥。</p>\n<p>但是现在的结果是操作arr1和arr2的时候就不能操作arr3和arr4。造成了性能下降。</p>\n<p>要避免这种情况可以缩小锁范围，<strong>创建专门的对象锁以替代方法所属对象的锁</strong></p>\n<p>如下修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr1;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr2;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr3;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] arr4;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] lock1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] lock2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock1) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock1) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method3</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock2) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method4</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 操作arr3和arr4</span></div><div class=\"line\">\t<span class=\"keyword\">synchronized</span> (lock2) &#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"0x05-避免多个锁顺序不同导致死锁\"><a href=\"#0x05-避免多个锁顺序不同导致死锁\" class=\"headerlink\" title=\"0x05 避免多个锁顺序不同导致死锁\"></a>0x05 避免多个锁顺序不同导致死锁</h1><p>要避免死锁首先要知道什么是死锁，以及死锁如何发生得。</p>\n<p><strong>线程A申请一个对象锁，但是对象锁被线程B持有了，而线程B申请的对象锁又被线程A持有了，这样导致两个线程分别阻塞了对方，这就是死锁。</strong></p>\n<p>死锁是如何形成的？</p>\n<p><strong>死锁一般是由于多个锁对象在不同的线程中获取对象锁顺序不同造成的</strong></p>\n<p>看如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TT</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr1, <span class=\"keyword\">int</span>[] arr2)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 操作arr1和arr2</span></div><div class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (arr1) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (arr2) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tTT tt = <span class=\"keyword\">new</span> TT();</div><div class=\"line\">\t<span class=\"keyword\">int</span>[] arr1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</div><div class=\"line\">\t<span class=\"keyword\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</div><div class=\"line\">\ttt.method1(arr1, arr2);</div><div class=\"line\">\ttt.method1(arr2, arr1);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在method1的方法调用中，因为两个数组参数的顺序调换，导致了多线程情况下获取对象锁顺序不同，导致死锁发生。</p>\n<p>如何解决死锁？</p>\n<p><strong>一种简单的方法就是保证不同线程中多个锁对象获取锁的顺序是相同的。</strong></p>\n"},{"title":"为什么每一个IT人员应该有一把人体工学电脑椅","date":"2017-05-15T09:32:36.000Z","_content":"\n# 说在前面的话\n\n工欲善其事，必先利其器。可能也有强迫症的原因，上班时总是会想尽办法提高工作效率，同时给自己创造一个愉悦的工作状态。对于能提高效率的硬件因素自然不能放过。什么罗技鼠标、机械键盘宿舍公司各一套。为了方便显示器调整，又买了乐哥支架，这样能随时调整角度，避免一个姿势容易疲劳。但是最近又出现了一个问题：一个姿势坐半个小时就浑身不自在，脖子僵硬大脑供血不足，严重时候还有恶心呕吐现象。其实不用说也猜到了—颈椎病，如果置之不理以后腰椎可能也会出现病症。毕竟这是很多IT从业人员的通病，如何缓解病况才不致于影响工作效率呢？个人感觉一把人体工学电脑椅是必须的。\n\n\n\n# 什么是人体工学电脑椅\n\n看下[百度百科](http://baike.baidu.com/link?url=DtpSA5XKbKnq0i8zuufuO3XadcstS54-xa_Yy1tgbhl2P962gqvxcBdlTMD9X38dAhw9THJrNJ4LvH3v_LrY34E1ENL3-2sLwtmJapNyawT3y9q8Q6rki5jdqYXnD9XahJADbgkPqYscZxNB0ImSqnqI62tEybnCUKPugI6sPRi) 对人体工学电脑椅的定义：人体工学电脑椅也称人体工学椅、人体工学办公椅，它是以“人体工程学”理论为基础，通过对人们在使用电脑椅的过程中的各个数据进行统计汇总，并根据最终统计的数据而设计研发的电脑椅。\n\n我们日常坐的椅子都是批量生产，都有固定的规格，并不能适应所有人，所以人体工学椅子和普通椅子一个明显区别就是：可调节！可调节的手托、可调节的坐垫高度、可调节的坐垫前后深度、可调节的枕托、可调节的背靠、可调节的腰托等。\n\n# 一把质量差的电脑椅\n\n质量差的电脑椅能有咋的，顶多坏了摔一跤？还是看图最直观：\n\n![1918606_151944_1](为什么每一个IT人员应该有一把人体工学电脑椅/1918606_151944_1.gif)\n\n\n\n上图的爆炸是气压棒爆炸引起的。\n\n电脑椅升降功能大都是靠气压棒来实现的。那么什么是气压棒呢？\n\n看下[百度百科](http://baike.baidu.com/item/%E6%B0%94%E5%8E%8B%E6%A3%92) 对气压棒的定义，其实说白了气压棒就是靠对棒内气体压缩和释放来达到升降电脑椅的。正品气压棒里面是高纯度氮气填充，并不会爆炸，而一些无良厂商为了节省成本，往往会以价格更为低廉的氧气作为填充物。氧气易燃，遇明火极易产生爆炸，酿成不可挽回的事故。\n\n# 一个气压棒引起的事故\n\n- 1.2007年4月20日晚，浙江省舟山市定海区，一位娄女士坐的椅子发生爆炸，座椅被炸穿，娄女士穿的裤子被炸了个大洞，硬塑料、木屑、海绵、布料、密封圈等大量碎片崩进娄女士体内达十厘米。\n\n- 2.2007年11月26日晚，烟台开发区68岁的吴老先生所坐的气压升降椅发生爆炸，臀部、腿部、直肠肛管和小肠受伤严重。\n\n- 3.2008年3月26日晚，江西赣州市，一位林先生家中的电脑椅突然发生爆炸，林先生背上、手上等处受伤，一根大约15厘米长的小铁棍炸飞到天花板上。\n\n- 4.2009年1月14日，山东胶州14岁少年小刚(化名)独自在家上网，在调节气压椅升降时，突然发生爆炸，顶杆从臀部顶进小刚体内，伤及多条血管，后因失血过多，抢救无效死亡。\n\n- 5.2010.5.12晚上9点半左右，厦门湖里殿前一户出租屋传出巨响。一名女子被突然发生爆裂的升降椅击伤。升降旋转椅突然爆炸，产生的冲击力将椅子里的螺丝小垫片等零件像子弹一样从臀部射入人体内。升降椅的气压杆插入伤者的肛门。女子当场晕倒在地。所幸经过5个多小时的手术，射入体内的椅子零件全被取出，刘小姐无生命危险。\n\n- 6.2010年5月，福建一女子因气压升降椅爆炸伤势严重当场昏迷，臀部被炸伤，直肠被撕裂了一个口子，阴道也穿了一个孔。后检查椅子的购物单据，没有任何厂名、厂址、电话之类信息。\n\n- 7.24岁的小林坐在升降旋转椅上吹头发，椅子爆炸，螺丝钉从她肛门边上穿进去，从子宫直肠陷凹处穿出。经过手术，医生从她的体内和臀部取出大量的螺丝钉和塑料碎片。医生说，还算幸运，穿过体内的螺丝钉没有伤及重要的脏器，手术后小林已脱离生命危险。\n\n  > 请务必一定要提醒你的家人和朋友注意：\n  >\n  > 1、务必购买正规厂家生产的升降椅，切勿贪图便宜，购买劣质货。\n  >\n  > 2、椅子在使用时，不要反复升降，不要滑来滑去，更不要猛地一下子坐上去。这易造成气压杆受力不均，长时间产生不均衡磨损，易爆炸。据模拟测算，爆炸会产生24个左右大气压，其威力至少能击穿6块密度板，顷刻能洞穿血肉之躯!\n  >\n  > 3、如果不是专业人士，不要拆开气缸，也不要让椅子靠近太热的东西，比如烤火炉或烤箱。\n  >\n  > 4、使用一段时间后，应该及时让专业人员检查，一旦发现裂痕、松动迹象，应及时维修更换。\n\n# 如何挑选人体工学电脑椅\n\n## 价格\n\n从价格上来说，和其他商品一样，往往都是一分钱一分货，一块钱二分货。\n\n国际品牌有欧美的Herman Miller、日本的岗村，这些高端系列普遍价格过万或者近万元，当然也有三五千的，但是可选性比较少。\n\n国内品牌有ergonor、ergomax以及黑白调、西昊等。国产价位3000以上就算是高端了，譬如金豪+e、l和ergomax旗舰版。\n\n个人感觉如果要买人体工学电脑椅，还是要舍得投资的，毕竟这投资的是自己的健康。建议起步买2k-3k的。毕竟这个价位在国内属于高端，国外品牌也能买到。这个价位的各方面功能齐全，可以都体验下，为以后的挑选打下基础。\n\n## 网布\n\n坐垫和椅背的材质有皮质、网布和海绵坐垫，我更喜欢全网布的，夏天透气性更好，但是也有个问题：如果网布质量不好，可能坐一段时间后网布就失去弹性，变得松垮。\n\n高端电脑椅网布大都进口，进口网布主要是美国matrex，韩国wintex次之，其他基本就是国产的。\n\n**进口网和国产网的差别：**\n\n价格：进口的美国Matrex网最贵，韩国Wintex网次之，国产网价格最便宜网，而且进口网涉及空运报关原因，货期长。\n\n耐用性：在厂家的垂直堕下机械测试中，进口Matrex网和Wintex网可以通过10万次强力冲击，国产网在按不同牌子在6-8万次之间会出现爆裂!\n\n材质：美国Matrex网和Wintex网材质柔软，弹力强，国产网比较硬，弹力及恢复力差。\n\n\n\nMatrex表面反光呈黏手手感，Wintex网表面反光呈光滑手感，国产网按不同牌子部分表面光滑，部分表面粗糙。\n\n据Matrex网和Wintex网国内代理商的说法，国内厂商用进口网布的并不多，内销产品基本都不会使用进口网，进口网一般都是外国客户指定要求才用的，原因在于进口网不仅更贵，而且在订购数量方面有要求，由于涉及空运报关因素，邮寄周期也比较长，这样就限制了小厂家的采购，掌柜曾经在网上看过一些网店几百产品也宣称使用Matrex网，那是不可能的，进口网，基本上只出现在2K以上的产品。\n\n\n\n**Matrex和wintex网布都是有吊牌的，如果商家真的采用这两种品牌，一定会拿出来当噱头显摆一番的，而不是轻描淡写的一句采用进口网布草草了事。网上那些说进口网布，但又不敢指明具体品牌的，就当时国产就行了或者不要买，毕竟涉嫌欺诈。**\n\n\n\n## 气压棒\n\n气压棒是有分级的，目前是共有四级：普遍使用的时三级，少数所谓高端使用四级。\n\n常用气压棒品牌：国内知名的有：安徽莱特，安德福，常州巨威，安吉斯诺尔，等还有一些进口的：韩国KGS，韩国三弘，德国SUS棒，台湾MID棒等等。\n\n**买回来后看气压棒有没有钢印，查看钢印信息是否和商家描述一致，如果有问题即时质疑。**\n\n\n\n\n\n## 底座\n\n一般来说都有底座防爆措施，但是价格越高底座用料越实，甚至是全铝合金底盘。我的2k 的gavee整个椅子70多斤重，厚重的材质更容易给人以安全感。\n\n\n\n**我对铝合金椅身有特殊好感，或许害怕塑料椅身不结实，也或许铝合金抛光后看起来更高端也更敦实。**\n\n\n\n这是我的电脑椅样式：\n\n![58f074a8N70fcfb6a](为什么每一个IT人员应该有一把人体工学电脑椅/58f074a8N70fcfb6a.jpg)\n\n","source":"_posts/为什么每一个IT人员应该有一把人体工学电脑椅.md","raw":"---\ntitle: 为什么每一个IT人员应该有一把人体工学电脑椅\ndate: 2017-05-15 17:32:36\ntags: 职场杂谈\ncategories: 职场杂谈\n---\n\n# 说在前面的话\n\n工欲善其事，必先利其器。可能也有强迫症的原因，上班时总是会想尽办法提高工作效率，同时给自己创造一个愉悦的工作状态。对于能提高效率的硬件因素自然不能放过。什么罗技鼠标、机械键盘宿舍公司各一套。为了方便显示器调整，又买了乐哥支架，这样能随时调整角度，避免一个姿势容易疲劳。但是最近又出现了一个问题：一个姿势坐半个小时就浑身不自在，脖子僵硬大脑供血不足，严重时候还有恶心呕吐现象。其实不用说也猜到了—颈椎病，如果置之不理以后腰椎可能也会出现病症。毕竟这是很多IT从业人员的通病，如何缓解病况才不致于影响工作效率呢？个人感觉一把人体工学电脑椅是必须的。\n\n\n\n# 什么是人体工学电脑椅\n\n看下[百度百科](http://baike.baidu.com/link?url=DtpSA5XKbKnq0i8zuufuO3XadcstS54-xa_Yy1tgbhl2P962gqvxcBdlTMD9X38dAhw9THJrNJ4LvH3v_LrY34E1ENL3-2sLwtmJapNyawT3y9q8Q6rki5jdqYXnD9XahJADbgkPqYscZxNB0ImSqnqI62tEybnCUKPugI6sPRi) 对人体工学电脑椅的定义：人体工学电脑椅也称人体工学椅、人体工学办公椅，它是以“人体工程学”理论为基础，通过对人们在使用电脑椅的过程中的各个数据进行统计汇总，并根据最终统计的数据而设计研发的电脑椅。\n\n我们日常坐的椅子都是批量生产，都有固定的规格，并不能适应所有人，所以人体工学椅子和普通椅子一个明显区别就是：可调节！可调节的手托、可调节的坐垫高度、可调节的坐垫前后深度、可调节的枕托、可调节的背靠、可调节的腰托等。\n\n# 一把质量差的电脑椅\n\n质量差的电脑椅能有咋的，顶多坏了摔一跤？还是看图最直观：\n\n![1918606_151944_1](为什么每一个IT人员应该有一把人体工学电脑椅/1918606_151944_1.gif)\n\n\n\n上图的爆炸是气压棒爆炸引起的。\n\n电脑椅升降功能大都是靠气压棒来实现的。那么什么是气压棒呢？\n\n看下[百度百科](http://baike.baidu.com/item/%E6%B0%94%E5%8E%8B%E6%A3%92) 对气压棒的定义，其实说白了气压棒就是靠对棒内气体压缩和释放来达到升降电脑椅的。正品气压棒里面是高纯度氮气填充，并不会爆炸，而一些无良厂商为了节省成本，往往会以价格更为低廉的氧气作为填充物。氧气易燃，遇明火极易产生爆炸，酿成不可挽回的事故。\n\n# 一个气压棒引起的事故\n\n- 1.2007年4月20日晚，浙江省舟山市定海区，一位娄女士坐的椅子发生爆炸，座椅被炸穿，娄女士穿的裤子被炸了个大洞，硬塑料、木屑、海绵、布料、密封圈等大量碎片崩进娄女士体内达十厘米。\n\n- 2.2007年11月26日晚，烟台开发区68岁的吴老先生所坐的气压升降椅发生爆炸，臀部、腿部、直肠肛管和小肠受伤严重。\n\n- 3.2008年3月26日晚，江西赣州市，一位林先生家中的电脑椅突然发生爆炸，林先生背上、手上等处受伤，一根大约15厘米长的小铁棍炸飞到天花板上。\n\n- 4.2009年1月14日，山东胶州14岁少年小刚(化名)独自在家上网，在调节气压椅升降时，突然发生爆炸，顶杆从臀部顶进小刚体内，伤及多条血管，后因失血过多，抢救无效死亡。\n\n- 5.2010.5.12晚上9点半左右，厦门湖里殿前一户出租屋传出巨响。一名女子被突然发生爆裂的升降椅击伤。升降旋转椅突然爆炸，产生的冲击力将椅子里的螺丝小垫片等零件像子弹一样从臀部射入人体内。升降椅的气压杆插入伤者的肛门。女子当场晕倒在地。所幸经过5个多小时的手术，射入体内的椅子零件全被取出，刘小姐无生命危险。\n\n- 6.2010年5月，福建一女子因气压升降椅爆炸伤势严重当场昏迷，臀部被炸伤，直肠被撕裂了一个口子，阴道也穿了一个孔。后检查椅子的购物单据，没有任何厂名、厂址、电话之类信息。\n\n- 7.24岁的小林坐在升降旋转椅上吹头发，椅子爆炸，螺丝钉从她肛门边上穿进去，从子宫直肠陷凹处穿出。经过手术，医生从她的体内和臀部取出大量的螺丝钉和塑料碎片。医生说，还算幸运，穿过体内的螺丝钉没有伤及重要的脏器，手术后小林已脱离生命危险。\n\n  > 请务必一定要提醒你的家人和朋友注意：\n  >\n  > 1、务必购买正规厂家生产的升降椅，切勿贪图便宜，购买劣质货。\n  >\n  > 2、椅子在使用时，不要反复升降，不要滑来滑去，更不要猛地一下子坐上去。这易造成气压杆受力不均，长时间产生不均衡磨损，易爆炸。据模拟测算，爆炸会产生24个左右大气压，其威力至少能击穿6块密度板，顷刻能洞穿血肉之躯!\n  >\n  > 3、如果不是专业人士，不要拆开气缸，也不要让椅子靠近太热的东西，比如烤火炉或烤箱。\n  >\n  > 4、使用一段时间后，应该及时让专业人员检查，一旦发现裂痕、松动迹象，应及时维修更换。\n\n# 如何挑选人体工学电脑椅\n\n## 价格\n\n从价格上来说，和其他商品一样，往往都是一分钱一分货，一块钱二分货。\n\n国际品牌有欧美的Herman Miller、日本的岗村，这些高端系列普遍价格过万或者近万元，当然也有三五千的，但是可选性比较少。\n\n国内品牌有ergonor、ergomax以及黑白调、西昊等。国产价位3000以上就算是高端了，譬如金豪+e、l和ergomax旗舰版。\n\n个人感觉如果要买人体工学电脑椅，还是要舍得投资的，毕竟这投资的是自己的健康。建议起步买2k-3k的。毕竟这个价位在国内属于高端，国外品牌也能买到。这个价位的各方面功能齐全，可以都体验下，为以后的挑选打下基础。\n\n## 网布\n\n坐垫和椅背的材质有皮质、网布和海绵坐垫，我更喜欢全网布的，夏天透气性更好，但是也有个问题：如果网布质量不好，可能坐一段时间后网布就失去弹性，变得松垮。\n\n高端电脑椅网布大都进口，进口网布主要是美国matrex，韩国wintex次之，其他基本就是国产的。\n\n**进口网和国产网的差别：**\n\n价格：进口的美国Matrex网最贵，韩国Wintex网次之，国产网价格最便宜网，而且进口网涉及空运报关原因，货期长。\n\n耐用性：在厂家的垂直堕下机械测试中，进口Matrex网和Wintex网可以通过10万次强力冲击，国产网在按不同牌子在6-8万次之间会出现爆裂!\n\n材质：美国Matrex网和Wintex网材质柔软，弹力强，国产网比较硬，弹力及恢复力差。\n\n\n\nMatrex表面反光呈黏手手感，Wintex网表面反光呈光滑手感，国产网按不同牌子部分表面光滑，部分表面粗糙。\n\n据Matrex网和Wintex网国内代理商的说法，国内厂商用进口网布的并不多，内销产品基本都不会使用进口网，进口网一般都是外国客户指定要求才用的，原因在于进口网不仅更贵，而且在订购数量方面有要求，由于涉及空运报关因素，邮寄周期也比较长，这样就限制了小厂家的采购，掌柜曾经在网上看过一些网店几百产品也宣称使用Matrex网，那是不可能的，进口网，基本上只出现在2K以上的产品。\n\n\n\n**Matrex和wintex网布都是有吊牌的，如果商家真的采用这两种品牌，一定会拿出来当噱头显摆一番的，而不是轻描淡写的一句采用进口网布草草了事。网上那些说进口网布，但又不敢指明具体品牌的，就当时国产就行了或者不要买，毕竟涉嫌欺诈。**\n\n\n\n## 气压棒\n\n气压棒是有分级的，目前是共有四级：普遍使用的时三级，少数所谓高端使用四级。\n\n常用气压棒品牌：国内知名的有：安徽莱特，安德福，常州巨威，安吉斯诺尔，等还有一些进口的：韩国KGS，韩国三弘，德国SUS棒，台湾MID棒等等。\n\n**买回来后看气压棒有没有钢印，查看钢印信息是否和商家描述一致，如果有问题即时质疑。**\n\n\n\n\n\n## 底座\n\n一般来说都有底座防爆措施，但是价格越高底座用料越实，甚至是全铝合金底盘。我的2k 的gavee整个椅子70多斤重，厚重的材质更容易给人以安全感。\n\n\n\n**我对铝合金椅身有特殊好感，或许害怕塑料椅身不结实，也或许铝合金抛光后看起来更高端也更敦实。**\n\n\n\n这是我的电脑椅样式：\n\n![58f074a8N70fcfb6a](为什么每一个IT人员应该有一把人体工学电脑椅/58f074a8N70fcfb6a.jpg)\n\n","slug":"为什么每一个IT人员应该有一把人体工学电脑椅","published":1,"updated":"2017-05-15T11:42:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwji00061wh9ciarvcq2f","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>工欲善其事，必先利其器。可能也有强迫症的原因，上班时总是会想尽办法提高工作效率，同时给自己创造一个愉悦的工作状态。对于能提高效率的硬件因素自然不能放过。什么罗技鼠标、机械键盘宿舍公司各一套。为了方便显示器调整，又买了乐哥支架，这样能随时调整角度，避免一个姿势容易疲劳。但是最近又出现了一个问题：一个姿势坐半个小时就浑身不自在，脖子僵硬大脑供血不足，严重时候还有恶心呕吐现象。其实不用说也猜到了—颈椎病，如果置之不理以后腰椎可能也会出现病症。毕竟这是很多IT从业人员的通病，如何缓解病况才不致于影响工作效率呢？个人感觉一把人体工学电脑椅是必须的。</p>\n<h1 id=\"什么是人体工学电脑椅\"><a href=\"#什么是人体工学电脑椅\" class=\"headerlink\" title=\"什么是人体工学电脑椅\"></a>什么是人体工学电脑椅</h1><p>看下<a href=\"http://baike.baidu.com/link?url=DtpSA5XKbKnq0i8zuufuO3XadcstS54-xa_Yy1tgbhl2P962gqvxcBdlTMD9X38dAhw9THJrNJ4LvH3v_LrY34E1ENL3-2sLwtmJapNyawT3y9q8Q6rki5jdqYXnD9XahJADbgkPqYscZxNB0ImSqnqI62tEybnCUKPugI6sPRi\" target=\"_blank\" rel=\"external\">百度百科</a> 对人体工学电脑椅的定义：人体工学电脑椅也称人体工学椅、人体工学办公椅，它是以“人体工程学”理论为基础，通过对人们在使用电脑椅的过程中的各个数据进行统计汇总，并根据最终统计的数据而设计研发的电脑椅。</p>\n<p>我们日常坐的椅子都是批量生产，都有固定的规格，并不能适应所有人，所以人体工学椅子和普通椅子一个明显区别就是：可调节！可调节的手托、可调节的坐垫高度、可调节的坐垫前后深度、可调节的枕托、可调节的背靠、可调节的腰托等。</p>\n<h1 id=\"一把质量差的电脑椅\"><a href=\"#一把质量差的电脑椅\" class=\"headerlink\" title=\"一把质量差的电脑椅\"></a>一把质量差的电脑椅</h1><p>质量差的电脑椅能有咋的，顶多坏了摔一跤？还是看图最直观：</p>\n<p><img src=\"/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/1918606_151944_1.gif\" alt=\"1918606_151944_1\"></p>\n<p>上图的爆炸是气压棒爆炸引起的。</p>\n<p>电脑椅升降功能大都是靠气压棒来实现的。那么什么是气压棒呢？</p>\n<p>看下<a href=\"http://baike.baidu.com/item/%E6%B0%94%E5%8E%8B%E6%A3%92\" target=\"_blank\" rel=\"external\">百度百科</a> 对气压棒的定义，其实说白了气压棒就是靠对棒内气体压缩和释放来达到升降电脑椅的。正品气压棒里面是高纯度氮气填充，并不会爆炸，而一些无良厂商为了节省成本，往往会以价格更为低廉的氧气作为填充物。氧气易燃，遇明火极易产生爆炸，酿成不可挽回的事故。</p>\n<h1 id=\"一个气压棒引起的事故\"><a href=\"#一个气压棒引起的事故\" class=\"headerlink\" title=\"一个气压棒引起的事故\"></a>一个气压棒引起的事故</h1><ul>\n<li><p>1.2007年4月20日晚，浙江省舟山市定海区，一位娄女士坐的椅子发生爆炸，座椅被炸穿，娄女士穿的裤子被炸了个大洞，硬塑料、木屑、海绵、布料、密封圈等大量碎片崩进娄女士体内达十厘米。</p>\n</li>\n<li><p>2.2007年11月26日晚，烟台开发区68岁的吴老先生所坐的气压升降椅发生爆炸，臀部、腿部、直肠肛管和小肠受伤严重。</p>\n</li>\n<li><p>3.2008年3月26日晚，江西赣州市，一位林先生家中的电脑椅突然发生爆炸，林先生背上、手上等处受伤，一根大约15厘米长的小铁棍炸飞到天花板上。</p>\n</li>\n<li><p>4.2009年1月14日，山东胶州14岁少年小刚(化名)独自在家上网，在调节气压椅升降时，突然发生爆炸，顶杆从臀部顶进小刚体内，伤及多条血管，后因失血过多，抢救无效死亡。</p>\n</li>\n<li><p>5.2010.5.12晚上9点半左右，厦门湖里殿前一户出租屋传出巨响。一名女子被突然发生爆裂的升降椅击伤。升降旋转椅突然爆炸，产生的冲击力将椅子里的螺丝小垫片等零件像子弹一样从臀部射入人体内。升降椅的气压杆插入伤者的肛门。女子当场晕倒在地。所幸经过5个多小时的手术，射入体内的椅子零件全被取出，刘小姐无生命危险。</p>\n</li>\n<li><p>6.2010年5月，福建一女子因气压升降椅爆炸伤势严重当场昏迷，臀部被炸伤，直肠被撕裂了一个口子，阴道也穿了一个孔。后检查椅子的购物单据，没有任何厂名、厂址、电话之类信息。</p>\n</li>\n<li><p>7.24岁的小林坐在升降旋转椅上吹头发，椅子爆炸，螺丝钉从她肛门边上穿进去，从子宫直肠陷凹处穿出。经过手术，医生从她的体内和臀部取出大量的螺丝钉和塑料碎片。医生说，还算幸运，穿过体内的螺丝钉没有伤及重要的脏器，手术后小林已脱离生命危险。</p>\n<blockquote>\n<p>请务必一定要提醒你的家人和朋友注意：</p>\n<p>1、务必购买正规厂家生产的升降椅，切勿贪图便宜，购买劣质货。</p>\n<p>2、椅子在使用时，不要反复升降，不要滑来滑去，更不要猛地一下子坐上去。这易造成气压杆受力不均，长时间产生不均衡磨损，易爆炸。据模拟测算，爆炸会产生24个左右大气压，其威力至少能击穿6块密度板，顷刻能洞穿血肉之躯!</p>\n<p>3、如果不是专业人士，不要拆开气缸，也不要让椅子靠近太热的东西，比如烤火炉或烤箱。</p>\n<p>4、使用一段时间后，应该及时让专业人员检查，一旦发现裂痕、松动迹象，应及时维修更换。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"如何挑选人体工学电脑椅\"><a href=\"#如何挑选人体工学电脑椅\" class=\"headerlink\" title=\"如何挑选人体工学电脑椅\"></a>如何挑选人体工学电脑椅</h1><h2 id=\"价格\"><a href=\"#价格\" class=\"headerlink\" title=\"价格\"></a>价格</h2><p>从价格上来说，和其他商品一样，往往都是一分钱一分货，一块钱二分货。</p>\n<p>国际品牌有欧美的Herman Miller、日本的岗村，这些高端系列普遍价格过万或者近万元，当然也有三五千的，但是可选性比较少。</p>\n<p>国内品牌有ergonor、ergomax以及黑白调、西昊等。国产价位3000以上就算是高端了，譬如金豪+e、l和ergomax旗舰版。</p>\n<p>个人感觉如果要买人体工学电脑椅，还是要舍得投资的，毕竟这投资的是自己的健康。建议起步买2k-3k的。毕竟这个价位在国内属于高端，国外品牌也能买到。这个价位的各方面功能齐全，可以都体验下，为以后的挑选打下基础。</p>\n<h2 id=\"网布\"><a href=\"#网布\" class=\"headerlink\" title=\"网布\"></a>网布</h2><p>坐垫和椅背的材质有皮质、网布和海绵坐垫，我更喜欢全网布的，夏天透气性更好，但是也有个问题：如果网布质量不好，可能坐一段时间后网布就失去弹性，变得松垮。</p>\n<p>高端电脑椅网布大都进口，进口网布主要是美国matrex，韩国wintex次之，其他基本就是国产的。</p>\n<p><strong>进口网和国产网的差别：</strong></p>\n<p>价格：进口的美国Matrex网最贵，韩国Wintex网次之，国产网价格最便宜网，而且进口网涉及空运报关原因，货期长。</p>\n<p>耐用性：在厂家的垂直堕下机械测试中，进口Matrex网和Wintex网可以通过10万次强力冲击，国产网在按不同牌子在6-8万次之间会出现爆裂!</p>\n<p>材质：美国Matrex网和Wintex网材质柔软，弹力强，国产网比较硬，弹力及恢复力差。</p>\n<p>Matrex表面反光呈黏手手感，Wintex网表面反光呈光滑手感，国产网按不同牌子部分表面光滑，部分表面粗糙。</p>\n<p>据Matrex网和Wintex网国内代理商的说法，国内厂商用进口网布的并不多，内销产品基本都不会使用进口网，进口网一般都是外国客户指定要求才用的，原因在于进口网不仅更贵，而且在订购数量方面有要求，由于涉及空运报关因素，邮寄周期也比较长，这样就限制了小厂家的采购，掌柜曾经在网上看过一些网店几百产品也宣称使用Matrex网，那是不可能的，进口网，基本上只出现在2K以上的产品。</p>\n<p><strong>Matrex和wintex网布都是有吊牌的，如果商家真的采用这两种品牌，一定会拿出来当噱头显摆一番的，而不是轻描淡写的一句采用进口网布草草了事。网上那些说进口网布，但又不敢指明具体品牌的，就当时国产就行了或者不要买，毕竟涉嫌欺诈。</strong></p>\n<h2 id=\"气压棒\"><a href=\"#气压棒\" class=\"headerlink\" title=\"气压棒\"></a>气压棒</h2><p>气压棒是有分级的，目前是共有四级：普遍使用的时三级，少数所谓高端使用四级。</p>\n<p>常用气压棒品牌：国内知名的有：安徽莱特，安德福，常州巨威，安吉斯诺尔，等还有一些进口的：韩国KGS，韩国三弘，德国SUS棒，台湾MID棒等等。</p>\n<p><strong>买回来后看气压棒有没有钢印，查看钢印信息是否和商家描述一致，如果有问题即时质疑。</strong></p>\n<h2 id=\"底座\"><a href=\"#底座\" class=\"headerlink\" title=\"底座\"></a>底座</h2><p>一般来说都有底座防爆措施，但是价格越高底座用料越实，甚至是全铝合金底盘。我的2k 的gavee整个椅子70多斤重，厚重的材质更容易给人以安全感。</p>\n<p><strong>我对铝合金椅身有特殊好感，或许害怕塑料椅身不结实，也或许铝合金抛光后看起来更高端也更敦实。</strong></p>\n<p>这是我的电脑椅样式：</p>\n<p><img src=\"/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/58f074a8N70fcfb6a.jpg\" alt=\"58f074a8N70fcfb6a\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>工欲善其事，必先利其器。可能也有强迫症的原因，上班时总是会想尽办法提高工作效率，同时给自己创造一个愉悦的工作状态。对于能提高效率的硬件因素自然不能放过。什么罗技鼠标、机械键盘宿舍公司各一套。为了方便显示器调整，又买了乐哥支架，这样能随时调整角度，避免一个姿势容易疲劳。但是最近又出现了一个问题：一个姿势坐半个小时就浑身不自在，脖子僵硬大脑供血不足，严重时候还有恶心呕吐现象。其实不用说也猜到了—颈椎病，如果置之不理以后腰椎可能也会出现病症。毕竟这是很多IT从业人员的通病，如何缓解病况才不致于影响工作效率呢？个人感觉一把人体工学电脑椅是必须的。</p>\n<h1 id=\"什么是人体工学电脑椅\"><a href=\"#什么是人体工学电脑椅\" class=\"headerlink\" title=\"什么是人体工学电脑椅\"></a>什么是人体工学电脑椅</h1><p>看下<a href=\"http://baike.baidu.com/link?url=DtpSA5XKbKnq0i8zuufuO3XadcstS54-xa_Yy1tgbhl2P962gqvxcBdlTMD9X38dAhw9THJrNJ4LvH3v_LrY34E1ENL3-2sLwtmJapNyawT3y9q8Q6rki5jdqYXnD9XahJADbgkPqYscZxNB0ImSqnqI62tEybnCUKPugI6sPRi\">百度百科</a> 对人体工学电脑椅的定义：人体工学电脑椅也称人体工学椅、人体工学办公椅，它是以“人体工程学”理论为基础，通过对人们在使用电脑椅的过程中的各个数据进行统计汇总，并根据最终统计的数据而设计研发的电脑椅。</p>\n<p>我们日常坐的椅子都是批量生产，都有固定的规格，并不能适应所有人，所以人体工学椅子和普通椅子一个明显区别就是：可调节！可调节的手托、可调节的坐垫高度、可调节的坐垫前后深度、可调节的枕托、可调节的背靠、可调节的腰托等。</p>\n<h1 id=\"一把质量差的电脑椅\"><a href=\"#一把质量差的电脑椅\" class=\"headerlink\" title=\"一把质量差的电脑椅\"></a>一把质量差的电脑椅</h1><p>质量差的电脑椅能有咋的，顶多坏了摔一跤？还是看图最直观：</p>\n<p><img src=\"/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/1918606_151944_1.gif\" alt=\"1918606_151944_1\"></p>\n<p>上图的爆炸是气压棒爆炸引起的。</p>\n<p>电脑椅升降功能大都是靠气压棒来实现的。那么什么是气压棒呢？</p>\n<p>看下<a href=\"http://baike.baidu.com/item/%E6%B0%94%E5%8E%8B%E6%A3%92\">百度百科</a> 对气压棒的定义，其实说白了气压棒就是靠对棒内气体压缩和释放来达到升降电脑椅的。正品气压棒里面是高纯度氮气填充，并不会爆炸，而一些无良厂商为了节省成本，往往会以价格更为低廉的氧气作为填充物。氧气易燃，遇明火极易产生爆炸，酿成不可挽回的事故。</p>\n<h1 id=\"一个气压棒引起的事故\"><a href=\"#一个气压棒引起的事故\" class=\"headerlink\" title=\"一个气压棒引起的事故\"></a>一个气压棒引起的事故</h1><ul>\n<li><p>1.2007年4月20日晚，浙江省舟山市定海区，一位娄女士坐的椅子发生爆炸，座椅被炸穿，娄女士穿的裤子被炸了个大洞，硬塑料、木屑、海绵、布料、密封圈等大量碎片崩进娄女士体内达十厘米。</p>\n</li>\n<li><p>2.2007年11月26日晚，烟台开发区68岁的吴老先生所坐的气压升降椅发生爆炸，臀部、腿部、直肠肛管和小肠受伤严重。</p>\n</li>\n<li><p>3.2008年3月26日晚，江西赣州市，一位林先生家中的电脑椅突然发生爆炸，林先生背上、手上等处受伤，一根大约15厘米长的小铁棍炸飞到天花板上。</p>\n</li>\n<li><p>4.2009年1月14日，山东胶州14岁少年小刚(化名)独自在家上网，在调节气压椅升降时，突然发生爆炸，顶杆从臀部顶进小刚体内，伤及多条血管，后因失血过多，抢救无效死亡。</p>\n</li>\n<li><p>5.2010.5.12晚上9点半左右，厦门湖里殿前一户出租屋传出巨响。一名女子被突然发生爆裂的升降椅击伤。升降旋转椅突然爆炸，产生的冲击力将椅子里的螺丝小垫片等零件像子弹一样从臀部射入人体内。升降椅的气压杆插入伤者的肛门。女子当场晕倒在地。所幸经过5个多小时的手术，射入体内的椅子零件全被取出，刘小姐无生命危险。</p>\n</li>\n<li><p>6.2010年5月，福建一女子因气压升降椅爆炸伤势严重当场昏迷，臀部被炸伤，直肠被撕裂了一个口子，阴道也穿了一个孔。后检查椅子的购物单据，没有任何厂名、厂址、电话之类信息。</p>\n</li>\n<li><p>7.24岁的小林坐在升降旋转椅上吹头发，椅子爆炸，螺丝钉从她肛门边上穿进去，从子宫直肠陷凹处穿出。经过手术，医生从她的体内和臀部取出大量的螺丝钉和塑料碎片。医生说，还算幸运，穿过体内的螺丝钉没有伤及重要的脏器，手术后小林已脱离生命危险。</p>\n<blockquote>\n<p>请务必一定要提醒你的家人和朋友注意：</p>\n<p>1、务必购买正规厂家生产的升降椅，切勿贪图便宜，购买劣质货。</p>\n<p>2、椅子在使用时，不要反复升降，不要滑来滑去，更不要猛地一下子坐上去。这易造成气压杆受力不均，长时间产生不均衡磨损，易爆炸。据模拟测算，爆炸会产生24个左右大气压，其威力至少能击穿6块密度板，顷刻能洞穿血肉之躯!</p>\n<p>3、如果不是专业人士，不要拆开气缸，也不要让椅子靠近太热的东西，比如烤火炉或烤箱。</p>\n<p>4、使用一段时间后，应该及时让专业人员检查，一旦发现裂痕、松动迹象，应及时维修更换。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"如何挑选人体工学电脑椅\"><a href=\"#如何挑选人体工学电脑椅\" class=\"headerlink\" title=\"如何挑选人体工学电脑椅\"></a>如何挑选人体工学电脑椅</h1><h2 id=\"价格\"><a href=\"#价格\" class=\"headerlink\" title=\"价格\"></a>价格</h2><p>从价格上来说，和其他商品一样，往往都是一分钱一分货，一块钱二分货。</p>\n<p>国际品牌有欧美的Herman Miller、日本的岗村，这些高端系列普遍价格过万或者近万元，当然也有三五千的，但是可选性比较少。</p>\n<p>国内品牌有ergonor、ergomax以及黑白调、西昊等。国产价位3000以上就算是高端了，譬如金豪+e、l和ergomax旗舰版。</p>\n<p>个人感觉如果要买人体工学电脑椅，还是要舍得投资的，毕竟这投资的是自己的健康。建议起步买2k-3k的。毕竟这个价位在国内属于高端，国外品牌也能买到。这个价位的各方面功能齐全，可以都体验下，为以后的挑选打下基础。</p>\n<h2 id=\"网布\"><a href=\"#网布\" class=\"headerlink\" title=\"网布\"></a>网布</h2><p>坐垫和椅背的材质有皮质、网布和海绵坐垫，我更喜欢全网布的，夏天透气性更好，但是也有个问题：如果网布质量不好，可能坐一段时间后网布就失去弹性，变得松垮。</p>\n<p>高端电脑椅网布大都进口，进口网布主要是美国matrex，韩国wintex次之，其他基本就是国产的。</p>\n<p><strong>进口网和国产网的差别：</strong></p>\n<p>价格：进口的美国Matrex网最贵，韩国Wintex网次之，国产网价格最便宜网，而且进口网涉及空运报关原因，货期长。</p>\n<p>耐用性：在厂家的垂直堕下机械测试中，进口Matrex网和Wintex网可以通过10万次强力冲击，国产网在按不同牌子在6-8万次之间会出现爆裂!</p>\n<p>材质：美国Matrex网和Wintex网材质柔软，弹力强，国产网比较硬，弹力及恢复力差。</p>\n<p>Matrex表面反光呈黏手手感，Wintex网表面反光呈光滑手感，国产网按不同牌子部分表面光滑，部分表面粗糙。</p>\n<p>据Matrex网和Wintex网国内代理商的说法，国内厂商用进口网布的并不多，内销产品基本都不会使用进口网，进口网一般都是外国客户指定要求才用的，原因在于进口网不仅更贵，而且在订购数量方面有要求，由于涉及空运报关因素，邮寄周期也比较长，这样就限制了小厂家的采购，掌柜曾经在网上看过一些网店几百产品也宣称使用Matrex网，那是不可能的，进口网，基本上只出现在2K以上的产品。</p>\n<p><strong>Matrex和wintex网布都是有吊牌的，如果商家真的采用这两种品牌，一定会拿出来当噱头显摆一番的，而不是轻描淡写的一句采用进口网布草草了事。网上那些说进口网布，但又不敢指明具体品牌的，就当时国产就行了或者不要买，毕竟涉嫌欺诈。</strong></p>\n<h2 id=\"气压棒\"><a href=\"#气压棒\" class=\"headerlink\" title=\"气压棒\"></a>气压棒</h2><p>气压棒是有分级的，目前是共有四级：普遍使用的时三级，少数所谓高端使用四级。</p>\n<p>常用气压棒品牌：国内知名的有：安徽莱特，安德福，常州巨威，安吉斯诺尔，等还有一些进口的：韩国KGS，韩国三弘，德国SUS棒，台湾MID棒等等。</p>\n<p><strong>买回来后看气压棒有没有钢印，查看钢印信息是否和商家描述一致，如果有问题即时质疑。</strong></p>\n<h2 id=\"底座\"><a href=\"#底座\" class=\"headerlink\" title=\"底座\"></a>底座</h2><p>一般来说都有底座防爆措施，但是价格越高底座用料越实，甚至是全铝合金底盘。我的2k 的gavee整个椅子70多斤重，厚重的材质更容易给人以安全感。</p>\n<p><strong>我对铝合金椅身有特殊好感，或许害怕塑料椅身不结实，也或许铝合金抛光后看起来更高端也更敦实。</strong></p>\n<p>这是我的电脑椅样式：</p>\n<p><img src=\"/2017/05/15/为什么每一个IT人员应该有一把人体工学电脑椅/58f074a8N70fcfb6a.jpg\" alt=\"58f074a8N70fcfb6a\"></p>\n"},{"title":"为什么Android中很多int常量使用十六进制表示","date":"2017-07-19T02:12:21.000Z","_content":"\n# 0x00 前言\n\n在Java或者Android中，发现很多涉及框架和源码地方，很多int常量都是使用十六进制表示的，而不是我们日常开发中直接使用我们最熟悉的十进制。这是为什么呢？换个问法，这样做有什么好处呢？\n\n```java\n    public static final int FLAG_DEBUG_TRIAGED_MISSING = 0x00000100;\n    public static final int FLAG_IGNORE_EPHEMERAL = 0x00000200;\n    public static final int FLAG_ACTIVITY_NO_HISTORY = 0x40000000;\n    public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000;\n    public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;\n    public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;\n    public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;\n\n```\n\n猜测可能的原因：\n\n①为了美观\n\n②为了方便位运算\n\n③关于①我是瞎说的\n\n既然多采用十六进制，那就先简单看看什么是十六进制\n\n# 0x01 十六进制简单介绍\n\n以0x或0X开头，使用数字0~9及字符A~F表示16个可能的值，这种进制方式一般称为十六进制。\n\n一个int占4个字节，32位。\n\n十六进制中0xF最大，二进制表示：1111，用4位即可表示出来，所以在用十六进制表示int时，通常0x后面跟8位数字/字符，这样就可以表示满一个int值。也就是前言中所看到的。\n\n# 0x02 发现规律\n\n通过前言中的代码可以发现基本上频繁出现的只有1，2，4，8几个数字而其他位置都是0占位。为什么会出现这种情况呢？\n\n首先把上面的十六进制转换成二进制看一下：\n\n`0x00000100`转换二进制`0001 0000 0000`\n\n`0x00000200`转换二进制`0010 0000 0000` \n\n`0X00004000`转换二进制`0100 0000 0000 0000`\n\n`0X00008000`转换二进制`1000 0000 0000`\n\n转换后可以发现，1，2，4，8这几个值很特殊，在二进制中表示这几个数时都只要某一位为1，其他位用0占位即可表示。\n\n换句话说，二进制的4位表示十六进制中的一个数字，而这4位中若只有其中一位为1的话，那么可能的值情况为1=2º，2=2¹，4=2²，8=2³。\n\n\n\n这样做有什么好处呢？\n\n# 0x03 这样做的好处\n\n- 拿位移来说因为只有一个数字带值，其他都是0占位，位移时大脑中快速把十六进制转为二进制然后补0位即可。\n\n  拿0x200来说，换算二进制我只要把2用二进制0010在大脑中展示出来，然后后面跟8个0就换算完成。如果0x200>>1,右移1位，相当于1后面的9个0被砍掉一个，左边高位补0。\n\n  二进制表示由`0010 0000 0000`变成了`0001 0000 000`。值由512变成了256，可见右移1位相当于除以2。前面十六进制和二进制转换是在大脑中完成，转换到十进制我是笔算的，可能这是采用十六进制表示int原因之一吧。\n\n  同样左移思路也是如此。\n\n- 位与&/位或|\n\n  位与/位或是对参与运算的数的二进制进行位与/位或。\n\n  位与&：两数二进制对应位均为1时结果才为1，其余为0\n\n  位或|：两数二进制对应位有一个为1时，结果位就为1\n\n  在源码和框架中，很多时候需要存储一些状态组合，比如：\n\n  ```java\n     public Intent addFlags(int flags) {\n          mFlags |= flags;\n          return this;\n      }\n  ```\n\n  最后在一些地方会根据状态组合的不同值来做出不同的响应。这时使用1，2，4，8这种格式的十六进制就很方便，因为不同的状态值只是在二进制的不同位上用1标记而已。这样最后可以根据mFlags的值二进制有多少位为1，基本就能判断有多少种状态。当然这里说的是位或。","source":"_posts/为什么Android中很多int常量使用十六进制表示.md","raw":"---\ntitle: 为什么Android中很多int常量使用十六进制表示\ndate: 2017-07-19 10:12:21\ntags: [Android,Java]\ncategory: [Android,Java]\n---\n\n# 0x00 前言\n\n在Java或者Android中，发现很多涉及框架和源码地方，很多int常量都是使用十六进制表示的，而不是我们日常开发中直接使用我们最熟悉的十进制。这是为什么呢？换个问法，这样做有什么好处呢？\n\n```java\n    public static final int FLAG_DEBUG_TRIAGED_MISSING = 0x00000100;\n    public static final int FLAG_IGNORE_EPHEMERAL = 0x00000200;\n    public static final int FLAG_ACTIVITY_NO_HISTORY = 0x40000000;\n    public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000;\n    public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;\n    public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;\n    public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;\n\n```\n\n猜测可能的原因：\n\n①为了美观\n\n②为了方便位运算\n\n③关于①我是瞎说的\n\n既然多采用十六进制，那就先简单看看什么是十六进制\n\n# 0x01 十六进制简单介绍\n\n以0x或0X开头，使用数字0~9及字符A~F表示16个可能的值，这种进制方式一般称为十六进制。\n\n一个int占4个字节，32位。\n\n十六进制中0xF最大，二进制表示：1111，用4位即可表示出来，所以在用十六进制表示int时，通常0x后面跟8位数字/字符，这样就可以表示满一个int值。也就是前言中所看到的。\n\n# 0x02 发现规律\n\n通过前言中的代码可以发现基本上频繁出现的只有1，2，4，8几个数字而其他位置都是0占位。为什么会出现这种情况呢？\n\n首先把上面的十六进制转换成二进制看一下：\n\n`0x00000100`转换二进制`0001 0000 0000`\n\n`0x00000200`转换二进制`0010 0000 0000` \n\n`0X00004000`转换二进制`0100 0000 0000 0000`\n\n`0X00008000`转换二进制`1000 0000 0000`\n\n转换后可以发现，1，2，4，8这几个值很特殊，在二进制中表示这几个数时都只要某一位为1，其他位用0占位即可表示。\n\n换句话说，二进制的4位表示十六进制中的一个数字，而这4位中若只有其中一位为1的话，那么可能的值情况为1=2º，2=2¹，4=2²，8=2³。\n\n\n\n这样做有什么好处呢？\n\n# 0x03 这样做的好处\n\n- 拿位移来说因为只有一个数字带值，其他都是0占位，位移时大脑中快速把十六进制转为二进制然后补0位即可。\n\n  拿0x200来说，换算二进制我只要把2用二进制0010在大脑中展示出来，然后后面跟8个0就换算完成。如果0x200>>1,右移1位，相当于1后面的9个0被砍掉一个，左边高位补0。\n\n  二进制表示由`0010 0000 0000`变成了`0001 0000 000`。值由512变成了256，可见右移1位相当于除以2。前面十六进制和二进制转换是在大脑中完成，转换到十进制我是笔算的，可能这是采用十六进制表示int原因之一吧。\n\n  同样左移思路也是如此。\n\n- 位与&/位或|\n\n  位与/位或是对参与运算的数的二进制进行位与/位或。\n\n  位与&：两数二进制对应位均为1时结果才为1，其余为0\n\n  位或|：两数二进制对应位有一个为1时，结果位就为1\n\n  在源码和框架中，很多时候需要存储一些状态组合，比如：\n\n  ```java\n     public Intent addFlags(int flags) {\n          mFlags |= flags;\n          return this;\n      }\n  ```\n\n  最后在一些地方会根据状态组合的不同值来做出不同的响应。这时使用1，2，4，8这种格式的十六进制就很方便，因为不同的状态值只是在二进制的不同位上用1标记而已。这样最后可以根据mFlags的值二进制有多少位为1，基本就能判断有多少种状态。当然这里说的是位或。","slug":"为什么Android中很多int常量使用十六进制表示","published":1,"updated":"2017-07-19T05:38:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwji50064wh9cueetfu44","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>在Java或者Android中，发现很多涉及框架和源码地方，很多int常量都是使用十六进制表示的，而不是我们日常开发中直接使用我们最熟悉的十进制。这是为什么呢？换个问法，这样做有什么好处呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_DEBUG_TRIAGED_MISSING = <span class=\"number\">0x00000100</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_IGNORE_EPHEMERAL = <span class=\"number\">0x00000200</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_NO_HISTORY = <span class=\"number\">0x40000000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_NEW_TASK = <span class=\"number\">0x10000000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_MULTIPLE_TASK = <span class=\"number\">0x08000000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_CLEAR_TASK = <span class=\"number\">0X00008000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_TASK_ON_HOME = <span class=\"number\">0X00004000</span>;</div></pre></td></tr></table></figure>\n<p>猜测可能的原因：</p>\n<p>①为了美观</p>\n<p>②为了方便位运算</p>\n<p>③关于①我是瞎说的</p>\n<p>既然多采用十六进制，那就先简单看看什么是十六进制</p>\n<h1 id=\"0x01-十六进制简单介绍\"><a href=\"#0x01-十六进制简单介绍\" class=\"headerlink\" title=\"0x01 十六进制简单介绍\"></a>0x01 十六进制简单介绍</h1><p>以0x或0X开头，使用数字0~9及字符A~F表示16个可能的值，这种进制方式一般称为十六进制。</p>\n<p>一个int占4个字节，32位。</p>\n<p>十六进制中0xF最大，二进制表示：1111，用4位即可表示出来，所以在用十六进制表示int时，通常0x后面跟8位数字/字符，这样就可以表示满一个int值。也就是前言中所看到的。</p>\n<h1 id=\"0x02-发现规律\"><a href=\"#0x02-发现规律\" class=\"headerlink\" title=\"0x02 发现规律\"></a>0x02 发现规律</h1><p>通过前言中的代码可以发现基本上频繁出现的只有1，2，4，8几个数字而其他位置都是0占位。为什么会出现这种情况呢？</p>\n<p>首先把上面的十六进制转换成二进制看一下：</p>\n<p><code>0x00000100</code>转换二进制<code>0001 0000 0000</code></p>\n<p><code>0x00000200</code>转换二进制<code>0010 0000 0000</code> </p>\n<p><code>0X00004000</code>转换二进制<code>0100 0000 0000 0000</code></p>\n<p><code>0X00008000</code>转换二进制<code>1000 0000 0000</code></p>\n<p>转换后可以发现，1，2，4，8这几个值很特殊，在二进制中表示这几个数时都只要某一位为1，其他位用0占位即可表示。</p>\n<p>换句话说，二进制的4位表示十六进制中的一个数字，而这4位中若只有其中一位为1的话，那么可能的值情况为1=2º，2=2¹，4=2²，8=2³。</p>\n<p>这样做有什么好处呢？</p>\n<h1 id=\"0x03-这样做的好处\"><a href=\"#0x03-这样做的好处\" class=\"headerlink\" title=\"0x03 这样做的好处\"></a>0x03 这样做的好处</h1><ul>\n<li><p>拿位移来说因为只有一个数字带值，其他都是0占位，位移时大脑中快速把十六进制转为二进制然后补0位即可。</p>\n<p>拿0x200来说，换算二进制我只要把2用二进制0010在大脑中展示出来，然后后面跟8个0就换算完成。如果0x200&gt;&gt;1,右移1位，相当于1后面的9个0被砍掉一个，左边高位补0。</p>\n<p>二进制表示由<code>0010 0000 0000</code>变成了<code>0001 0000 000</code>。值由512变成了256，可见右移1位相当于除以2。前面十六进制和二进制转换是在大脑中完成，转换到十进制我是笔算的，可能这是采用十六进制表示int原因之一吧。</p>\n<p>同样左移思路也是如此。</p>\n</li>\n<li><p>位与&amp;/位或|</p>\n<p>位与/位或是对参与运算的数的二进制进行位与/位或。</p>\n<p>位与&amp;：两数二进制对应位均为1时结果才为1，其余为0</p>\n<p>位或|：两数二进制对应位有一个为1时，结果位就为1</p>\n<p>在源码和框架中，很多时候需要存储一些状态组合，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Intent <span class=\"title\">addFlags</span><span class=\"params\">(<span class=\"keyword\">int</span> flags)</span> </span>&#123;</div><div class=\"line\">     mFlags |= flags;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>最后在一些地方会根据状态组合的不同值来做出不同的响应。这时使用1，2，4，8这种格式的十六进制就很方便，因为不同的状态值只是在二进制的不同位上用1标记而已。这样最后可以根据mFlags的值二进制有多少位为1，基本就能判断有多少种状态。当然这里说的是位或。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>在Java或者Android中，发现很多涉及框架和源码地方，很多int常量都是使用十六进制表示的，而不是我们日常开发中直接使用我们最熟悉的十进制。这是为什么呢？换个问法，这样做有什么好处呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_DEBUG_TRIAGED_MISSING = <span class=\"number\">0x00000100</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_IGNORE_EPHEMERAL = <span class=\"number\">0x00000200</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_NO_HISTORY = <span class=\"number\">0x40000000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_NEW_TASK = <span class=\"number\">0x10000000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_MULTIPLE_TASK = <span class=\"number\">0x08000000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_CLEAR_TASK = <span class=\"number\">0X00008000</span>;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_ACTIVITY_TASK_ON_HOME = <span class=\"number\">0X00004000</span>;</div></pre></td></tr></table></figure>\n<p>猜测可能的原因：</p>\n<p>①为了美观</p>\n<p>②为了方便位运算</p>\n<p>③关于①我是瞎说的</p>\n<p>既然多采用十六进制，那就先简单看看什么是十六进制</p>\n<h1 id=\"0x01-十六进制简单介绍\"><a href=\"#0x01-十六进制简单介绍\" class=\"headerlink\" title=\"0x01 十六进制简单介绍\"></a>0x01 十六进制简单介绍</h1><p>以0x或0X开头，使用数字0~9及字符A~F表示16个可能的值，这种进制方式一般称为十六进制。</p>\n<p>一个int占4个字节，32位。</p>\n<p>十六进制中0xF最大，二进制表示：1111，用4位即可表示出来，所以在用十六进制表示int时，通常0x后面跟8位数字/字符，这样就可以表示满一个int值。也就是前言中所看到的。</p>\n<h1 id=\"0x02-发现规律\"><a href=\"#0x02-发现规律\" class=\"headerlink\" title=\"0x02 发现规律\"></a>0x02 发现规律</h1><p>通过前言中的代码可以发现基本上频繁出现的只有1，2，4，8几个数字而其他位置都是0占位。为什么会出现这种情况呢？</p>\n<p>首先把上面的十六进制转换成二进制看一下：</p>\n<p><code>0x00000100</code>转换二进制<code>0001 0000 0000</code></p>\n<p><code>0x00000200</code>转换二进制<code>0010 0000 0000</code> </p>\n<p><code>0X00004000</code>转换二进制<code>0100 0000 0000 0000</code></p>\n<p><code>0X00008000</code>转换二进制<code>1000 0000 0000</code></p>\n<p>转换后可以发现，1，2，4，8这几个值很特殊，在二进制中表示这几个数时都只要某一位为1，其他位用0占位即可表示。</p>\n<p>换句话说，二进制的4位表示十六进制中的一个数字，而这4位中若只有其中一位为1的话，那么可能的值情况为1=2º，2=2¹，4=2²，8=2³。</p>\n<p>这样做有什么好处呢？</p>\n<h1 id=\"0x03-这样做的好处\"><a href=\"#0x03-这样做的好处\" class=\"headerlink\" title=\"0x03 这样做的好处\"></a>0x03 这样做的好处</h1><ul>\n<li><p>拿位移来说因为只有一个数字带值，其他都是0占位，位移时大脑中快速把十六进制转为二进制然后补0位即可。</p>\n<p>拿0x200来说，换算二进制我只要把2用二进制0010在大脑中展示出来，然后后面跟8个0就换算完成。如果0x200&gt;&gt;1,右移1位，相当于1后面的9个0被砍掉一个，左边高位补0。</p>\n<p>二进制表示由<code>0010 0000 0000</code>变成了<code>0001 0000 000</code>。值由512变成了256，可见右移1位相当于除以2。前面十六进制和二进制转换是在大脑中完成，转换到十进制我是笔算的，可能这是采用十六进制表示int原因之一吧。</p>\n<p>同样左移思路也是如此。</p>\n</li>\n<li><p>位与&amp;/位或|</p>\n<p>位与/位或是对参与运算的数的二进制进行位与/位或。</p>\n<p>位与&amp;：两数二进制对应位均为1时结果才为1，其余为0</p>\n<p>位或|：两数二进制对应位有一个为1时，结果位就为1</p>\n<p>在源码和框架中，很多时候需要存储一些状态组合，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Intent <span class=\"title\">addFlags</span><span class=\"params\">(<span class=\"keyword\">int</span> flags)</span> </span>&#123;</div><div class=\"line\">     mFlags |= flags;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>最后在一些地方会根据状态组合的不同值来做出不同的响应。这时使用1，2，4，8这种格式的十六进制就很方便，因为不同的状态值只是在二进制的不同位上用1标记而已。这样最后可以根据mFlags的值二进制有多少位为1，基本就能判断有多少种状态。当然这里说的是位或。</p>\n</li>\n</ul>\n"},{"title":"关于家庭网络宽带、路由及上网设备那些事---后续篇","date":"2017-04-21T14:50:50.000Z","_content":"上一篇主要写了几点制约网速的可能原因，没有看过上一篇的请移步[关于家庭网络宽带、路由及上网设备那些事](http://www.jianshu.com/p/f1018427d0eb)。这一篇就分别介绍下宽带、路由和用网设备的一些知识。\n### 家庭宽带的那些事\n\n网络出了问题都会打客服咨询，但是你知道你家的网络服务商是几级的吗？\n\n####1.宽带运营商分级\n\n目前宽带运营商一般分为三级即可，三级··立马就邪恶了。\n一级服运营商是国家、省市、城域骨干网的建设者。主要有联通、电信、移动和广电，以前小的时候就有种说法叫南电信北联通。\n\n电信在一级运营商里算是老前辈了。之所以就叫北联通是因为北方以前上网是通过电话线来拨号的，座机的电话那时候归属网通，后来联通收购了网通。移动以前只有无限上网的业务，宽带业务应该是合并了铁通后才有的，广电应该近些年发展起来的，据说广电是租用电信和自建都有的。\n二级运营商是租用了一级运营商的网络设备来发展的。如果一级运营商是厂家的话，二级运营商就相当于批发商了。主要有歌华宽带、长城宽带等。二级运营商的优势就是性价比较高和比较优质的售后。\n三级运营商是写字楼和办公楼这类，背靠房地产开发商和物业提供商发展的。比如有些写字楼只提供某一种宽带，网络 差但又不允许公司拉其他服务商的宽带，着实可恨。\n\n看到这里相信大家对自家的网络提供商有了个大概了解，如果感兴趣请继续：\n\n\n\n\n### 路由器的那些事\n先上一张图放松下，你们觉得这张图说明了什么问题？\n![148318216333359786_620_1000.JPEG](http://upload-images.jianshu.io/upload_images/1796052-6efbb8ea799a2ea4.JPEG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n跟风！！中国人跟风习气太严重，一旦发现别人尝到了点甜头，马上就会有一大波人挤破头的往里钻。\n#### 1.互联网路由器兴起\n也是由于跟风，前两年物联网炒的热闹，家中万物互联，有人分析路由器是物联设备走向网络的首个大门，所以就纷纷研发所谓智能路由器。某米、某为、某极和某数字加入战斗，互联网行业经常是老大和老二掐架，老三莫名的死了。这次乱战虽然没有谁阵亡，但是其实用户还是受益的。最起码手机app管理路由器算是普及了不少，查看联网设备和拉黑蹭网设备也方便不少。\n#### 2.智能路由器\n个人觉得现在所谓的智能路由器其实就是互联网路由器后续发展的产物，而且其实在当不起“智能”二字，可能也是如此，所以目前对于智能路由器的定义也就是拥有独立的系统，可以扩展应用插件来实现不同的功能。\n目前区别路由器是否智能，比较直观的应该是看官方对该型号路由器是否有一个app来支持其手机端操作。\n#### 3. 双频路由器\n上一篇中简单介绍了双频路由器的优点，这里在详细说下：\n以前的无线路由器中只有一个频段就是2.4G，双频路由器中多了一个5G频段。两个频段是由802.11 工作组划分，每个频段又划分为若干信道\n2.4 GHz (802.11b/g/n)信道图如下：\n\n![be261390397543.png](http://upload-images.jianshu.io/upload_images/1796052-fb028f78b96bfa77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有人可能会说中国有13个信道可用，可以的啦。其实每个信道的频宽有22MHz，所以这13个信道有很多重叠的区域，不信你看\n\n![880px-2.4_GHz_Wi-Fi_channels_(802.11b,g_WLAN).svg.png](http://upload-images.jianshu.io/upload_images/1796052-e74729391935e100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样一看刨去重叠的的那些，只有1、6和11三个信道可以互不影响。\n下面我们再看看5G:\n![2e2eb9389b504fc21a213501e3dde71190ef6dbc.jpg](http://upload-images.jianshu.io/upload_images/1796052-d39dbb91334a0469.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n发现中国地5G有5个信道可以使用，看起来也没有比2.4G的好到哪里，为什么传输速率会快呢?\n看下图5G信道间距有20MHz相比2.4G的5MHz大很多，如果使用一个信道时，不会受到其他信道的干扰，如果想提升速率，可以把多个信道合并为40MHz或者80MHz。相比之下速度就提升很多了。\n\n![223707rvzdtllllcvkcv7w.png](http://upload-images.jianshu.io/upload_images/1796052-0b2998b024656dfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n*所以综合得出结论：\n2.4G 信道虽然多，但是互不影响的只有三个，加上使用设备多，干扰大，所以传输速率2.4G低于5G\n但是由于 5G频率高，波长短，所以穿透性2.4G大于5G。\n举个例子理解下穿透性强弱：假如靠近路由器时都是100%信号，但是穿过一堵墙时，2.4G可能还有80%信号，而5G可能仅剩50%信号，就是说两个频段都能穿墙，但是5G穿墙过程自身损失的更严重，所以常说穿透性弱。*\n\n#### 4.\b什么样的路由器才是好路由器？\n\n在我看来好的路由器首要因素就是是否稳定。上面说了穿墙后的信号会减弱。日常路由器放客厅，但是我们又不可能随时守在客厅，可能在卧室、可能在厕所、也可能在院子，远距离加穿墙后，信号可能只有一格了，很多路由器这时候网络是很差的，经常QQ和微信就可能提示网络无法连接，但是现在明明还有一格信号啊。这就是我所说的稳定。一个性能稳定的路由器就算信号只有微弱的一格，仍然能保持网络的流畅，这是我认为的好路由器。就这一点恰恰是很多市面路由都不具备的。\n其他就是参考路由器的性能指标了，如cpu、内存、flash等越大越好，但能耗能也愈大，发热也严重。一般来说家庭百兆宽带最好配上千兆路由，这里的千兆是wlan和lan口也要是千兆的。\n\n### 用网设备那些事\n#### 1.用有线网\n这里只想说一点如果你刚配的主机加上百兆光纤感觉还是网速不达标，那么你可能遇到假网线了。\n其实网线也是分类的，网线分为五类线、超五类线、六类线、七类线，可以通过网线外皮的Cat.5, Cat.5e,Cat.6等来判断,其中cat.6中间有十字的骨架把网线分开\n![70c2802e87d8e3a8224e0e928e0951b7_r.jpg](http://upload-images.jianshu.io/upload_images/1796052-21fa54d3e840c9a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果家里是百兆光纤一般用超五类或者六类，当然六类最好，因为抗干扰更强。\n\n#### 2.无线设备\n暂时没啥想说的了，想起了再更。见谅~","source":"_posts/关于家庭网络宽带、路由及上网设备那些事---后续篇.md","raw":"---\ntitle: 关于家庭网络宽带、路由及上网设备那些事---后续篇\ndate: 2017-04-21 22:50:50\ntags: 网络\ncategories: 网络\n---\n上一篇主要写了几点制约网速的可能原因，没有看过上一篇的请移步[关于家庭网络宽带、路由及上网设备那些事](http://www.jianshu.com/p/f1018427d0eb)。这一篇就分别介绍下宽带、路由和用网设备的一些知识。\n### 家庭宽带的那些事\n\n网络出了问题都会打客服咨询，但是你知道你家的网络服务商是几级的吗？\n\n####1.宽带运营商分级\n\n目前宽带运营商一般分为三级即可，三级··立马就邪恶了。\n一级服运营商是国家、省市、城域骨干网的建设者。主要有联通、电信、移动和广电，以前小的时候就有种说法叫南电信北联通。\n\n电信在一级运营商里算是老前辈了。之所以就叫北联通是因为北方以前上网是通过电话线来拨号的，座机的电话那时候归属网通，后来联通收购了网通。移动以前只有无限上网的业务，宽带业务应该是合并了铁通后才有的，广电应该近些年发展起来的，据说广电是租用电信和自建都有的。\n二级运营商是租用了一级运营商的网络设备来发展的。如果一级运营商是厂家的话，二级运营商就相当于批发商了。主要有歌华宽带、长城宽带等。二级运营商的优势就是性价比较高和比较优质的售后。\n三级运营商是写字楼和办公楼这类，背靠房地产开发商和物业提供商发展的。比如有些写字楼只提供某一种宽带，网络 差但又不允许公司拉其他服务商的宽带，着实可恨。\n\n看到这里相信大家对自家的网络提供商有了个大概了解，如果感兴趣请继续：\n\n\n\n\n### 路由器的那些事\n先上一张图放松下，你们觉得这张图说明了什么问题？\n![148318216333359786_620_1000.JPEG](http://upload-images.jianshu.io/upload_images/1796052-6efbb8ea799a2ea4.JPEG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n跟风！！中国人跟风习气太严重，一旦发现别人尝到了点甜头，马上就会有一大波人挤破头的往里钻。\n#### 1.互联网路由器兴起\n也是由于跟风，前两年物联网炒的热闹，家中万物互联，有人分析路由器是物联设备走向网络的首个大门，所以就纷纷研发所谓智能路由器。某米、某为、某极和某数字加入战斗，互联网行业经常是老大和老二掐架，老三莫名的死了。这次乱战虽然没有谁阵亡，但是其实用户还是受益的。最起码手机app管理路由器算是普及了不少，查看联网设备和拉黑蹭网设备也方便不少。\n#### 2.智能路由器\n个人觉得现在所谓的智能路由器其实就是互联网路由器后续发展的产物，而且其实在当不起“智能”二字，可能也是如此，所以目前对于智能路由器的定义也就是拥有独立的系统，可以扩展应用插件来实现不同的功能。\n目前区别路由器是否智能，比较直观的应该是看官方对该型号路由器是否有一个app来支持其手机端操作。\n#### 3. 双频路由器\n上一篇中简单介绍了双频路由器的优点，这里在详细说下：\n以前的无线路由器中只有一个频段就是2.4G，双频路由器中多了一个5G频段。两个频段是由802.11 工作组划分，每个频段又划分为若干信道\n2.4 GHz (802.11b/g/n)信道图如下：\n\n![be261390397543.png](http://upload-images.jianshu.io/upload_images/1796052-fb028f78b96bfa77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有人可能会说中国有13个信道可用，可以的啦。其实每个信道的频宽有22MHz，所以这13个信道有很多重叠的区域，不信你看\n\n![880px-2.4_GHz_Wi-Fi_channels_(802.11b,g_WLAN).svg.png](http://upload-images.jianshu.io/upload_images/1796052-e74729391935e100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样一看刨去重叠的的那些，只有1、6和11三个信道可以互不影响。\n下面我们再看看5G:\n![2e2eb9389b504fc21a213501e3dde71190ef6dbc.jpg](http://upload-images.jianshu.io/upload_images/1796052-d39dbb91334a0469.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n发现中国地5G有5个信道可以使用，看起来也没有比2.4G的好到哪里，为什么传输速率会快呢?\n看下图5G信道间距有20MHz相比2.4G的5MHz大很多，如果使用一个信道时，不会受到其他信道的干扰，如果想提升速率，可以把多个信道合并为40MHz或者80MHz。相比之下速度就提升很多了。\n\n![223707rvzdtllllcvkcv7w.png](http://upload-images.jianshu.io/upload_images/1796052-0b2998b024656dfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n*所以综合得出结论：\n2.4G 信道虽然多，但是互不影响的只有三个，加上使用设备多，干扰大，所以传输速率2.4G低于5G\n但是由于 5G频率高，波长短，所以穿透性2.4G大于5G。\n举个例子理解下穿透性强弱：假如靠近路由器时都是100%信号，但是穿过一堵墙时，2.4G可能还有80%信号，而5G可能仅剩50%信号，就是说两个频段都能穿墙，但是5G穿墙过程自身损失的更严重，所以常说穿透性弱。*\n\n#### 4.\b什么样的路由器才是好路由器？\n\n在我看来好的路由器首要因素就是是否稳定。上面说了穿墙后的信号会减弱。日常路由器放客厅，但是我们又不可能随时守在客厅，可能在卧室、可能在厕所、也可能在院子，远距离加穿墙后，信号可能只有一格了，很多路由器这时候网络是很差的，经常QQ和微信就可能提示网络无法连接，但是现在明明还有一格信号啊。这就是我所说的稳定。一个性能稳定的路由器就算信号只有微弱的一格，仍然能保持网络的流畅，这是我认为的好路由器。就这一点恰恰是很多市面路由都不具备的。\n其他就是参考路由器的性能指标了，如cpu、内存、flash等越大越好，但能耗能也愈大，发热也严重。一般来说家庭百兆宽带最好配上千兆路由，这里的千兆是wlan和lan口也要是千兆的。\n\n### 用网设备那些事\n#### 1.用有线网\n这里只想说一点如果你刚配的主机加上百兆光纤感觉还是网速不达标，那么你可能遇到假网线了。\n其实网线也是分类的，网线分为五类线、超五类线、六类线、七类线，可以通过网线外皮的Cat.5, Cat.5e,Cat.6等来判断,其中cat.6中间有十字的骨架把网线分开\n![70c2802e87d8e3a8224e0e928e0951b7_r.jpg](http://upload-images.jianshu.io/upload_images/1796052-21fa54d3e840c9a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果家里是百兆光纤一般用超五类或者六类，当然六类最好，因为抗干扰更强。\n\n#### 2.无线设备\n暂时没啥想说的了，想起了再更。见谅~","slug":"关于家庭网络宽带、路由及上网设备那些事---后续篇","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwji80067wh9c6u91zwk5","content":"<p>上一篇主要写了几点制约网速的可能原因，没有看过上一篇的请移步<a href=\"http://www.jianshu.com/p/f1018427d0eb\" target=\"_blank\" rel=\"external\">关于家庭网络宽带、路由及上网设备那些事</a>。这一篇就分别介绍下宽带、路由和用网设备的一些知识。</p>\n<h3 id=\"家庭宽带的那些事\"><a href=\"#家庭宽带的那些事\" class=\"headerlink\" title=\"家庭宽带的那些事\"></a>家庭宽带的那些事</h3><p>网络出了问题都会打客服咨询，但是你知道你家的网络服务商是几级的吗？</p>\n<p>####1.宽带运营商分级</p>\n<p>目前宽带运营商一般分为三级即可，三级··立马就邪恶了。<br>一级服运营商是国家、省市、城域骨干网的建设者。主要有联通、电信、移动和广电，以前小的时候就有种说法叫南电信北联通。</p>\n<p>电信在一级运营商里算是老前辈了。之所以就叫北联通是因为北方以前上网是通过电话线来拨号的，座机的电话那时候归属网通，后来联通收购了网通。移动以前只有无限上网的业务，宽带业务应该是合并了铁通后才有的，广电应该近些年发展起来的，据说广电是租用电信和自建都有的。<br>二级运营商是租用了一级运营商的网络设备来发展的。如果一级运营商是厂家的话，二级运营商就相当于批发商了。主要有歌华宽带、长城宽带等。二级运营商的优势就是性价比较高和比较优质的售后。<br>三级运营商是写字楼和办公楼这类，背靠房地产开发商和物业提供商发展的。比如有些写字楼只提供某一种宽带，网络 差但又不允许公司拉其他服务商的宽带，着实可恨。</p>\n<p>看到这里相信大家对自家的网络提供商有了个大概了解，如果感兴趣请继续：</p>\n<h3 id=\"路由器的那些事\"><a href=\"#路由器的那些事\" class=\"headerlink\" title=\"路由器的那些事\"></a>路由器的那些事</h3><p>先上一张图放松下，你们觉得这张图说明了什么问题？<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6efbb8ea799a2ea4.JPEG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"148318216333359786_620_1000.JPEG\"><br>跟风！！中国人跟风习气太严重，一旦发现别人尝到了点甜头，马上就会有一大波人挤破头的往里钻。</p>\n<h4 id=\"1-互联网路由器兴起\"><a href=\"#1-互联网路由器兴起\" class=\"headerlink\" title=\"1.互联网路由器兴起\"></a>1.互联网路由器兴起</h4><p>也是由于跟风，前两年物联网炒的热闹，家中万物互联，有人分析路由器是物联设备走向网络的首个大门，所以就纷纷研发所谓智能路由器。某米、某为、某极和某数字加入战斗，互联网行业经常是老大和老二掐架，老三莫名的死了。这次乱战虽然没有谁阵亡，但是其实用户还是受益的。最起码手机app管理路由器算是普及了不少，查看联网设备和拉黑蹭网设备也方便不少。</p>\n<h4 id=\"2-智能路由器\"><a href=\"#2-智能路由器\" class=\"headerlink\" title=\"2.智能路由器\"></a>2.智能路由器</h4><p>个人觉得现在所谓的智能路由器其实就是互联网路由器后续发展的产物，而且其实在当不起“智能”二字，可能也是如此，所以目前对于智能路由器的定义也就是拥有独立的系统，可以扩展应用插件来实现不同的功能。<br>目前区别路由器是否智能，比较直观的应该是看官方对该型号路由器是否有一个app来支持其手机端操作。</p>\n<h4 id=\"3-双频路由器\"><a href=\"#3-双频路由器\" class=\"headerlink\" title=\"3. 双频路由器\"></a>3. 双频路由器</h4><p>上一篇中简单介绍了双频路由器的优点，这里在详细说下：<br>以前的无线路由器中只有一个频段就是2.4G，双频路由器中多了一个5G频段。两个频段是由802.11 工作组划分，每个频段又划分为若干信道<br>2.4 GHz (802.11b/g/n)信道图如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-fb028f78b96bfa77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"be261390397543.png\"></p>\n<p>有人可能会说中国有13个信道可用，可以的啦。其实每个信道的频宽有22MHz，所以这13个信道有很多重叠的区域，不信你看</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-e74729391935e100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"880px-2.4_GHz_Wi-Fi_channels_(802.11b,g_WLAN).svg.png\"></p>\n<p>这样一看刨去重叠的的那些，只有1、6和11三个信道可以互不影响。<br>下面我们再看看5G:<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-d39dbb91334a0469.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2e2eb9389b504fc21a213501e3dde71190ef6dbc.jpg\"></p>\n<p>发现中国地5G有5个信道可以使用，看起来也没有比2.4G的好到哪里，为什么传输速率会快呢?<br>看下图5G信道间距有20MHz相比2.4G的5MHz大很多，如果使用一个信道时，不会受到其他信道的干扰，如果想提升速率，可以把多个信道合并为40MHz或者80MHz。相比之下速度就提升很多了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-0b2998b024656dfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"223707rvzdtllllcvkcv7w.png\"></p>\n<p><em>所以综合得出结论：<br>2.4G 信道虽然多，但是互不影响的只有三个，加上使用设备多，干扰大，所以传输速率2.4G低于5G<br>但是由于 5G频率高，波长短，所以穿透性2.4G大于5G。<br>举个例子理解下穿透性强弱：假如靠近路由器时都是100%信号，但是穿过一堵墙时，2.4G可能还有80%信号，而5G可能仅剩50%信号，就是说两个频段都能穿墙，但是5G穿墙过程自身损失的更严重，所以常说穿透性弱。</em></p>\n<h4 id=\"4-什么样的路由器才是好路由器？\"><a href=\"#4-什么样的路由器才是好路由器？\" class=\"headerlink\" title=\"4.\b什么样的路由器才是好路由器？\"></a>4.\b什么样的路由器才是好路由器？</h4><p>在我看来好的路由器首要因素就是是否稳定。上面说了穿墙后的信号会减弱。日常路由器放客厅，但是我们又不可能随时守在客厅，可能在卧室、可能在厕所、也可能在院子，远距离加穿墙后，信号可能只有一格了，很多路由器这时候网络是很差的，经常QQ和微信就可能提示网络无法连接，但是现在明明还有一格信号啊。这就是我所说的稳定。一个性能稳定的路由器就算信号只有微弱的一格，仍然能保持网络的流畅，这是我认为的好路由器。就这一点恰恰是很多市面路由都不具备的。<br>其他就是参考路由器的性能指标了，如cpu、内存、flash等越大越好，但能耗能也愈大，发热也严重。一般来说家庭百兆宽带最好配上千兆路由，这里的千兆是wlan和lan口也要是千兆的。</p>\n<h3 id=\"用网设备那些事\"><a href=\"#用网设备那些事\" class=\"headerlink\" title=\"用网设备那些事\"></a>用网设备那些事</h3><h4 id=\"1-用有线网\"><a href=\"#1-用有线网\" class=\"headerlink\" title=\"1.用有线网\"></a>1.用有线网</h4><p>这里只想说一点如果你刚配的主机加上百兆光纤感觉还是网速不达标，那么你可能遇到假网线了。<br>其实网线也是分类的，网线分为五类线、超五类线、六类线、七类线，可以通过网线外皮的Cat.5, Cat.5e,Cat.6等来判断,其中cat.6中间有十字的骨架把网线分开<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-21fa54d3e840c9a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"70c2802e87d8e3a8224e0e928e0951b7_r.jpg\"></p>\n<p>如果家里是百兆光纤一般用超五类或者六类，当然六类最好，因为抗干扰更强。</p>\n<h4 id=\"2-无线设备\"><a href=\"#2-无线设备\" class=\"headerlink\" title=\"2.无线设备\"></a>2.无线设备</h4><p>暂时没啥想说的了，想起了再更。见谅~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一篇主要写了几点制约网速的可能原因，没有看过上一篇的请移步<a href=\"http://www.jianshu.com/p/f1018427d0eb\">关于家庭网络宽带、路由及上网设备那些事</a>。这一篇就分别介绍下宽带、路由和用网设备的一些知识。</p>\n<h3 id=\"家庭宽带的那些事\"><a href=\"#家庭宽带的那些事\" class=\"headerlink\" title=\"家庭宽带的那些事\"></a>家庭宽带的那些事</h3><p>网络出了问题都会打客服咨询，但是你知道你家的网络服务商是几级的吗？</p>\n<p>####1.宽带运营商分级</p>\n<p>目前宽带运营商一般分为三级即可，三级··立马就邪恶了。<br>一级服运营商是国家、省市、城域骨干网的建设者。主要有联通、电信、移动和广电，以前小的时候就有种说法叫南电信北联通。</p>\n<p>电信在一级运营商里算是老前辈了。之所以就叫北联通是因为北方以前上网是通过电话线来拨号的，座机的电话那时候归属网通，后来联通收购了网通。移动以前只有无限上网的业务，宽带业务应该是合并了铁通后才有的，广电应该近些年发展起来的，据说广电是租用电信和自建都有的。<br>二级运营商是租用了一级运营商的网络设备来发展的。如果一级运营商是厂家的话，二级运营商就相当于批发商了。主要有歌华宽带、长城宽带等。二级运营商的优势就是性价比较高和比较优质的售后。<br>三级运营商是写字楼和办公楼这类，背靠房地产开发商和物业提供商发展的。比如有些写字楼只提供某一种宽带，网络 差但又不允许公司拉其他服务商的宽带，着实可恨。</p>\n<p>看到这里相信大家对自家的网络提供商有了个大概了解，如果感兴趣请继续：</p>\n<h3 id=\"路由器的那些事\"><a href=\"#路由器的那些事\" class=\"headerlink\" title=\"路由器的那些事\"></a>路由器的那些事</h3><p>先上一张图放松下，你们觉得这张图说明了什么问题？<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6efbb8ea799a2ea4.JPEG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"148318216333359786_620_1000.JPEG\"><br>跟风！！中国人跟风习气太严重，一旦发现别人尝到了点甜头，马上就会有一大波人挤破头的往里钻。</p>\n<h4 id=\"1-互联网路由器兴起\"><a href=\"#1-互联网路由器兴起\" class=\"headerlink\" title=\"1.互联网路由器兴起\"></a>1.互联网路由器兴起</h4><p>也是由于跟风，前两年物联网炒的热闹，家中万物互联，有人分析路由器是物联设备走向网络的首个大门，所以就纷纷研发所谓智能路由器。某米、某为、某极和某数字加入战斗，互联网行业经常是老大和老二掐架，老三莫名的死了。这次乱战虽然没有谁阵亡，但是其实用户还是受益的。最起码手机app管理路由器算是普及了不少，查看联网设备和拉黑蹭网设备也方便不少。</p>\n<h4 id=\"2-智能路由器\"><a href=\"#2-智能路由器\" class=\"headerlink\" title=\"2.智能路由器\"></a>2.智能路由器</h4><p>个人觉得现在所谓的智能路由器其实就是互联网路由器后续发展的产物，而且其实在当不起“智能”二字，可能也是如此，所以目前对于智能路由器的定义也就是拥有独立的系统，可以扩展应用插件来实现不同的功能。<br>目前区别路由器是否智能，比较直观的应该是看官方对该型号路由器是否有一个app来支持其手机端操作。</p>\n<h4 id=\"3-双频路由器\"><a href=\"#3-双频路由器\" class=\"headerlink\" title=\"3. 双频路由器\"></a>3. 双频路由器</h4><p>上一篇中简单介绍了双频路由器的优点，这里在详细说下：<br>以前的无线路由器中只有一个频段就是2.4G，双频路由器中多了一个5G频段。两个频段是由802.11 工作组划分，每个频段又划分为若干信道<br>2.4 GHz (802.11b/g/n)信道图如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-fb028f78b96bfa77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"be261390397543.png\"></p>\n<p>有人可能会说中国有13个信道可用，可以的啦。其实每个信道的频宽有22MHz，所以这13个信道有很多重叠的区域，不信你看</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-e74729391935e100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"880px-2.4_GHz_Wi-Fi_channels_(802.11b,g_WLAN).svg.png\"></p>\n<p>这样一看刨去重叠的的那些，只有1、6和11三个信道可以互不影响。<br>下面我们再看看5G:<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-d39dbb91334a0469.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2e2eb9389b504fc21a213501e3dde71190ef6dbc.jpg\"></p>\n<p>发现中国地5G有5个信道可以使用，看起来也没有比2.4G的好到哪里，为什么传输速率会快呢?<br>看下图5G信道间距有20MHz相比2.4G的5MHz大很多，如果使用一个信道时，不会受到其他信道的干扰，如果想提升速率，可以把多个信道合并为40MHz或者80MHz。相比之下速度就提升很多了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-0b2998b024656dfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"223707rvzdtllllcvkcv7w.png\"></p>\n<p><em>所以综合得出结论：<br>2.4G 信道虽然多，但是互不影响的只有三个，加上使用设备多，干扰大，所以传输速率2.4G低于5G<br>但是由于 5G频率高，波长短，所以穿透性2.4G大于5G。<br>举个例子理解下穿透性强弱：假如靠近路由器时都是100%信号，但是穿过一堵墙时，2.4G可能还有80%信号，而5G可能仅剩50%信号，就是说两个频段都能穿墙，但是5G穿墙过程自身损失的更严重，所以常说穿透性弱。</em></p>\n<h4 id=\"4-什么样的路由器才是好路由器？\"><a href=\"#4-什么样的路由器才是好路由器？\" class=\"headerlink\" title=\"4.\b什么样的路由器才是好路由器？\"></a>4.\b什么样的路由器才是好路由器？</h4><p>在我看来好的路由器首要因素就是是否稳定。上面说了穿墙后的信号会减弱。日常路由器放客厅，但是我们又不可能随时守在客厅，可能在卧室、可能在厕所、也可能在院子，远距离加穿墙后，信号可能只有一格了，很多路由器这时候网络是很差的，经常QQ和微信就可能提示网络无法连接，但是现在明明还有一格信号啊。这就是我所说的稳定。一个性能稳定的路由器就算信号只有微弱的一格，仍然能保持网络的流畅，这是我认为的好路由器。就这一点恰恰是很多市面路由都不具备的。<br>其他就是参考路由器的性能指标了，如cpu、内存、flash等越大越好，但能耗能也愈大，发热也严重。一般来说家庭百兆宽带最好配上千兆路由，这里的千兆是wlan和lan口也要是千兆的。</p>\n<h3 id=\"用网设备那些事\"><a href=\"#用网设备那些事\" class=\"headerlink\" title=\"用网设备那些事\"></a>用网设备那些事</h3><h4 id=\"1-用有线网\"><a href=\"#1-用有线网\" class=\"headerlink\" title=\"1.用有线网\"></a>1.用有线网</h4><p>这里只想说一点如果你刚配的主机加上百兆光纤感觉还是网速不达标，那么你可能遇到假网线了。<br>其实网线也是分类的，网线分为五类线、超五类线、六类线、七类线，可以通过网线外皮的Cat.5, Cat.5e,Cat.6等来判断,其中cat.6中间有十字的骨架把网线分开<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-21fa54d3e840c9a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"70c2802e87d8e3a8224e0e928e0951b7_r.jpg\"></p>\n<p>如果家里是百兆光纤一般用超五类或者六类，当然六类最好，因为抗干扰更强。</p>\n<h4 id=\"2-无线设备\"><a href=\"#2-无线设备\" class=\"headerlink\" title=\"2.无线设备\"></a>2.无线设备</h4><p>暂时没啥想说的了，想起了再更。见谅~</p>\n"},{"title":"关于Intent那些事","date":"2017-07-17T07:51:08.000Z","_content":"\n# 0x00 前言\n\nIntent，译为“意图”。从汉语角度理解，意图是什么意思？意图谋反，就是想要谋反。所以意图可以通俗理解为想要做什么。当然这里的“想要做什么”是告诉Android系统的而不是别人。\n\n虽然想要做什么就告诉Android系统，但是并不是为所欲为的。通过Intent只能请求三大组件：Activity，Service，Broadcast。\n\n# 0x01 抽象理解\n\n因为涉及三个组件，这里不会单独讲每个组件和Intent。startActivity不要叫启动Activity，startService也不要叫启动服务，我们把他们抽象为一个请求。通过Intent向Android发出请求，Android去哪给你匹配呢？你不注册系统当然没地方找，所以我们要在AndroidManifest.xml中进行注册(广播可以动态注册)。注册的作用不光告诉系统可以从这找我，还告诉系统本组件只接收满足要求的请求。说到要求这就要提到IntentFilter了，每个IntentFilter代表一种要求，一个组件可以有多种要求即多个IntentFilter，但只要满足一种就能请求成功。系统所要做的就是把接收到得请求Intent和组件的要求IntentFilter进行匹配，如果匹配上了则牵手成功~\n\n这个流程抽象为：\n\n![请求流程](关于Intent那些事/请求流程.png)\n\n# 0x02 分类\n\n通过Intent告诉Android系统“我想要做什么”，可以有两种方式阐述，一种是直白的表述“我想要启动某个页面”，我们称之为显性，另一种是告诉系统“我想要一个满足我某些要求的页面”,至于是哪个或哪几个页面由系统决定，如果是多个可以返回列表给我，这种称之为隐性。\n\n>Intent从请求性质上分为显性和隐性两种。\n\n\n\n由于显性Intent指定了具体的请求，如下：\n\n```java\nintent.setClass(Context packageContext, Class<?> cls)\n```\n\n所以匹配并不会发生在显性Intent,显性组件注册时一般这样的：\n\n```xml\n<activity android:name=\".ThirdActivity\" />\n```\n\n没有多余的要求。\n\n在抽象理解中，IntentFilter匹配只是为隐性准备的。\n\n下面要了解具体匹配规则如何：\n\n# 0x03 匹配规则\n\n要了解匹配规则是怎样的，首先要知道是从哪几方面入手匹配的，由于Android系统也是根据组件注册的要求进行匹配，所以看看注册时的IntentFilter有哪些属性就知道要匹配哪些方面了：\n\n```xml\n <intent-filter>\n     <action android:name=\"android.intent.action.CALL\" />\n     <category android:name=\"android.intent.category.DEFAULT\" />\n     <data android:mimeType=\"image/*\"/>\n     <data android:scheme=\"http\"/>\n </intent-filter>\n```\n\n显然系统匹配也就是匹配category、action和data。\n\n下面分别来看看这三种是分别如何匹配的：\n\n**注意：下面将原理、源码、实例三管齐下** \n\n- category如何匹配\n\n  > 匹配原理：\n  >\n  > ①在请求的Intent中需要在IntentFilter找到匹配项才算匹配成功。\n  >\n  > ②如果Intent没有添加任何category，那么系统会自动给你添加android.intent.category.DEFAULT，所以如果你的三大组件是为隐性启动准备的，那么你就要在注册时手动添加<category android:name=\"android.intent.category.DEFAULT\" />。\n  >\n  > ③当然如果添加了其他值得category也可以不用添加default了。\n\n  ​\n\n\n\n- action如何匹配\n\n  > 匹配原理：\n  >\n  > ①IntentFilter如果没有声明action，则所有Intent都不能匹配成功。\n  >\n  > ②若IntentFilter声明了action，而Intent没有不带任何action，则匹配通过。\n  >\n  > ③若IntentFilter声明了action，Intent也声明了action，那么Intent中action必须是IntentFilter中action的子集才能匹配成功。\n\n\n\n- data如何匹配\n\n  data分为两部分，MIME type和URI。\n\n  - MIME type就是表明数据格式类型，方便系统正确解析处理\n\n    MIME type又分为两部分：主类型type和子类型subtype，以\"/\"分割。比如：\n\n    video/mp4，image/jpeg。\n\n  - URI 唯一资源标识符\n\n    URI分为scheme、Authory和path三部分。\n\n    scheme表示采用协议，既可以是http网络协议也可以是本地content和file协议。\n\n    Authority由host和port组成。\n\n    path表示文件在host中具体位置。\n\n  了解了data组成，下面说说data匹配原理\n\n  > 匹配原理：\n  >\n  > ①data只匹配IntentFilter中所拥有部分。\n  >\n  > ②如果Intent中既没有MIME，也没用URI，那么IntentFilter中也都不能有才能通过。\n  >\n  > ③若Intent没有指定类型，只指定了URI，那么IntentFilter必须没有指定类型。特殊情况下能根据URI推断出类型，这种情况按⑤情况算。\n  >\n  > ④若Intent只指定了类型，没有URI。那么IntentFilter也必须没有指定URI\n  >\n  > ⑤若Intent同时指定了类型和URI，那么必须都匹配上才能通过。","source":"_posts/关于Intent那些事.md","raw":"---\ntitle: 关于Intent那些事\ndate: 2017-07-17 15:51:08\ntags: Android\ncategories: Android\n---\n\n# 0x00 前言\n\nIntent，译为“意图”。从汉语角度理解，意图是什么意思？意图谋反，就是想要谋反。所以意图可以通俗理解为想要做什么。当然这里的“想要做什么”是告诉Android系统的而不是别人。\n\n虽然想要做什么就告诉Android系统，但是并不是为所欲为的。通过Intent只能请求三大组件：Activity，Service，Broadcast。\n\n# 0x01 抽象理解\n\n因为涉及三个组件，这里不会单独讲每个组件和Intent。startActivity不要叫启动Activity，startService也不要叫启动服务，我们把他们抽象为一个请求。通过Intent向Android发出请求，Android去哪给你匹配呢？你不注册系统当然没地方找，所以我们要在AndroidManifest.xml中进行注册(广播可以动态注册)。注册的作用不光告诉系统可以从这找我，还告诉系统本组件只接收满足要求的请求。说到要求这就要提到IntentFilter了，每个IntentFilter代表一种要求，一个组件可以有多种要求即多个IntentFilter，但只要满足一种就能请求成功。系统所要做的就是把接收到得请求Intent和组件的要求IntentFilter进行匹配，如果匹配上了则牵手成功~\n\n这个流程抽象为：\n\n![请求流程](关于Intent那些事/请求流程.png)\n\n# 0x02 分类\n\n通过Intent告诉Android系统“我想要做什么”，可以有两种方式阐述，一种是直白的表述“我想要启动某个页面”，我们称之为显性，另一种是告诉系统“我想要一个满足我某些要求的页面”,至于是哪个或哪几个页面由系统决定，如果是多个可以返回列表给我，这种称之为隐性。\n\n>Intent从请求性质上分为显性和隐性两种。\n\n\n\n由于显性Intent指定了具体的请求，如下：\n\n```java\nintent.setClass(Context packageContext, Class<?> cls)\n```\n\n所以匹配并不会发生在显性Intent,显性组件注册时一般这样的：\n\n```xml\n<activity android:name=\".ThirdActivity\" />\n```\n\n没有多余的要求。\n\n在抽象理解中，IntentFilter匹配只是为隐性准备的。\n\n下面要了解具体匹配规则如何：\n\n# 0x03 匹配规则\n\n要了解匹配规则是怎样的，首先要知道是从哪几方面入手匹配的，由于Android系统也是根据组件注册的要求进行匹配，所以看看注册时的IntentFilter有哪些属性就知道要匹配哪些方面了：\n\n```xml\n <intent-filter>\n     <action android:name=\"android.intent.action.CALL\" />\n     <category android:name=\"android.intent.category.DEFAULT\" />\n     <data android:mimeType=\"image/*\"/>\n     <data android:scheme=\"http\"/>\n </intent-filter>\n```\n\n显然系统匹配也就是匹配category、action和data。\n\n下面分别来看看这三种是分别如何匹配的：\n\n**注意：下面将原理、源码、实例三管齐下** \n\n- category如何匹配\n\n  > 匹配原理：\n  >\n  > ①在请求的Intent中需要在IntentFilter找到匹配项才算匹配成功。\n  >\n  > ②如果Intent没有添加任何category，那么系统会自动给你添加android.intent.category.DEFAULT，所以如果你的三大组件是为隐性启动准备的，那么你就要在注册时手动添加<category android:name=\"android.intent.category.DEFAULT\" />。\n  >\n  > ③当然如果添加了其他值得category也可以不用添加default了。\n\n  ​\n\n\n\n- action如何匹配\n\n  > 匹配原理：\n  >\n  > ①IntentFilter如果没有声明action，则所有Intent都不能匹配成功。\n  >\n  > ②若IntentFilter声明了action，而Intent没有不带任何action，则匹配通过。\n  >\n  > ③若IntentFilter声明了action，Intent也声明了action，那么Intent中action必须是IntentFilter中action的子集才能匹配成功。\n\n\n\n- data如何匹配\n\n  data分为两部分，MIME type和URI。\n\n  - MIME type就是表明数据格式类型，方便系统正确解析处理\n\n    MIME type又分为两部分：主类型type和子类型subtype，以\"/\"分割。比如：\n\n    video/mp4，image/jpeg。\n\n  - URI 唯一资源标识符\n\n    URI分为scheme、Authory和path三部分。\n\n    scheme表示采用协议，既可以是http网络协议也可以是本地content和file协议。\n\n    Authority由host和port组成。\n\n    path表示文件在host中具体位置。\n\n  了解了data组成，下面说说data匹配原理\n\n  > 匹配原理：\n  >\n  > ①data只匹配IntentFilter中所拥有部分。\n  >\n  > ②如果Intent中既没有MIME，也没用URI，那么IntentFilter中也都不能有才能通过。\n  >\n  > ③若Intent没有指定类型，只指定了URI，那么IntentFilter必须没有指定类型。特殊情况下能根据URI推断出类型，这种情况按⑤情况算。\n  >\n  > ④若Intent只指定了类型，没有URI。那么IntentFilter也必须没有指定URI\n  >\n  > ⑤若Intent同时指定了类型和URI，那么必须都匹配上才能通过。","slug":"关于Intent那些事","published":1,"updated":"2017-07-19T05:28:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjia006cwh9cdttfdwjf","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Intent，译为“意图”。从汉语角度理解，意图是什么意思？意图谋反，就是想要谋反。所以意图可以通俗理解为想要做什么。当然这里的“想要做什么”是告诉Android系统的而不是别人。</p>\n<p>虽然想要做什么就告诉Android系统，但是并不是为所欲为的。通过Intent只能请求三大组件：Activity，Service，Broadcast。</p>\n<h1 id=\"0x01-抽象理解\"><a href=\"#0x01-抽象理解\" class=\"headerlink\" title=\"0x01 抽象理解\"></a>0x01 抽象理解</h1><p>因为涉及三个组件，这里不会单独讲每个组件和Intent。startActivity不要叫启动Activity，startService也不要叫启动服务，我们把他们抽象为一个请求。通过Intent向Android发出请求，Android去哪给你匹配呢？你不注册系统当然没地方找，所以我们要在AndroidManifest.xml中进行注册(广播可以动态注册)。注册的作用不光告诉系统可以从这找我，还告诉系统本组件只接收满足要求的请求。说到要求这就要提到IntentFilter了，每个IntentFilter代表一种要求，一个组件可以有多种要求即多个IntentFilter，但只要满足一种就能请求成功。系统所要做的就是把接收到得请求Intent和组件的要求IntentFilter进行匹配，如果匹配上了则牵手成功~</p>\n<p>这个流程抽象为：</p>\n<p><img src=\"/2017/07/17/关于Intent那些事/请求流程.png\" alt=\"请求流程\"></p>\n<h1 id=\"0x02-分类\"><a href=\"#0x02-分类\" class=\"headerlink\" title=\"0x02 分类\"></a>0x02 分类</h1><p>通过Intent告诉Android系统“我想要做什么”，可以有两种方式阐述，一种是直白的表述“我想要启动某个页面”，我们称之为显性，另一种是告诉系统“我想要一个满足我某些要求的页面”,至于是哪个或哪几个页面由系统决定，如果是多个可以返回列表给我，这种称之为隐性。</p>\n<blockquote>\n<p>Intent从请求性质上分为显性和隐性两种。</p>\n</blockquote>\n<p>由于显性Intent指定了具体的请求，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.setClass(Context packageContext, Class&lt;?&gt; cls)</div></pre></td></tr></table></figure>\n<p>所以匹配并不会发生在显性Intent,显性组件注册时一般这样的：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".ThirdActivity\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p>没有多余的要求。</p>\n<p>在抽象理解中，IntentFilter匹配只是为隐性准备的。</p>\n<p>下面要了解具体匹配规则如何：</p>\n<h1 id=\"0x03-匹配规则\"><a href=\"#0x03-匹配规则\" class=\"headerlink\" title=\"0x03 匹配规则\"></a>0x03 匹配规则</h1><p>要了解匹配规则是怎样的，首先要知道是从哪几方面入手匹配的，由于Android系统也是根据组件注册的要求进行匹配，所以看看注册时的IntentFilter有哪些属性就知道要匹配哪些方面了：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.CALL\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"image/*\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:scheme</span>=<span class=\"string\">\"http\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>显然系统匹配也就是匹配category、action和data。</p>\n<p>下面分别来看看这三种是分别如何匹配的：</p>\n<p><strong>注意：下面将原理、源码、实例三管齐下</strong> </p>\n<ul>\n<li><p>category如何匹配</p>\n<blockquote>\n<p>匹配原理：</p>\n<p>①在请求的Intent中需要在IntentFilter找到匹配项才算匹配成功。</p>\n<p>②如果Intent没有添加任何category，那么系统会自动给你添加android.intent.category.DEFAULT，所以如果你的三大组件是为隐性启动准备的，那么你就要在注册时手动添加<category android:name=\"android.intent.category.DEFAULT\">。</category></p>\n<p>③当然如果添加了其他值得category也可以不用添加default了。</p>\n</blockquote>\n<p>​</p>\n</li>\n</ul>\n<ul>\n<li><p>action如何匹配</p>\n<blockquote>\n<p>匹配原理：</p>\n<p>①IntentFilter如果没有声明action，则所有Intent都不能匹配成功。</p>\n<p>②若IntentFilter声明了action，而Intent没有不带任何action，则匹配通过。</p>\n<p>③若IntentFilter声明了action，Intent也声明了action，那么Intent中action必须是IntentFilter中action的子集才能匹配成功。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>data如何匹配</p>\n<p>data分为两部分，MIME type和URI。</p>\n<ul>\n<li><p>MIME type就是表明数据格式类型，方便系统正确解析处理</p>\n<p>MIME type又分为两部分：主类型type和子类型subtype，以”/“分割。比如：</p>\n<p>video/mp4，image/jpeg。</p>\n</li>\n<li><p>URI 唯一资源标识符</p>\n<p>URI分为scheme、Authory和path三部分。</p>\n<p>scheme表示采用协议，既可以是http网络协议也可以是本地content和file协议。</p>\n<p>Authority由host和port组成。</p>\n<p>path表示文件在host中具体位置。</p>\n</li>\n</ul>\n<p>了解了data组成，下面说说data匹配原理</p>\n<blockquote>\n<p>匹配原理：</p>\n<p>①data只匹配IntentFilter中所拥有部分。</p>\n<p>②如果Intent中既没有MIME，也没用URI，那么IntentFilter中也都不能有才能通过。</p>\n<p>③若Intent没有指定类型，只指定了URI，那么IntentFilter必须没有指定类型。特殊情况下能根据URI推断出类型，这种情况按⑤情况算。</p>\n<p>④若Intent只指定了类型，没有URI。那么IntentFilter也必须没有指定URI</p>\n<p>⑤若Intent同时指定了类型和URI，那么必须都匹配上才能通过。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>Intent，译为“意图”。从汉语角度理解，意图是什么意思？意图谋反，就是想要谋反。所以意图可以通俗理解为想要做什么。当然这里的“想要做什么”是告诉Android系统的而不是别人。</p>\n<p>虽然想要做什么就告诉Android系统，但是并不是为所欲为的。通过Intent只能请求三大组件：Activity，Service，Broadcast。</p>\n<h1 id=\"0x01-抽象理解\"><a href=\"#0x01-抽象理解\" class=\"headerlink\" title=\"0x01 抽象理解\"></a>0x01 抽象理解</h1><p>因为涉及三个组件，这里不会单独讲每个组件和Intent。startActivity不要叫启动Activity，startService也不要叫启动服务，我们把他们抽象为一个请求。通过Intent向Android发出请求，Android去哪给你匹配呢？你不注册系统当然没地方找，所以我们要在AndroidManifest.xml中进行注册(广播可以动态注册)。注册的作用不光告诉系统可以从这找我，还告诉系统本组件只接收满足要求的请求。说到要求这就要提到IntentFilter了，每个IntentFilter代表一种要求，一个组件可以有多种要求即多个IntentFilter，但只要满足一种就能请求成功。系统所要做的就是把接收到得请求Intent和组件的要求IntentFilter进行匹配，如果匹配上了则牵手成功~</p>\n<p>这个流程抽象为：</p>\n<p><img src=\"/2017/07/17/关于Intent那些事/请求流程.png\" alt=\"请求流程\"></p>\n<h1 id=\"0x02-分类\"><a href=\"#0x02-分类\" class=\"headerlink\" title=\"0x02 分类\"></a>0x02 分类</h1><p>通过Intent告诉Android系统“我想要做什么”，可以有两种方式阐述，一种是直白的表述“我想要启动某个页面”，我们称之为显性，另一种是告诉系统“我想要一个满足我某些要求的页面”,至于是哪个或哪几个页面由系统决定，如果是多个可以返回列表给我，这种称之为隐性。</p>\n<blockquote>\n<p>Intent从请求性质上分为显性和隐性两种。</p>\n</blockquote>\n<p>由于显性Intent指定了具体的请求，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">intent.setClass(Context packageContext, Class&lt;?&gt; cls)</div></pre></td></tr></table></figure>\n<p>所以匹配并不会发生在显性Intent,显性组件注册时一般这样的：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\".ThirdActivity\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p>没有多余的要求。</p>\n<p>在抽象理解中，IntentFilter匹配只是为隐性准备的。</p>\n<p>下面要了解具体匹配规则如何：</p>\n<h1 id=\"0x03-匹配规则\"><a href=\"#0x03-匹配规则\" class=\"headerlink\" title=\"0x03 匹配规则\"></a>0x03 匹配规则</h1><p>要了解匹配规则是怎样的，首先要知道是从哪几方面入手匹配的，由于Android系统也是根据组件注册的要求进行匹配，所以看看注册时的IntentFilter有哪些属性就知道要匹配哪些方面了：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.action.CALL\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.intent.category.DEFAULT\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:mimeType</span>=<span class=\"string\">\"image/*\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:scheme</span>=<span class=\"string\">\"http\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>显然系统匹配也就是匹配category、action和data。</p>\n<p>下面分别来看看这三种是分别如何匹配的：</p>\n<p><strong>注意：下面将原理、源码、实例三管齐下</strong> </p>\n<ul>\n<li><p>category如何匹配</p>\n<blockquote>\n<p>匹配原理：</p>\n<p>①在请求的Intent中需要在IntentFilter找到匹配项才算匹配成功。</p>\n<p>②如果Intent没有添加任何category，那么系统会自动给你添加android.intent.category.DEFAULT，所以如果你的三大组件是为隐性启动准备的，那么你就要在注册时手动添加<category android:name=\"android.intent.category.DEFAULT\">。</category></p>\n<p>③当然如果添加了其他值得category也可以不用添加default了。</p>\n</blockquote>\n<p>​</p>\n</li>\n</ul>\n<ul>\n<li><p>action如何匹配</p>\n<blockquote>\n<p>匹配原理：</p>\n<p>①IntentFilter如果没有声明action，则所有Intent都不能匹配成功。</p>\n<p>②若IntentFilter声明了action，而Intent没有不带任何action，则匹配通过。</p>\n<p>③若IntentFilter声明了action，Intent也声明了action，那么Intent中action必须是IntentFilter中action的子集才能匹配成功。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>data如何匹配</p>\n<p>data分为两部分，MIME type和URI。</p>\n<ul>\n<li><p>MIME type就是表明数据格式类型，方便系统正确解析处理</p>\n<p>MIME type又分为两部分：主类型type和子类型subtype，以”/“分割。比如：</p>\n<p>video/mp4，image/jpeg。</p>\n</li>\n<li><p>URI 唯一资源标识符</p>\n<p>URI分为scheme、Authory和path三部分。</p>\n<p>scheme表示采用协议，既可以是http网络协议也可以是本地content和file协议。</p>\n<p>Authority由host和port组成。</p>\n<p>path表示文件在host中具体位置。</p>\n</li>\n</ul>\n<p>了解了data组成，下面说说data匹配原理</p>\n<blockquote>\n<p>匹配原理：</p>\n<p>①data只匹配IntentFilter中所拥有部分。</p>\n<p>②如果Intent中既没有MIME，也没用URI，那么IntentFilter中也都不能有才能通过。</p>\n<p>③若Intent没有指定类型，只指定了URI，那么IntentFilter必须没有指定类型。特殊情况下能根据URI推断出类型，这种情况按⑤情况算。</p>\n<p>④若Intent只指定了类型，没有URI。那么IntentFilter也必须没有指定URI</p>\n<p>⑤若Intent同时指定了类型和URI，那么必须都匹配上才能通过。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"关于家庭网络宽带、路由及上网设备那些事","date":"2017-04-21T14:40:50.000Z","_content":"\n看不见摸不着，但又对我们很重要的东西，你们觉得是什么？很多人一定会说是空气，但是肯定还有一部分心里会认为是WIFI~。\n  以前经常感慨每次回家最先欢迎我的不是别人，正是WIFI(~信号强没办法，一进小区就连接上了)。的确随着宽带的普及，我们的生活也愈来愈离不开网络，不管看电影玩游戏还是查资料。那你到底对它连接多少呢？\n\n1.你知道网络运营商所说的20M、50M和100M到底是什么意思吗?\n2.你知道运营商提供的50M和迅雷下载的速度2MB/s有什么区别联系吗？\n3.你知道为什么升级了宽带，然而下载速度为什么没有提升吗？\n如果都不清楚，那这篇文章就是为你准备的，请继续。\n\n我们先来看下日常家庭网络图：\n![P70214-123417.jpg](http://upload-images.jianshu.io/upload_images/1796052-375a9d5345b944e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n一般都是运营商把网线拉到家中，然后插到路由器上，然后通过无线路由功能为多台设备提供上网功能。\n如果是光纤用户会，则应该是网线接入光猫，再把光猫接入到路由器。\n看懂了这张图，下面的要讲的内容就很容易理解了。\n### 运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\n其实不管是运营商还是路由器厂家标称的xxM其实是Mbps的简称，而Mbps是Million bits per second的缩写，意思就是声称的20M是20兆位/秒。迅雷的下载速度5MB/s又是什么意思？这里的MB是指兆字节/秒\n要找出带宽和下载的关系要知道一个公式```1字节=8比特位  即1Byte=8bit。```所以声称的20M带宽实际下载速度为20/8=2.5MB/s，当然这是理论上的最大下载速度，线路的传输是有损耗的，所以一般下载速度会小于该理论值。\n### 为什么升级了宽带，网速还是没有什么明显提升？\n上面知道了带宽和下载速度的关系，那么路由器带宽和其支持的最大传输速度关系也就明白了吧。\n哪些号称150M的路由器最大支持传输速率为150/8 =18.75MB/s ，加上路由器厂商的偷工减料，所以一般速率又严重小于18.75这个值(如果你的路由器能达到这个值，那一定是遇到良心厂家了)。假设光纤用户使用100兆时最大下载速度本可以达到12.5MB/s的，然而由于路由器偷工减料仅能达到18.75的一半即9MB/s时，这时你的家庭网络最大速度就只能被路由器所限制。\n### 升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧~\n先来个问题：马路上能一次同时过5个人，家门口小路一次只能同时走3个人，但是我家大门一次只能同时1人过。那人员流动速率瓶颈在哪就很明显了吧，同样的，宽带、路由器都是网络的媒介，真正使用网络的是我们的手机电脑和平板。假设你的宽带和路由器的最大传输速率都达到了12.5MB/s，但是你的笔记本电脑的网卡还是54Mbps的老网卡o(╯□╰)o，结果可想而知了。\n### 笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\n县城的马路和北京的马路差不多宽，为什么北京每天堵车而县城基本不会？因为车少哇。同样的，目前大多数路由器的无线提供的都是2.4G无线，而电磁炉、无线键鼠等也有很多使用2.4G无线。在这个频段的设备多了也就难免发生堵塞。为了缓解堵塞，无线双频路由器也就诞生了，所谓双频就是2.4G和5G。5G频段使用设备少所以数据传输也就更稳定。5G高效的还有一个原因是无干扰信道数量比2.4G的更多。对于游戏玩家和高清影视爱好者，一台双频路由是必须的。但是还有一点要注意：使用5G频段需要路由器和网卡都支持802.11ac才可以。\n\n上面说了这么多都是讲出你的网络中制约网速的瓶颈，至于具体的解决方法不用说了大家也心里有数了吧。","source":"_posts/关于家庭网络宽带、路由及上网设备那些事.md","raw":"---\ntitle: 关于家庭网络宽带、路由及上网设备那些事\ndate: 2017-04-21 22:40:50\ntags: 网络\ncategories: 网络\n---\n\n看不见摸不着，但又对我们很重要的东西，你们觉得是什么？很多人一定会说是空气，但是肯定还有一部分心里会认为是WIFI~。\n  以前经常感慨每次回家最先欢迎我的不是别人，正是WIFI(~信号强没办法，一进小区就连接上了)。的确随着宽带的普及，我们的生活也愈来愈离不开网络，不管看电影玩游戏还是查资料。那你到底对它连接多少呢？\n\n1.你知道网络运营商所说的20M、50M和100M到底是什么意思吗?\n2.你知道运营商提供的50M和迅雷下载的速度2MB/s有什么区别联系吗？\n3.你知道为什么升级了宽带，然而下载速度为什么没有提升吗？\n如果都不清楚，那这篇文章就是为你准备的，请继续。\n\n我们先来看下日常家庭网络图：\n![P70214-123417.jpg](http://upload-images.jianshu.io/upload_images/1796052-375a9d5345b944e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n一般都是运营商把网线拉到家中，然后插到路由器上，然后通过无线路由功能为多台设备提供上网功能。\n如果是光纤用户会，则应该是网线接入光猫，再把光猫接入到路由器。\n看懂了这张图，下面的要讲的内容就很容易理解了。\n### 运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\n其实不管是运营商还是路由器厂家标称的xxM其实是Mbps的简称，而Mbps是Million bits per second的缩写，意思就是声称的20M是20兆位/秒。迅雷的下载速度5MB/s又是什么意思？这里的MB是指兆字节/秒\n要找出带宽和下载的关系要知道一个公式```1字节=8比特位  即1Byte=8bit。```所以声称的20M带宽实际下载速度为20/8=2.5MB/s，当然这是理论上的最大下载速度，线路的传输是有损耗的，所以一般下载速度会小于该理论值。\n### 为什么升级了宽带，网速还是没有什么明显提升？\n上面知道了带宽和下载速度的关系，那么路由器带宽和其支持的最大传输速度关系也就明白了吧。\n哪些号称150M的路由器最大支持传输速率为150/8 =18.75MB/s ，加上路由器厂商的偷工减料，所以一般速率又严重小于18.75这个值(如果你的路由器能达到这个值，那一定是遇到良心厂家了)。假设光纤用户使用100兆时最大下载速度本可以达到12.5MB/s的，然而由于路由器偷工减料仅能达到18.75的一半即9MB/s时，这时你的家庭网络最大速度就只能被路由器所限制。\n### 升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧~\n先来个问题：马路上能一次同时过5个人，家门口小路一次只能同时走3个人，但是我家大门一次只能同时1人过。那人员流动速率瓶颈在哪就很明显了吧，同样的，宽带、路由器都是网络的媒介，真正使用网络的是我们的手机电脑和平板。假设你的宽带和路由器的最大传输速率都达到了12.5MB/s，但是你的笔记本电脑的网卡还是54Mbps的老网卡o(╯□╰)o，结果可想而知了。\n### 笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\n县城的马路和北京的马路差不多宽，为什么北京每天堵车而县城基本不会？因为车少哇。同样的，目前大多数路由器的无线提供的都是2.4G无线，而电磁炉、无线键鼠等也有很多使用2.4G无线。在这个频段的设备多了也就难免发生堵塞。为了缓解堵塞，无线双频路由器也就诞生了，所谓双频就是2.4G和5G。5G频段使用设备少所以数据传输也就更稳定。5G高效的还有一个原因是无干扰信道数量比2.4G的更多。对于游戏玩家和高清影视爱好者，一台双频路由是必须的。但是还有一点要注意：使用5G频段需要路由器和网卡都支持802.11ac才可以。\n\n上面说了这么多都是讲出你的网络中制约网速的瓶颈，至于具体的解决方法不用说了大家也心里有数了吧。","slug":"关于家庭网络宽带、路由及上网设备那些事","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjid006fwh9cypyxle1j","content":"<p>看不见摸不着，但又对我们很重要的东西，你们觉得是什么？很多人一定会说是空气，但是肯定还有一部分心里会认为是WIFI~。<br>  以前经常感慨每次回家最先欢迎我的不是别人，正是WIFI(~信号强没办法，一进小区就连接上了)。的确随着宽带的普及，我们的生活也愈来愈离不开网络，不管看电影玩游戏还是查资料。那你到底对它连接多少呢？</p>\n<p>1.你知道网络运营商所说的20M、50M和100M到底是什么意思吗?<br>2.你知道运营商提供的50M和迅雷下载的速度2MB/s有什么区别联系吗？<br>3.你知道为什么升级了宽带，然而下载速度为什么没有提升吗？<br>如果都不清楚，那这篇文章就是为你准备的，请继续。</p>\n<p>我们先来看下日常家庭网络图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-375a9d5345b944e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"P70214-123417.jpg\"></p>\n<p>一般都是运营商把网线拉到家中，然后插到路由器上，然后通过无线路由功能为多台设备提供上网功能。<br>如果是光纤用户会，则应该是网线接入光猫，再把光猫接入到路由器。<br>看懂了这张图，下面的要讲的内容就很容易理解了。</p>\n<h3 id=\"运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\"><a href=\"#运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\" class=\"headerlink\" title=\"运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\"></a>运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？</h3><p>其实不管是运营商还是路由器厂家标称的xxM其实是Mbps的简称，而Mbps是Million bits per second的缩写，意思就是声称的20M是20兆位/秒。迅雷的下载速度5MB/s又是什么意思？这里的MB是指兆字节/秒<br>要找出带宽和下载的关系要知道一个公式<code>1字节=8比特位  即1Byte=8bit。</code>所以声称的20M带宽实际下载速度为20/8=2.5MB/s，当然这是理论上的最大下载速度，线路的传输是有损耗的，所以一般下载速度会小于该理论值。</p>\n<h3 id=\"为什么升级了宽带，网速还是没有什么明显提升？\"><a href=\"#为什么升级了宽带，网速还是没有什么明显提升？\" class=\"headerlink\" title=\"为什么升级了宽带，网速还是没有什么明显提升？\"></a>为什么升级了宽带，网速还是没有什么明显提升？</h3><p>上面知道了带宽和下载速度的关系，那么路由器带宽和其支持的最大传输速度关系也就明白了吧。<br>哪些号称150M的路由器最大支持传输速率为150/8 =18.75MB/s ，加上路由器厂商的偷工减料，所以一般速率又严重小于18.75这个值(如果你的路由器能达到这个值，那一定是遇到良心厂家了)。假设光纤用户使用100兆时最大下载速度本可以达到12.5MB/s的，然而由于路由器偷工减料仅能达到18.75的一半即9MB/s时，这时你的家庭网络最大速度就只能被路由器所限制。</p>\n<h3 id=\"升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧\"><a href=\"#升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧\" class=\"headerlink\" title=\"升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧~\"></a>升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧~</h3><p>先来个问题：马路上能一次同时过5个人，家门口小路一次只能同时走3个人，但是我家大门一次只能同时1人过。那人员流动速率瓶颈在哪就很明显了吧，同样的，宽带、路由器都是网络的媒介，真正使用网络的是我们的手机电脑和平板。假设你的宽带和路由器的最大传输速率都达到了12.5MB/s，但是你的笔记本电脑的网卡还是54Mbps的老网卡o(╯□╰)o，结果可想而知了。</p>\n<h3 id=\"笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\"><a href=\"#笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\" class=\"headerlink\" title=\"笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\"></a>笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？</h3><p>县城的马路和北京的马路差不多宽，为什么北京每天堵车而县城基本不会？因为车少哇。同样的，目前大多数路由器的无线提供的都是2.4G无线，而电磁炉、无线键鼠等也有很多使用2.4G无线。在这个频段的设备多了也就难免发生堵塞。为了缓解堵塞，无线双频路由器也就诞生了，所谓双频就是2.4G和5G。5G频段使用设备少所以数据传输也就更稳定。5G高效的还有一个原因是无干扰信道数量比2.4G的更多。对于游戏玩家和高清影视爱好者，一台双频路由是必须的。但是还有一点要注意：使用5G频段需要路由器和网卡都支持802.11ac才可以。</p>\n<p>上面说了这么多都是讲出你的网络中制约网速的瓶颈，至于具体的解决方法不用说了大家也心里有数了吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>看不见摸不着，但又对我们很重要的东西，你们觉得是什么？很多人一定会说是空气，但是肯定还有一部分心里会认为是WIFI~。<br>  以前经常感慨每次回家最先欢迎我的不是别人，正是WIFI(~信号强没办法，一进小区就连接上了)。的确随着宽带的普及，我们的生活也愈来愈离不开网络，不管看电影玩游戏还是查资料。那你到底对它连接多少呢？</p>\n<p>1.你知道网络运营商所说的20M、50M和100M到底是什么意思吗?<br>2.你知道运营商提供的50M和迅雷下载的速度2MB/s有什么区别联系吗？<br>3.你知道为什么升级了宽带，然而下载速度为什么没有提升吗？<br>如果都不清楚，那这篇文章就是为你准备的，请继续。</p>\n<p>我们先来看下日常家庭网络图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-375a9d5345b944e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"P70214-123417.jpg\"></p>\n<p>一般都是运营商把网线拉到家中，然后插到路由器上，然后通过无线路由功能为多台设备提供上网功能。<br>如果是光纤用户会，则应该是网线接入光猫，再把光猫接入到路由器。<br>看懂了这张图，下面的要讲的内容就很容易理解了。</p>\n<h3 id=\"运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\"><a href=\"#运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\" class=\"headerlink\" title=\"运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？\"></a>运营商提供的20M带宽下载时并没有那么高，到底是怎么回事？这和迅雷下载速度有什么关系？</h3><p>其实不管是运营商还是路由器厂家标称的xxM其实是Mbps的简称，而Mbps是Million bits per second的缩写，意思就是声称的20M是20兆位/秒。迅雷的下载速度5MB/s又是什么意思？这里的MB是指兆字节/秒<br>要找出带宽和下载的关系要知道一个公式<code>1字节=8比特位  即1Byte=8bit。</code>所以声称的20M带宽实际下载速度为20/8=2.5MB/s，当然这是理论上的最大下载速度，线路的传输是有损耗的，所以一般下载速度会小于该理论值。</p>\n<h3 id=\"为什么升级了宽带，网速还是没有什么明显提升？\"><a href=\"#为什么升级了宽带，网速还是没有什么明显提升？\" class=\"headerlink\" title=\"为什么升级了宽带，网速还是没有什么明显提升？\"></a>为什么升级了宽带，网速还是没有什么明显提升？</h3><p>上面知道了带宽和下载速度的关系，那么路由器带宽和其支持的最大传输速度关系也就明白了吧。<br>哪些号称150M的路由器最大支持传输速率为150/8 =18.75MB/s ，加上路由器厂商的偷工减料，所以一般速率又严重小于18.75这个值(如果你的路由器能达到这个值，那一定是遇到良心厂家了)。假设光纤用户使用100兆时最大下载速度本可以达到12.5MB/s的，然而由于路由器偷工减料仅能达到18.75的一半即9MB/s时，这时你的家庭网络最大速度就只能被路由器所限制。</p>\n<h3 id=\"升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧\"><a href=\"#升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧\" class=\"headerlink\" title=\"升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧~\"></a>升级了宽带，新买了路由器这下网速该嗖嗖的了吧？只能说也许吧~</h3><p>先来个问题：马路上能一次同时过5个人，家门口小路一次只能同时走3个人，但是我家大门一次只能同时1人过。那人员流动速率瓶颈在哪就很明显了吧，同样的，宽带、路由器都是网络的媒介，真正使用网络的是我们的手机电脑和平板。假设你的宽带和路由器的最大传输速率都达到了12.5MB/s，但是你的笔记本电脑的网卡还是54Mbps的老网卡o(╯□╰)o，结果可想而知了。</p>\n<h3 id=\"笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\"><a href=\"#笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\" class=\"headerlink\" title=\"笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？\"></a>笔记本无线网卡已经是450M的了，为什么玩游戏延迟还是很高？</h3><p>县城的马路和北京的马路差不多宽，为什么北京每天堵车而县城基本不会？因为车少哇。同样的，目前大多数路由器的无线提供的都是2.4G无线，而电磁炉、无线键鼠等也有很多使用2.4G无线。在这个频段的设备多了也就难免发生堵塞。为了缓解堵塞，无线双频路由器也就诞生了，所谓双频就是2.4G和5G。5G频段使用设备少所以数据传输也就更稳定。5G高效的还有一个原因是无干扰信道数量比2.4G的更多。对于游戏玩家和高清影视爱好者，一台双频路由是必须的。但是还有一点要注意：使用5G频段需要路由器和网卡都支持802.11ac才可以。</p>\n<p>上面说了这么多都是讲出你的网络中制约网速的瓶颈，至于具体的解决方法不用说了大家也心里有数了吧。</p>\n"},{"title":"关于Canvas的一些概念","date":"2017-08-03T06:46:20.000Z","_content":"\n# 前言\n\n在Android开发中不管是图片的绘制还是控件的绘制都少不了**Canvas**的参与。\n\n**Canvas**如此重要，对其多一些了解自然是对开发有益的。\n\n# 获得对象\n\n有两种获得Canvas对象的方法：\n\n- 重写onDraw方法，使用参数中的Canvas\n- 直接创建Canvas对象\n\n# 它有什么用\n\nCanvas一般译为“画布”。而画布一般只是用来承载画像的，显然在Android中叫Canvas为画布，显然狭隘了。因为Android开发中，Canvas不仅提供了动画特效还提供了常见图形绘制方法，比如圆形、矩形、扇形等。\n\n在进行绘制过程中，还需要借助Pain辅助，Paint可以理解为画笔。\n\n\n\n# 绘制图形方法\n\n- 绘制文字\n\n  `drawText(String text, float x, float y, Paint paint)`\n\n  `drawText(char[] text, int index, int count, float x, float y, Paint paint)`\n\n  `drawText(CharSequence text, int start, int end, float x, float y, Paint paint)`\n\n  **float x**：文本开始的x轴位置\n\n  **float y**：文本开始的y轴位置\n\n  **text**：要绘制的文本\n\n  **paint**: 使用的画笔\n\n  **start**：文本开始的位置\n\n  **end**：文本结束的位置\n\n  ​\n\n- 绘制圆形\n\n  `drawCircle(float cx, float cy, float radius, Paint paint)`\n\n  **float cx**：圆心x轴坐标\n\n  **float cy**：圆心y轴坐标\n\n  **float radius**：圆半径\n\n  **paint**：画笔\n\n  ​\n\n- 绘制线条\n\n  `drawLine(float startX, float startY, float stopX, float stopY, Paint paint)`\n\n  **float startX**：起点x坐标\n\n  **float startY**：起点y坐标\n\n  **float stopX**：终点x坐标\n\n  **float stopY**：终点y坐标\n\n  ​\n\n- 绘制椭圆\n\n  `drawOval(float left, float top, float right, float bottom, Paint paint)`\n\n  `drawOval(RectF oval, Paint paint)`\n\n  这里的两个方法可以是一样的，因为绘制一个**RectF**也是需要方法一中的四个点。\n\n  **float left**：左下\n\n  **float top**：左上\n\n  **float right**：右上\n\n  **float bottom**：右下\n\n  ​\n\n- 绘制弧度\n\n  `drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\n\n  ​\n\n  `drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\n\n  **float startAngle**：开始角度\n\n  **float sweepAngle**：扫过角度\n\n  **boolean useCenter**：是否和中心连线 \n\n  ​\n\n- 绘制矩形\n\n  `drawRect(float left, float top, float right, float bottom, Paint paint)`\n\n  `drawRect(Rect r, Paint paint)`\n\n  ​\n\n- 绘制多边形\n\n  多边形绘制需要用到Path，路径类\n\n  用到moveTo，lineTo等常用方法\n\n  `moveTo(float x, float y)`\n\n  `lineTo(float x, float y)`\n\n  ​\n\n- 绘制赛贝尔曲线\n\n  赛贝尔曲线的绘制也用到了Path。\n\n  `quadTo(float x1, float y1, float x2, float y2)`\n\n  ​\n\n- 绘制点\n\n  `drawPoint(float x, float y, Paint paint)`\n\n  `drawPoints(float[] pts, Paint paint)`\n\n  **float x**：点x轴坐标\n\n  **float y**：点y轴坐标\n\n  **float pts**：点数组，每两个值组合一个点，最后如果不够2个点则忽略。\n\n  ​\n\n- 绘制图片\n\n  `drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)`\n\n  ​\n\n  ​\n\n# 动画方法\n\n- 位移\n\n  `translate(float dx, float dy)`\n\n  **float dx**：x轴移动距离\n\n  **float dy**：y轴移动距离\n\n  ​\n\n- 缩放\n\n  `scale(float sx, float sy)`\n\n  `scale(float sx, float sy, float px, float py)`\n\n  **float sx**：x轴放大倍数\n\n  **float sy**：y轴放大倍数\n\n  **float px, float py**：以该点为中心缩放\n\n- 旋转\n\n  `rotate(float degrees)`\n\n  `rotate(float degrees, float px, float py)`\n\n  **float degrees**：旋转角度\n\n  **float px, float py**：以px，py组成的点为中心旋转degrees角度\n\n\n\n# save和restore\n\n- save保存画布\n\n  把save之前的数据保存起来，以便后续的操作在一个新的图层。\n\n- restore合并图层\n\n  把save之前和之后的多个图层进行合并\n\n  ​\n\n  ​\n\n\n\n","source":"_posts/关于Canvas的一些概念.md","raw":"---\ntitle: 关于Canvas的一些概念\ndate: 2017-08-03 14:46:20\ntags: Android\ncategories: Android\n---\n\n# 前言\n\n在Android开发中不管是图片的绘制还是控件的绘制都少不了**Canvas**的参与。\n\n**Canvas**如此重要，对其多一些了解自然是对开发有益的。\n\n# 获得对象\n\n有两种获得Canvas对象的方法：\n\n- 重写onDraw方法，使用参数中的Canvas\n- 直接创建Canvas对象\n\n# 它有什么用\n\nCanvas一般译为“画布”。而画布一般只是用来承载画像的，显然在Android中叫Canvas为画布，显然狭隘了。因为Android开发中，Canvas不仅提供了动画特效还提供了常见图形绘制方法，比如圆形、矩形、扇形等。\n\n在进行绘制过程中，还需要借助Pain辅助，Paint可以理解为画笔。\n\n\n\n# 绘制图形方法\n\n- 绘制文字\n\n  `drawText(String text, float x, float y, Paint paint)`\n\n  `drawText(char[] text, int index, int count, float x, float y, Paint paint)`\n\n  `drawText(CharSequence text, int start, int end, float x, float y, Paint paint)`\n\n  **float x**：文本开始的x轴位置\n\n  **float y**：文本开始的y轴位置\n\n  **text**：要绘制的文本\n\n  **paint**: 使用的画笔\n\n  **start**：文本开始的位置\n\n  **end**：文本结束的位置\n\n  ​\n\n- 绘制圆形\n\n  `drawCircle(float cx, float cy, float radius, Paint paint)`\n\n  **float cx**：圆心x轴坐标\n\n  **float cy**：圆心y轴坐标\n\n  **float radius**：圆半径\n\n  **paint**：画笔\n\n  ​\n\n- 绘制线条\n\n  `drawLine(float startX, float startY, float stopX, float stopY, Paint paint)`\n\n  **float startX**：起点x坐标\n\n  **float startY**：起点y坐标\n\n  **float stopX**：终点x坐标\n\n  **float stopY**：终点y坐标\n\n  ​\n\n- 绘制椭圆\n\n  `drawOval(float left, float top, float right, float bottom, Paint paint)`\n\n  `drawOval(RectF oval, Paint paint)`\n\n  这里的两个方法可以是一样的，因为绘制一个**RectF**也是需要方法一中的四个点。\n\n  **float left**：左下\n\n  **float top**：左上\n\n  **float right**：右上\n\n  **float bottom**：右下\n\n  ​\n\n- 绘制弧度\n\n  `drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\n\n  ​\n\n  `drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\n\n  **float startAngle**：开始角度\n\n  **float sweepAngle**：扫过角度\n\n  **boolean useCenter**：是否和中心连线 \n\n  ​\n\n- 绘制矩形\n\n  `drawRect(float left, float top, float right, float bottom, Paint paint)`\n\n  `drawRect(Rect r, Paint paint)`\n\n  ​\n\n- 绘制多边形\n\n  多边形绘制需要用到Path，路径类\n\n  用到moveTo，lineTo等常用方法\n\n  `moveTo(float x, float y)`\n\n  `lineTo(float x, float y)`\n\n  ​\n\n- 绘制赛贝尔曲线\n\n  赛贝尔曲线的绘制也用到了Path。\n\n  `quadTo(float x1, float y1, float x2, float y2)`\n\n  ​\n\n- 绘制点\n\n  `drawPoint(float x, float y, Paint paint)`\n\n  `drawPoints(float[] pts, Paint paint)`\n\n  **float x**：点x轴坐标\n\n  **float y**：点y轴坐标\n\n  **float pts**：点数组，每两个值组合一个点，最后如果不够2个点则忽略。\n\n  ​\n\n- 绘制图片\n\n  `drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)`\n\n  ​\n\n  ​\n\n# 动画方法\n\n- 位移\n\n  `translate(float dx, float dy)`\n\n  **float dx**：x轴移动距离\n\n  **float dy**：y轴移动距离\n\n  ​\n\n- 缩放\n\n  `scale(float sx, float sy)`\n\n  `scale(float sx, float sy, float px, float py)`\n\n  **float sx**：x轴放大倍数\n\n  **float sy**：y轴放大倍数\n\n  **float px, float py**：以该点为中心缩放\n\n- 旋转\n\n  `rotate(float degrees)`\n\n  `rotate(float degrees, float px, float py)`\n\n  **float degrees**：旋转角度\n\n  **float px, float py**：以px，py组成的点为中心旋转degrees角度\n\n\n\n# save和restore\n\n- save保存画布\n\n  把save之前的数据保存起来，以便后续的操作在一个新的图层。\n\n- restore合并图层\n\n  把save之前和之后的多个图层进行合并\n\n  ​\n\n  ​\n\n\n\n","slug":"关于Canvas的一些概念","published":1,"updated":"2017-08-03T08:29:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjih006jwh9ckdy9b0wh","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在Android开发中不管是图片的绘制还是控件的绘制都少不了<strong>Canvas</strong>的参与。</p>\n<p><strong>Canvas</strong>如此重要，对其多一些了解自然是对开发有益的。</p>\n<h1 id=\"获得对象\"><a href=\"#获得对象\" class=\"headerlink\" title=\"获得对象\"></a>获得对象</h1><p>有两种获得Canvas对象的方法：</p>\n<ul>\n<li>重写onDraw方法，使用参数中的Canvas</li>\n<li>直接创建Canvas对象</li>\n</ul>\n<h1 id=\"它有什么用\"><a href=\"#它有什么用\" class=\"headerlink\" title=\"它有什么用\"></a>它有什么用</h1><p>Canvas一般译为“画布”。而画布一般只是用来承载画像的，显然在Android中叫Canvas为画布，显然狭隘了。因为Android开发中，Canvas不仅提供了动画特效还提供了常见图形绘制方法，比如圆形、矩形、扇形等。</p>\n<p>在进行绘制过程中，还需要借助Pain辅助，Paint可以理解为画笔。</p>\n<h1 id=\"绘制图形方法\"><a href=\"#绘制图形方法\" class=\"headerlink\" title=\"绘制图形方法\"></a>绘制图形方法</h1><ul>\n<li><p>绘制文字</p>\n<p><code>drawText(String text, float x, float y, Paint paint)</code></p>\n<p><code>drawText(char[] text, int index, int count, float x, float y, Paint paint)</code></p>\n<p><code>drawText(CharSequence text, int start, int end, float x, float y, Paint paint)</code></p>\n<p><strong>float x</strong>：文本开始的x轴位置</p>\n<p><strong>float y</strong>：文本开始的y轴位置</p>\n<p><strong>text</strong>：要绘制的文本</p>\n<p><strong>paint</strong>: 使用的画笔</p>\n<p><strong>start</strong>：文本开始的位置</p>\n<p><strong>end</strong>：文本结束的位置</p>\n<p>​</p>\n</li>\n<li><p>绘制圆形</p>\n<p><code>drawCircle(float cx, float cy, float radius, Paint paint)</code></p>\n<p><strong>float cx</strong>：圆心x轴坐标</p>\n<p><strong>float cy</strong>：圆心y轴坐标</p>\n<p><strong>float radius</strong>：圆半径</p>\n<p><strong>paint</strong>：画笔</p>\n<p>​</p>\n</li>\n<li><p>绘制线条</p>\n<p><code>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</code></p>\n<p><strong>float startX</strong>：起点x坐标</p>\n<p><strong>float startY</strong>：起点y坐标</p>\n<p><strong>float stopX</strong>：终点x坐标</p>\n<p><strong>float stopY</strong>：终点y坐标</p>\n<p>​</p>\n</li>\n<li><p>绘制椭圆</p>\n<p><code>drawOval(float left, float top, float right, float bottom, Paint paint)</code></p>\n<p><code>drawOval(RectF oval, Paint paint)</code></p>\n<p>这里的两个方法可以是一样的，因为绘制一个<strong>RectF</strong>也是需要方法一中的四个点。</p>\n<p><strong>float left</strong>：左下</p>\n<p><strong>float top</strong>：左上</p>\n<p><strong>float right</strong>：右上</p>\n<p><strong>float bottom</strong>：右下</p>\n<p>​</p>\n</li>\n<li><p>绘制弧度</p>\n<p><code>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</code></p>\n<p>​</p>\n<p><code>drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</code></p>\n<p><strong>float startAngle</strong>：开始角度</p>\n<p><strong>float sweepAngle</strong>：扫过角度</p>\n<p><strong>boolean useCenter</strong>：是否和中心连线 </p>\n<p>​</p>\n</li>\n<li><p>绘制矩形</p>\n<p><code>drawRect(float left, float top, float right, float bottom, Paint paint)</code></p>\n<p><code>drawRect(Rect r, Paint paint)</code></p>\n<p>​</p>\n</li>\n<li><p>绘制多边形</p>\n<p>多边形绘制需要用到Path，路径类</p>\n<p>用到moveTo，lineTo等常用方法</p>\n<p><code>moveTo(float x, float y)</code></p>\n<p><code>lineTo(float x, float y)</code></p>\n<p>​</p>\n</li>\n<li><p>绘制赛贝尔曲线</p>\n<p>赛贝尔曲线的绘制也用到了Path。</p>\n<p><code>quadTo(float x1, float y1, float x2, float y2)</code></p>\n<p>​</p>\n</li>\n<li><p>绘制点</p>\n<p><code>drawPoint(float x, float y, Paint paint)</code></p>\n<p><code>drawPoints(float[] pts, Paint paint)</code></p>\n<p><strong>float x</strong>：点x轴坐标</p>\n<p><strong>float y</strong>：点y轴坐标</p>\n<p><strong>float pts</strong>：点数组，每两个值组合一个点，最后如果不够2个点则忽略。</p>\n<p>​</p>\n</li>\n<li><p>绘制图片</p>\n<p><code>drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)</code></p>\n<p>​</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"动画方法\"><a href=\"#动画方法\" class=\"headerlink\" title=\"动画方法\"></a>动画方法</h1><ul>\n<li><p>位移</p>\n<p><code>translate(float dx, float dy)</code></p>\n<p><strong>float dx</strong>：x轴移动距离</p>\n<p><strong>float dy</strong>：y轴移动距离</p>\n<p>​</p>\n</li>\n<li><p>缩放</p>\n<p><code>scale(float sx, float sy)</code></p>\n<p><code>scale(float sx, float sy, float px, float py)</code></p>\n<p><strong>float sx</strong>：x轴放大倍数</p>\n<p><strong>float sy</strong>：y轴放大倍数</p>\n<p><strong>float px, float py</strong>：以该点为中心缩放</p>\n</li>\n<li><p>旋转</p>\n<p><code>rotate(float degrees)</code></p>\n<p><code>rotate(float degrees, float px, float py)</code></p>\n<p><strong>float degrees</strong>：旋转角度</p>\n<p><strong>float px, float py</strong>：以px，py组成的点为中心旋转degrees角度</p>\n</li>\n</ul>\n<h1 id=\"save和restore\"><a href=\"#save和restore\" class=\"headerlink\" title=\"save和restore\"></a>save和restore</h1><ul>\n<li><p>save保存画布</p>\n<p>把save之前的数据保存起来，以便后续的操作在一个新的图层。</p>\n</li>\n<li><p>restore合并图层</p>\n<p>把save之前和之后的多个图层进行合并</p>\n<p>​</p>\n<p>​</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在Android开发中不管是图片的绘制还是控件的绘制都少不了<strong>Canvas</strong>的参与。</p>\n<p><strong>Canvas</strong>如此重要，对其多一些了解自然是对开发有益的。</p>\n<h1 id=\"获得对象\"><a href=\"#获得对象\" class=\"headerlink\" title=\"获得对象\"></a>获得对象</h1><p>有两种获得Canvas对象的方法：</p>\n<ul>\n<li>重写onDraw方法，使用参数中的Canvas</li>\n<li>直接创建Canvas对象</li>\n</ul>\n<h1 id=\"它有什么用\"><a href=\"#它有什么用\" class=\"headerlink\" title=\"它有什么用\"></a>它有什么用</h1><p>Canvas一般译为“画布”。而画布一般只是用来承载画像的，显然在Android中叫Canvas为画布，显然狭隘了。因为Android开发中，Canvas不仅提供了动画特效还提供了常见图形绘制方法，比如圆形、矩形、扇形等。</p>\n<p>在进行绘制过程中，还需要借助Pain辅助，Paint可以理解为画笔。</p>\n<h1 id=\"绘制图形方法\"><a href=\"#绘制图形方法\" class=\"headerlink\" title=\"绘制图形方法\"></a>绘制图形方法</h1><ul>\n<li><p>绘制文字</p>\n<p><code>drawText(String text, float x, float y, Paint paint)</code></p>\n<p><code>drawText(char[] text, int index, int count, float x, float y, Paint paint)</code></p>\n<p><code>drawText(CharSequence text, int start, int end, float x, float y, Paint paint)</code></p>\n<p><strong>float x</strong>：文本开始的x轴位置</p>\n<p><strong>float y</strong>：文本开始的y轴位置</p>\n<p><strong>text</strong>：要绘制的文本</p>\n<p><strong>paint</strong>: 使用的画笔</p>\n<p><strong>start</strong>：文本开始的位置</p>\n<p><strong>end</strong>：文本结束的位置</p>\n<p>​</p>\n</li>\n<li><p>绘制圆形</p>\n<p><code>drawCircle(float cx, float cy, float radius, Paint paint)</code></p>\n<p><strong>float cx</strong>：圆心x轴坐标</p>\n<p><strong>float cy</strong>：圆心y轴坐标</p>\n<p><strong>float radius</strong>：圆半径</p>\n<p><strong>paint</strong>：画笔</p>\n<p>​</p>\n</li>\n<li><p>绘制线条</p>\n<p><code>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</code></p>\n<p><strong>float startX</strong>：起点x坐标</p>\n<p><strong>float startY</strong>：起点y坐标</p>\n<p><strong>float stopX</strong>：终点x坐标</p>\n<p><strong>float stopY</strong>：终点y坐标</p>\n<p>​</p>\n</li>\n<li><p>绘制椭圆</p>\n<p><code>drawOval(float left, float top, float right, float bottom, Paint paint)</code></p>\n<p><code>drawOval(RectF oval, Paint paint)</code></p>\n<p>这里的两个方法可以是一样的，因为绘制一个<strong>RectF</strong>也是需要方法一中的四个点。</p>\n<p><strong>float left</strong>：左下</p>\n<p><strong>float top</strong>：左上</p>\n<p><strong>float right</strong>：右上</p>\n<p><strong>float bottom</strong>：右下</p>\n<p>​</p>\n</li>\n<li><p>绘制弧度</p>\n<p><code>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</code></p>\n<p>​</p>\n<p><code>drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</code></p>\n<p><strong>float startAngle</strong>：开始角度</p>\n<p><strong>float sweepAngle</strong>：扫过角度</p>\n<p><strong>boolean useCenter</strong>：是否和中心连线 </p>\n<p>​</p>\n</li>\n<li><p>绘制矩形</p>\n<p><code>drawRect(float left, float top, float right, float bottom, Paint paint)</code></p>\n<p><code>drawRect(Rect r, Paint paint)</code></p>\n<p>​</p>\n</li>\n<li><p>绘制多边形</p>\n<p>多边形绘制需要用到Path，路径类</p>\n<p>用到moveTo，lineTo等常用方法</p>\n<p><code>moveTo(float x, float y)</code></p>\n<p><code>lineTo(float x, float y)</code></p>\n<p>​</p>\n</li>\n<li><p>绘制赛贝尔曲线</p>\n<p>赛贝尔曲线的绘制也用到了Path。</p>\n<p><code>quadTo(float x1, float y1, float x2, float y2)</code></p>\n<p>​</p>\n</li>\n<li><p>绘制点</p>\n<p><code>drawPoint(float x, float y, Paint paint)</code></p>\n<p><code>drawPoints(float[] pts, Paint paint)</code></p>\n<p><strong>float x</strong>：点x轴坐标</p>\n<p><strong>float y</strong>：点y轴坐标</p>\n<p><strong>float pts</strong>：点数组，每两个值组合一个点，最后如果不够2个点则忽略。</p>\n<p>​</p>\n</li>\n<li><p>绘制图片</p>\n<p><code>drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)</code></p>\n<p>​</p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"动画方法\"><a href=\"#动画方法\" class=\"headerlink\" title=\"动画方法\"></a>动画方法</h1><ul>\n<li><p>位移</p>\n<p><code>translate(float dx, float dy)</code></p>\n<p><strong>float dx</strong>：x轴移动距离</p>\n<p><strong>float dy</strong>：y轴移动距离</p>\n<p>​</p>\n</li>\n<li><p>缩放</p>\n<p><code>scale(float sx, float sy)</code></p>\n<p><code>scale(float sx, float sy, float px, float py)</code></p>\n<p><strong>float sx</strong>：x轴放大倍数</p>\n<p><strong>float sy</strong>：y轴放大倍数</p>\n<p><strong>float px, float py</strong>：以该点为中心缩放</p>\n</li>\n<li><p>旋转</p>\n<p><code>rotate(float degrees)</code></p>\n<p><code>rotate(float degrees, float px, float py)</code></p>\n<p><strong>float degrees</strong>：旋转角度</p>\n<p><strong>float px, float py</strong>：以px，py组成的点为中心旋转degrees角度</p>\n</li>\n</ul>\n<h1 id=\"save和restore\"><a href=\"#save和restore\" class=\"headerlink\" title=\"save和restore\"></a>save和restore</h1><ul>\n<li><p>save保存画布</p>\n<p>把save之前的数据保存起来，以便后续的操作在一个新的图层。</p>\n</li>\n<li><p>restore合并图层</p>\n<p>把save之前和之后的多个图层进行合并</p>\n<p>​</p>\n<p>​</p>\n</li>\n</ul>\n"},{"title":"为什么相对布局比线性布局性能低","date":"2017-07-19T02:53:28.000Z","_content":"\n# 0x00 前言\n\nUI优化原则之一：如果使用线性布局和相对布局的层级一样，那么优先使用线性布局。\n\n经常说出这个原则的时候就会顺便被问到为什么。为了避免尴尬还是抽时间把源码大概看了一下。\n\n# 0x01 View绘制流程简述 \n\n看过源码的应该知道，View的绘制是从`ViewRootImpl.performTraversals()`方法开始的。\n\n先后经历`performMeasure`、`performLayout`和`performDraw`三个阶段，就是常说的测量、布局和绘制。\n\n- performMeasure会调用根View的measure，进而调用onMeasure方法\n- performLayout调用根View的layout，进而调用onLayout方法\n- performDraw调用根View的draw，进而调用onDraw方法\n\n鉴于两个都是ViewGroup，所以可以忽略onDraw\n\n有对比才有伤害，要比较这两个布局性能，要先看看这两个布局分别在onMeasure，onLayout都做了什么。\n\n# 0x02 LinearLayout分析\n\nLinearLayout的onMeasure方法内容很简单，就是判断方向然后分别调用:\n\n```java\n   @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (mOrientation == VERTICAL) {\n            measureVertical(widthMeasureSpec, heightMeasureSpec);\n        } else {\n            measureHorizontal(widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n```\n\n那就随便看看`measureVertical`方法里面干了些什么：\n\n```Java\n        // See how tall everyone is. Also remember max width.\n        for (int i = 0; i < count; ++i) {\n            final View child = getVirtualChildAt(i);\n\n            if (child == null) {\n                mTotalLength += measureNullChild(i);\n                continue;\n            }\n\n            if (child.getVisibility() == View.GONE) {\n               i += getChildrenSkipCount(child, i);\n               continue;\n            }\n\n            if (hasDividerBeforeChildAt(i)) {\n                mTotalLength += mDividerHeight;\n            }\n\n            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();\n\n            totalWeight += lp.weight;\n            \n            if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {\n                // Optimization: don't bother measuring children who are going to use\n                // leftover space. These views will get measured again down below if\n                // there is any leftover space.\n                final int totalLength = mTotalLength;\n                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);\n                skippedMeasure = true;\n            } else {\n                int oldHeight = Integer.MIN_VALUE;\n\n                if (lp.height == 0 && lp.weight > 0) {\n                    // heightMode is either UNSPECIFIED or AT_MOST, and this\n                    // child wanted to stretch to fill available space.\n                    // Translate that to WRAP_CONTENT so that it does not end up\n                    // with a height of 0\n                    oldHeight = 0;\n                    lp.height = LayoutParams.WRAP_CONTENT;\n                }\n\n                // Determine how big this child would like to be. If this or\n                // previous children have given a weight, then we allow it to\n                // use all available space (and we will shrink things later\n                // if needed).\n                measureChildBeforeLayout(\n                       child, i, widthMeasureSpec, 0, heightMeasureSpec,\n                       totalWeight == 0 ? mTotalLength : 0);\n\n                if (oldHeight != Integer.MIN_VALUE) {\n                   lp.height = oldHeight;\n                }\n\n                final int childHeight = child.getMeasuredHeight();\n                final int totalLength = mTotalLength;\n                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +\n                       lp.bottomMargin + getNextLocationOffset(child));\n\n                if (useLargestChild) {\n                    largestChildHeight = Math.max(childHeight, largestChildHeight);\n                }\n            }\n\n            /**\n             * If applicable, compute the additional offset to the child's baseline\n             * we'll need later when asked {@link #getBaseline}.\n             */\n            if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {\n               mBaselineChildTop = mTotalLength;\n            }\n\n            // if we are trying to use a child index for our baseline, the above\n            // book keeping only works if there are no children above it with\n            // weight.  fail fast to aid the developer.\n            if (i < baselineChildIndex && lp.weight > 0) {\n                throw new RuntimeException(\"A child of LinearLayout with index \"\n                        + \"less than mBaselineAlignedChildIndex has weight > 0, which \"\n                        + \"won't work.  Either remove the weight, or don't set \"\n                        + \"mBaselineAlignedChildIndex.\");\n            }\n\n            boolean matchWidthLocally = false;\n            if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {\n                // The width of the linear layout will scale, and at least one\n                // child said it wanted to match our width. Set a flag\n                // indicating that we need to remeasure at least that view when\n                // we know our width.\n                matchWidth = true;\n                matchWidthLocally = true;\n            }\n\n            final int margin = lp.leftMargin + lp.rightMargin;\n            final int measuredWidth = child.getMeasuredWidth() + margin;\n            maxWidth = Math.max(maxWidth, measuredWidth);\n            childState = combineMeasuredStates(childState, child.getMeasuredState());\n\n            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;\n            if (lp.weight > 0) {\n                /*\n                 * Widths of weighted Views are bogus if we end up\n                 * remeasuring, so keep them separate.\n                 */\n                weightedMaxWidth = Math.max(weightedMaxWidth,\n                        matchWidthLocally ? margin : measuredWidth);\n            } else {\n                alternativeMaxWidth = Math.max(alternativeMaxWidth,\n                        matchWidthLocally ? margin : measuredWidth);\n            }\n\n            i += getChildrenSkipCount(child, i);\n        }  \n```\n\n这个方法主要是for循环中通过`measureChildBeforeLayout`测量子View高度，把每次测量的高度都累加到`mTotalLength`。\n\n\n\n\n\n\n\n# 0x03 RelativeLayout分析\n\n看看RelativeLayout的onMeasure方法：\n\n```java\n       View[] views = mSortedHorizontalChildren;\n        int count = views.length;\n\n        for (int i = 0; i < count; i++) {\n            View child = views[i];\n            if (child.getVisibility() != GONE) {\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\n                int[] rules = params.getRules(layoutDirection);\n\n                applyHorizontalSizeRules(params, myWidth, rules);\n                measureChildHorizontal(child, params, myWidth, myHeight);\n\n                if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) {\n                    offsetHorizontalAxis = true;\n                }\n            }\n        }\n\n        views = mSortedVerticalChildren;\n        count = views.length;\n        final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;\n\n        for (int i = 0; i < count; i++) {\n            View child = views[i];\n            if (child.getVisibility() != GONE) {\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\n                \n                applyVerticalSizeRules(params, myHeight);\n                measureChild(child, params, myWidth, myHeight);\n                if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) {\n                    offsetVerticalAxis = true;\n                }\n\n                if (isWrapContentWidth) {\n                    if (isLayoutRtl()) {\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\n                            width = Math.max(width, myWidth - params.mLeft);\n                        } else {\n                            width = Math.max(width, myWidth - params.mLeft - params.leftMargin);\n                        }\n                    } else {\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\n                            width = Math.max(width, params.mRight);\n                        } else {\n                            width = Math.max(width, params.mRight + params.rightMargin);\n                        }\n                    }\n                }\n\n                if (isWrapContentHeight) {\n                    if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\n                        height = Math.max(height, params.mBottom);\n                    } else {\n                        height = Math.max(height, params.mBottom + params.bottomMargin);\n                    }\n                }\n\n                if (child != ignore || verticalGravity) {\n                    left = Math.min(left, params.mLeft - params.leftMargin);\n                    top = Math.min(top, params.mTop - params.topMargin);\n                }\n\n                if (child != ignore || horizontalGravity) {\n                    right = Math.max(right, params.mRight + params.rightMargin);\n                    bottom = Math.max(bottom, params.mBottom + params.bottomMargin);\n                }\n            }\n        }\n```\n\n第一个for循环中`measureChildHorizontal`方法实现如下：\n\n```Java\n     int childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\n                params.mRight, params.width,\n                params.leftMargin, params.rightMargin,\n                mPaddingLeft, mPaddingRight,\n                myWidth);\n        int maxHeight = myHeight;\n        if (mMeasureVerticalWithPaddingMargin) {\n            maxHeight = Math.max(0, myHeight - mPaddingTop - mPaddingBottom -\n                    params.topMargin - params.bottomMargin);\n        }\n        int childHeightMeasureSpec;\n        if (myHeight < 0 && !mAllowBrokenMeasureSpecs) {\n            if (params.height >= 0) {\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(\n                        params.height, MeasureSpec.EXACTLY);\n            } else {\n                // Negative values in a mySize/myWidth/myWidth value in RelativeLayout measurement\n                // is code for, \"we got an unspecified mode in the RelativeLayout's measurespec.\"\n                // Carry it forward.\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            }\n        } else if (params.width == LayoutParams.MATCH_PARENT) {\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY);\n        } else {\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.AT_MOST);\n        }\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n\n\n第二个for循环中`measureChild`实现如下：\n\n```Java\nint childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\n                params.mRight, params.width,\n                params.leftMargin, params.rightMargin,\n                mPaddingLeft, mPaddingRight,\n                myWidth);\n        int childHeightMeasureSpec = getChildMeasureSpec(params.mTop,\n                params.mBottom, params.height,\n                params.topMargin, params.bottomMargin,\n                mPaddingTop, mPaddingBottom,\n                myHeight);\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n两个for循环中都执行了`child.measure(childWidthMeasureSpec, childHeightMeasureSpec);`这意味着子View测量执行了两遍。\n\n为什么RelativeLayout要测量两遍？\n\n> 因为RelativeLayout并不像LinearLayout那样有着方向单一性。RelativeLayout的灵活性就在于允许纵横双向的，这样view直接不仅横向依赖，还有纵向依赖，每个方向都要测量一遍。导致性能略差。","source":"_posts/为什么相对布局比线性布局性能低.md","raw":"---\ntitle: 为什么相对布局比线性布局性能低\ndate: 2017-07-19 10:53:28\ntags: Android\ncategory: Android\n---\n\n# 0x00 前言\n\nUI优化原则之一：如果使用线性布局和相对布局的层级一样，那么优先使用线性布局。\n\n经常说出这个原则的时候就会顺便被问到为什么。为了避免尴尬还是抽时间把源码大概看了一下。\n\n# 0x01 View绘制流程简述 \n\n看过源码的应该知道，View的绘制是从`ViewRootImpl.performTraversals()`方法开始的。\n\n先后经历`performMeasure`、`performLayout`和`performDraw`三个阶段，就是常说的测量、布局和绘制。\n\n- performMeasure会调用根View的measure，进而调用onMeasure方法\n- performLayout调用根View的layout，进而调用onLayout方法\n- performDraw调用根View的draw，进而调用onDraw方法\n\n鉴于两个都是ViewGroup，所以可以忽略onDraw\n\n有对比才有伤害，要比较这两个布局性能，要先看看这两个布局分别在onMeasure，onLayout都做了什么。\n\n# 0x02 LinearLayout分析\n\nLinearLayout的onMeasure方法内容很简单，就是判断方向然后分别调用:\n\n```java\n   @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (mOrientation == VERTICAL) {\n            measureVertical(widthMeasureSpec, heightMeasureSpec);\n        } else {\n            measureHorizontal(widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n```\n\n那就随便看看`measureVertical`方法里面干了些什么：\n\n```Java\n        // See how tall everyone is. Also remember max width.\n        for (int i = 0; i < count; ++i) {\n            final View child = getVirtualChildAt(i);\n\n            if (child == null) {\n                mTotalLength += measureNullChild(i);\n                continue;\n            }\n\n            if (child.getVisibility() == View.GONE) {\n               i += getChildrenSkipCount(child, i);\n               continue;\n            }\n\n            if (hasDividerBeforeChildAt(i)) {\n                mTotalLength += mDividerHeight;\n            }\n\n            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();\n\n            totalWeight += lp.weight;\n            \n            if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {\n                // Optimization: don't bother measuring children who are going to use\n                // leftover space. These views will get measured again down below if\n                // there is any leftover space.\n                final int totalLength = mTotalLength;\n                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);\n                skippedMeasure = true;\n            } else {\n                int oldHeight = Integer.MIN_VALUE;\n\n                if (lp.height == 0 && lp.weight > 0) {\n                    // heightMode is either UNSPECIFIED or AT_MOST, and this\n                    // child wanted to stretch to fill available space.\n                    // Translate that to WRAP_CONTENT so that it does not end up\n                    // with a height of 0\n                    oldHeight = 0;\n                    lp.height = LayoutParams.WRAP_CONTENT;\n                }\n\n                // Determine how big this child would like to be. If this or\n                // previous children have given a weight, then we allow it to\n                // use all available space (and we will shrink things later\n                // if needed).\n                measureChildBeforeLayout(\n                       child, i, widthMeasureSpec, 0, heightMeasureSpec,\n                       totalWeight == 0 ? mTotalLength : 0);\n\n                if (oldHeight != Integer.MIN_VALUE) {\n                   lp.height = oldHeight;\n                }\n\n                final int childHeight = child.getMeasuredHeight();\n                final int totalLength = mTotalLength;\n                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +\n                       lp.bottomMargin + getNextLocationOffset(child));\n\n                if (useLargestChild) {\n                    largestChildHeight = Math.max(childHeight, largestChildHeight);\n                }\n            }\n\n            /**\n             * If applicable, compute the additional offset to the child's baseline\n             * we'll need later when asked {@link #getBaseline}.\n             */\n            if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {\n               mBaselineChildTop = mTotalLength;\n            }\n\n            // if we are trying to use a child index for our baseline, the above\n            // book keeping only works if there are no children above it with\n            // weight.  fail fast to aid the developer.\n            if (i < baselineChildIndex && lp.weight > 0) {\n                throw new RuntimeException(\"A child of LinearLayout with index \"\n                        + \"less than mBaselineAlignedChildIndex has weight > 0, which \"\n                        + \"won't work.  Either remove the weight, or don't set \"\n                        + \"mBaselineAlignedChildIndex.\");\n            }\n\n            boolean matchWidthLocally = false;\n            if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {\n                // The width of the linear layout will scale, and at least one\n                // child said it wanted to match our width. Set a flag\n                // indicating that we need to remeasure at least that view when\n                // we know our width.\n                matchWidth = true;\n                matchWidthLocally = true;\n            }\n\n            final int margin = lp.leftMargin + lp.rightMargin;\n            final int measuredWidth = child.getMeasuredWidth() + margin;\n            maxWidth = Math.max(maxWidth, measuredWidth);\n            childState = combineMeasuredStates(childState, child.getMeasuredState());\n\n            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;\n            if (lp.weight > 0) {\n                /*\n                 * Widths of weighted Views are bogus if we end up\n                 * remeasuring, so keep them separate.\n                 */\n                weightedMaxWidth = Math.max(weightedMaxWidth,\n                        matchWidthLocally ? margin : measuredWidth);\n            } else {\n                alternativeMaxWidth = Math.max(alternativeMaxWidth,\n                        matchWidthLocally ? margin : measuredWidth);\n            }\n\n            i += getChildrenSkipCount(child, i);\n        }  \n```\n\n这个方法主要是for循环中通过`measureChildBeforeLayout`测量子View高度，把每次测量的高度都累加到`mTotalLength`。\n\n\n\n\n\n\n\n# 0x03 RelativeLayout分析\n\n看看RelativeLayout的onMeasure方法：\n\n```java\n       View[] views = mSortedHorizontalChildren;\n        int count = views.length;\n\n        for (int i = 0; i < count; i++) {\n            View child = views[i];\n            if (child.getVisibility() != GONE) {\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\n                int[] rules = params.getRules(layoutDirection);\n\n                applyHorizontalSizeRules(params, myWidth, rules);\n                measureChildHorizontal(child, params, myWidth, myHeight);\n\n                if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) {\n                    offsetHorizontalAxis = true;\n                }\n            }\n        }\n\n        views = mSortedVerticalChildren;\n        count = views.length;\n        final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;\n\n        for (int i = 0; i < count; i++) {\n            View child = views[i];\n            if (child.getVisibility() != GONE) {\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\n                \n                applyVerticalSizeRules(params, myHeight);\n                measureChild(child, params, myWidth, myHeight);\n                if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) {\n                    offsetVerticalAxis = true;\n                }\n\n                if (isWrapContentWidth) {\n                    if (isLayoutRtl()) {\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\n                            width = Math.max(width, myWidth - params.mLeft);\n                        } else {\n                            width = Math.max(width, myWidth - params.mLeft - params.leftMargin);\n                        }\n                    } else {\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\n                            width = Math.max(width, params.mRight);\n                        } else {\n                            width = Math.max(width, params.mRight + params.rightMargin);\n                        }\n                    }\n                }\n\n                if (isWrapContentHeight) {\n                    if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\n                        height = Math.max(height, params.mBottom);\n                    } else {\n                        height = Math.max(height, params.mBottom + params.bottomMargin);\n                    }\n                }\n\n                if (child != ignore || verticalGravity) {\n                    left = Math.min(left, params.mLeft - params.leftMargin);\n                    top = Math.min(top, params.mTop - params.topMargin);\n                }\n\n                if (child != ignore || horizontalGravity) {\n                    right = Math.max(right, params.mRight + params.rightMargin);\n                    bottom = Math.max(bottom, params.mBottom + params.bottomMargin);\n                }\n            }\n        }\n```\n\n第一个for循环中`measureChildHorizontal`方法实现如下：\n\n```Java\n     int childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\n                params.mRight, params.width,\n                params.leftMargin, params.rightMargin,\n                mPaddingLeft, mPaddingRight,\n                myWidth);\n        int maxHeight = myHeight;\n        if (mMeasureVerticalWithPaddingMargin) {\n            maxHeight = Math.max(0, myHeight - mPaddingTop - mPaddingBottom -\n                    params.topMargin - params.bottomMargin);\n        }\n        int childHeightMeasureSpec;\n        if (myHeight < 0 && !mAllowBrokenMeasureSpecs) {\n            if (params.height >= 0) {\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(\n                        params.height, MeasureSpec.EXACTLY);\n            } else {\n                // Negative values in a mySize/myWidth/myWidth value in RelativeLayout measurement\n                // is code for, \"we got an unspecified mode in the RelativeLayout's measurespec.\"\n                // Carry it forward.\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            }\n        } else if (params.width == LayoutParams.MATCH_PARENT) {\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY);\n        } else {\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.AT_MOST);\n        }\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n\n\n第二个for循环中`measureChild`实现如下：\n\n```Java\nint childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\n                params.mRight, params.width,\n                params.leftMargin, params.rightMargin,\n                mPaddingLeft, mPaddingRight,\n                myWidth);\n        int childHeightMeasureSpec = getChildMeasureSpec(params.mTop,\n                params.mBottom, params.height,\n                params.topMargin, params.bottomMargin,\n                mPaddingTop, mPaddingBottom,\n                myHeight);\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n```\n\n两个for循环中都执行了`child.measure(childWidthMeasureSpec, childHeightMeasureSpec);`这意味着子View测量执行了两遍。\n\n为什么RelativeLayout要测量两遍？\n\n> 因为RelativeLayout并不像LinearLayout那样有着方向单一性。RelativeLayout的灵活性就在于允许纵横双向的，这样view直接不仅横向依赖，还有纵向依赖，每个方向都要测量一遍。导致性能略差。","slug":"为什么相对布局比线性布局性能低","published":1,"updated":"2017-07-19T10:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjil006mwh9cl0uleut8","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>UI优化原则之一：如果使用线性布局和相对布局的层级一样，那么优先使用线性布局。</p>\n<p>经常说出这个原则的时候就会顺便被问到为什么。为了避免尴尬还是抽时间把源码大概看了一下。</p>\n<h1 id=\"0x01-View绘制流程简述\"><a href=\"#0x01-View绘制流程简述\" class=\"headerlink\" title=\"0x01 View绘制流程简述\"></a>0x01 View绘制流程简述</h1><p>看过源码的应该知道，View的绘制是从<code>ViewRootImpl.performTraversals()</code>方法开始的。</p>\n<p>先后经历<code>performMeasure</code>、<code>performLayout</code>和<code>performDraw</code>三个阶段，就是常说的测量、布局和绘制。</p>\n<ul>\n<li>performMeasure会调用根View的measure，进而调用onMeasure方法</li>\n<li>performLayout调用根View的layout，进而调用onLayout方法</li>\n<li>performDraw调用根View的draw，进而调用onDraw方法</li>\n</ul>\n<p>鉴于两个都是ViewGroup，所以可以忽略onDraw</p>\n<p>有对比才有伤害，要比较这两个布局性能，要先看看这两个布局分别在onMeasure，onLayout都做了什么。</p>\n<h1 id=\"0x02-LinearLayout分析\"><a href=\"#0x02-LinearLayout分析\" class=\"headerlink\" title=\"0x02 LinearLayout分析\"></a>0x02 LinearLayout分析</h1><p>LinearLayout的onMeasure方法内容很简单，就是判断方向然后分别调用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (mOrientation == VERTICAL) &#123;</div><div class=\"line\">         measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>那就随便看看<code>measureVertical</code>方法里面干了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// See how tall everyone is. Also remember max width.</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; ++i) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> View child = getVirtualChildAt(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mTotalLength += measureNullChild(i);</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class=\"line\">       i += getChildrenSkipCount(child, i);</div><div class=\"line\">       <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class=\"line\">        mTotalLength += mDividerHeight;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">    totalWeight += lp.weight;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class=\"number\">0</span> &amp;&amp; lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// Optimization: don't bother measuring children who are going to use</span></div><div class=\"line\">        <span class=\"comment\">// leftover space. These views will get measured again down below if</span></div><div class=\"line\">        <span class=\"comment\">// there is any leftover space.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> totalLength = mTotalLength;</div><div class=\"line\">        mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class=\"line\">        skippedMeasure = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldHeight = Integer.MIN_VALUE;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (lp.height == <span class=\"number\">0</span> &amp;&amp; lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></div><div class=\"line\">            <span class=\"comment\">// child wanted to stretch to fill available space.</span></div><div class=\"line\">            <span class=\"comment\">// Translate that to WRAP_CONTENT so that it does not end up</span></div><div class=\"line\">            <span class=\"comment\">// with a height of 0</span></div><div class=\"line\">            oldHeight = <span class=\"number\">0</span>;</div><div class=\"line\">            lp.height = LayoutParams.WRAP_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Determine how big this child would like to be. If this or</span></div><div class=\"line\">        <span class=\"comment\">// previous children have given a weight, then we allow it to</span></div><div class=\"line\">        <span class=\"comment\">// use all available space (and we will shrink things later</span></div><div class=\"line\">        <span class=\"comment\">// if needed).</span></div><div class=\"line\">        measureChildBeforeLayout(</div><div class=\"line\">               child, i, widthMeasureSpec, <span class=\"number\">0</span>, heightMeasureSpec,</div><div class=\"line\">               totalWeight == <span class=\"number\">0</span> ? mTotalLength : <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class=\"line\">           lp.height = oldHeight;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight();</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> totalLength = mTotalLength;</div><div class=\"line\">        mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class=\"line\">               lp.bottomMargin + getNextLocationOffset(child));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (useLargestChild) &#123;</div><div class=\"line\">            largestChildHeight = Math.max(childHeight, largestChildHeight);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * If applicable, compute the additional offset to the child's baseline</div><div class=\"line\">     * we'll need later when asked &#123;<span class=\"doctag\">@link</span> #getBaseline&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">if</span> ((baselineChildIndex &gt;= <span class=\"number\">0</span>) &amp;&amp; (baselineChildIndex == i + <span class=\"number\">1</span>)) &#123;</div><div class=\"line\">       mBaselineChildTop = mTotalLength;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// if we are trying to use a child index for our baseline, the above</span></div><div class=\"line\">    <span class=\"comment\">// book keeping only works if there are no children above it with</span></div><div class=\"line\">    <span class=\"comment\">// weight.  fail fast to aid the developer.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"A child of LinearLayout with index \"</span></div><div class=\"line\">                + <span class=\"string\">\"less than mBaselineAlignedChildIndex has weight &gt; 0, which \"</span></div><div class=\"line\">                + <span class=\"string\">\"won't work.  Either remove the weight, or don't set \"</span></div><div class=\"line\">                + <span class=\"string\">\"mBaselineAlignedChildIndex.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">boolean</span> matchWidthLocally = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">        <span class=\"comment\">// The width of the linear layout will scale, and at least one</span></div><div class=\"line\">        <span class=\"comment\">// child said it wanted to match our width. Set a flag</span></div><div class=\"line\">        <span class=\"comment\">// indicating that we need to remeasure at least that view when</span></div><div class=\"line\">        <span class=\"comment\">// we know our width.</span></div><div class=\"line\">        matchWidth = <span class=\"keyword\">true</span>;</div><div class=\"line\">        matchWidthLocally = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> margin = lp.leftMargin + lp.rightMargin;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> measuredWidth = child.getMeasuredWidth() + margin;</div><div class=\"line\">    maxWidth = Math.max(maxWidth, measuredWidth);</div><div class=\"line\">    childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class=\"line\"></div><div class=\"line\">    allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * Widths of weighted Views are bogus if we end up</div><div class=\"line\">         * remeasuring, so keep them separate.</div><div class=\"line\">         */</div><div class=\"line\">        weightedMaxWidth = Math.max(weightedMaxWidth,</div><div class=\"line\">                matchWidthLocally ? margin : measuredWidth);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class=\"line\">                matchWidthLocally ? margin : measuredWidth);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    i += getChildrenSkipCount(child, i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法主要是for循环中通过<code>measureChildBeforeLayout</code>测量子View高度，把每次测量的高度都累加到<code>mTotalLength</code>。</p>\n<h1 id=\"0x03-RelativeLayout分析\"><a href=\"#0x03-RelativeLayout分析\" class=\"headerlink\" title=\"0x03 RelativeLayout分析\"></a>0x03 RelativeLayout分析</h1><p>看看RelativeLayout的onMeasure方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">View[] views = mSortedHorizontalChildren;</div><div class=\"line\"> <span class=\"keyword\">int</span> count = views.length;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">     View child = views[i];</div><div class=\"line\">     <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</div><div class=\"line\">         LayoutParams params = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">         <span class=\"keyword\">int</span>[] rules = params.getRules(layoutDirection);</div><div class=\"line\"></div><div class=\"line\">         applyHorizontalSizeRules(params, myWidth, rules);</div><div class=\"line\">         measureChildHorizontal(child, params, myWidth, myHeight);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</div><div class=\"line\">             offsetHorizontalAxis = <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> views = mSortedVerticalChildren;</div><div class=\"line\"> count = views.length;</div><div class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">     View child = views[i];</div><div class=\"line\">     <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</div><div class=\"line\">         LayoutParams params = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">         </div><div class=\"line\">         applyVerticalSizeRules(params, myHeight);</div><div class=\"line\">         measureChild(child, params, myWidth, myHeight);</div><div class=\"line\">         <span class=\"keyword\">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</div><div class=\"line\">             offsetVerticalAxis = <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (isWrapContentWidth) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (isLayoutRtl()) &#123;</div><div class=\"line\">                 <span class=\"keyword\">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</div><div class=\"line\">                     width = Math.max(width, myWidth - params.mLeft);</div><div class=\"line\">                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                     width = Math.max(width, myWidth - params.mLeft - params.leftMargin);</div><div class=\"line\">                 &#125;</div><div class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                 <span class=\"keyword\">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</div><div class=\"line\">                     width = Math.max(width, params.mRight);</div><div class=\"line\">                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                     width = Math.max(width, params.mRight + params.rightMargin);</div><div class=\"line\">                 &#125;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (isWrapContentHeight) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</div><div class=\"line\">                 height = Math.max(height, params.mBottom);</div><div class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                 height = Math.max(height, params.mBottom + params.bottomMargin);</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (child != ignore || verticalGravity) &#123;</div><div class=\"line\">             left = Math.min(left, params.mLeft - params.leftMargin);</div><div class=\"line\">             top = Math.min(top, params.mTop - params.topMargin);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (child != ignore || horizontalGravity) &#123;</div><div class=\"line\">             right = Math.max(right, params.mRight + params.rightMargin);</div><div class=\"line\">             bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>第一个for循环中<code>measureChildHorizontal</code>方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,</div><div class=\"line\">           params.mRight, params.width,</div><div class=\"line\">           params.leftMargin, params.rightMargin,</div><div class=\"line\">           mPaddingLeft, mPaddingRight,</div><div class=\"line\">           myWidth);</div><div class=\"line\">   <span class=\"keyword\">int</span> maxHeight = myHeight;</div><div class=\"line\">   <span class=\"keyword\">if</span> (mMeasureVerticalWithPaddingMargin) &#123;</div><div class=\"line\">       maxHeight = Math.max(<span class=\"number\">0</span>, myHeight - mPaddingTop - mPaddingBottom -</div><div class=\"line\">               params.topMargin - params.bottomMargin);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">int</span> childHeightMeasureSpec;</div><div class=\"line\">   <span class=\"keyword\">if</span> (myHeight &lt; <span class=\"number\">0</span> &amp;&amp; !mAllowBrokenMeasureSpecs) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (params.height &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class=\"line\">                   params.height, MeasureSpec.EXACTLY);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"comment\">// Negative values in a mySize/myWidth/myWidth value in RelativeLayout measurement</span></div><div class=\"line\">           <span class=\"comment\">// is code for, \"we got an unspecified mode in the RelativeLayout's measurespec.\"</span></div><div class=\"line\">           <span class=\"comment\">// Carry it forward.</span></div><div class=\"line\">           childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class=\"number\">0</span>, MeasureSpec.UNSPECIFIED);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (params.width == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY);</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.AT_MOST);</div><div class=\"line\">   &#125;</div><div class=\"line\">   child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>\n<p>第二个for循环中<code>measureChild</code>实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,</div><div class=\"line\">                params.mRight, params.width,</div><div class=\"line\">                params.leftMargin, params.rightMargin,</div><div class=\"line\">                mPaddingLeft, mPaddingRight,</div><div class=\"line\">                myWidth);</div><div class=\"line\">        <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(params.mTop,</div><div class=\"line\">                params.mBottom, params.height,</div><div class=\"line\">                params.topMargin, params.bottomMargin,</div><div class=\"line\">                mPaddingTop, mPaddingBottom,</div><div class=\"line\">                myHeight);</div><div class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>\n<p>两个for循环中都执行了<code>child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</code>这意味着子View测量执行了两遍。</p>\n<p>为什么RelativeLayout要测量两遍？</p>\n<blockquote>\n<p>因为RelativeLayout并不像LinearLayout那样有着方向单一性。RelativeLayout的灵活性就在于允许纵横双向的，这样view直接不仅横向依赖，还有纵向依赖，每个方向都要测量一遍。导致性能略差。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>UI优化原则之一：如果使用线性布局和相对布局的层级一样，那么优先使用线性布局。</p>\n<p>经常说出这个原则的时候就会顺便被问到为什么。为了避免尴尬还是抽时间把源码大概看了一下。</p>\n<h1 id=\"0x01-View绘制流程简述\"><a href=\"#0x01-View绘制流程简述\" class=\"headerlink\" title=\"0x01 View绘制流程简述\"></a>0x01 View绘制流程简述</h1><p>看过源码的应该知道，View的绘制是从<code>ViewRootImpl.performTraversals()</code>方法开始的。</p>\n<p>先后经历<code>performMeasure</code>、<code>performLayout</code>和<code>performDraw</code>三个阶段，就是常说的测量、布局和绘制。</p>\n<ul>\n<li>performMeasure会调用根View的measure，进而调用onMeasure方法</li>\n<li>performLayout调用根View的layout，进而调用onLayout方法</li>\n<li>performDraw调用根View的draw，进而调用onDraw方法</li>\n</ul>\n<p>鉴于两个都是ViewGroup，所以可以忽略onDraw</p>\n<p>有对比才有伤害，要比较这两个布局性能，要先看看这两个布局分别在onMeasure，onLayout都做了什么。</p>\n<h1 id=\"0x02-LinearLayout分析\"><a href=\"#0x02-LinearLayout分析\" class=\"headerlink\" title=\"0x02 LinearLayout分析\"></a>0x02 LinearLayout分析</h1><p>LinearLayout的onMeasure方法内容很简单，就是判断方向然后分别调用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (mOrientation == VERTICAL) &#123;</div><div class=\"line\">         measureVertical(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         measureHorizontal(widthMeasureSpec, heightMeasureSpec);</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>那就随便看看<code>measureVertical</code>方法里面干了些什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// See how tall everyone is. Also remember max width.</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; ++i) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> View child = getVirtualChildAt(i);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mTotalLength += measureNullChild(i);</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (child.getVisibility() == View.GONE) &#123;</div><div class=\"line\">       i += getChildrenSkipCount(child, i);</div><div class=\"line\">       <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (hasDividerBeforeChildAt(i)) &#123;</div><div class=\"line\">        mTotalLength += mDividerHeight;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class=\"line\"></div><div class=\"line\">    totalWeight += lp.weight;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class=\"number\">0</span> &amp;&amp; lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// Optimization: don't bother measuring children who are going to use</span></div><div class=\"line\">        <span class=\"comment\">// leftover space. These views will get measured again down below if</span></div><div class=\"line\">        <span class=\"comment\">// there is any leftover space.</span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> totalLength = mTotalLength;</div><div class=\"line\">        mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</div><div class=\"line\">        skippedMeasure = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> oldHeight = Integer.MIN_VALUE;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (lp.height == <span class=\"number\">0</span> &amp;&amp; lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></div><div class=\"line\">            <span class=\"comment\">// child wanted to stretch to fill available space.</span></div><div class=\"line\">            <span class=\"comment\">// Translate that to WRAP_CONTENT so that it does not end up</span></div><div class=\"line\">            <span class=\"comment\">// with a height of 0</span></div><div class=\"line\">            oldHeight = <span class=\"number\">0</span>;</div><div class=\"line\">            lp.height = LayoutParams.WRAP_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Determine how big this child would like to be. If this or</span></div><div class=\"line\">        <span class=\"comment\">// previous children have given a weight, then we allow it to</span></div><div class=\"line\">        <span class=\"comment\">// use all available space (and we will shrink things later</span></div><div class=\"line\">        <span class=\"comment\">// if needed).</span></div><div class=\"line\">        measureChildBeforeLayout(</div><div class=\"line\">               child, i, widthMeasureSpec, <span class=\"number\">0</span>, heightMeasureSpec,</div><div class=\"line\">               totalWeight == <span class=\"number\">0</span> ? mTotalLength : <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</div><div class=\"line\">           lp.height = oldHeight;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeight = child.getMeasuredHeight();</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> totalLength = mTotalLength;</div><div class=\"line\">        mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</div><div class=\"line\">               lp.bottomMargin + getNextLocationOffset(child));</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (useLargestChild) &#123;</div><div class=\"line\">            largestChildHeight = Math.max(childHeight, largestChildHeight);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * If applicable, compute the additional offset to the child's baseline</div><div class=\"line\">     * we'll need later when asked &#123;<span class=\"doctag\">@link</span> #getBaseline&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">if</span> ((baselineChildIndex &gt;= <span class=\"number\">0</span>) &amp;&amp; (baselineChildIndex == i + <span class=\"number\">1</span>)) &#123;</div><div class=\"line\">       mBaselineChildTop = mTotalLength;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// if we are trying to use a child index for our baseline, the above</span></div><div class=\"line\">    <span class=\"comment\">// book keeping only works if there are no children above it with</span></div><div class=\"line\">    <span class=\"comment\">// weight.  fail fast to aid the developer.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"A child of LinearLayout with index \"</span></div><div class=\"line\">                + <span class=\"string\">\"less than mBaselineAlignedChildIndex has weight &gt; 0, which \"</span></div><div class=\"line\">                + <span class=\"string\">\"won't work.  Either remove the weight, or don't set \"</span></div><div class=\"line\">                + <span class=\"string\">\"mBaselineAlignedChildIndex.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">boolean</span> matchWidthLocally = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">        <span class=\"comment\">// The width of the linear layout will scale, and at least one</span></div><div class=\"line\">        <span class=\"comment\">// child said it wanted to match our width. Set a flag</span></div><div class=\"line\">        <span class=\"comment\">// indicating that we need to remeasure at least that view when</span></div><div class=\"line\">        <span class=\"comment\">// we know our width.</span></div><div class=\"line\">        matchWidth = <span class=\"keyword\">true</span>;</div><div class=\"line\">        matchWidthLocally = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> margin = lp.leftMargin + lp.rightMargin;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> measuredWidth = child.getMeasuredWidth() + margin;</div><div class=\"line\">    maxWidth = Math.max(maxWidth, measuredWidth);</div><div class=\"line\">    childState = combineMeasuredStates(childState, child.getMeasuredState());</div><div class=\"line\"></div><div class=\"line\">    allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lp.weight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">/*</span></div><div class=\"line\">         * Widths of weighted Views are bogus if we end up</div><div class=\"line\">         * remeasuring, so keep them separate.</div><div class=\"line\">         */</div><div class=\"line\">        weightedMaxWidth = Math.max(weightedMaxWidth,</div><div class=\"line\">                matchWidthLocally ? margin : measuredWidth);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</div><div class=\"line\">                matchWidthLocally ? margin : measuredWidth);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    i += getChildrenSkipCount(child, i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法主要是for循环中通过<code>measureChildBeforeLayout</code>测量子View高度，把每次测量的高度都累加到<code>mTotalLength</code>。</p>\n<h1 id=\"0x03-RelativeLayout分析\"><a href=\"#0x03-RelativeLayout分析\" class=\"headerlink\" title=\"0x03 RelativeLayout分析\"></a>0x03 RelativeLayout分析</h1><p>看看RelativeLayout的onMeasure方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">View[] views = mSortedHorizontalChildren;</div><div class=\"line\"> <span class=\"keyword\">int</span> count = views.length;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">     View child = views[i];</div><div class=\"line\">     <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</div><div class=\"line\">         LayoutParams params = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">         <span class=\"keyword\">int</span>[] rules = params.getRules(layoutDirection);</div><div class=\"line\"></div><div class=\"line\">         applyHorizontalSizeRules(params, myWidth, rules);</div><div class=\"line\">         measureChildHorizontal(child, params, myWidth, myHeight);</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123;</div><div class=\"line\">             offsetHorizontalAxis = <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> views = mSortedVerticalChildren;</div><div class=\"line\"> count = views.length;</div><div class=\"line\"> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">     View child = views[i];</div><div class=\"line\">     <span class=\"keyword\">if</span> (child.getVisibility() != GONE) &#123;</div><div class=\"line\">         LayoutParams params = (LayoutParams) child.getLayoutParams();</div><div class=\"line\">         </div><div class=\"line\">         applyVerticalSizeRules(params, myHeight);</div><div class=\"line\">         measureChild(child, params, myWidth, myHeight);</div><div class=\"line\">         <span class=\"keyword\">if</span> (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123;</div><div class=\"line\">             offsetVerticalAxis = <span class=\"keyword\">true</span>;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (isWrapContentWidth) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (isLayoutRtl()) &#123;</div><div class=\"line\">                 <span class=\"keyword\">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</div><div class=\"line\">                     width = Math.max(width, myWidth - params.mLeft);</div><div class=\"line\">                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                     width = Math.max(width, myWidth - params.mLeft - params.leftMargin);</div><div class=\"line\">                 &#125;</div><div class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                 <span class=\"keyword\">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</div><div class=\"line\">                     width = Math.max(width, params.mRight);</div><div class=\"line\">                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                     width = Math.max(width, params.mRight + params.rightMargin);</div><div class=\"line\">                 &#125;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (isWrapContentHeight) &#123;</div><div class=\"line\">             <span class=\"keyword\">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123;</div><div class=\"line\">                 height = Math.max(height, params.mBottom);</div><div class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                 height = Math.max(height, params.mBottom + params.bottomMargin);</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (child != ignore || verticalGravity) &#123;</div><div class=\"line\">             left = Math.min(left, params.mLeft - params.leftMargin);</div><div class=\"line\">             top = Math.min(top, params.mTop - params.topMargin);</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         <span class=\"keyword\">if</span> (child != ignore || horizontalGravity) &#123;</div><div class=\"line\">             right = Math.max(right, params.mRight + params.rightMargin);</div><div class=\"line\">             bottom = Math.max(bottom, params.mBottom + params.bottomMargin);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>第一个for循环中<code>measureChildHorizontal</code>方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,</div><div class=\"line\">           params.mRight, params.width,</div><div class=\"line\">           params.leftMargin, params.rightMargin,</div><div class=\"line\">           mPaddingLeft, mPaddingRight,</div><div class=\"line\">           myWidth);</div><div class=\"line\">   <span class=\"keyword\">int</span> maxHeight = myHeight;</div><div class=\"line\">   <span class=\"keyword\">if</span> (mMeasureVerticalWithPaddingMargin) &#123;</div><div class=\"line\">       maxHeight = Math.max(<span class=\"number\">0</span>, myHeight - mPaddingTop - mPaddingBottom -</div><div class=\"line\">               params.topMargin - params.bottomMargin);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">int</span> childHeightMeasureSpec;</div><div class=\"line\">   <span class=\"keyword\">if</span> (myHeight &lt; <span class=\"number\">0</span> &amp;&amp; !mAllowBrokenMeasureSpecs) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (params.height &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">           childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</div><div class=\"line\">                   params.height, MeasureSpec.EXACTLY);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"comment\">// Negative values in a mySize/myWidth/myWidth value in RelativeLayout measurement</span></div><div class=\"line\">           <span class=\"comment\">// is code for, \"we got an unspecified mode in the RelativeLayout's measurespec.\"</span></div><div class=\"line\">           <span class=\"comment\">// Carry it forward.</span></div><div class=\"line\">           childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class=\"number\">0</span>, MeasureSpec.UNSPECIFIED);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (params.width == LayoutParams.MATCH_PARENT) &#123;</div><div class=\"line\">       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY);</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.AT_MOST);</div><div class=\"line\">   &#125;</div><div class=\"line\">   child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>\n<p>第二个for循环中<code>measureChild</code>实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,</div><div class=\"line\">                params.mRight, params.width,</div><div class=\"line\">                params.leftMargin, params.rightMargin,</div><div class=\"line\">                mPaddingLeft, mPaddingRight,</div><div class=\"line\">                myWidth);</div><div class=\"line\">        <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(params.mTop,</div><div class=\"line\">                params.mBottom, params.height,</div><div class=\"line\">                params.topMargin, params.bottomMargin,</div><div class=\"line\">                mPaddingTop, mPaddingBottom,</div><div class=\"line\">                myHeight);</div><div class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure>\n<p>两个for循环中都执行了<code>child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</code>这意味着子View测量执行了两遍。</p>\n<p>为什么RelativeLayout要测量两遍？</p>\n<blockquote>\n<p>因为RelativeLayout并不像LinearLayout那样有着方向单一性。RelativeLayout的灵活性就在于允许纵横双向的，这样view直接不仅横向依赖，还有纵向依赖，每个方向都要测量一遍。导致性能略差。</p>\n</blockquote>\n"},{"title":"农夫带着狼、羊和白菜过河问题","date":"2017-05-10T09:55:25.000Z","_content":"\n一个农夫带着一只狼，一只羊和一棵白菜来到河边要过河，船只狭小，一次农夫只能带一样物品过河，如果农夫不在场，狼会吃羊，羊也会吃白菜。那么农夫如何才能过河或者证明出无解。\n\n\n\n这是一道自古有之的谜题，但是一些公司也有把这作为笔试题...\n\n看到这个题我的第一个想法就是船上系一根绳，把狼和白菜一起放船上，待漂到对岸后再用绳子拉过来，然后农夫抱着羊过河。不过这太投机取巧了啊哈哈。还是来点务实的吧：\n\n\n\n务实的想法就是要农夫一直和船一起。毕竟不能指望顺风船自动漂对岸然后狼羊白菜自动下船吧。\n\n食物链是这样的：狼>羊>白菜\n\n农夫只要离开，食物链就会发生吞食，所以要让食物链隔开。\n\n那么第一步做法就明白了：必须带羊过河~~\n\n我们假设A为现在所在岸边，B为目的岸边\n\n\n\n| 步骤        | A    | B      |\n| --------- | ---- | ------ |\n| ①农夫带着羊过河  | 狼和白菜 | 羊      |\n| ②农夫独自返回A  |      |        |\n| ③农夫带着白菜过河 | 狼    | 羊和白菜   |\n| ④农夫带着羊返回  | 羊和狼  | 白菜     |\n| ⑤农夫带着狼过河  | 羊    | 白菜和狼   |\n| ⑥农夫独自返回A  |      |        |\n| ⑦农夫带着羊过河  |      | 白菜、狼和羊 |\n\n\n\n其实这个解法不是唯一的。\n\n虽然第一步都是要带着羊过河，但是第三步带着白菜和带狼都是可以的。\n\n| 步骤        | A    | B      |\n| --------- | ---- | ------ |\n| ③农夫带着狼过河  | 白菜   | 羊和狼    |\n| ④农夫带着羊返回A | 白菜和羊 | 狼      |\n| ⑤农夫带着白菜过河 | 羊    | 狼和白菜   |\n| ⑥农夫独自返回A  |      |        |\n| ⑦农夫带着羊过河  |      | 狼、白菜和羊 |\n|           |      |        |\n\n\n\n","source":"_posts/农夫带着狼、羊和白菜过河问题.md","raw":"---\ntitle: 农夫带着狼、羊和白菜过河问题\ndate: 2017-05-10 17:55:25\ntags: 趣题\ncategories: 趣题\n---\n\n一个农夫带着一只狼，一只羊和一棵白菜来到河边要过河，船只狭小，一次农夫只能带一样物品过河，如果农夫不在场，狼会吃羊，羊也会吃白菜。那么农夫如何才能过河或者证明出无解。\n\n\n\n这是一道自古有之的谜题，但是一些公司也有把这作为笔试题...\n\n看到这个题我的第一个想法就是船上系一根绳，把狼和白菜一起放船上，待漂到对岸后再用绳子拉过来，然后农夫抱着羊过河。不过这太投机取巧了啊哈哈。还是来点务实的吧：\n\n\n\n务实的想法就是要农夫一直和船一起。毕竟不能指望顺风船自动漂对岸然后狼羊白菜自动下船吧。\n\n食物链是这样的：狼>羊>白菜\n\n农夫只要离开，食物链就会发生吞食，所以要让食物链隔开。\n\n那么第一步做法就明白了：必须带羊过河~~\n\n我们假设A为现在所在岸边，B为目的岸边\n\n\n\n| 步骤        | A    | B      |\n| --------- | ---- | ------ |\n| ①农夫带着羊过河  | 狼和白菜 | 羊      |\n| ②农夫独自返回A  |      |        |\n| ③农夫带着白菜过河 | 狼    | 羊和白菜   |\n| ④农夫带着羊返回  | 羊和狼  | 白菜     |\n| ⑤农夫带着狼过河  | 羊    | 白菜和狼   |\n| ⑥农夫独自返回A  |      |        |\n| ⑦农夫带着羊过河  |      | 白菜、狼和羊 |\n\n\n\n其实这个解法不是唯一的。\n\n虽然第一步都是要带着羊过河，但是第三步带着白菜和带狼都是可以的。\n\n| 步骤        | A    | B      |\n| --------- | ---- | ------ |\n| ③农夫带着狼过河  | 白菜   | 羊和狼    |\n| ④农夫带着羊返回A | 白菜和羊 | 狼      |\n| ⑤农夫带着白菜过河 | 羊    | 狼和白菜   |\n| ⑥农夫独自返回A  |      |        |\n| ⑦农夫带着羊过河  |      | 狼、白菜和羊 |\n|           |      |        |\n\n\n\n","slug":"农夫带着狼、羊和白菜过河问题","published":1,"updated":"2017-05-10T16:19:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjiq006pwh9cb7819vws","content":"<p>一个农夫带着一只狼，一只羊和一棵白菜来到河边要过河，船只狭小，一次农夫只能带一样物品过河，如果农夫不在场，狼会吃羊，羊也会吃白菜。那么农夫如何才能过河或者证明出无解。</p>\n<p>这是一道自古有之的谜题，但是一些公司也有把这作为笔试题…</p>\n<p>看到这个题我的第一个想法就是船上系一根绳，把狼和白菜一起放船上，待漂到对岸后再用绳子拉过来，然后农夫抱着羊过河。不过这太投机取巧了啊哈哈。还是来点务实的吧：</p>\n<p>务实的想法就是要农夫一直和船一起。毕竟不能指望顺风船自动漂对岸然后狼羊白菜自动下船吧。</p>\n<p>食物链是这样的：狼&gt;羊&gt;白菜</p>\n<p>农夫只要离开，食物链就会发生吞食，所以要让食物链隔开。</p>\n<p>那么第一步做法就明白了：必须带羊过河~~</p>\n<p>我们假设A为现在所在岸边，B为目的岸边</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>①农夫带着羊过河</td>\n<td>狼和白菜</td>\n<td>羊</td>\n</tr>\n<tr>\n<td>②农夫独自返回A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>③农夫带着白菜过河</td>\n<td>狼</td>\n<td>羊和白菜</td>\n</tr>\n<tr>\n<td>④农夫带着羊返回</td>\n<td>羊和狼</td>\n<td>白菜</td>\n</tr>\n<tr>\n<td>⑤农夫带着狼过河</td>\n<td>羊</td>\n<td>白菜和狼</td>\n</tr>\n<tr>\n<td>⑥农夫独自返回A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>⑦农夫带着羊过河</td>\n<td></td>\n<td>白菜、狼和羊</td>\n</tr>\n</tbody>\n</table>\n<p>其实这个解法不是唯一的。</p>\n<p>虽然第一步都是要带着羊过河，但是第三步带着白菜和带狼都是可以的。</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>③农夫带着狼过河</td>\n<td>白菜</td>\n<td>羊和狼</td>\n</tr>\n<tr>\n<td>④农夫带着羊返回A</td>\n<td>白菜和羊</td>\n<td>狼</td>\n</tr>\n<tr>\n<td>⑤农夫带着白菜过河</td>\n<td>羊</td>\n<td>狼和白菜</td>\n</tr>\n<tr>\n<td>⑥农夫独自返回A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>⑦农夫带着羊过河</td>\n<td></td>\n<td>狼、白菜和羊</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p>一个农夫带着一只狼，一只羊和一棵白菜来到河边要过河，船只狭小，一次农夫只能带一样物品过河，如果农夫不在场，狼会吃羊，羊也会吃白菜。那么农夫如何才能过河或者证明出无解。</p>\n<p>这是一道自古有之的谜题，但是一些公司也有把这作为笔试题…</p>\n<p>看到这个题我的第一个想法就是船上系一根绳，把狼和白菜一起放船上，待漂到对岸后再用绳子拉过来，然后农夫抱着羊过河。不过这太投机取巧了啊哈哈。还是来点务实的吧：</p>\n<p>务实的想法就是要农夫一直和船一起。毕竟不能指望顺风船自动漂对岸然后狼羊白菜自动下船吧。</p>\n<p>食物链是这样的：狼&gt;羊&gt;白菜</p>\n<p>农夫只要离开，食物链就会发生吞食，所以要让食物链隔开。</p>\n<p>那么第一步做法就明白了：必须带羊过河~~</p>\n<p>我们假设A为现在所在岸边，B为目的岸边</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>①农夫带着羊过河</td>\n<td>狼和白菜</td>\n<td>羊</td>\n</tr>\n<tr>\n<td>②农夫独自返回A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>③农夫带着白菜过河</td>\n<td>狼</td>\n<td>羊和白菜</td>\n</tr>\n<tr>\n<td>④农夫带着羊返回</td>\n<td>羊和狼</td>\n<td>白菜</td>\n</tr>\n<tr>\n<td>⑤农夫带着狼过河</td>\n<td>羊</td>\n<td>白菜和狼</td>\n</tr>\n<tr>\n<td>⑥农夫独自返回A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>⑦农夫带着羊过河</td>\n<td></td>\n<td>白菜、狼和羊</td>\n</tr>\n</tbody>\n</table>\n<p>其实这个解法不是唯一的。</p>\n<p>虽然第一步都是要带着羊过河，但是第三步带着白菜和带狼都是可以的。</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>③农夫带着狼过河</td>\n<td>白菜</td>\n<td>羊和狼</td>\n</tr>\n<tr>\n<td>④农夫带着羊返回A</td>\n<td>白菜和羊</td>\n<td>狼</td>\n</tr>\n<tr>\n<td>⑤农夫带着白菜过河</td>\n<td>羊</td>\n<td>狼和白菜</td>\n</tr>\n<tr>\n<td>⑥农夫独自返回A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>⑦农夫带着羊过河</td>\n<td></td>\n<td>狼、白菜和羊</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"四个人过桥问题","date":"2017-05-11T07:55:37.000Z","_content":"\n有甲乙丙丁4个人要过桥，他们都在桥一端，他们只有17分钟时间过桥。时间在晚上，过桥需要用到手电筒，而且手电筒必须来回都用到且手电筒不能扔来扔去，一次只能有2个人同时过桥。每个人走路速度不同，甲过桥需要1分钟，乙过桥需要2分钟，丙过桥需要5分钟，丁过桥需要10分钟。两个人一起走路，速度决定于走的慢的那个。请你给这四人规划合适的搭配过桥。\n\n\n\n\n\n看到这道题脑子第一想法是：5和10分钟不能分开，如果分开，这俩人就占了15分钟。然而刚让这俩一起过桥，然后就让5分钟的哥们拿着手电筒回来了~~~一脸懵逼试了好几种都没有通过。后来发现我又被自己看问题角度给局限住了，每2个人过桥后，就一直一门心思的让刚过来的2个人中的一个人送手电筒返回，其实送手电筒的这个人只要在同一岸边的就行。说到这里，答案以及开始浮出水面了：\n\n\n\n| 步骤              | A    | B    |\n| --------------- | ---- | ---- |\n| ①甲和乙一起过河，花费2分钟  | 丙丁   | 甲乙   |\n| ②甲带手电筒返回，花费1分钟  | 甲丙丁  | 乙    |\n| ③丙和丁一起过河，花费10分钟 | 甲    | 乙丙丁  |\n| ④乙带手电筒返回，花费2分钟  | 甲乙   | 丙丁   |\n| ⑤甲和乙一起过河，花费2分钟  |      | 甲乙丙丁 |\n\n\n\n上面5个步骤刚好四人全部过桥，花费时间17分钟，当然②中也可以由乙带手电筒返回，不过④要由甲带手电筒。这样也是17分钟，其他时间应该是大于17分钟的。\n\n> 其实这道题和农夫过河一样，都不难，只要看问题时，眼界要能钻进问题角落深入分析，又能抽出眼界，站在一定高度俯视问题全局。\n\n\n\n网上据说这道题在西雅图一个有名软件公司的考官面试时也出过这道题，怎么样你答对了吗？","source":"_posts/四个人过桥问题.md","raw":"---\ntitle: 四个人过桥问题\ndate: 2017-05-11 15:55:37\ntags: 趣题\ncategories: 趣题\n---\n\n有甲乙丙丁4个人要过桥，他们都在桥一端，他们只有17分钟时间过桥。时间在晚上，过桥需要用到手电筒，而且手电筒必须来回都用到且手电筒不能扔来扔去，一次只能有2个人同时过桥。每个人走路速度不同，甲过桥需要1分钟，乙过桥需要2分钟，丙过桥需要5分钟，丁过桥需要10分钟。两个人一起走路，速度决定于走的慢的那个。请你给这四人规划合适的搭配过桥。\n\n\n\n\n\n看到这道题脑子第一想法是：5和10分钟不能分开，如果分开，这俩人就占了15分钟。然而刚让这俩一起过桥，然后就让5分钟的哥们拿着手电筒回来了~~~一脸懵逼试了好几种都没有通过。后来发现我又被自己看问题角度给局限住了，每2个人过桥后，就一直一门心思的让刚过来的2个人中的一个人送手电筒返回，其实送手电筒的这个人只要在同一岸边的就行。说到这里，答案以及开始浮出水面了：\n\n\n\n| 步骤              | A    | B    |\n| --------------- | ---- | ---- |\n| ①甲和乙一起过河，花费2分钟  | 丙丁   | 甲乙   |\n| ②甲带手电筒返回，花费1分钟  | 甲丙丁  | 乙    |\n| ③丙和丁一起过河，花费10分钟 | 甲    | 乙丙丁  |\n| ④乙带手电筒返回，花费2分钟  | 甲乙   | 丙丁   |\n| ⑤甲和乙一起过河，花费2分钟  |      | 甲乙丙丁 |\n\n\n\n上面5个步骤刚好四人全部过桥，花费时间17分钟，当然②中也可以由乙带手电筒返回，不过④要由甲带手电筒。这样也是17分钟，其他时间应该是大于17分钟的。\n\n> 其实这道题和农夫过河一样，都不难，只要看问题时，眼界要能钻进问题角落深入分析，又能抽出眼界，站在一定高度俯视问题全局。\n\n\n\n网上据说这道题在西雅图一个有名软件公司的考官面试时也出过这道题，怎么样你答对了吗？","slug":"四个人过桥问题","published":1,"updated":"2017-05-11T11:50:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjj9006swh9c77akhy20","content":"<p>有甲乙丙丁4个人要过桥，他们都在桥一端，他们只有17分钟时间过桥。时间在晚上，过桥需要用到手电筒，而且手电筒必须来回都用到且手电筒不能扔来扔去，一次只能有2个人同时过桥。每个人走路速度不同，甲过桥需要1分钟，乙过桥需要2分钟，丙过桥需要5分钟，丁过桥需要10分钟。两个人一起走路，速度决定于走的慢的那个。请你给这四人规划合适的搭配过桥。</p>\n<p>看到这道题脑子第一想法是：5和10分钟不能分开，如果分开，这俩人就占了15分钟。然而刚让这俩一起过桥，然后就让5分钟的哥们拿着手电筒回来了~~~一脸懵逼试了好几种都没有通过。后来发现我又被自己看问题角度给局限住了，每2个人过桥后，就一直一门心思的让刚过来的2个人中的一个人送手电筒返回，其实送手电筒的这个人只要在同一岸边的就行。说到这里，答案以及开始浮出水面了：</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>①甲和乙一起过河，花费2分钟</td>\n<td>丙丁</td>\n<td>甲乙</td>\n</tr>\n<tr>\n<td>②甲带手电筒返回，花费1分钟</td>\n<td>甲丙丁</td>\n<td>乙</td>\n</tr>\n<tr>\n<td>③丙和丁一起过河，花费10分钟</td>\n<td>甲</td>\n<td>乙丙丁</td>\n</tr>\n<tr>\n<td>④乙带手电筒返回，花费2分钟</td>\n<td>甲乙</td>\n<td>丙丁</td>\n</tr>\n<tr>\n<td>⑤甲和乙一起过河，花费2分钟</td>\n<td></td>\n<td>甲乙丙丁</td>\n</tr>\n</tbody>\n</table>\n<p>上面5个步骤刚好四人全部过桥，花费时间17分钟，当然②中也可以由乙带手电筒返回，不过④要由甲带手电筒。这样也是17分钟，其他时间应该是大于17分钟的。</p>\n<blockquote>\n<p>其实这道题和农夫过河一样，都不难，只要看问题时，眼界要能钻进问题角落深入分析，又能抽出眼界，站在一定高度俯视问题全局。</p>\n</blockquote>\n<p>网上据说这道题在西雅图一个有名软件公司的考官面试时也出过这道题，怎么样你答对了吗？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有甲乙丙丁4个人要过桥，他们都在桥一端，他们只有17分钟时间过桥。时间在晚上，过桥需要用到手电筒，而且手电筒必须来回都用到且手电筒不能扔来扔去，一次只能有2个人同时过桥。每个人走路速度不同，甲过桥需要1分钟，乙过桥需要2分钟，丙过桥需要5分钟，丁过桥需要10分钟。两个人一起走路，速度决定于走的慢的那个。请你给这四人规划合适的搭配过桥。</p>\n<p>看到这道题脑子第一想法是：5和10分钟不能分开，如果分开，这俩人就占了15分钟。然而刚让这俩一起过桥，然后就让5分钟的哥们拿着手电筒回来了~~~一脸懵逼试了好几种都没有通过。后来发现我又被自己看问题角度给局限住了，每2个人过桥后，就一直一门心思的让刚过来的2个人中的一个人送手电筒返回，其实送手电筒的这个人只要在同一岸边的就行。说到这里，答案以及开始浮出水面了：</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>A</th>\n<th>B</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>①甲和乙一起过河，花费2分钟</td>\n<td>丙丁</td>\n<td>甲乙</td>\n</tr>\n<tr>\n<td>②甲带手电筒返回，花费1分钟</td>\n<td>甲丙丁</td>\n<td>乙</td>\n</tr>\n<tr>\n<td>③丙和丁一起过河，花费10分钟</td>\n<td>甲</td>\n<td>乙丙丁</td>\n</tr>\n<tr>\n<td>④乙带手电筒返回，花费2分钟</td>\n<td>甲乙</td>\n<td>丙丁</td>\n</tr>\n<tr>\n<td>⑤甲和乙一起过河，花费2分钟</td>\n<td></td>\n<td>甲乙丙丁</td>\n</tr>\n</tbody>\n</table>\n<p>上面5个步骤刚好四人全部过桥，花费时间17分钟，当然②中也可以由乙带手电筒返回，不过④要由甲带手电筒。这样也是17分钟，其他时间应该是大于17分钟的。</p>\n<blockquote>\n<p>其实这道题和农夫过河一样，都不难，只要看问题时，眼界要能钻进问题角落深入分析，又能抽出眼界，站在一定高度俯视问题全局。</p>\n</blockquote>\n<p>网上据说这道题在西雅图一个有名软件公司的考官面试时也出过这道题，怎么样你答对了吗？</p>\n"},{"title":"如何知道下载好的aosp版本？","date":"2017-04-21T12:55:54.000Z","_content":"下载源码时执行的是\n\n```\nrepo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest\n\n```\n\n没有写上分支然后就直接同步了，下载完了不知道版本是多少。\n在\n\n```\n找到 build/make/core/version_defaults.mk文件打开\n搜索 PLATFORM_SDK_VERSION\n找到了   PLATFORM_SDK_VERSION := 25\nsdk版本知道了晓得原来是最新的7.1\n```","source":"_posts/如何知道下载好的aosp版本.md","raw":"---\ntitle: 如何知道下载好的aosp版本？\ndate: 2017-04-21 20:55:54\ntags: Android\ncategories: Android\n---\n下载源码时执行的是\n\n```\nrepo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest\n\n```\n\n没有写上分支然后就直接同步了，下载完了不知道版本是多少。\n在\n\n```\n找到 build/make/core/version_defaults.mk文件打开\n搜索 PLATFORM_SDK_VERSION\n找到了   PLATFORM_SDK_VERSION := 25\nsdk版本知道了晓得原来是最新的7.1\n```","slug":"如何知道下载好的aosp版本","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjd006xwh9cqeqluefd","content":"<p>下载源码时执行的是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest</div></pre></td></tr></table></figure>\n<p>没有写上分支然后就直接同步了，下载完了不知道版本是多少。<br>在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">找到 build/make/core/version_defaults.mk文件打开</div><div class=\"line\">搜索 PLATFORM_SDK_VERSION</div><div class=\"line\">找到了   PLATFORM_SDK_VERSION := 25</div><div class=\"line\">sdk版本知道了晓得原来是最新的7.1</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>下载源码时执行的是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest</div></pre></td></tr></table></figure>\n<p>没有写上分支然后就直接同步了，下载完了不知道版本是多少。<br>在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">找到 build/make/core/version_defaults.mk文件打开</div><div class=\"line\">搜索 PLATFORM_SDK_VERSION</div><div class=\"line\">找到了   PLATFORM_SDK_VERSION := 25</div><div class=\"line\">sdk版本知道了晓得原来是最新的7.1</div></pre></td></tr></table></figure>"},{"title":"搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼","date":"2017-04-21T12:55:54.000Z","_content":">一直以来对这几个SDK版本概念都有点模糊不清，对于API的使用又会产生什么样的影响。所以今天花点时间来记录下。\n\n\n\n![屏幕快照 2017-04-19 下午12.09.45.png](http://upload-images.jianshu.io/upload_images/1796052-947f3215a5f6169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### minSDKVersion\n顾名思义是设置sdk最低版本的。作用就是操作系统会拒绝低于\n该标准的APP的安装。\n\n例如，minSDKVersion设置为16(Jelly Bean 4.1系统)，那么该APP将只能运行在4.1系统以上的设备中，想要在2.3系统上安装是不被允许的。\n\nminSDKVersion比较容易理解，经常让我混淆的时其他两个版本设置会对API产生的影响。\n\n#### targetSDKVersion\ntargetSDKVersion就是设置SDK目标版本，目标版本的设置就是为了告诉Android系统：本APP是设计计划给哪个API级别运行的。\n\n一般情况下目标版本设置为当前Android最新版本即可。既然是一般那也就有特殊情况，什么情况下需要修改目标版本呢？\n\n如果新发布的SDK版本会对UI显示甚至操作系统运行机制产生影响，而你的APP又没有做好应对措施，为了保证你的APP正常运行，那你需要降低目标版本。因为你的目标版本仍然是旧的SDK，所以在新版系统中那些新的变化会在你的APP中被忽略，继而保证其正常运行。\n\n例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。\n\n#### compileSDKVersion\ncompileSDKVersion是设置编译版本。\n\n一般来说编译目标版本是选择最新的SDK，这样可以及时使用体验到新的API提供的新功能。\n\n值得注意的是，如果minSDKVersion和compileSDKVersion版本差距比较大的话，可能会造成API的不兼容。例如，你的最低版本是2.3 ，但是编译版本是5.0，API中使用了4.0SDK提供的一些新API，这样的后果是在2.3系统中运行到该处代码时会发生异常崩溃。这是因为代码的不兼容造成的。如图：\n\n![屏幕快照 2017-04-19 下午1.05.00.png](http://upload-images.jianshu.io/upload_images/1796052-67bfb13669a8dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如何解决这种API的不兼容呢？\n一种办法是提升minSDKVersion到新API使用的SDK版本，但是这种方法只是回避兼容性，并没有确实解决问题，而且还要放弃低版本部分市场。\n比较好的做法是在使用新API地方做设备版本的检查。Build.VERSION_SDK_INT常量表示当前Android设备的版本号。可以将该常量同新API版本进行比较，如果版本大于等于新版API版本号，则正常使用新API功能，否则使用旧的调用。兼容设置如下：\n\n![屏幕快照 2017-04-19 下午1.16.40.png](http://upload-images.jianshu.io/upload_images/1796052-a2d7e548c4a118cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>注意：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。\n","source":"_posts/搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼.md","raw":"---\ntitle: 搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼\ndate: 2017-04-21 20:55:54\ntags: Android\ncategories: Android\n---\n>一直以来对这几个SDK版本概念都有点模糊不清，对于API的使用又会产生什么样的影响。所以今天花点时间来记录下。\n\n\n\n![屏幕快照 2017-04-19 下午12.09.45.png](http://upload-images.jianshu.io/upload_images/1796052-947f3215a5f6169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### minSDKVersion\n顾名思义是设置sdk最低版本的。作用就是操作系统会拒绝低于\n该标准的APP的安装。\n\n例如，minSDKVersion设置为16(Jelly Bean 4.1系统)，那么该APP将只能运行在4.1系统以上的设备中，想要在2.3系统上安装是不被允许的。\n\nminSDKVersion比较容易理解，经常让我混淆的时其他两个版本设置会对API产生的影响。\n\n#### targetSDKVersion\ntargetSDKVersion就是设置SDK目标版本，目标版本的设置就是为了告诉Android系统：本APP是设计计划给哪个API级别运行的。\n\n一般情况下目标版本设置为当前Android最新版本即可。既然是一般那也就有特殊情况，什么情况下需要修改目标版本呢？\n\n如果新发布的SDK版本会对UI显示甚至操作系统运行机制产生影响，而你的APP又没有做好应对措施，为了保证你的APP正常运行，那你需要降低目标版本。因为你的目标版本仍然是旧的SDK，所以在新版系统中那些新的变化会在你的APP中被忽略，继而保证其正常运行。\n\n例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。\n\n#### compileSDKVersion\ncompileSDKVersion是设置编译版本。\n\n一般来说编译目标版本是选择最新的SDK，这样可以及时使用体验到新的API提供的新功能。\n\n值得注意的是，如果minSDKVersion和compileSDKVersion版本差距比较大的话，可能会造成API的不兼容。例如，你的最低版本是2.3 ，但是编译版本是5.0，API中使用了4.0SDK提供的一些新API，这样的后果是在2.3系统中运行到该处代码时会发生异常崩溃。这是因为代码的不兼容造成的。如图：\n\n![屏幕快照 2017-04-19 下午1.05.00.png](http://upload-images.jianshu.io/upload_images/1796052-67bfb13669a8dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如何解决这种API的不兼容呢？\n一种办法是提升minSDKVersion到新API使用的SDK版本，但是这种方法只是回避兼容性，并没有确实解决问题，而且还要放弃低版本部分市场。\n比较好的做法是在使用新API地方做设备版本的检查。Build.VERSION_SDK_INT常量表示当前Android设备的版本号。可以将该常量同新API版本进行比较，如果版本大于等于新版API版本号，则正常使用新API功能，否则使用旧的调用。兼容设置如下：\n\n![屏幕快照 2017-04-19 下午1.16.40.png](http://upload-images.jianshu.io/upload_images/1796052-a2d7e548c4a118cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>注意：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。\n","slug":"搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjg0070wh9cj6ch8vv2","content":"<blockquote>\n<p>一直以来对这几个SDK版本概念都有点模糊不清，对于API的使用又会产生什么样的影响。所以今天花点时间来记录下。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-947f3215a5f6169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-19 下午12.09.45.png\"></p>\n<h4 id=\"minSDKVersion\"><a href=\"#minSDKVersion\" class=\"headerlink\" title=\"minSDKVersion\"></a>minSDKVersion</h4><p>顾名思义是设置sdk最低版本的。作用就是操作系统会拒绝低于<br>该标准的APP的安装。</p>\n<p>例如，minSDKVersion设置为16(Jelly Bean 4.1系统)，那么该APP将只能运行在4.1系统以上的设备中，想要在2.3系统上安装是不被允许的。</p>\n<p>minSDKVersion比较容易理解，经常让我混淆的时其他两个版本设置会对API产生的影响。</p>\n<h4 id=\"targetSDKVersion\"><a href=\"#targetSDKVersion\" class=\"headerlink\" title=\"targetSDKVersion\"></a>targetSDKVersion</h4><p>targetSDKVersion就是设置SDK目标版本，目标版本的设置就是为了告诉Android系统：本APP是设计计划给哪个API级别运行的。</p>\n<p>一般情况下目标版本设置为当前Android最新版本即可。既然是一般那也就有特殊情况，什么情况下需要修改目标版本呢？</p>\n<p>如果新发布的SDK版本会对UI显示甚至操作系统运行机制产生影响，而你的APP又没有做好应对措施，为了保证你的APP正常运行，那你需要降低目标版本。因为你的目标版本仍然是旧的SDK，所以在新版系统中那些新的变化会在你的APP中被忽略，继而保证其正常运行。</p>\n<p>例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。</p>\n<h4 id=\"compileSDKVersion\"><a href=\"#compileSDKVersion\" class=\"headerlink\" title=\"compileSDKVersion\"></a>compileSDKVersion</h4><p>compileSDKVersion是设置编译版本。</p>\n<p>一般来说编译目标版本是选择最新的SDK，这样可以及时使用体验到新的API提供的新功能。</p>\n<p>值得注意的是，如果minSDKVersion和compileSDKVersion版本差距比较大的话，可能会造成API的不兼容。例如，你的最低版本是2.3 ，但是编译版本是5.0，API中使用了4.0SDK提供的一些新API，这样的后果是在2.3系统中运行到该处代码时会发生异常崩溃。这是因为代码的不兼容造成的。如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-67bfb13669a8dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-19 下午1.05.00.png\"></p>\n<p>如何解决这种API的不兼容呢？<br>一种办法是提升minSDKVersion到新API使用的SDK版本，但是这种方法只是回避兼容性，并没有确实解决问题，而且还要放弃低版本部分市场。<br>比较好的做法是在使用新API地方做设备版本的检查。Build.VERSION_SDK_INT常量表示当前Android设备的版本号。可以将该常量同新API版本进行比较，如果版本大于等于新版API版本号，则正常使用新API功能，否则使用旧的调用。兼容设置如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a2d7e548c4a118cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-19 下午1.16.40.png\"></p>\n<blockquote>\n<p>注意：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一直以来对这几个SDK版本概念都有点模糊不清，对于API的使用又会产生什么样的影响。所以今天花点时间来记录下。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-947f3215a5f6169e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-19 下午12.09.45.png\"></p>\n<h4 id=\"minSDKVersion\"><a href=\"#minSDKVersion\" class=\"headerlink\" title=\"minSDKVersion\"></a>minSDKVersion</h4><p>顾名思义是设置sdk最低版本的。作用就是操作系统会拒绝低于<br>该标准的APP的安装。</p>\n<p>例如，minSDKVersion设置为16(Jelly Bean 4.1系统)，那么该APP将只能运行在4.1系统以上的设备中，想要在2.3系统上安装是不被允许的。</p>\n<p>minSDKVersion比较容易理解，经常让我混淆的时其他两个版本设置会对API产生的影响。</p>\n<h4 id=\"targetSDKVersion\"><a href=\"#targetSDKVersion\" class=\"headerlink\" title=\"targetSDKVersion\"></a>targetSDKVersion</h4><p>targetSDKVersion就是设置SDK目标版本，目标版本的设置就是为了告诉Android系统：本APP是设计计划给哪个API级别运行的。</p>\n<p>一般情况下目标版本设置为当前Android最新版本即可。既然是一般那也就有特殊情况，什么情况下需要修改目标版本呢？</p>\n<p>如果新发布的SDK版本会对UI显示甚至操作系统运行机制产生影响，而你的APP又没有做好应对措施，为了保证你的APP正常运行，那你需要降低目标版本。因为你的目标版本仍然是旧的SDK，所以在新版系统中那些新的变化会在你的APP中被忽略，继而保证其正常运行。</p>\n<p>例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。</p>\n<h4 id=\"compileSDKVersion\"><a href=\"#compileSDKVersion\" class=\"headerlink\" title=\"compileSDKVersion\"></a>compileSDKVersion</h4><p>compileSDKVersion是设置编译版本。</p>\n<p>一般来说编译目标版本是选择最新的SDK，这样可以及时使用体验到新的API提供的新功能。</p>\n<p>值得注意的是，如果minSDKVersion和compileSDKVersion版本差距比较大的话，可能会造成API的不兼容。例如，你的最低版本是2.3 ，但是编译版本是5.0，API中使用了4.0SDK提供的一些新API，这样的后果是在2.3系统中运行到该处代码时会发生异常崩溃。这是因为代码的不兼容造成的。如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-67bfb13669a8dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-19 下午1.05.00.png\"></p>\n<p>如何解决这种API的不兼容呢？<br>一种办法是提升minSDKVersion到新API使用的SDK版本，但是这种方法只是回避兼容性，并没有确实解决问题，而且还要放弃低版本部分市场。<br>比较好的做法是在使用新API地方做设备版本的检查。Build.VERSION_SDK_INT常量表示当前Android设备的版本号。可以将该常量同新API版本进行比较，如果版本大于等于新版API版本号，则正常使用新API功能，否则使用旧的调用。兼容设置如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-a2d7e548c4a118cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕快照 2017-04-19 下午1.16.40.png\"></p>\n<blockquote>\n<p>注意：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。</p>\n</blockquote>\n"},{"title":"垃圾回收机制~关于GC","date":"2017-07-26T12:25:26.000Z","_content":"\n# 0x00 前言\n\n很多人通过Java才听说GC的，甚至刚开始做开发时以为GC是Java独有的。其实不然，GC是一项很古老的技术，与Lisp语言在20世纪60年代一同出现的。\n\n虽然GC不是Java独有的，但是不得不承认，GC很大成分上是因为Java的广泛应用才被广大开发者所熟知的。\n\n说到GC不得不提一个人：John McCarthy，Lisp语言之父和人工智能之父，同时还是GC之父，其论文中提到的算法就是标记-清除算法。\n\n如果是一门语言可以从基础语法学起，但是GC该如何学习呢？\n\n**其实问答形式就是最好的学习方式**\n\n# 0x01 什么是GC\n\nGC(垃圾回收)，通过查找无效对象释放空间达到自动管理内存的目的。\n\n\n\n# 0x02 如何确定垃圾\n\n要查找垃圾对象，首先要知道什么样对象才算是垃圾对象才好对症下药。\n\n**在内存中，不再被引用的对象就称为垃圾对象**\n\n现在的问题又转到如何确定一个对象是否被引用？\n\n首先想到一种方法是给每个对象都添加一个计数器功能，这个计数器用例记录引用自己的指针数量，每多一个引用数量计数器就增加1，每减少一个引用数量计数器就减少1，如果计数器为0，说明没有其他对象引用当前对象，那么这个对象就是垃圾对象，可以被回收。这种方式叫做**引用计数法**\n\n引用计数法虽然容易理解，但是因为缺点也很明显，所以不得不另寻它法。这时**可达性分析法**就登场了。\n\n**可达性分析法**也可以称为**跟踪收集器法**，找一个对象作为GC的根节点(Root)，通过对对象的连续引用形成一条引用链，如果一个对象能够通过直接或间接的到达Root称为对象可达，否则称为对象不可达。对于不可达对象就可以判定为垃圾对象。\n\n\n\n# 0x03 如何回收垃圾\n\n上一节知道了哪些对象是垃圾，现在该讨论有哪些方式能回收垃圾了。\n\n常用的GC算法有**标记-清除算法**、**标记-整理算法**、**复制算法**、**分代GC**、**G1 GC**。\n\n## 标记-清除算法\n\n**标记-清除算法(Mark-Weep)**看名字就知道分为标记和清除两个阶段。\n\n**注意一点这里的标记是指标记活着的对象，而非死对象。**\n\n**标记阶段**从Root开始首先标记Root能直接访问的对象，然后递归通过指针能访问到得对象，同时把这些对象做标记。\n\n**清除阶段**遍历堆内存，把未被标记的对象清除以达到垃圾回收目的。\n\n图片表示如下：\n\n![标记清除](http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)\n\n图中问题很明显：回收后会产生大量的内存碎片，不利于对内存连续要求的数据结构的使用，譬如数组。\n\n\n\n## 标记-整理算法\n\n**标记-整理算法也叫标记-压缩**，这里的标记阶段和上面的标记-清除的标记阶段完全一样，不同的是整理阶段是对清除阶段的改进。\n\n整理阶段简单来说就是把活着的对象移动到一端，然后从边界处清除另一端所有空间。\n\n图片表示如下：\n\n![标记整理](http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png)\n\n\n\n优点是有效利用堆，但又不会产生内存碎片。\n\n缺点是浪费时间，整理阶段要搜索三次堆内存，而标记-清除算法的清除阶段只搜索一次堆内存。\n\n\n\n## 复制算法\n\n**复制算法**是把堆内存分为两块空间标识为from和to。当from空间被占满时，GC把活着的对象复制到to空间，复制完成后把from和to标识互换，GC结束。为了保证from空间对象都能复制到to空间，须要保证from和to空间大小一致。\n\n图片表示如下：\n\n![复制算法](http://othg5ggzi.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)\n\n\n\n复制算法吞吐量优秀，分配内存速度快，没有碎片，但是堆内存利用率低下\n\n\n\n## 分代GC\n\n根据日常研发总结出一个经验“大部分对象在生成后不久就变成垃圾，很少能活的久”。据此经验，分代GC引入了“年龄”的概念。经历过一次GC后活下来的对象年龄+1。\n\n**分代GC**把内存分为新生代和老年代，针对不同的年代使用不同的GC算法。刚生产的对象称为新生代对象，活到一定年龄的称为老年代对象。\n\n我们把对新对象执行的GC称为**新生代GC(minor GC)**， 把老年代对象执行的GC称为**老年代GC(major GC)**。\n\n**分代GC属于综合性GC，对上面GC算法的综合使用。**\n\n图片表示如下：\n\n![分代GC](http://othg5ggzi.bkt.clouddn.com/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png)\n\n如图所示：**新生代空间包括Eden，S0和S1三个区，老年代空间是Old区**\n\n其中新生代每次回收只有少数对象存活，可以使用复制算法，而老年代对象存活率高也没用额外空间，可以使用标记-整理和标记清除算法。\n\n刚开始时，Eden用来存放刚创建的对象，S0和S1为空，如果发生GC，Eden区幸存对象转移到S0区，如果S0区已有数据前提下再次进行GC时，会把Eden和S0区存活对象转移到S1区，同时清空Eden和S0，然后交换S0和S1标识。经过一定次数的GC仍然存活的对象转移到老年代。\n\n\n\n## G1 GC\n\n\n\n\n\n# 0x04 谁来回收垃圾\n\n知道了哪些对象是垃圾，也知道了用哪些算法来回收垃圾，然后呢？直接满地调用算法回收垃圾吗？\n\n当然不是！GC要分时机且统一来回收垃圾，这里是由垃圾收集器来来根据时机统一回收垃圾对象。\n\n由于各方面需求原因，垃圾收集器也是有多种的。\n\n\n\n未完待续.......","source":"_posts/垃圾回收机制-关于GC.md","raw":"---\ntitle: 垃圾回收机制~关于GC\ndate: 2017-07-26 20:25:26\ntags: [GC, Java]\ncategories: [GC, Java]\n---\n\n# 0x00 前言\n\n很多人通过Java才听说GC的，甚至刚开始做开发时以为GC是Java独有的。其实不然，GC是一项很古老的技术，与Lisp语言在20世纪60年代一同出现的。\n\n虽然GC不是Java独有的，但是不得不承认，GC很大成分上是因为Java的广泛应用才被广大开发者所熟知的。\n\n说到GC不得不提一个人：John McCarthy，Lisp语言之父和人工智能之父，同时还是GC之父，其论文中提到的算法就是标记-清除算法。\n\n如果是一门语言可以从基础语法学起，但是GC该如何学习呢？\n\n**其实问答形式就是最好的学习方式**\n\n# 0x01 什么是GC\n\nGC(垃圾回收)，通过查找无效对象释放空间达到自动管理内存的目的。\n\n\n\n# 0x02 如何确定垃圾\n\n要查找垃圾对象，首先要知道什么样对象才算是垃圾对象才好对症下药。\n\n**在内存中，不再被引用的对象就称为垃圾对象**\n\n现在的问题又转到如何确定一个对象是否被引用？\n\n首先想到一种方法是给每个对象都添加一个计数器功能，这个计数器用例记录引用自己的指针数量，每多一个引用数量计数器就增加1，每减少一个引用数量计数器就减少1，如果计数器为0，说明没有其他对象引用当前对象，那么这个对象就是垃圾对象，可以被回收。这种方式叫做**引用计数法**\n\n引用计数法虽然容易理解，但是因为缺点也很明显，所以不得不另寻它法。这时**可达性分析法**就登场了。\n\n**可达性分析法**也可以称为**跟踪收集器法**，找一个对象作为GC的根节点(Root)，通过对对象的连续引用形成一条引用链，如果一个对象能够通过直接或间接的到达Root称为对象可达，否则称为对象不可达。对于不可达对象就可以判定为垃圾对象。\n\n\n\n# 0x03 如何回收垃圾\n\n上一节知道了哪些对象是垃圾，现在该讨论有哪些方式能回收垃圾了。\n\n常用的GC算法有**标记-清除算法**、**标记-整理算法**、**复制算法**、**分代GC**、**G1 GC**。\n\n## 标记-清除算法\n\n**标记-清除算法(Mark-Weep)**看名字就知道分为标记和清除两个阶段。\n\n**注意一点这里的标记是指标记活着的对象，而非死对象。**\n\n**标记阶段**从Root开始首先标记Root能直接访问的对象，然后递归通过指针能访问到得对象，同时把这些对象做标记。\n\n**清除阶段**遍历堆内存，把未被标记的对象清除以达到垃圾回收目的。\n\n图片表示如下：\n\n![标记清除](http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)\n\n图中问题很明显：回收后会产生大量的内存碎片，不利于对内存连续要求的数据结构的使用，譬如数组。\n\n\n\n## 标记-整理算法\n\n**标记-整理算法也叫标记-压缩**，这里的标记阶段和上面的标记-清除的标记阶段完全一样，不同的是整理阶段是对清除阶段的改进。\n\n整理阶段简单来说就是把活着的对象移动到一端，然后从边界处清除另一端所有空间。\n\n图片表示如下：\n\n![标记整理](http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png)\n\n\n\n优点是有效利用堆，但又不会产生内存碎片。\n\n缺点是浪费时间，整理阶段要搜索三次堆内存，而标记-清除算法的清除阶段只搜索一次堆内存。\n\n\n\n## 复制算法\n\n**复制算法**是把堆内存分为两块空间标识为from和to。当from空间被占满时，GC把活着的对象复制到to空间，复制完成后把from和to标识互换，GC结束。为了保证from空间对象都能复制到to空间，须要保证from和to空间大小一致。\n\n图片表示如下：\n\n![复制算法](http://othg5ggzi.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)\n\n\n\n复制算法吞吐量优秀，分配内存速度快，没有碎片，但是堆内存利用率低下\n\n\n\n## 分代GC\n\n根据日常研发总结出一个经验“大部分对象在生成后不久就变成垃圾，很少能活的久”。据此经验，分代GC引入了“年龄”的概念。经历过一次GC后活下来的对象年龄+1。\n\n**分代GC**把内存分为新生代和老年代，针对不同的年代使用不同的GC算法。刚生产的对象称为新生代对象，活到一定年龄的称为老年代对象。\n\n我们把对新对象执行的GC称为**新生代GC(minor GC)**， 把老年代对象执行的GC称为**老年代GC(major GC)**。\n\n**分代GC属于综合性GC，对上面GC算法的综合使用。**\n\n图片表示如下：\n\n![分代GC](http://othg5ggzi.bkt.clouddn.com/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png)\n\n如图所示：**新生代空间包括Eden，S0和S1三个区，老年代空间是Old区**\n\n其中新生代每次回收只有少数对象存活，可以使用复制算法，而老年代对象存活率高也没用额外空间，可以使用标记-整理和标记清除算法。\n\n刚开始时，Eden用来存放刚创建的对象，S0和S1为空，如果发生GC，Eden区幸存对象转移到S0区，如果S0区已有数据前提下再次进行GC时，会把Eden和S0区存活对象转移到S1区，同时清空Eden和S0，然后交换S0和S1标识。经过一定次数的GC仍然存活的对象转移到老年代。\n\n\n\n## G1 GC\n\n\n\n\n\n# 0x04 谁来回收垃圾\n\n知道了哪些对象是垃圾，也知道了用哪些算法来回收垃圾，然后呢？直接满地调用算法回收垃圾吗？\n\n当然不是！GC要分时机且统一来回收垃圾，这里是由垃圾收集器来来根据时机统一回收垃圾对象。\n\n由于各方面需求原因，垃圾收集器也是有多种的。\n\n\n\n未完待续.......","slug":"垃圾回收机制-关于GC","published":1,"updated":"2017-07-27T04:45:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjk0073wh9c9avz0o4c","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>很多人通过Java才听说GC的，甚至刚开始做开发时以为GC是Java独有的。其实不然，GC是一项很古老的技术，与Lisp语言在20世纪60年代一同出现的。</p>\n<p>虽然GC不是Java独有的，但是不得不承认，GC很大成分上是因为Java的广泛应用才被广大开发者所熟知的。</p>\n<p>说到GC不得不提一个人：John McCarthy，Lisp语言之父和人工智能之父，同时还是GC之父，其论文中提到的算法就是标记-清除算法。</p>\n<p>如果是一门语言可以从基础语法学起，但是GC该如何学习呢？</p>\n<p><strong>其实问答形式就是最好的学习方式</strong></p>\n<h1 id=\"0x01-什么是GC\"><a href=\"#0x01-什么是GC\" class=\"headerlink\" title=\"0x01 什么是GC\"></a>0x01 什么是GC</h1><p>GC(垃圾回收)，通过查找无效对象释放空间达到自动管理内存的目的。</p>\n<h1 id=\"0x02-如何确定垃圾\"><a href=\"#0x02-如何确定垃圾\" class=\"headerlink\" title=\"0x02 如何确定垃圾\"></a>0x02 如何确定垃圾</h1><p>要查找垃圾对象，首先要知道什么样对象才算是垃圾对象才好对症下药。</p>\n<p><strong>在内存中，不再被引用的对象就称为垃圾对象</strong></p>\n<p>现在的问题又转到如何确定一个对象是否被引用？</p>\n<p>首先想到一种方法是给每个对象都添加一个计数器功能，这个计数器用例记录引用自己的指针数量，每多一个引用数量计数器就增加1，每减少一个引用数量计数器就减少1，如果计数器为0，说明没有其他对象引用当前对象，那么这个对象就是垃圾对象，可以被回收。这种方式叫做<strong>引用计数法</strong></p>\n<p>引用计数法虽然容易理解，但是因为缺点也很明显，所以不得不另寻它法。这时<strong>可达性分析法</strong>就登场了。</p>\n<p><strong>可达性分析法</strong>也可以称为<strong>跟踪收集器法</strong>，找一个对象作为GC的根节点(Root)，通过对对象的连续引用形成一条引用链，如果一个对象能够通过直接或间接的到达Root称为对象可达，否则称为对象不可达。对于不可达对象就可以判定为垃圾对象。</p>\n<h1 id=\"0x03-如何回收垃圾\"><a href=\"#0x03-如何回收垃圾\" class=\"headerlink\" title=\"0x03 如何回收垃圾\"></a>0x03 如何回收垃圾</h1><p>上一节知道了哪些对象是垃圾，现在该讨论有哪些方式能回收垃圾了。</p>\n<p>常用的GC算法有<strong>标记-清除算法</strong>、<strong>标记-整理算法</strong>、<strong>复制算法</strong>、<strong>分代GC</strong>、<strong>G1 GC</strong>。</p>\n<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p><strong>标记-清除算法(Mark-Weep)</strong>看名字就知道分为标记和清除两个阶段。</p>\n<p><strong>注意一点这里的标记是指标记活着的对象，而非死对象。</strong></p>\n<p><strong>标记阶段</strong>从Root开始首先标记Root能直接访问的对象，然后递归通过指针能访问到得对象，同时把这些对象做标记。</p>\n<p><strong>清除阶段</strong>遍历堆内存，把未被标记的对象清除以达到垃圾回收目的。</p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png\" alt=\"标记清除\"></p>\n<p>图中问题很明显：回收后会产生大量的内存碎片，不利于对内存连续要求的数据结构的使用，譬如数组。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p><strong>标记-整理算法也叫标记-压缩</strong>，这里的标记阶段和上面的标记-清除的标记阶段完全一样，不同的是整理阶段是对清除阶段的改进。</p>\n<p>整理阶段简单来说就是把活着的对象移动到一端，然后从边界处清除另一端所有空间。</p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png\" alt=\"标记整理\"></p>\n<p>优点是有效利用堆，但又不会产生内存碎片。</p>\n<p>缺点是浪费时间，整理阶段要搜索三次堆内存，而标记-清除算法的清除阶段只搜索一次堆内存。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p><strong>复制算法</strong>是把堆内存分为两块空间标识为from和to。当from空间被占满时，GC把活着的对象复制到to空间，复制完成后把from和to标识互换，GC结束。为了保证from空间对象都能复制到to空间，须要保证from和to空间大小一致。</p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png\" alt=\"复制算法\"></p>\n<p>复制算法吞吐量优秀，分配内存速度快，没有碎片，但是堆内存利用率低下</p>\n<h2 id=\"分代GC\"><a href=\"#分代GC\" class=\"headerlink\" title=\"分代GC\"></a>分代GC</h2><p>根据日常研发总结出一个经验“大部分对象在生成后不久就变成垃圾，很少能活的久”。据此经验，分代GC引入了“年龄”的概念。经历过一次GC后活下来的对象年龄+1。</p>\n<p><strong>分代GC</strong>把内存分为新生代和老年代，针对不同的年代使用不同的GC算法。刚生产的对象称为新生代对象，活到一定年龄的称为老年代对象。</p>\n<p>我们把对新对象执行的GC称为<strong>新生代GC(minor GC)</strong>， 把老年代对象执行的GC称为<strong>老年代GC(major GC)</strong>。</p>\n<p><strong>分代GC属于综合性GC，对上面GC算法的综合使用。</strong></p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png\" alt=\"分代GC\"></p>\n<p>如图所示：<strong>新生代空间包括Eden，S0和S1三个区，老年代空间是Old区</strong></p>\n<p>其中新生代每次回收只有少数对象存活，可以使用复制算法，而老年代对象存活率高也没用额外空间，可以使用标记-整理和标记清除算法。</p>\n<p>刚开始时，Eden用来存放刚创建的对象，S0和S1为空，如果发生GC，Eden区幸存对象转移到S0区，如果S0区已有数据前提下再次进行GC时，会把Eden和S0区存活对象转移到S1区，同时清空Eden和S0，然后交换S0和S1标识。经过一定次数的GC仍然存活的对象转移到老年代。</p>\n<h2 id=\"G1-GC\"><a href=\"#G1-GC\" class=\"headerlink\" title=\"G1 GC\"></a>G1 GC</h2><h1 id=\"0x04-谁来回收垃圾\"><a href=\"#0x04-谁来回收垃圾\" class=\"headerlink\" title=\"0x04 谁来回收垃圾\"></a>0x04 谁来回收垃圾</h1><p>知道了哪些对象是垃圾，也知道了用哪些算法来回收垃圾，然后呢？直接满地调用算法回收垃圾吗？</p>\n<p>当然不是！GC要分时机且统一来回收垃圾，这里是由垃圾收集器来来根据时机统一回收垃圾对象。</p>\n<p>由于各方面需求原因，垃圾收集器也是有多种的。</p>\n<p>未完待续…….</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>很多人通过Java才听说GC的，甚至刚开始做开发时以为GC是Java独有的。其实不然，GC是一项很古老的技术，与Lisp语言在20世纪60年代一同出现的。</p>\n<p>虽然GC不是Java独有的，但是不得不承认，GC很大成分上是因为Java的广泛应用才被广大开发者所熟知的。</p>\n<p>说到GC不得不提一个人：John McCarthy，Lisp语言之父和人工智能之父，同时还是GC之父，其论文中提到的算法就是标记-清除算法。</p>\n<p>如果是一门语言可以从基础语法学起，但是GC该如何学习呢？</p>\n<p><strong>其实问答形式就是最好的学习方式</strong></p>\n<h1 id=\"0x01-什么是GC\"><a href=\"#0x01-什么是GC\" class=\"headerlink\" title=\"0x01 什么是GC\"></a>0x01 什么是GC</h1><p>GC(垃圾回收)，通过查找无效对象释放空间达到自动管理内存的目的。</p>\n<h1 id=\"0x02-如何确定垃圾\"><a href=\"#0x02-如何确定垃圾\" class=\"headerlink\" title=\"0x02 如何确定垃圾\"></a>0x02 如何确定垃圾</h1><p>要查找垃圾对象，首先要知道什么样对象才算是垃圾对象才好对症下药。</p>\n<p><strong>在内存中，不再被引用的对象就称为垃圾对象</strong></p>\n<p>现在的问题又转到如何确定一个对象是否被引用？</p>\n<p>首先想到一种方法是给每个对象都添加一个计数器功能，这个计数器用例记录引用自己的指针数量，每多一个引用数量计数器就增加1，每减少一个引用数量计数器就减少1，如果计数器为0，说明没有其他对象引用当前对象，那么这个对象就是垃圾对象，可以被回收。这种方式叫做<strong>引用计数法</strong></p>\n<p>引用计数法虽然容易理解，但是因为缺点也很明显，所以不得不另寻它法。这时<strong>可达性分析法</strong>就登场了。</p>\n<p><strong>可达性分析法</strong>也可以称为<strong>跟踪收集器法</strong>，找一个对象作为GC的根节点(Root)，通过对对象的连续引用形成一条引用链，如果一个对象能够通过直接或间接的到达Root称为对象可达，否则称为对象不可达。对于不可达对象就可以判定为垃圾对象。</p>\n<h1 id=\"0x03-如何回收垃圾\"><a href=\"#0x03-如何回收垃圾\" class=\"headerlink\" title=\"0x03 如何回收垃圾\"></a>0x03 如何回收垃圾</h1><p>上一节知道了哪些对象是垃圾，现在该讨论有哪些方式能回收垃圾了。</p>\n<p>常用的GC算法有<strong>标记-清除算法</strong>、<strong>标记-整理算法</strong>、<strong>复制算法</strong>、<strong>分代GC</strong>、<strong>G1 GC</strong>。</p>\n<h2 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h2><p><strong>标记-清除算法(Mark-Weep)</strong>看名字就知道分为标记和清除两个阶段。</p>\n<p><strong>注意一点这里的标记是指标记活着的对象，而非死对象。</strong></p>\n<p><strong>标记阶段</strong>从Root开始首先标记Root能直接访问的对象，然后递归通过指针能访问到得对象，同时把这些对象做标记。</p>\n<p><strong>清除阶段</strong>遍历堆内存，把未被标记的对象清除以达到垃圾回收目的。</p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png\" alt=\"标记清除\"></p>\n<p>图中问题很明显：回收后会产生大量的内存碎片，不利于对内存连续要求的数据结构的使用，譬如数组。</p>\n<h2 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h2><p><strong>标记-整理算法也叫标记-压缩</strong>，这里的标记阶段和上面的标记-清除的标记阶段完全一样，不同的是整理阶段是对清除阶段的改进。</p>\n<p>整理阶段简单来说就是把活着的对象移动到一端，然后从边界处清除另一端所有空间。</p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png\" alt=\"标记整理\"></p>\n<p>优点是有效利用堆，但又不会产生内存碎片。</p>\n<p>缺点是浪费时间，整理阶段要搜索三次堆内存，而标记-清除算法的清除阶段只搜索一次堆内存。</p>\n<h2 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h2><p><strong>复制算法</strong>是把堆内存分为两块空间标识为from和to。当from空间被占满时，GC把活着的对象复制到to空间，复制完成后把from和to标识互换，GC结束。为了保证from空间对象都能复制到to空间，须要保证from和to空间大小一致。</p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png\" alt=\"复制算法\"></p>\n<p>复制算法吞吐量优秀，分配内存速度快，没有碎片，但是堆内存利用率低下</p>\n<h2 id=\"分代GC\"><a href=\"#分代GC\" class=\"headerlink\" title=\"分代GC\"></a>分代GC</h2><p>根据日常研发总结出一个经验“大部分对象在生成后不久就变成垃圾，很少能活的久”。据此经验，分代GC引入了“年龄”的概念。经历过一次GC后活下来的对象年龄+1。</p>\n<p><strong>分代GC</strong>把内存分为新生代和老年代，针对不同的年代使用不同的GC算法。刚生产的对象称为新生代对象，活到一定年龄的称为老年代对象。</p>\n<p>我们把对新对象执行的GC称为<strong>新生代GC(minor GC)</strong>， 把老年代对象执行的GC称为<strong>老年代GC(major GC)</strong>。</p>\n<p><strong>分代GC属于综合性GC，对上面GC算法的综合使用。</strong></p>\n<p>图片表示如下：</p>\n<p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png\" alt=\"分代GC\"></p>\n<p>如图所示：<strong>新生代空间包括Eden，S0和S1三个区，老年代空间是Old区</strong></p>\n<p>其中新生代每次回收只有少数对象存活，可以使用复制算法，而老年代对象存活率高也没用额外空间，可以使用标记-整理和标记清除算法。</p>\n<p>刚开始时，Eden用来存放刚创建的对象，S0和S1为空，如果发生GC，Eden区幸存对象转移到S0区，如果S0区已有数据前提下再次进行GC时，会把Eden和S0区存活对象转移到S1区，同时清空Eden和S0，然后交换S0和S1标识。经过一定次数的GC仍然存活的对象转移到老年代。</p>\n<h2 id=\"G1-GC\"><a href=\"#G1-GC\" class=\"headerlink\" title=\"G1 GC\"></a>G1 GC</h2><h1 id=\"0x04-谁来回收垃圾\"><a href=\"#0x04-谁来回收垃圾\" class=\"headerlink\" title=\"0x04 谁来回收垃圾\"></a>0x04 谁来回收垃圾</h1><p>知道了哪些对象是垃圾，也知道了用哪些算法来回收垃圾，然后呢？直接满地调用算法回收垃圾吗？</p>\n<p>当然不是！GC要分时机且统一来回收垃圾，这里是由垃圾收集器来来根据时机统一回收垃圾对象。</p>\n<p>由于各方面需求原因，垃圾收集器也是有多种的。</p>\n<p>未完待续…….</p>\n"},{"title":"浅谈Android事件传递机制","date":"2017-07-24T09:34:17.000Z","_content":"\n# 0x00 前言\n\n为什么点下屏幕某个位置时候，系统会找到正确地控件来响应？\n\n为什么按下按下返回键系统会让当前窗口页面关闭而不是下面的那个页面？\n\n很多时候多问自己个为什么就发现自己会的其实还很少。\n\n# 0x01 冯诺依曼模型回顾\n\n![冯诺依曼模型](http://othg5ggzi.bkt.clouddn.com/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)\n\n讲事件传递为什么把冯诺依曼模型带进来了？\n\n事件传递的事件来自哪里？\n\n基本的事件来自按键、屏幕，属于输入设备，而最终事件的结果要显示在屏幕上(输出设备)，这样才算完成一次交互。其实这里屏幕同时兼顾输入和输出。\n\n有了输入设备，系统是如何从中采集数据的呢？\n\n# 0x02 设备节点到ViewRootImpl\n\n## Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\n\n当发现输入设备可用时，Linux内核会在/dev/input/目录下创建名称为event0~n的设备节点。当设备不可用时则删除对应节点。\n\n*如果刚才的不好理解，那么可以理解windows这种情况：当我们新买的鼠标插入USB口时，右下角一般弹窗正在安装USB驱动，而最终会在设备管理中多出一个USBHub设备节点，拔掉USB时就会消失*\n\n输入设备准备就绪，当有事件发生时，Linux内核收到硬件中断，然后把中断加工成原始输入事件存入对应设备节点中。\n\n输入事件已经有了，用户空间只要读取事件信息就可以了。\n\n## 在用户空间这块输入事件的负责人是谁呢？\n\nAndroid系统为我们指定好了负责人：InputManagerService(后面直接称：IMS)。\n\nIMS和WMS，AMS一样都属于系统服务，在系统启动时由SystemServer统一启动。所以只要看看源码才能知道具体情况如何。\n\n首先看下`SystemServer`启动情况：\n\n```java\n    /**\n     * The main entry point from zygote.\n     */\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n\nprivate void run() {\n      // Start services.\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(\"System\", \t\"******************************************\");\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n            throw ex;\n        }\n}\n```\n\n通过源码发现`SystemServer`通过main方法直接启动的。当然这里run方法代码只是关键的一部分，如果都粘贴上来会影响分析。\n\n那么IMS在哪启动的呢？其实IMS通过`startOtherServices`方法启动。\n\n```java\n    private void startOtherServices() {\n         WindowManagerService wm = null;\n        InputManagerService inputManager = null;\n\n\t\t wm = WindowManagerService.main(context, inputManager,\n                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,\n                    !mFirstBoot, mOnlyCore);\n            ServiceManager.addService(Context.WINDOW_SERVICE, wm);\n            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);\n\n            inputManager = new InputManagerService(context);\n           inputManager.setWindowManagerCallbacks(wm.getInputMonitor());\n            inputManager.start();\n\t}\n```\n\n这里不仅启动了IMS，还有WMS，还给IMS设置了一个`wm.getInputMonitor()`，这个设置有什么用先不用管。最后调用了start方法。\n\n目前只只知道IMS是用户空间的输入事件负责人，具体如何负责还要继续看，IMS的start方法调用了`        nativeStart(mPtr);`，看的出来这是要进入C层实现了。\n\n找到Java层IMS对应的C层实现，打开文件找到`nativeStart`实现：\n\n```c++\nstatic void nativeStart(JNIEnv* env, jclass clazz, jlong ptr) {\n    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);\n\n    status_t result = im->getInputManager()->start();\n    if (result) {\n        jniThrowRuntimeException(env, \"Input manager could not be started.\");\n    }\n}\n```\n\n方法如此简单，又是个躯壳，仅仅调用了其他类的方法。\n\n下面看看`start()`里面干了什么，\n\n注意一点：这里显示的是`NativeInputManager`，但其实找到的是`InputManager`,多态特性。\n\n```C++\nstatus_t InputManager::start() {    \n    status_t result = mDispatcherThread->run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);\n    if (result) {\n        ALOGE(\"Could not start InputDispatcher thread due to error %d.\", result);\n        return result;\n    }\n\n    result = mReaderThread->run(\"InputReader\", PRIORITY_URGENT_DISPLAY);\n    if (result) {\n        ALOGE(\"Could not start InputReader thread due to error %d.\", result);\n\n        mDispatcherThread->requestExit();\n        return result;\n    }\n\n    return OK;\n}\n```\n\n这次真的是全部代码，没有精简，看的出来好像start就启动了两个线程。\n\nmDispatcherThread对应`InputDispatcherThread`类，负责事件分发\n\nmReaderThread对应`InputReaderThread`类，负责事件读取\n\n现在我们基本可以猜到，一个线程读取事件，读取后把事件信息传递给分发线程，由分发线程继续处理。\n\n当然这还都只是猜测，实践是检验真理的唯一标准。\n\n## 看看InputReaderThread干了什么\n\n首先看看`InputReaderThread`源码\n\n```C++\n/* Reads raw events from the event hub and processes them, endlessly. */\nclass InputReaderThread : public Thread {\npublic:\n    InputReaderThread(const sp<InputReaderInterface>& reader);\n    virtual ~InputReaderThread();\n\nprivate:\n    sp<InputReaderInterface> mReader;\n\n    virtual bool threadLoop();\n};\n```\n\n`InputReaderThread`继承了Thread，在执行run方法时会回调`threadLoop`。从`virtual`知道这是一个虚函数，来看看具体实现：\n\n```C++\nbool InputReaderThread::threadLoop() {\n    mReader->loopOnce();\n    return true;\n}\n```\n\nmReader对应`InputReader`类，看下`loopOnce`方法实现：\n\n```C++\n\nvoid InputReader::loopOnce() {\n    int32_t oldGeneration;\n    int32_t timeoutMillis;\n    bool inputDevicesChanged = false;\n    Vector<InputDeviceInfo> inputDevices;\n    { // acquire lock\n        AutoMutex _l(mLock);\n\n        oldGeneration = mGeneration;\n        timeoutMillis = -1;\n\n        uint32_t changes = mConfigurationChangesToRefresh;\n        if (changes) {\n            mConfigurationChangesToRefresh = 0;\n            timeoutMillis = 0;\n            refreshConfigurationLocked(changes);\n        } else if (mNextTimeout != LLONG_MAX) {\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);\n        }\n    } // release lock\n    //这里就是我们开始说的从设备节点读取输入事件的函数了。\n    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);\n\n    { // acquire lock\n        AutoMutex _l(mLock);\n        mReaderIsAliveCondition.broadcast();\n\n        if (count) {\n          //处理事件\n            processEventsLocked(mEventBuffer, count);\n        }\n\n        if (mNextTimeout != LLONG_MAX) {\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n            if (now >= mNextTimeout) {\n#if DEBUG_RAW_EVENTS\n                ALOGD(\"Timeout expired, latency=%0.3fms\", (now - mNextTimeout) * 0.000001f);\n#endif\n                mNextTimeout = LLONG_MAX;\n                timeoutExpiredLocked(now);\n            }\n        }\n\n        if (oldGeneration != mGeneration) {\n            inputDevicesChanged = true;\n            getInputDevicesLocked(inputDevices);\n        }\n    } // release lock\n\n    // Send out a message that the describes the changed input devices.\n    if (inputDevicesChanged) {\n        mPolicy->notifyInputDevicesChanged(inputDevices);\n    }\n\n    // Flush queued events out to the listener.\n    // This must happen outside of the lock because the listener could potentially call\n    // back into the InputReader's methods, such as getScanCodeState, or become blocked\n    // on another thread similarly waiting to acquire the InputReader lock thereby\n    // resulting in a deadlock.  This situation is actually quite plausible because the\n    // listener is actually the input dispatcher, which calls into the window manager,\n    // which occasionally calls into the input reader.\n    mQueuedListener->flush();\n}\n```\n\n上面方法主要执行了三个流程：\n\n①通过`mEventHub->getEvents`读取事件\n\n​\t这里不再继续深入，重点理解②③\n\n②通过`processEventsLocked`处理事件\n\n这方法里面有`processEventsForDeviceLocked`方法，这是处理一般事件的方法。\n\n```C++\nvoid InputReader::processEventsForDeviceLocked(int32_t deviceId,\n        const RawEvent* rawEvents, size_t count) {\n    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);\n    if (deviceIndex < 0) {\n        ALOGW(\"Discarding event for unknown deviceId %d.\", deviceId);\n        return;\n    }\n\n    InputDevice* device = mDevices.valueAt(deviceIndex);\n    if (device->isIgnored()) {\n        //ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId);\n        return;\n    }\n\n    device->process(rawEvents, count);\n}\n```\n\n这里根据`deviceId`生成`InputDevice`。进而调用`device->process`。\n\n```C++\n for (size_t i = 0; i < numMappers; i++) {\n                InputMapper* mapper = mMappers[i];\n                mapper->process(rawEvent);\n            }\n```\n\n最终引出了`InputMapper`，这是一个基类，而对于触摸事件会调用`TouchInputMapper`类的`process`方法：\n\n```C++\nvoid TouchInputMapper::process(const RawEvent* rawEvent) {\n    mCursorButtonAccumulator.process(rawEvent);\n    mCursorScrollAccumulator.process(rawEvent);\n    mTouchButtonAccumulator.process(rawEvent);\n\n    if (rawEvent->type == EV_SYN && rawEvent->code == SYN_REPORT) {\n        sync(rawEvent->when);\n    }\n}\n```\n\n后面经过一系列方法调用，事件信息封装到`NotifyMotionArgs args`，通过`getListener()->notifyMotion(&args)`方法把事件加入到队列中。然后开始③过程。\n\n\n\n③通过`mQueuedListener->flush()`事件转移到`InputDispatcherThread`。\n\n看看`flush`源码：\n\n```C++\nvoid QueuedInputListener::flush() {\n    size_t count = mArgsQueue.size();\n    for (size_t i = 0; i < count; i++) {\n        NotifyArgs* args = mArgsQueue[i];\n        args->notify(mInnerListener);\n        delete args;\n    }\n    mArgsQueue.clear();\n}\n```\n\n这个方法遍历事件，同时执行`notify`，然后从队列删除消息，\n\n`NotifyArgs`也是基类，有多种子类，其中触摸事件为`NotifyMotionArgs`，其`notify`方法如下：\n\n```C++\nvoid NotifyMotionArgs::notify(const sp<InputListenerInterface>& listener) const {\n    listener->notifyMotion(this);\n}\n```\n\n这里的`listener`指向`InputDispatcher`，而`InputDispatcher`隶属于`InputDispatcherThread` ，下一节继续\n\n\n\n## 看看InputDispatcherThread干了什么\n\n`InputDispatcherThread`执行的时候调用了`threadLoop`然后调用了`mDispatcher->dispatchOnce();`。经过一些列调用会转战到`InputChannel::sendMessage`。\n\n继续上一节，看看`InputDispatcher`中`notifyMotion`方法：\n\n```C++\n  void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) {\n\n  \tneedWake = enqueueInboundEventLocked(newEntry);\n       if (needWake) {\n        mLooper->wake();\n    }\n  }\n```\n\n方法主要做了这两件事：\n\n①事件再次加入队列\n\n​\t其中还执行了`findTouchedWindowAtLocked`查找当前活动窗口并拿到句柄。\n\n②唤醒looper。\n\n\n\n> 这里疑惑的一点是：事件加入队列，唤醒looper，接下来应该是looper循环读取消息队列进行事件分发，但是这里没有找到和dispatchOnce想关联的地方。可能有疏漏地方。以后发现问题会及时更新上。这里直接继续InputChannel::sendMessage来说。\n\n\n\n`InputChannel`是负责与app窗口进行通信的，通过WMS找到对应的窗口。那么`InputChannel`到底是怎么找到窗口的？\n\n在WMS的`addWindow`方法中有这样几行代码：\n\n```c++\npublic int addWindow(Session session, IWindow client, int seq,\n            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,\n            Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) {\n            \n                \n                String name = win.makeInputChannelName();\n                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\n                win.setInputChannel(inputChannels[0]);\n                inputChannels[1].transferTo(outInputChannel);\n\n                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);\n            \n            }\n```\n\n这里是在Activity初始化时想WMS添加的窗口的调用方法，其中在添加窗口时候就已经给这个窗口设置了通信通道。\n\n然后看下`InputChannel.openInputChannelPair`里面做了什么：\n\n```c++\nstatus_t InputChannel::openInputChannelPair(const String8& name,\n        sp<InputChannel>& outServerChannel, sp<InputChannel>& outClientChannel) {\n    int sockets[2];\n    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) {\n        status_t result = -errno;\n        ALOGE(\"channel '%s' ~ Could not create socket pair.  errno=%d\",\n                name.string(), errno);\n        outServerChannel.clear();\n        outClientChannel.clear();\n        return result;\n    }\n\n    int bufferSize = SOCKET_BUFFER_SIZE;\n    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\n\n    String8 serverChannelName = name;\n    serverChannelName.append(\" (server)\");\n    outServerChannel = new InputChannel(serverChannelName, sockets[0]);\n\n    String8 clientChannelName = name;\n    clientChannelName.append(\" (client)\");\n    outClientChannel = new InputChannel(clientChannelName, sockets[1]);\n    return OK;\n}\n```\n\n这里主要创建了两个`InputChannel`，一个服务端一个客户端，这里的的`InputChannel`是基于socket的，这个socket不是网络的socket而是Unix特有的关于文件的Unix domain socket。\n\n## WMS和ViewRootImpl\n\n经过一些列的调转，最终会回调到`InputEventReceiver`的`dispatchInputEvent`方法。\n\n这个方法是C++通过JNi回调的：\n\n```java\n    // Called from native code.\n    @SuppressWarnings(\"unused\")\n    private void dispatchInputEvent(int seq, InputEvent event) {\n        mSeqMap.put(event.getSequenceNumber(), seq);\n        onInputEvent(event);\n    }\n```\n\n上面的`InputEventReceiver` 对象其实是`WindowInputEventReceiver` 的引用，所以`onInputEvent`其实调用的`WindowInputEventReceiver`方法：\n\n```java\n\t\t@Override\n        public void onInputEvent(InputEvent event) {\n            enqueueInputEvent(event, this, 0, true);\n        }\n```\n\n`enqueueInputEvent`通过连续调用，跳转到`deliverInputEvent`：\n\n```java\n    private void deliverInputEvent(QueuedInputEvent q) {\n        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\",\n                q.mEvent.getSequenceNumber());\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0);\n        }\n\n        InputStage stage;\n        if (q.shouldSendToSynthesizer()) {\n            stage = mSyntheticInputStage;\n        } else {\n            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;\n        }\n\n        if (stage != null) {\n            stage.deliver(q);\n        } else {\n            finishInputEvent(q);\n        }\n    }\n```\n\n这里的`stage`是多态形式，但是最终会调用`ViewPostImeInputStage`的`onProcess`方法。\n\n```java\n       @Override\n        protected int onProcess(QueuedInputEvent q) {\n            if (q.mEvent instanceof KeyEvent) {\n                return processKeyEvent(q);\n            } else {\n                // If delivering a new non-key event, make sure the window is\n                // now allowed to start updating.\n                handleDispatchDoneAnimating();\n                final int source = q.mEvent.getSource();\n                if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n                    return processPointerEvent(q);\n                } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {\n                    return processTrackballEvent(q);\n                } else {\n                    return processGenericMotionEvent(q);\n                }\n            }\n        }\n```\n\n由于是触摸事件，所以会执行`processPointerEvent`方法：\n\n```java\n       private int processPointerEvent(QueuedInputEvent q) {\n            final MotionEvent event = (MotionEvent)q.mEvent;\n\n            mAttachInfo.mUnbufferedDispatchRequested = false;\n            boolean handled = mView.dispatchPointerEvent(event);\n            if (mAttachInfo.mUnbufferedDispatchRequested && !mUnbufferedInputDispatch) {\n                mUnbufferedInputDispatch = true;\n                if (mConsumeBatchedInputScheduled) {\n                    scheduleConsumeBatchedInputImmediately();\n                }\n            }\n            return handled ? FINISH_HANDLED : FORWARD;\n        }\n```\n\n发现有` boolean handled = mView.dispatchPointerEvent(event);`这么一句话，看来现在已经开始向view分发事件了。\n\n这里的`mView`是指向`DecorView`，剩下的内容下节继续\n\n\n\n# 0x03 ViewRootImpl到View \n\n通过View的`dispatchPointerEvent`调用了`dispatchTouchEvent`，\n\n因为`DecorView`重写了`dispatchTouchEvent`方法，看下这个内容：\n\n```java\n  @Override\n        public boolean dispatchTouchEvent(MotionEvent ev) {\n            final Callback cb = getCallback();\n            return cb != null && !isDestroyed() && mFeatureId < 0 ? cb.dispatchTouchEvent(ev)\n                    : super.dispatchTouchEvent(ev);\n        }\n```\n\n这里的`getCallback`返回的是Activity引用，如果Activity没有销毁，则调用Activity的`dispatchTouchEvent`方法。代码如下：\n\n```java\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n```\n\n这里注意一点，如果`getWindow().superDispatchTouchEvent(ev)`返回true，则不继续执行Activity的`onTouchEvent`。\n\n这里的getWinddow就是PhoneWindow，而PhoneWindow的`superDispatchTouchEvent`直接引用了DecorView的`superDispatchTouchEvent`，接着调用了`super.dispatchTouchEvent(event)`，这里的super是ViewGroup，这里主要做了两件事：①判断当前ViewGroup是否拦截事件，如果拦截则执行`onInterceptTouchEvent`。②如果不拦截，事件也没取消，则事件向子View分发。在向子View分发前会先判断子View是否接受事件及事件是否在子View范围内。如果都为true了则调用`dispatchTransformedTouchEvent`。这里面调用了子View的`dispatchTouchEvent`。\n\n子View的`dispatchTouchEvent`里面会判断`touchListener.onTouch`方法和`onTouchEvent`方法。\n\n\n\n# 0x04 事件传递须知\n\n ①如果DecorView的`dispatchPointerEvent`方法返回true表示事件消费成功。\n\n②如果Activity没有销毁，则回调Activity的`dispatchTouchEvent`,如果phone window的`superDispatchTouchEvent`返回true表示被DecorView或其子View消耗了事件，则不执行Activity的onTouchEvent方法。\n\n③如果ViewGroup执行dispatchTouchEvent方法，先判断是否需要拦截事件：\n\n如果需要拦截则执行onInterceptTouchEvent方法。\n\n如果拦截返回true，则不继续事件传递，如果返回false，则继续，首先判断子View是否接受事件及是否在范围内，如果都符合则传递给子View。\n\n④如果子View执行dispatchTouchEvent方法，会先判断是否设置onTouchListener，\n\n如果设置了则执行onTouch方法。如果该方法返回true，则不继续执行子View 的onTouchEvent方法，否则继续执行ouTouchEvent方法。\n\n⑤如果ouTouchEvent方法执行，actionDown时检查长按事件，actionUp时检查onClick事件。\n\n\n\n\n\n\n\n","source":"_posts/浅谈Android事件传递机制.md","raw":"---\ntitle: 浅谈Android事件传递机制\ndate: 2017-07-24 17:34:17\ntags: [Android, 源码解析]\ncategories: [Android, 源码解析]\n---\n\n# 0x00 前言\n\n为什么点下屏幕某个位置时候，系统会找到正确地控件来响应？\n\n为什么按下按下返回键系统会让当前窗口页面关闭而不是下面的那个页面？\n\n很多时候多问自己个为什么就发现自己会的其实还很少。\n\n# 0x01 冯诺依曼模型回顾\n\n![冯诺依曼模型](http://othg5ggzi.bkt.clouddn.com/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)\n\n讲事件传递为什么把冯诺依曼模型带进来了？\n\n事件传递的事件来自哪里？\n\n基本的事件来自按键、屏幕，属于输入设备，而最终事件的结果要显示在屏幕上(输出设备)，这样才算完成一次交互。其实这里屏幕同时兼顾输入和输出。\n\n有了输入设备，系统是如何从中采集数据的呢？\n\n# 0x02 设备节点到ViewRootImpl\n\n## Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\n\n当发现输入设备可用时，Linux内核会在/dev/input/目录下创建名称为event0~n的设备节点。当设备不可用时则删除对应节点。\n\n*如果刚才的不好理解，那么可以理解windows这种情况：当我们新买的鼠标插入USB口时，右下角一般弹窗正在安装USB驱动，而最终会在设备管理中多出一个USBHub设备节点，拔掉USB时就会消失*\n\n输入设备准备就绪，当有事件发生时，Linux内核收到硬件中断，然后把中断加工成原始输入事件存入对应设备节点中。\n\n输入事件已经有了，用户空间只要读取事件信息就可以了。\n\n## 在用户空间这块输入事件的负责人是谁呢？\n\nAndroid系统为我们指定好了负责人：InputManagerService(后面直接称：IMS)。\n\nIMS和WMS，AMS一样都属于系统服务，在系统启动时由SystemServer统一启动。所以只要看看源码才能知道具体情况如何。\n\n首先看下`SystemServer`启动情况：\n\n```java\n    /**\n     * The main entry point from zygote.\n     */\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n\nprivate void run() {\n      // Start services.\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(\"System\", \t\"******************************************\");\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n            throw ex;\n        }\n}\n```\n\n通过源码发现`SystemServer`通过main方法直接启动的。当然这里run方法代码只是关键的一部分，如果都粘贴上来会影响分析。\n\n那么IMS在哪启动的呢？其实IMS通过`startOtherServices`方法启动。\n\n```java\n    private void startOtherServices() {\n         WindowManagerService wm = null;\n        InputManagerService inputManager = null;\n\n\t\t wm = WindowManagerService.main(context, inputManager,\n                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,\n                    !mFirstBoot, mOnlyCore);\n            ServiceManager.addService(Context.WINDOW_SERVICE, wm);\n            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);\n\n            inputManager = new InputManagerService(context);\n           inputManager.setWindowManagerCallbacks(wm.getInputMonitor());\n            inputManager.start();\n\t}\n```\n\n这里不仅启动了IMS，还有WMS，还给IMS设置了一个`wm.getInputMonitor()`，这个设置有什么用先不用管。最后调用了start方法。\n\n目前只只知道IMS是用户空间的输入事件负责人，具体如何负责还要继续看，IMS的start方法调用了`        nativeStart(mPtr);`，看的出来这是要进入C层实现了。\n\n找到Java层IMS对应的C层实现，打开文件找到`nativeStart`实现：\n\n```c++\nstatic void nativeStart(JNIEnv* env, jclass clazz, jlong ptr) {\n    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);\n\n    status_t result = im->getInputManager()->start();\n    if (result) {\n        jniThrowRuntimeException(env, \"Input manager could not be started.\");\n    }\n}\n```\n\n方法如此简单，又是个躯壳，仅仅调用了其他类的方法。\n\n下面看看`start()`里面干了什么，\n\n注意一点：这里显示的是`NativeInputManager`，但其实找到的是`InputManager`,多态特性。\n\n```C++\nstatus_t InputManager::start() {    \n    status_t result = mDispatcherThread->run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);\n    if (result) {\n        ALOGE(\"Could not start InputDispatcher thread due to error %d.\", result);\n        return result;\n    }\n\n    result = mReaderThread->run(\"InputReader\", PRIORITY_URGENT_DISPLAY);\n    if (result) {\n        ALOGE(\"Could not start InputReader thread due to error %d.\", result);\n\n        mDispatcherThread->requestExit();\n        return result;\n    }\n\n    return OK;\n}\n```\n\n这次真的是全部代码，没有精简，看的出来好像start就启动了两个线程。\n\nmDispatcherThread对应`InputDispatcherThread`类，负责事件分发\n\nmReaderThread对应`InputReaderThread`类，负责事件读取\n\n现在我们基本可以猜到，一个线程读取事件，读取后把事件信息传递给分发线程，由分发线程继续处理。\n\n当然这还都只是猜测，实践是检验真理的唯一标准。\n\n## 看看InputReaderThread干了什么\n\n首先看看`InputReaderThread`源码\n\n```C++\n/* Reads raw events from the event hub and processes them, endlessly. */\nclass InputReaderThread : public Thread {\npublic:\n    InputReaderThread(const sp<InputReaderInterface>& reader);\n    virtual ~InputReaderThread();\n\nprivate:\n    sp<InputReaderInterface> mReader;\n\n    virtual bool threadLoop();\n};\n```\n\n`InputReaderThread`继承了Thread，在执行run方法时会回调`threadLoop`。从`virtual`知道这是一个虚函数，来看看具体实现：\n\n```C++\nbool InputReaderThread::threadLoop() {\n    mReader->loopOnce();\n    return true;\n}\n```\n\nmReader对应`InputReader`类，看下`loopOnce`方法实现：\n\n```C++\n\nvoid InputReader::loopOnce() {\n    int32_t oldGeneration;\n    int32_t timeoutMillis;\n    bool inputDevicesChanged = false;\n    Vector<InputDeviceInfo> inputDevices;\n    { // acquire lock\n        AutoMutex _l(mLock);\n\n        oldGeneration = mGeneration;\n        timeoutMillis = -1;\n\n        uint32_t changes = mConfigurationChangesToRefresh;\n        if (changes) {\n            mConfigurationChangesToRefresh = 0;\n            timeoutMillis = 0;\n            refreshConfigurationLocked(changes);\n        } else if (mNextTimeout != LLONG_MAX) {\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);\n        }\n    } // release lock\n    //这里就是我们开始说的从设备节点读取输入事件的函数了。\n    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);\n\n    { // acquire lock\n        AutoMutex _l(mLock);\n        mReaderIsAliveCondition.broadcast();\n\n        if (count) {\n          //处理事件\n            processEventsLocked(mEventBuffer, count);\n        }\n\n        if (mNextTimeout != LLONG_MAX) {\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n            if (now >= mNextTimeout) {\n#if DEBUG_RAW_EVENTS\n                ALOGD(\"Timeout expired, latency=%0.3fms\", (now - mNextTimeout) * 0.000001f);\n#endif\n                mNextTimeout = LLONG_MAX;\n                timeoutExpiredLocked(now);\n            }\n        }\n\n        if (oldGeneration != mGeneration) {\n            inputDevicesChanged = true;\n            getInputDevicesLocked(inputDevices);\n        }\n    } // release lock\n\n    // Send out a message that the describes the changed input devices.\n    if (inputDevicesChanged) {\n        mPolicy->notifyInputDevicesChanged(inputDevices);\n    }\n\n    // Flush queued events out to the listener.\n    // This must happen outside of the lock because the listener could potentially call\n    // back into the InputReader's methods, such as getScanCodeState, or become blocked\n    // on another thread similarly waiting to acquire the InputReader lock thereby\n    // resulting in a deadlock.  This situation is actually quite plausible because the\n    // listener is actually the input dispatcher, which calls into the window manager,\n    // which occasionally calls into the input reader.\n    mQueuedListener->flush();\n}\n```\n\n上面方法主要执行了三个流程：\n\n①通过`mEventHub->getEvents`读取事件\n\n​\t这里不再继续深入，重点理解②③\n\n②通过`processEventsLocked`处理事件\n\n这方法里面有`processEventsForDeviceLocked`方法，这是处理一般事件的方法。\n\n```C++\nvoid InputReader::processEventsForDeviceLocked(int32_t deviceId,\n        const RawEvent* rawEvents, size_t count) {\n    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);\n    if (deviceIndex < 0) {\n        ALOGW(\"Discarding event for unknown deviceId %d.\", deviceId);\n        return;\n    }\n\n    InputDevice* device = mDevices.valueAt(deviceIndex);\n    if (device->isIgnored()) {\n        //ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId);\n        return;\n    }\n\n    device->process(rawEvents, count);\n}\n```\n\n这里根据`deviceId`生成`InputDevice`。进而调用`device->process`。\n\n```C++\n for (size_t i = 0; i < numMappers; i++) {\n                InputMapper* mapper = mMappers[i];\n                mapper->process(rawEvent);\n            }\n```\n\n最终引出了`InputMapper`，这是一个基类，而对于触摸事件会调用`TouchInputMapper`类的`process`方法：\n\n```C++\nvoid TouchInputMapper::process(const RawEvent* rawEvent) {\n    mCursorButtonAccumulator.process(rawEvent);\n    mCursorScrollAccumulator.process(rawEvent);\n    mTouchButtonAccumulator.process(rawEvent);\n\n    if (rawEvent->type == EV_SYN && rawEvent->code == SYN_REPORT) {\n        sync(rawEvent->when);\n    }\n}\n```\n\n后面经过一系列方法调用，事件信息封装到`NotifyMotionArgs args`，通过`getListener()->notifyMotion(&args)`方法把事件加入到队列中。然后开始③过程。\n\n\n\n③通过`mQueuedListener->flush()`事件转移到`InputDispatcherThread`。\n\n看看`flush`源码：\n\n```C++\nvoid QueuedInputListener::flush() {\n    size_t count = mArgsQueue.size();\n    for (size_t i = 0; i < count; i++) {\n        NotifyArgs* args = mArgsQueue[i];\n        args->notify(mInnerListener);\n        delete args;\n    }\n    mArgsQueue.clear();\n}\n```\n\n这个方法遍历事件，同时执行`notify`，然后从队列删除消息，\n\n`NotifyArgs`也是基类，有多种子类，其中触摸事件为`NotifyMotionArgs`，其`notify`方法如下：\n\n```C++\nvoid NotifyMotionArgs::notify(const sp<InputListenerInterface>& listener) const {\n    listener->notifyMotion(this);\n}\n```\n\n这里的`listener`指向`InputDispatcher`，而`InputDispatcher`隶属于`InputDispatcherThread` ，下一节继续\n\n\n\n## 看看InputDispatcherThread干了什么\n\n`InputDispatcherThread`执行的时候调用了`threadLoop`然后调用了`mDispatcher->dispatchOnce();`。经过一些列调用会转战到`InputChannel::sendMessage`。\n\n继续上一节，看看`InputDispatcher`中`notifyMotion`方法：\n\n```C++\n  void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) {\n\n  \tneedWake = enqueueInboundEventLocked(newEntry);\n       if (needWake) {\n        mLooper->wake();\n    }\n  }\n```\n\n方法主要做了这两件事：\n\n①事件再次加入队列\n\n​\t其中还执行了`findTouchedWindowAtLocked`查找当前活动窗口并拿到句柄。\n\n②唤醒looper。\n\n\n\n> 这里疑惑的一点是：事件加入队列，唤醒looper，接下来应该是looper循环读取消息队列进行事件分发，但是这里没有找到和dispatchOnce想关联的地方。可能有疏漏地方。以后发现问题会及时更新上。这里直接继续InputChannel::sendMessage来说。\n\n\n\n`InputChannel`是负责与app窗口进行通信的，通过WMS找到对应的窗口。那么`InputChannel`到底是怎么找到窗口的？\n\n在WMS的`addWindow`方法中有这样几行代码：\n\n```c++\npublic int addWindow(Session session, IWindow client, int seq,\n            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,\n            Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) {\n            \n                \n                String name = win.makeInputChannelName();\n                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\n                win.setInputChannel(inputChannels[0]);\n                inputChannels[1].transferTo(outInputChannel);\n\n                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);\n            \n            }\n```\n\n这里是在Activity初始化时想WMS添加的窗口的调用方法，其中在添加窗口时候就已经给这个窗口设置了通信通道。\n\n然后看下`InputChannel.openInputChannelPair`里面做了什么：\n\n```c++\nstatus_t InputChannel::openInputChannelPair(const String8& name,\n        sp<InputChannel>& outServerChannel, sp<InputChannel>& outClientChannel) {\n    int sockets[2];\n    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) {\n        status_t result = -errno;\n        ALOGE(\"channel '%s' ~ Could not create socket pair.  errno=%d\",\n                name.string(), errno);\n        outServerChannel.clear();\n        outClientChannel.clear();\n        return result;\n    }\n\n    int bufferSize = SOCKET_BUFFER_SIZE;\n    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\n\n    String8 serverChannelName = name;\n    serverChannelName.append(\" (server)\");\n    outServerChannel = new InputChannel(serverChannelName, sockets[0]);\n\n    String8 clientChannelName = name;\n    clientChannelName.append(\" (client)\");\n    outClientChannel = new InputChannel(clientChannelName, sockets[1]);\n    return OK;\n}\n```\n\n这里主要创建了两个`InputChannel`，一个服务端一个客户端，这里的的`InputChannel`是基于socket的，这个socket不是网络的socket而是Unix特有的关于文件的Unix domain socket。\n\n## WMS和ViewRootImpl\n\n经过一些列的调转，最终会回调到`InputEventReceiver`的`dispatchInputEvent`方法。\n\n这个方法是C++通过JNi回调的：\n\n```java\n    // Called from native code.\n    @SuppressWarnings(\"unused\")\n    private void dispatchInputEvent(int seq, InputEvent event) {\n        mSeqMap.put(event.getSequenceNumber(), seq);\n        onInputEvent(event);\n    }\n```\n\n上面的`InputEventReceiver` 对象其实是`WindowInputEventReceiver` 的引用，所以`onInputEvent`其实调用的`WindowInputEventReceiver`方法：\n\n```java\n\t\t@Override\n        public void onInputEvent(InputEvent event) {\n            enqueueInputEvent(event, this, 0, true);\n        }\n```\n\n`enqueueInputEvent`通过连续调用，跳转到`deliverInputEvent`：\n\n```java\n    private void deliverInputEvent(QueuedInputEvent q) {\n        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\",\n                q.mEvent.getSequenceNumber());\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0);\n        }\n\n        InputStage stage;\n        if (q.shouldSendToSynthesizer()) {\n            stage = mSyntheticInputStage;\n        } else {\n            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;\n        }\n\n        if (stage != null) {\n            stage.deliver(q);\n        } else {\n            finishInputEvent(q);\n        }\n    }\n```\n\n这里的`stage`是多态形式，但是最终会调用`ViewPostImeInputStage`的`onProcess`方法。\n\n```java\n       @Override\n        protected int onProcess(QueuedInputEvent q) {\n            if (q.mEvent instanceof KeyEvent) {\n                return processKeyEvent(q);\n            } else {\n                // If delivering a new non-key event, make sure the window is\n                // now allowed to start updating.\n                handleDispatchDoneAnimating();\n                final int source = q.mEvent.getSource();\n                if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n                    return processPointerEvent(q);\n                } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {\n                    return processTrackballEvent(q);\n                } else {\n                    return processGenericMotionEvent(q);\n                }\n            }\n        }\n```\n\n由于是触摸事件，所以会执行`processPointerEvent`方法：\n\n```java\n       private int processPointerEvent(QueuedInputEvent q) {\n            final MotionEvent event = (MotionEvent)q.mEvent;\n\n            mAttachInfo.mUnbufferedDispatchRequested = false;\n            boolean handled = mView.dispatchPointerEvent(event);\n            if (mAttachInfo.mUnbufferedDispatchRequested && !mUnbufferedInputDispatch) {\n                mUnbufferedInputDispatch = true;\n                if (mConsumeBatchedInputScheduled) {\n                    scheduleConsumeBatchedInputImmediately();\n                }\n            }\n            return handled ? FINISH_HANDLED : FORWARD;\n        }\n```\n\n发现有` boolean handled = mView.dispatchPointerEvent(event);`这么一句话，看来现在已经开始向view分发事件了。\n\n这里的`mView`是指向`DecorView`，剩下的内容下节继续\n\n\n\n# 0x03 ViewRootImpl到View \n\n通过View的`dispatchPointerEvent`调用了`dispatchTouchEvent`，\n\n因为`DecorView`重写了`dispatchTouchEvent`方法，看下这个内容：\n\n```java\n  @Override\n        public boolean dispatchTouchEvent(MotionEvent ev) {\n            final Callback cb = getCallback();\n            return cb != null && !isDestroyed() && mFeatureId < 0 ? cb.dispatchTouchEvent(ev)\n                    : super.dispatchTouchEvent(ev);\n        }\n```\n\n这里的`getCallback`返回的是Activity引用，如果Activity没有销毁，则调用Activity的`dispatchTouchEvent`方法。代码如下：\n\n```java\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n            onUserInteraction();\n        }\n        if (getWindow().superDispatchTouchEvent(ev)) {\n            return true;\n        }\n        return onTouchEvent(ev);\n    }\n```\n\n这里注意一点，如果`getWindow().superDispatchTouchEvent(ev)`返回true，则不继续执行Activity的`onTouchEvent`。\n\n这里的getWinddow就是PhoneWindow，而PhoneWindow的`superDispatchTouchEvent`直接引用了DecorView的`superDispatchTouchEvent`，接着调用了`super.dispatchTouchEvent(event)`，这里的super是ViewGroup，这里主要做了两件事：①判断当前ViewGroup是否拦截事件，如果拦截则执行`onInterceptTouchEvent`。②如果不拦截，事件也没取消，则事件向子View分发。在向子View分发前会先判断子View是否接受事件及事件是否在子View范围内。如果都为true了则调用`dispatchTransformedTouchEvent`。这里面调用了子View的`dispatchTouchEvent`。\n\n子View的`dispatchTouchEvent`里面会判断`touchListener.onTouch`方法和`onTouchEvent`方法。\n\n\n\n# 0x04 事件传递须知\n\n ①如果DecorView的`dispatchPointerEvent`方法返回true表示事件消费成功。\n\n②如果Activity没有销毁，则回调Activity的`dispatchTouchEvent`,如果phone window的`superDispatchTouchEvent`返回true表示被DecorView或其子View消耗了事件，则不执行Activity的onTouchEvent方法。\n\n③如果ViewGroup执行dispatchTouchEvent方法，先判断是否需要拦截事件：\n\n如果需要拦截则执行onInterceptTouchEvent方法。\n\n如果拦截返回true，则不继续事件传递，如果返回false，则继续，首先判断子View是否接受事件及是否在范围内，如果都符合则传递给子View。\n\n④如果子View执行dispatchTouchEvent方法，会先判断是否设置onTouchListener，\n\n如果设置了则执行onTouch方法。如果该方法返回true，则不继续执行子View 的onTouchEvent方法，否则继续执行ouTouchEvent方法。\n\n⑤如果ouTouchEvent方法执行，actionDown时检查长按事件，actionUp时检查onClick事件。\n\n\n\n\n\n\n\n","slug":"浅谈Android事件传递机制","published":1,"updated":"2017-07-25T17:31:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjn0078wh9coxj6j0p7","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>为什么点下屏幕某个位置时候，系统会找到正确地控件来响应？</p>\n<p>为什么按下按下返回键系统会让当前窗口页面关闭而不是下面的那个页面？</p>\n<p>很多时候多问自己个为什么就发现自己会的其实还很少。</p>\n<h1 id=\"0x01-冯诺依曼模型回顾\"><a href=\"#0x01-冯诺依曼模型回顾\" class=\"headerlink\" title=\"0x01 冯诺依曼模型回顾\"></a>0x01 冯诺依曼模型回顾</h1><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png\" alt=\"冯诺依曼模型\"></p>\n<p>讲事件传递为什么把冯诺依曼模型带进来了？</p>\n<p>事件传递的事件来自哪里？</p>\n<p>基本的事件来自按键、屏幕，属于输入设备，而最终事件的结果要显示在屏幕上(输出设备)，这样才算完成一次交互。其实这里屏幕同时兼顾输入和输出。</p>\n<p>有了输入设备，系统是如何从中采集数据的呢？</p>\n<h1 id=\"0x02-设备节点到ViewRootImpl\"><a href=\"#0x02-设备节点到ViewRootImpl\" class=\"headerlink\" title=\"0x02 设备节点到ViewRootImpl\"></a>0x02 设备节点到ViewRootImpl</h1><h2 id=\"Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\"><a href=\"#Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\" class=\"headerlink\" title=\"Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\"></a>Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。</h2><p>当发现输入设备可用时，Linux内核会在/dev/input/目录下创建名称为event0~n的设备节点。当设备不可用时则删除对应节点。</p>\n<p><em>如果刚才的不好理解，那么可以理解windows这种情况：当我们新买的鼠标插入USB口时，右下角一般弹窗正在安装USB驱动，而最终会在设备管理中多出一个USBHub设备节点，拔掉USB时就会消失</em></p>\n<p>输入设备准备就绪，当有事件发生时，Linux内核收到硬件中断，然后把中断加工成原始输入事件存入对应设备节点中。</p>\n<p>输入事件已经有了，用户空间只要读取事件信息就可以了。</p>\n<h2 id=\"在用户空间这块输入事件的负责人是谁呢？\"><a href=\"#在用户空间这块输入事件的负责人是谁呢？\" class=\"headerlink\" title=\"在用户空间这块输入事件的负责人是谁呢？\"></a>在用户空间这块输入事件的负责人是谁呢？</h2><p>Android系统为我们指定好了负责人：InputManagerService(后面直接称：IMS)。</p>\n<p>IMS和WMS，AMS一样都属于系统服务，在系统启动时由SystemServer统一启动。所以只要看看源码才能知道具体情况如何。</p>\n<p>首先看下<code>SystemServer</code>启动情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * The main entry point from zygote.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> SystemServer().run();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// Start services.</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            startBootstrapServices();</div><div class=\"line\">            startCoreServices();</div><div class=\"line\">            startOtherServices();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">            Slog.e(<span class=\"string\">\"System\"</span>, \t<span class=\"string\">\"******************************************\"</span>);</div><div class=\"line\">            Slog.e(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"************ Failure starting system services\"</span>, ex);</div><div class=\"line\">            <span class=\"keyword\">throw</span> ex;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过源码发现<code>SystemServer</code>通过main方法直接启动的。当然这里run方法代码只是关键的一部分，如果都粘贴上来会影响分析。</p>\n<p>那么IMS在哪启动的呢？其实IMS通过<code>startOtherServices</code>方法启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startOtherServices</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        WindowManagerService wm = <span class=\"keyword\">null</span>;</div><div class=\"line\">       InputManagerService inputManager = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">\t wm = WindowManagerService.main(context, inputManager,</div><div class=\"line\">                   mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</div><div class=\"line\">                   !mFirstBoot, mOnlyCore);</div><div class=\"line\">           ServiceManager.addService(Context.WINDOW_SERVICE, wm);</div><div class=\"line\">           ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</div><div class=\"line\"></div><div class=\"line\">           inputManager = <span class=\"keyword\">new</span> InputManagerService(context);</div><div class=\"line\">          inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</div><div class=\"line\">           inputManager.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里不仅启动了IMS，还有WMS，还给IMS设置了一个<code>wm.getInputMonitor()</code>，这个设置有什么用先不用管。最后调用了start方法。</p>\n<p>目前只只知道IMS是用户空间的输入事件负责人，具体如何负责还要继续看，IMS的start方法调用了<code>nativeStart(mPtr);</code>，看的出来这是要进入C层实现了。</p>\n<p>找到Java层IMS对应的C层实现，打开文件找到<code>nativeStart</code>实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">nativeStart</span><span class=\"params\">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</div><div class=\"line\">    NativeInputManager* im = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">status_t</span> result = im-&gt;getInputManager()-&gt;start();</div><div class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Input manager could not be started.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法如此简单，又是个躯壳，仅仅调用了其他类的方法。</p>\n<p>下面看看<code>start()</code>里面干了什么，</p>\n<p>注意一点：这里显示的是<code>NativeInputManager</code>，但其实找到的是<code>InputManager</code>,多态特性。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">status_t</span> InputManager::start() &#123;    </div><div class=\"line\">    <span class=\"keyword\">status_t</span> result = mDispatcherThread-&gt;run(<span class=\"string\">\"InputDispatcher\"</span>, PRIORITY_URGENT_DISPLAY);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">        ALOGE(<span class=\"string\">\"Could not start InputDispatcher thread due to error %d.\"</span>, result);</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    result = mReaderThread-&gt;run(<span class=\"string\">\"InputReader\"</span>, PRIORITY_URGENT_DISPLAY);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">        ALOGE(<span class=\"string\">\"Could not start InputReader thread due to error %d.\"</span>, result);</div><div class=\"line\"></div><div class=\"line\">        mDispatcherThread-&gt;requestExit();</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> OK;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这次真的是全部代码，没有精简，看的出来好像start就启动了两个线程。</p>\n<p>mDispatcherThread对应<code>InputDispatcherThread</code>类，负责事件分发</p>\n<p>mReaderThread对应<code>InputReaderThread</code>类，负责事件读取</p>\n<p>现在我们基本可以猜到，一个线程读取事件，读取后把事件信息传递给分发线程，由分发线程继续处理。</p>\n<p>当然这还都只是猜测，实践是检验真理的唯一标准。</p>\n<h2 id=\"看看InputReaderThread干了什么\"><a href=\"#看看InputReaderThread干了什么\" class=\"headerlink\" title=\"看看InputReaderThread干了什么\"></a>看看InputReaderThread干了什么</h2><p>首先看看<code>InputReaderThread</code>源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Reads raw events from the event hub and processes them, endlessly. */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputReaderThread</span> :</span> <span class=\"keyword\">public</span> Thread &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    InputReaderThread(<span class=\"keyword\">const</span> sp&lt;InputReaderInterface&gt;&amp; reader);</div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~InputReaderThread();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    sp&lt;InputReaderInterface&gt; mReader;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">threadLoop</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>InputReaderThread</code>继承了Thread，在执行run方法时会回调<code>threadLoop</code>。从<code>virtual</code>知道这是一个虚函数，来看看具体实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">bool</span> InputReaderThread::threadLoop() &#123;</div><div class=\"line\">    mReader-&gt;loopOnce();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mReader对应<code>InputReader</code>类，看下<code>loopOnce</code>方法实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> InputReader::loopOnce() &#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> oldGeneration;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> timeoutMillis;</div><div class=\"line\">    <span class=\"keyword\">bool</span> inputDevicesChanged = <span class=\"literal\">false</span>;</div><div class=\"line\">    Vector&lt;InputDeviceInfo&gt; inputDevices;</div><div class=\"line\">    &#123; <span class=\"comment\">// acquire lock</span></div><div class=\"line\">        AutoMutex _l(mLock);</div><div class=\"line\"></div><div class=\"line\">        oldGeneration = mGeneration;</div><div class=\"line\">        timeoutMillis = <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> changes = mConfigurationChangesToRefresh;</div><div class=\"line\">        <span class=\"keyword\">if</span> (changes) &#123;</div><div class=\"line\">            mConfigurationChangesToRefresh = <span class=\"number\">0</span>;</div><div class=\"line\">            timeoutMillis = <span class=\"number\">0</span>;</div><div class=\"line\">            refreshConfigurationLocked(changes);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mNextTimeout != LLONG_MAX) &#123;</div><div class=\"line\">            <span class=\"keyword\">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class=\"line\">            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"comment\">// release lock</span></div><div class=\"line\">    <span class=\"comment\">//这里就是我们开始说的从设备节点读取输入事件的函数了。</span></div><div class=\"line\">    <span class=\"keyword\">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</div><div class=\"line\"></div><div class=\"line\">    &#123; <span class=\"comment\">// acquire lock</span></div><div class=\"line\">        AutoMutex _l(mLock);</div><div class=\"line\">        mReaderIsAliveCondition.broadcast();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (count) &#123;</div><div class=\"line\">          <span class=\"comment\">//处理事件</span></div><div class=\"line\">            processEventsLocked(mEventBuffer, count);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mNextTimeout != LLONG_MAX) &#123;</div><div class=\"line\">            <span class=\"keyword\">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class=\"line\">            <span class=\"keyword\">if</span> (now &gt;= mNextTimeout) &#123;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DEBUG_RAW_EVENTS</span></div><div class=\"line\">                ALOGD(<span class=\"string\">\"Timeout expired, latency=%0.3fms\"</span>, (now - mNextTimeout) * <span class=\"number\">0.000001f</span>);</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">                mNextTimeout = LLONG_MAX;</div><div class=\"line\">                timeoutExpiredLocked(now);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (oldGeneration != mGeneration) &#123;</div><div class=\"line\">            inputDevicesChanged = <span class=\"literal\">true</span>;</div><div class=\"line\">            getInputDevicesLocked(inputDevices);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"comment\">// release lock</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Send out a message that the describes the changed input devices.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (inputDevicesChanged) &#123;</div><div class=\"line\">        mPolicy-&gt;notifyInputDevicesChanged(inputDevices);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Flush queued events out to the listener.</span></div><div class=\"line\">    <span class=\"comment\">// This must happen outside of the lock because the listener could potentially call</span></div><div class=\"line\">    <span class=\"comment\">// back into the InputReader's methods, such as getScanCodeState, or become blocked</span></div><div class=\"line\">    <span class=\"comment\">// on another thread similarly waiting to acquire the InputReader lock thereby</span></div><div class=\"line\">    <span class=\"comment\">// resulting in a deadlock.  This situation is actually quite plausible because the</span></div><div class=\"line\">    <span class=\"comment\">// listener is actually the input dispatcher, which calls into the window manager,</span></div><div class=\"line\">    <span class=\"comment\">// which occasionally calls into the input reader.</span></div><div class=\"line\">    mQueuedListener-&gt;flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面方法主要执行了三个流程：</p>\n<p>①通过<code>mEventHub-&gt;getEvents</code>读取事件</p>\n<p>​    这里不再继续深入，重点理解②③</p>\n<p>②通过<code>processEventsLocked</code>处理事件</p>\n<p>这方法里面有<code>processEventsForDeviceLocked</code>方法，这是处理一般事件的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> InputReader::processEventsForDeviceLocked(<span class=\"keyword\">int32_t</span> deviceId,</div><div class=\"line\">        <span class=\"keyword\">const</span> RawEvent* rawEvents, <span class=\"keyword\">size_t</span> count) &#123;</div><div class=\"line\">    <span class=\"keyword\">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</div><div class=\"line\">    <span class=\"keyword\">if</span> (deviceIndex &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ALOGW(<span class=\"string\">\"Discarding event for unknown deviceId %d.\"</span>, deviceId);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    InputDevice* device = mDevices.valueAt(deviceIndex);</div><div class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;isIgnored()) &#123;</div><div class=\"line\">        <span class=\"comment\">//ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId);</span></div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    device-&gt;process(rawEvents, count);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里根据<code>deviceId</code>生成<code>InputDevice</code>。进而调用<code>device-&gt;process</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; numMappers; i++) &#123;</div><div class=\"line\">               InputMapper* mapper = mMappers[i];</div><div class=\"line\">               mapper-&gt;process(rawEvent);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n<p>最终引出了<code>InputMapper</code>，这是一个基类，而对于触摸事件会调用<code>TouchInputMapper</code>类的<code>process</code>方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> TouchInputMapper::process(<span class=\"keyword\">const</span> RawEvent* rawEvent) &#123;</div><div class=\"line\">    mCursorButtonAccumulator.process(rawEvent);</div><div class=\"line\">    mCursorScrollAccumulator.process(rawEvent);</div><div class=\"line\">    mTouchButtonAccumulator.process(rawEvent);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</div><div class=\"line\">        sync(rawEvent-&gt;when);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>后面经过一系列方法调用，事件信息封装到<code>NotifyMotionArgs args</code>，通过<code>getListener()-&gt;notifyMotion(&amp;args)</code>方法把事件加入到队列中。然后开始③过程。</p>\n<p>③通过<code>mQueuedListener-&gt;flush()</code>事件转移到<code>InputDispatcherThread</code>。</p>\n<p>看看<code>flush</code>源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> QueuedInputListener::flush() &#123;</div><div class=\"line\">    <span class=\"keyword\">size_t</span> count = mArgsQueue.size();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">        NotifyArgs* args = mArgsQueue[i];</div><div class=\"line\">        args-&gt;notify(mInnerListener);</div><div class=\"line\">        <span class=\"keyword\">delete</span> args;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mArgsQueue.clear();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法遍历事件，同时执行<code>notify</code>，然后从队列删除消息，</p>\n<p><code>NotifyArgs</code>也是基类，有多种子类，其中触摸事件为<code>NotifyMotionArgs</code>，其<code>notify</code>方法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> NotifyMotionArgs::notify(<span class=\"keyword\">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class=\"keyword\">const</span> &#123;</div><div class=\"line\">    listener-&gt;notifyMotion(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的<code>listener</code>指向<code>InputDispatcher</code>，而<code>InputDispatcher</code>隶属于<code>InputDispatcherThread</code> ，下一节继续</p>\n<h2 id=\"看看InputDispatcherThread干了什么\"><a href=\"#看看InputDispatcherThread干了什么\" class=\"headerlink\" title=\"看看InputDispatcherThread干了什么\"></a>看看InputDispatcherThread干了什么</h2><p><code>InputDispatcherThread</code>执行的时候调用了<code>threadLoop</code>然后调用了<code>mDispatcher-&gt;dispatchOnce();</code>。经过一些列调用会转战到<code>InputChannel::sendMessage</code>。</p>\n<p>继续上一节，看看<code>InputDispatcher</code>中<code>notifyMotion</code>方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> InputDispatcher::notifyMotion(<span class=\"keyword\">const</span> NotifyMotionArgs* args) &#123;</div><div class=\"line\"></div><div class=\"line\">\tneedWake = enqueueInboundEventLocked(newEntry);</div><div class=\"line\">     <span class=\"keyword\">if</span> (needWake) &#123;</div><div class=\"line\">      mLooper-&gt;wake();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法主要做了这两件事：</p>\n<p>①事件再次加入队列</p>\n<p>​    其中还执行了<code>findTouchedWindowAtLocked</code>查找当前活动窗口并拿到句柄。</p>\n<p>②唤醒looper。</p>\n<blockquote>\n<p>这里疑惑的一点是：事件加入队列，唤醒looper，接下来应该是looper循环读取消息队列进行事件分发，但是这里没有找到和dispatchOnce想关联的地方。可能有疏漏地方。以后发现问题会及时更新上。这里直接继续InputChannel::sendMessage来说。</p>\n</blockquote>\n<p><code>InputChannel</code>是负责与app窗口进行通信的，通过WMS找到对应的窗口。那么<code>InputChannel</code>到底是怎么找到窗口的？</p>\n<p>在WMS的<code>addWindow</code>方法中有这样几行代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">addWindow</span><span class=\"params\">(Session session, IWindow client, <span class=\"keyword\">int</span> seq,</span></span></div><div class=\"line\">            WindowManager.LayoutParams attrs, <span class=\"keyword\">int</span> viewVisibility, <span class=\"keyword\">int</span> displayId,</div><div class=\"line\">            Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) &#123;</div><div class=\"line\">            </div><div class=\"line\">                </div><div class=\"line\">                String name = win.makeInputChannelName();</div><div class=\"line\">                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</div><div class=\"line\">                win.setInputChannel(inputChannels[<span class=\"number\">0</span>]);</div><div class=\"line\">                inputChannels[<span class=\"number\">1</span>].transferTo(outInputChannel);</div><div class=\"line\"></div><div class=\"line\">                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</div><div class=\"line\">            </div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里是在Activity初始化时想WMS添加的窗口的调用方法，其中在添加窗口时候就已经给这个窗口设置了通信通道。</p>\n<p>然后看下<code>InputChannel.openInputChannelPair</code>里面做了什么：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">status_t</span> InputChannel::openInputChannelPair(<span class=\"keyword\">const</span> String8&amp; name,</div><div class=\"line\">        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sockets[<span class=\"number\">2</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class=\"number\">0</span>, sockets)) &#123;</div><div class=\"line\">        <span class=\"keyword\">status_t</span> result = -errno;</div><div class=\"line\">        ALOGE(<span class=\"string\">\"channel '%s' ~ Could not create socket pair.  errno=%d\"</span>,</div><div class=\"line\">                name.<span class=\"built_in\">string</span>(), errno);</div><div class=\"line\">        outServerChannel.clear();</div><div class=\"line\">        outClientChannel.clear();</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> bufferSize = SOCKET_BUFFER_SIZE;</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\"></div><div class=\"line\">    String8 serverChannelName = name;</div><div class=\"line\">    serverChannelName.append(<span class=\"string\">\" (server)\"</span>);</div><div class=\"line\">    outServerChannel = <span class=\"keyword\">new</span> InputChannel(serverChannelName, sockets[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\">    String8 clientChannelName = name;</div><div class=\"line\">    clientChannelName.append(<span class=\"string\">\" (client)\"</span>);</div><div class=\"line\">    outClientChannel = <span class=\"keyword\">new</span> InputChannel(clientChannelName, sockets[<span class=\"number\">1</span>]);</div><div class=\"line\">    <span class=\"keyword\">return</span> OK;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里主要创建了两个<code>InputChannel</code>，一个服务端一个客户端，这里的的<code>InputChannel</code>是基于socket的，这个socket不是网络的socket而是Unix特有的关于文件的Unix domain socket。</p>\n<h2 id=\"WMS和ViewRootImpl\"><a href=\"#WMS和ViewRootImpl\" class=\"headerlink\" title=\"WMS和ViewRootImpl\"></a>WMS和ViewRootImpl</h2><p>经过一些列的调转，最终会回调到<code>InputEventReceiver</code>的<code>dispatchInputEvent</code>方法。</p>\n<p>这个方法是C++通过JNi回调的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Called from native code.</span></div><div class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unused\"</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchInputEvent</span><span class=\"params\">(<span class=\"keyword\">int</span> seq, InputEvent event)</span> </span>&#123;</div><div class=\"line\">    mSeqMap.put(event.getSequenceNumber(), seq);</div><div class=\"line\">    onInputEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的<code>InputEventReceiver</code> 对象其实是<code>WindowInputEventReceiver</code> 的引用，所以<code>onInputEvent</code>其实调用的<code>WindowInputEventReceiver</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onInputEvent</span><span class=\"params\">(InputEvent event)</span> </span>&#123;</div><div class=\"line\">          enqueueInputEvent(event, <span class=\"keyword\">this</span>, <span class=\"number\">0</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p><code>enqueueInputEvent</code>通过连续调用，跳转到<code>deliverInputEvent</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverInputEvent</span><span class=\"params\">(QueuedInputEvent q)</span> </span>&#123;</div><div class=\"line\">    Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">\"deliverInputEvent\"</span>,</div><div class=\"line\">            q.mEvent.getSequenceNumber());</div><div class=\"line\">    <span class=\"keyword\">if</span> (mInputEventConsistencyVerifier != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mInputEventConsistencyVerifier.onInputEvent(q.mEvent, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    InputStage stage;</div><div class=\"line\">    <span class=\"keyword\">if</span> (q.shouldSendToSynthesizer()) &#123;</div><div class=\"line\">        stage = mSyntheticInputStage;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (stage != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        stage.deliver(q);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        finishInputEvent(q);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的<code>stage</code>是多态形式，但是最终会调用<code>ViewPostImeInputStage</code>的<code>onProcess</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">onProcess</span><span class=\"params\">(QueuedInputEvent q)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (q.mEvent <span class=\"keyword\">instanceof</span> KeyEvent) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> processKeyEvent(q);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// If delivering a new non-key event, make sure the window is</span></div><div class=\"line\">         <span class=\"comment\">// now allowed to start updating.</span></div><div class=\"line\">         handleDispatchDoneAnimating();</div><div class=\"line\">         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> source = q.mEvent.getSource();</div><div class=\"line\">         <span class=\"keyword\">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">return</span> processPointerEvent(q);</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">return</span> processTrackballEvent(q);</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             <span class=\"keyword\">return</span> processGenericMotionEvent(q);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>由于是触摸事件，所以会执行<code>processPointerEvent</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">processPointerEvent</span><span class=\"params\">(QueuedInputEvent q)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">final</span> MotionEvent event = (MotionEvent)q.mEvent;</div><div class=\"line\"></div><div class=\"line\">     mAttachInfo.mUnbufferedDispatchRequested = <span class=\"keyword\">false</span>;</div><div class=\"line\">     <span class=\"keyword\">boolean</span> handled = mView.dispatchPointerEvent(event);</div><div class=\"line\">     <span class=\"keyword\">if</span> (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) &#123;</div><div class=\"line\">         mUnbufferedInputDispatch = <span class=\"keyword\">true</span>;</div><div class=\"line\">         <span class=\"keyword\">if</span> (mConsumeBatchedInputScheduled) &#123;</div><div class=\"line\">             scheduleConsumeBatchedInputImmediately();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> handled ? FINISH_HANDLED : FORWARD;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>发现有<code>boolean handled = mView.dispatchPointerEvent(event);</code>这么一句话，看来现在已经开始向view分发事件了。</p>\n<p>这里的<code>mView</code>是指向<code>DecorView</code>，剩下的内容下节继续</p>\n<h1 id=\"0x03-ViewRootImpl到View\"><a href=\"#0x03-ViewRootImpl到View\" class=\"headerlink\" title=\"0x03 ViewRootImpl到View\"></a>0x03 ViewRootImpl到View</h1><p>通过View的<code>dispatchPointerEvent</code>调用了<code>dispatchTouchEvent</code>，</p>\n<p>因为<code>DecorView</code>重写了<code>dispatchTouchEvent</code>方法，看下这个内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> Callback cb = getCallback();</div><div class=\"line\">          <span class=\"keyword\">return</span> cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; <span class=\"number\">0</span> ? cb.dispatchTouchEvent(ev)</div><div class=\"line\">                  : <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>这里的<code>getCallback</code>返回的是Activity引用，如果Activity没有销毁，则调用Activity的<code>dispatchTouchEvent</code>方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">        onUserInteraction();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(ev);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里注意一点，如果<code>getWindow().superDispatchTouchEvent(ev)</code>返回true，则不继续执行Activity的<code>onTouchEvent</code>。</p>\n<p>这里的getWinddow就是PhoneWindow，而PhoneWindow的<code>superDispatchTouchEvent</code>直接引用了DecorView的<code>superDispatchTouchEvent</code>，接着调用了<code>super.dispatchTouchEvent(event)</code>，这里的super是ViewGroup，这里主要做了两件事：①判断当前ViewGroup是否拦截事件，如果拦截则执行<code>onInterceptTouchEvent</code>。②如果不拦截，事件也没取消，则事件向子View分发。在向子View分发前会先判断子View是否接受事件及事件是否在子View范围内。如果都为true了则调用<code>dispatchTransformedTouchEvent</code>。这里面调用了子View的<code>dispatchTouchEvent</code>。</p>\n<p>子View的<code>dispatchTouchEvent</code>里面会判断<code>touchListener.onTouch</code>方法和<code>onTouchEvent</code>方法。</p>\n<h1 id=\"0x04-事件传递须知\"><a href=\"#0x04-事件传递须知\" class=\"headerlink\" title=\"0x04 事件传递须知\"></a>0x04 事件传递须知</h1><p> ①如果DecorView的<code>dispatchPointerEvent</code>方法返回true表示事件消费成功。</p>\n<p>②如果Activity没有销毁，则回调Activity的<code>dispatchTouchEvent</code>,如果phone window的<code>superDispatchTouchEvent</code>返回true表示被DecorView或其子View消耗了事件，则不执行Activity的onTouchEvent方法。</p>\n<p>③如果ViewGroup执行dispatchTouchEvent方法，先判断是否需要拦截事件：</p>\n<p>如果需要拦截则执行onInterceptTouchEvent方法。</p>\n<p>如果拦截返回true，则不继续事件传递，如果返回false，则继续，首先判断子View是否接受事件及是否在范围内，如果都符合则传递给子View。</p>\n<p>④如果子View执行dispatchTouchEvent方法，会先判断是否设置onTouchListener，</p>\n<p>如果设置了则执行onTouch方法。如果该方法返回true，则不继续执行子View 的onTouchEvent方法，否则继续执行ouTouchEvent方法。</p>\n<p>⑤如果ouTouchEvent方法执行，actionDown时检查长按事件，actionUp时检查onClick事件。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>为什么点下屏幕某个位置时候，系统会找到正确地控件来响应？</p>\n<p>为什么按下按下返回键系统会让当前窗口页面关闭而不是下面的那个页面？</p>\n<p>很多时候多问自己个为什么就发现自己会的其实还很少。</p>\n<h1 id=\"0x01-冯诺依曼模型回顾\"><a href=\"#0x01-冯诺依曼模型回顾\" class=\"headerlink\" title=\"0x01 冯诺依曼模型回顾\"></a>0x01 冯诺依曼模型回顾</h1><p><img src=\"http://othg5ggzi.bkt.clouddn.com/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png\" alt=\"冯诺依曼模型\"></p>\n<p>讲事件传递为什么把冯诺依曼模型带进来了？</p>\n<p>事件传递的事件来自哪里？</p>\n<p>基本的事件来自按键、屏幕，属于输入设备，而最终事件的结果要显示在屏幕上(输出设备)，这样才算完成一次交互。其实这里屏幕同时兼顾输入和输出。</p>\n<p>有了输入设备，系统是如何从中采集数据的呢？</p>\n<h1 id=\"0x02-设备节点到ViewRootImpl\"><a href=\"#0x02-设备节点到ViewRootImpl\" class=\"headerlink\" title=\"0x02 设备节点到ViewRootImpl\"></a>0x02 设备节点到ViewRootImpl</h1><h2 id=\"Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\"><a href=\"#Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\" class=\"headerlink\" title=\"Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\"></a>Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。</h2><p>当发现输入设备可用时，Linux内核会在/dev/input/目录下创建名称为event0~n的设备节点。当设备不可用时则删除对应节点。</p>\n<p><em>如果刚才的不好理解，那么可以理解windows这种情况：当我们新买的鼠标插入USB口时，右下角一般弹窗正在安装USB驱动，而最终会在设备管理中多出一个USBHub设备节点，拔掉USB时就会消失</em></p>\n<p>输入设备准备就绪，当有事件发生时，Linux内核收到硬件中断，然后把中断加工成原始输入事件存入对应设备节点中。</p>\n<p>输入事件已经有了，用户空间只要读取事件信息就可以了。</p>\n<h2 id=\"在用户空间这块输入事件的负责人是谁呢？\"><a href=\"#在用户空间这块输入事件的负责人是谁呢？\" class=\"headerlink\" title=\"在用户空间这块输入事件的负责人是谁呢？\"></a>在用户空间这块输入事件的负责人是谁呢？</h2><p>Android系统为我们指定好了负责人：InputManagerService(后面直接称：IMS)。</p>\n<p>IMS和WMS，AMS一样都属于系统服务，在系统启动时由SystemServer统一启动。所以只要看看源码才能知道具体情况如何。</p>\n<p>首先看下<code>SystemServer</code>启动情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * The main entry point from zygote.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> SystemServer().run();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// Start services.</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            startBootstrapServices();</div><div class=\"line\">            startCoreServices();</div><div class=\"line\">            startOtherServices();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">            Slog.e(<span class=\"string\">\"System\"</span>, \t<span class=\"string\">\"******************************************\"</span>);</div><div class=\"line\">            Slog.e(<span class=\"string\">\"System\"</span>, <span class=\"string\">\"************ Failure starting system services\"</span>, ex);</div><div class=\"line\">            <span class=\"keyword\">throw</span> ex;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过源码发现<code>SystemServer</code>通过main方法直接启动的。当然这里run方法代码只是关键的一部分，如果都粘贴上来会影响分析。</p>\n<p>那么IMS在哪启动的呢？其实IMS通过<code>startOtherServices</code>方法启动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startOtherServices</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        WindowManagerService wm = <span class=\"keyword\">null</span>;</div><div class=\"line\">       InputManagerService inputManager = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">\t wm = WindowManagerService.main(context, inputManager,</div><div class=\"line\">                   mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</div><div class=\"line\">                   !mFirstBoot, mOnlyCore);</div><div class=\"line\">           ServiceManager.addService(Context.WINDOW_SERVICE, wm);</div><div class=\"line\">           ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</div><div class=\"line\"></div><div class=\"line\">           inputManager = <span class=\"keyword\">new</span> InputManagerService(context);</div><div class=\"line\">          inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</div><div class=\"line\">           inputManager.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里不仅启动了IMS，还有WMS，还给IMS设置了一个<code>wm.getInputMonitor()</code>，这个设置有什么用先不用管。最后调用了start方法。</p>\n<p>目前只只知道IMS是用户空间的输入事件负责人，具体如何负责还要继续看，IMS的start方法调用了<code>nativeStart(mPtr);</code>，看的出来这是要进入C层实现了。</p>\n<p>找到Java层IMS对应的C层实现，打开文件找到<code>nativeStart</code>实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">nativeStart</span><span class=\"params\">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</div><div class=\"line\">    NativeInputManager* im = <span class=\"keyword\">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">status_t</span> result = im-&gt;getInputManager()-&gt;start();</div><div class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Input manager could not be started.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法如此简单，又是个躯壳，仅仅调用了其他类的方法。</p>\n<p>下面看看<code>start()</code>里面干了什么，</p>\n<p>注意一点：这里显示的是<code>NativeInputManager</code>，但其实找到的是<code>InputManager</code>,多态特性。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">status_t</span> InputManager::start() &#123;    </div><div class=\"line\">    <span class=\"keyword\">status_t</span> result = mDispatcherThread-&gt;run(<span class=\"string\">\"InputDispatcher\"</span>, PRIORITY_URGENT_DISPLAY);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">        ALOGE(<span class=\"string\">\"Could not start InputDispatcher thread due to error %d.\"</span>, result);</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    result = mReaderThread-&gt;run(<span class=\"string\">\"InputReader\"</span>, PRIORITY_URGENT_DISPLAY);</div><div class=\"line\">    <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\">        ALOGE(<span class=\"string\">\"Could not start InputReader thread due to error %d.\"</span>, result);</div><div class=\"line\"></div><div class=\"line\">        mDispatcherThread-&gt;requestExit();</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> OK;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这次真的是全部代码，没有精简，看的出来好像start就启动了两个线程。</p>\n<p>mDispatcherThread对应<code>InputDispatcherThread</code>类，负责事件分发</p>\n<p>mReaderThread对应<code>InputReaderThread</code>类，负责事件读取</p>\n<p>现在我们基本可以猜到，一个线程读取事件，读取后把事件信息传递给分发线程，由分发线程继续处理。</p>\n<p>当然这还都只是猜测，实践是检验真理的唯一标准。</p>\n<h2 id=\"看看InputReaderThread干了什么\"><a href=\"#看看InputReaderThread干了什么\" class=\"headerlink\" title=\"看看InputReaderThread干了什么\"></a>看看InputReaderThread干了什么</h2><p>首先看看<code>InputReaderThread</code>源码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Reads raw events from the event hub and processes them, endlessly. */</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputReaderThread</span> :</span> <span class=\"keyword\">public</span> Thread &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    InputReaderThread(<span class=\"keyword\">const</span> sp&lt;InputReaderInterface&gt;&amp; reader);</div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~InputReaderThread();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span>:</div><div class=\"line\">    sp&lt;InputReaderInterface&gt; mReader;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">threadLoop</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>InputReaderThread</code>继承了Thread，在执行run方法时会回调<code>threadLoop</code>。从<code>virtual</code>知道这是一个虚函数，来看看具体实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">bool</span> InputReaderThread::threadLoop() &#123;</div><div class=\"line\">    mReader-&gt;loopOnce();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mReader对应<code>InputReader</code>类，看下<code>loopOnce</code>方法实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> InputReader::loopOnce() &#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> oldGeneration;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> timeoutMillis;</div><div class=\"line\">    <span class=\"keyword\">bool</span> inputDevicesChanged = <span class=\"literal\">false</span>;</div><div class=\"line\">    Vector&lt;InputDeviceInfo&gt; inputDevices;</div><div class=\"line\">    &#123; <span class=\"comment\">// acquire lock</span></div><div class=\"line\">        AutoMutex _l(mLock);</div><div class=\"line\"></div><div class=\"line\">        oldGeneration = mGeneration;</div><div class=\"line\">        timeoutMillis = <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> changes = mConfigurationChangesToRefresh;</div><div class=\"line\">        <span class=\"keyword\">if</span> (changes) &#123;</div><div class=\"line\">            mConfigurationChangesToRefresh = <span class=\"number\">0</span>;</div><div class=\"line\">            timeoutMillis = <span class=\"number\">0</span>;</div><div class=\"line\">            refreshConfigurationLocked(changes);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mNextTimeout != LLONG_MAX) &#123;</div><div class=\"line\">            <span class=\"keyword\">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class=\"line\">            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"comment\">// release lock</span></div><div class=\"line\">    <span class=\"comment\">//这里就是我们开始说的从设备节点读取输入事件的函数了。</span></div><div class=\"line\">    <span class=\"keyword\">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</div><div class=\"line\"></div><div class=\"line\">    &#123; <span class=\"comment\">// acquire lock</span></div><div class=\"line\">        AutoMutex _l(mLock);</div><div class=\"line\">        mReaderIsAliveCondition.broadcast();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (count) &#123;</div><div class=\"line\">          <span class=\"comment\">//处理事件</span></div><div class=\"line\">            processEventsLocked(mEventBuffer, count);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mNextTimeout != LLONG_MAX) &#123;</div><div class=\"line\">            <span class=\"keyword\">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class=\"line\">            <span class=\"keyword\">if</span> (now &gt;= mNextTimeout) &#123;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DEBUG_RAW_EVENTS</span></div><div class=\"line\">                ALOGD(<span class=\"string\">\"Timeout expired, latency=%0.3fms\"</span>, (now - mNextTimeout) * <span class=\"number\">0.000001f</span>);</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\">                mNextTimeout = LLONG_MAX;</div><div class=\"line\">                timeoutExpiredLocked(now);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (oldGeneration != mGeneration) &#123;</div><div class=\"line\">            inputDevicesChanged = <span class=\"literal\">true</span>;</div><div class=\"line\">            getInputDevicesLocked(inputDevices);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"comment\">// release lock</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Send out a message that the describes the changed input devices.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (inputDevicesChanged) &#123;</div><div class=\"line\">        mPolicy-&gt;notifyInputDevicesChanged(inputDevices);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Flush queued events out to the listener.</span></div><div class=\"line\">    <span class=\"comment\">// This must happen outside of the lock because the listener could potentially call</span></div><div class=\"line\">    <span class=\"comment\">// back into the InputReader's methods, such as getScanCodeState, or become blocked</span></div><div class=\"line\">    <span class=\"comment\">// on another thread similarly waiting to acquire the InputReader lock thereby</span></div><div class=\"line\">    <span class=\"comment\">// resulting in a deadlock.  This situation is actually quite plausible because the</span></div><div class=\"line\">    <span class=\"comment\">// listener is actually the input dispatcher, which calls into the window manager,</span></div><div class=\"line\">    <span class=\"comment\">// which occasionally calls into the input reader.</span></div><div class=\"line\">    mQueuedListener-&gt;flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面方法主要执行了三个流程：</p>\n<p>①通过<code>mEventHub-&gt;getEvents</code>读取事件</p>\n<p>​    这里不再继续深入，重点理解②③</p>\n<p>②通过<code>processEventsLocked</code>处理事件</p>\n<p>这方法里面有<code>processEventsForDeviceLocked</code>方法，这是处理一般事件的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> InputReader::processEventsForDeviceLocked(<span class=\"keyword\">int32_t</span> deviceId,</div><div class=\"line\">        <span class=\"keyword\">const</span> RawEvent* rawEvents, <span class=\"keyword\">size_t</span> count) &#123;</div><div class=\"line\">    <span class=\"keyword\">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</div><div class=\"line\">    <span class=\"keyword\">if</span> (deviceIndex &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ALOGW(<span class=\"string\">\"Discarding event for unknown deviceId %d.\"</span>, deviceId);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    InputDevice* device = mDevices.valueAt(deviceIndex);</div><div class=\"line\">    <span class=\"keyword\">if</span> (device-&gt;isIgnored()) &#123;</div><div class=\"line\">        <span class=\"comment\">//ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId);</span></div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    device-&gt;process(rawEvents, count);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里根据<code>deviceId</code>生成<code>InputDevice</code>。进而调用<code>device-&gt;process</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; numMappers; i++) &#123;</div><div class=\"line\">               InputMapper* mapper = mMappers[i];</div><div class=\"line\">               mapper-&gt;process(rawEvent);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n<p>最终引出了<code>InputMapper</code>，这是一个基类，而对于触摸事件会调用<code>TouchInputMapper</code>类的<code>process</code>方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> TouchInputMapper::process(<span class=\"keyword\">const</span> RawEvent* rawEvent) &#123;</div><div class=\"line\">    mCursorButtonAccumulator.process(rawEvent);</div><div class=\"line\">    mCursorScrollAccumulator.process(rawEvent);</div><div class=\"line\">    mTouchButtonAccumulator.process(rawEvent);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</div><div class=\"line\">        sync(rawEvent-&gt;when);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>后面经过一系列方法调用，事件信息封装到<code>NotifyMotionArgs args</code>，通过<code>getListener()-&gt;notifyMotion(&amp;args)</code>方法把事件加入到队列中。然后开始③过程。</p>\n<p>③通过<code>mQueuedListener-&gt;flush()</code>事件转移到<code>InputDispatcherThread</code>。</p>\n<p>看看<code>flush</code>源码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> QueuedInputListener::flush() &#123;</div><div class=\"line\">    <span class=\"keyword\">size_t</span> count = mArgsQueue.size();</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">        NotifyArgs* args = mArgsQueue[i];</div><div class=\"line\">        args-&gt;notify(mInnerListener);</div><div class=\"line\">        <span class=\"keyword\">delete</span> args;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mArgsQueue.clear();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法遍历事件，同时执行<code>notify</code>，然后从队列删除消息，</p>\n<p><code>NotifyArgs</code>也是基类，有多种子类，其中触摸事件为<code>NotifyMotionArgs</code>，其<code>notify</code>方法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> NotifyMotionArgs::notify(<span class=\"keyword\">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class=\"keyword\">const</span> &#123;</div><div class=\"line\">    listener-&gt;notifyMotion(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的<code>listener</code>指向<code>InputDispatcher</code>，而<code>InputDispatcher</code>隶属于<code>InputDispatcherThread</code> ，下一节继续</p>\n<h2 id=\"看看InputDispatcherThread干了什么\"><a href=\"#看看InputDispatcherThread干了什么\" class=\"headerlink\" title=\"看看InputDispatcherThread干了什么\"></a>看看InputDispatcherThread干了什么</h2><p><code>InputDispatcherThread</code>执行的时候调用了<code>threadLoop</code>然后调用了<code>mDispatcher-&gt;dispatchOnce();</code>。经过一些列调用会转战到<code>InputChannel::sendMessage</code>。</p>\n<p>继续上一节，看看<code>InputDispatcher</code>中<code>notifyMotion</code>方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> InputDispatcher::notifyMotion(<span class=\"keyword\">const</span> NotifyMotionArgs* args) &#123;</div><div class=\"line\"></div><div class=\"line\">\tneedWake = enqueueInboundEventLocked(newEntry);</div><div class=\"line\">     <span class=\"keyword\">if</span> (needWake) &#123;</div><div class=\"line\">      mLooper-&gt;wake();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>方法主要做了这两件事：</p>\n<p>①事件再次加入队列</p>\n<p>​    其中还执行了<code>findTouchedWindowAtLocked</code>查找当前活动窗口并拿到句柄。</p>\n<p>②唤醒looper。</p>\n<blockquote>\n<p>这里疑惑的一点是：事件加入队列，唤醒looper，接下来应该是looper循环读取消息队列进行事件分发，但是这里没有找到和dispatchOnce想关联的地方。可能有疏漏地方。以后发现问题会及时更新上。这里直接继续InputChannel::sendMessage来说。</p>\n</blockquote>\n<p><code>InputChannel</code>是负责与app窗口进行通信的，通过WMS找到对应的窗口。那么<code>InputChannel</code>到底是怎么找到窗口的？</p>\n<p>在WMS的<code>addWindow</code>方法中有这样几行代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">addWindow</span><span class=\"params\">(Session session, IWindow client, <span class=\"keyword\">int</span> seq,</span></span></div><div class=\"line\">            WindowManager.LayoutParams attrs, <span class=\"keyword\">int</span> viewVisibility, <span class=\"keyword\">int</span> displayId,</div><div class=\"line\">            Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) &#123;</div><div class=\"line\">            </div><div class=\"line\">                </div><div class=\"line\">                String name = win.makeInputChannelName();</div><div class=\"line\">                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</div><div class=\"line\">                win.setInputChannel(inputChannels[<span class=\"number\">0</span>]);</div><div class=\"line\">                inputChannels[<span class=\"number\">1</span>].transferTo(outInputChannel);</div><div class=\"line\"></div><div class=\"line\">                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</div><div class=\"line\">            </div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure>\n<p>这里是在Activity初始化时想WMS添加的窗口的调用方法，其中在添加窗口时候就已经给这个窗口设置了通信通道。</p>\n<p>然后看下<code>InputChannel.openInputChannelPair</code>里面做了什么：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">status_t</span> InputChannel::openInputChannelPair(<span class=\"keyword\">const</span> String8&amp; name,</div><div class=\"line\">        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> sockets[<span class=\"number\">2</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class=\"number\">0</span>, sockets)) &#123;</div><div class=\"line\">        <span class=\"keyword\">status_t</span> result = -errno;</div><div class=\"line\">        ALOGE(<span class=\"string\">\"channel '%s' ~ Could not create socket pair.  errno=%d\"</span>,</div><div class=\"line\">                name.<span class=\"built_in\">string</span>(), errno);</div><div class=\"line\">        outServerChannel.clear();</div><div class=\"line\">        outClientChannel.clear();</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> bufferSize = SOCKET_BUFFER_SIZE;</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\">    setsockopt(sockets[<span class=\"number\">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class=\"keyword\">sizeof</span>(bufferSize));</div><div class=\"line\"></div><div class=\"line\">    String8 serverChannelName = name;</div><div class=\"line\">    serverChannelName.append(<span class=\"string\">\" (server)\"</span>);</div><div class=\"line\">    outServerChannel = <span class=\"keyword\">new</span> InputChannel(serverChannelName, sockets[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\">    String8 clientChannelName = name;</div><div class=\"line\">    clientChannelName.append(<span class=\"string\">\" (client)\"</span>);</div><div class=\"line\">    outClientChannel = <span class=\"keyword\">new</span> InputChannel(clientChannelName, sockets[<span class=\"number\">1</span>]);</div><div class=\"line\">    <span class=\"keyword\">return</span> OK;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里主要创建了两个<code>InputChannel</code>，一个服务端一个客户端，这里的的<code>InputChannel</code>是基于socket的，这个socket不是网络的socket而是Unix特有的关于文件的Unix domain socket。</p>\n<h2 id=\"WMS和ViewRootImpl\"><a href=\"#WMS和ViewRootImpl\" class=\"headerlink\" title=\"WMS和ViewRootImpl\"></a>WMS和ViewRootImpl</h2><p>经过一些列的调转，最终会回调到<code>InputEventReceiver</code>的<code>dispatchInputEvent</code>方法。</p>\n<p>这个方法是C++通过JNi回调的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Called from native code.</span></div><div class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unused\"</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchInputEvent</span><span class=\"params\">(<span class=\"keyword\">int</span> seq, InputEvent event)</span> </span>&#123;</div><div class=\"line\">    mSeqMap.put(event.getSequenceNumber(), seq);</div><div class=\"line\">    onInputEvent(event);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的<code>InputEventReceiver</code> 对象其实是<code>WindowInputEventReceiver</code> 的引用，所以<code>onInputEvent</code>其实调用的<code>WindowInputEventReceiver</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onInputEvent</span><span class=\"params\">(InputEvent event)</span> </span>&#123;</div><div class=\"line\">          enqueueInputEvent(event, <span class=\"keyword\">this</span>, <span class=\"number\">0</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p><code>enqueueInputEvent</code>通过连续调用，跳转到<code>deliverInputEvent</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverInputEvent</span><span class=\"params\">(QueuedInputEvent q)</span> </span>&#123;</div><div class=\"line\">    Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, <span class=\"string\">\"deliverInputEvent\"</span>,</div><div class=\"line\">            q.mEvent.getSequenceNumber());</div><div class=\"line\">    <span class=\"keyword\">if</span> (mInputEventConsistencyVerifier != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mInputEventConsistencyVerifier.onInputEvent(q.mEvent, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    InputStage stage;</div><div class=\"line\">    <span class=\"keyword\">if</span> (q.shouldSendToSynthesizer()) &#123;</div><div class=\"line\">        stage = mSyntheticInputStage;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (stage != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        stage.deliver(q);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        finishInputEvent(q);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的<code>stage</code>是多态形式，但是最终会调用<code>ViewPostImeInputStage</code>的<code>onProcess</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">onProcess</span><span class=\"params\">(QueuedInputEvent q)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (q.mEvent <span class=\"keyword\">instanceof</span> KeyEvent) &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> processKeyEvent(q);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"comment\">// If delivering a new non-key event, make sure the window is</span></div><div class=\"line\">         <span class=\"comment\">// now allowed to start updating.</span></div><div class=\"line\">         handleDispatchDoneAnimating();</div><div class=\"line\">         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> source = q.mEvent.getSource();</div><div class=\"line\">         <span class=\"keyword\">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">return</span> processPointerEvent(q);</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">             <span class=\"keyword\">return</span> processTrackballEvent(q);</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             <span class=\"keyword\">return</span> processGenericMotionEvent(q);</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>由于是触摸事件，所以会执行<code>processPointerEvent</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">processPointerEvent</span><span class=\"params\">(QueuedInputEvent q)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">final</span> MotionEvent event = (MotionEvent)q.mEvent;</div><div class=\"line\"></div><div class=\"line\">     mAttachInfo.mUnbufferedDispatchRequested = <span class=\"keyword\">false</span>;</div><div class=\"line\">     <span class=\"keyword\">boolean</span> handled = mView.dispatchPointerEvent(event);</div><div class=\"line\">     <span class=\"keyword\">if</span> (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) &#123;</div><div class=\"line\">         mUnbufferedInputDispatch = <span class=\"keyword\">true</span>;</div><div class=\"line\">         <span class=\"keyword\">if</span> (mConsumeBatchedInputScheduled) &#123;</div><div class=\"line\">             scheduleConsumeBatchedInputImmediately();</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> handled ? FINISH_HANDLED : FORWARD;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>发现有<code>boolean handled = mView.dispatchPointerEvent(event);</code>这么一句话，看来现在已经开始向view分发事件了。</p>\n<p>这里的<code>mView</code>是指向<code>DecorView</code>，剩下的内容下节继续</p>\n<h1 id=\"0x03-ViewRootImpl到View\"><a href=\"#0x03-ViewRootImpl到View\" class=\"headerlink\" title=\"0x03 ViewRootImpl到View\"></a>0x03 ViewRootImpl到View</h1><p>通过View的<code>dispatchPointerEvent</code>调用了<code>dispatchTouchEvent</code>，</p>\n<p>因为<code>DecorView</code>重写了<code>dispatchTouchEvent</code>方法，看下这个内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">          <span class=\"keyword\">final</span> Callback cb = getCallback();</div><div class=\"line\">          <span class=\"keyword\">return</span> cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; <span class=\"number\">0</span> ? cb.dispatchTouchEvent(ev)</div><div class=\"line\">                  : <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n<p>这里的<code>getCallback</code>返回的是Activity引用，如果Activity没有销毁，则调用Activity的<code>dispatchTouchEvent</code>方法。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">        onUserInteraction();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(ev);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里注意一点，如果<code>getWindow().superDispatchTouchEvent(ev)</code>返回true，则不继续执行Activity的<code>onTouchEvent</code>。</p>\n<p>这里的getWinddow就是PhoneWindow，而PhoneWindow的<code>superDispatchTouchEvent</code>直接引用了DecorView的<code>superDispatchTouchEvent</code>，接着调用了<code>super.dispatchTouchEvent(event)</code>，这里的super是ViewGroup，这里主要做了两件事：①判断当前ViewGroup是否拦截事件，如果拦截则执行<code>onInterceptTouchEvent</code>。②如果不拦截，事件也没取消，则事件向子View分发。在向子View分发前会先判断子View是否接受事件及事件是否在子View范围内。如果都为true了则调用<code>dispatchTransformedTouchEvent</code>。这里面调用了子View的<code>dispatchTouchEvent</code>。</p>\n<p>子View的<code>dispatchTouchEvent</code>里面会判断<code>touchListener.onTouch</code>方法和<code>onTouchEvent</code>方法。</p>\n<h1 id=\"0x04-事件传递须知\"><a href=\"#0x04-事件传递须知\" class=\"headerlink\" title=\"0x04 事件传递须知\"></a>0x04 事件传递须知</h1><p> ①如果DecorView的<code>dispatchPointerEvent</code>方法返回true表示事件消费成功。</p>\n<p>②如果Activity没有销毁，则回调Activity的<code>dispatchTouchEvent</code>,如果phone window的<code>superDispatchTouchEvent</code>返回true表示被DecorView或其子View消耗了事件，则不执行Activity的onTouchEvent方法。</p>\n<p>③如果ViewGroup执行dispatchTouchEvent方法，先判断是否需要拦截事件：</p>\n<p>如果需要拦截则执行onInterceptTouchEvent方法。</p>\n<p>如果拦截返回true，则不继续事件传递，如果返回false，则继续，首先判断子View是否接受事件及是否在范围内，如果都符合则传递给子View。</p>\n<p>④如果子View执行dispatchTouchEvent方法，会先判断是否设置onTouchListener，</p>\n<p>如果设置了则执行onTouch方法。如果该方法返回true，则不继续执行子View 的onTouchEvent方法，否则继续执行ouTouchEvent方法。</p>\n<p>⑤如果ouTouchEvent方法执行，actionDown时检查长按事件，actionUp时检查onClick事件。</p>\n"},{"title":"反转字符串","date":"2017-07-27T05:28:07.000Z","_content":"\n# 0x00 前言\n\n比如abc，反转后cba\n\n\n\n# 0x01 实现\n\n```java\n\tpublic static String reverseStr(String str) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = str.length() - 1; i >= 0; i--) {\n\t\t\tsb.append(str.charAt(i));\n\t\t}\n\t\treturn sb.toString();\n\t}\n```\n\n上面这种是遍历所有字符串长度，复杂度为O(n)。\n\n应该还有更好的方法:\n\n```java\n\tpublic static String reverse(String str) {\n\t\tint len = str.length();\n\t\tint max = len - 1;\n\t\tchar[] chars = str.toCharArray();\n\t\tfor (int i = 0; i < (len >> 1); i++) {\n\t\t\tchar pre = str.charAt(i);\n\t\t\tchar last = str.charAt(max);\n\t\t\tchars[i] = last;\n\t\t\tchars[max] = pre;\n\t\t\tmax--;\n\t\t}\n\t\treturn String.valueOf(chars);\n\t}\n```\n\n","source":"_posts/反转字符串.md","raw":"---\ntitle: 反转字符串\ndate: 2017-07-27 13:28:07\ntags: [Java,算法,趣题]\ncategories: [Java,算法,趣题]\n---\n\n# 0x00 前言\n\n比如abc，反转后cba\n\n\n\n# 0x01 实现\n\n```java\n\tpublic static String reverseStr(String str) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = str.length() - 1; i >= 0; i--) {\n\t\t\tsb.append(str.charAt(i));\n\t\t}\n\t\treturn sb.toString();\n\t}\n```\n\n上面这种是遍历所有字符串长度，复杂度为O(n)。\n\n应该还有更好的方法:\n\n```java\n\tpublic static String reverse(String str) {\n\t\tint len = str.length();\n\t\tint max = len - 1;\n\t\tchar[] chars = str.toCharArray();\n\t\tfor (int i = 0; i < (len >> 1); i++) {\n\t\t\tchar pre = str.charAt(i);\n\t\t\tchar last = str.charAt(max);\n\t\t\tchars[i] = last;\n\t\t\tchars[max] = pre;\n\t\t\tmax--;\n\t\t}\n\t\treturn String.valueOf(chars);\n\t}\n```\n\n","slug":"反转字符串","published":1,"updated":"2017-07-27T08:42:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjp007bwh9cx08rha5s","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>比如abc，反转后cba</p>\n<h1 id=\"0x01-实现\"><a href=\"#0x01-实现\" class=\"headerlink\" title=\"0x01 实现\"></a>0x01 实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverseStr</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = str.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">\t\tsb.append(str.charAt(i));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> sb.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种是遍历所有字符串长度，复杂度为O(n)。</p>\n<p>应该还有更好的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverse</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> len = str.length();</div><div class=\"line\">\t<span class=\"keyword\">int</span> max = len - <span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">char</span>[] chars = str.toCharArray();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (len &gt;&gt; <span class=\"number\">1</span>); i++) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">char</span> pre = str.charAt(i);</div><div class=\"line\">\t\t<span class=\"keyword\">char</span> last = str.charAt(max);</div><div class=\"line\">\t\tchars[i] = last;</div><div class=\"line\">\t\tchars[max] = pre;</div><div class=\"line\">\t\tmax--;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> String.valueOf(chars);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>比如abc，反转后cba</p>\n<h1 id=\"0x01-实现\"><a href=\"#0x01-实现\" class=\"headerlink\" title=\"0x01 实现\"></a>0x01 实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverseStr</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = str.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">\t\tsb.append(str.charAt(i));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> sb.toString();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种是遍历所有字符串长度，复杂度为O(n)。</p>\n<p>应该还有更好的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">reverse</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> len = str.length();</div><div class=\"line\">\t<span class=\"keyword\">int</span> max = len - <span class=\"number\">1</span>;</div><div class=\"line\">\t<span class=\"keyword\">char</span>[] chars = str.toCharArray();</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (len &gt;&gt; <span class=\"number\">1</span>); i++) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">char</span> pre = str.charAt(i);</div><div class=\"line\">\t\t<span class=\"keyword\">char</span> last = str.charAt(max);</div><div class=\"line\">\t\tchars[i] = last;</div><div class=\"line\">\t\tchars[max] = pre;</div><div class=\"line\">\t\tmax--;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> String.valueOf(chars);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"求解1到n中1的个数","date":"2017-07-27T16:11:31.000Z","_content":"\n# 0x00 前言\n\n注意一点的是不管有几位数，每位都要检查是否为1.\n\n\n\n# 0x01 暴力实现\n\n最简单暴力的方法就是直接遍历判断：\n\n```java\n\t/**\n\t * 暴力求解1-n中有多少个1\n\t * \n\t * @param value\n\t * @return\n\t */\n\tpublic static int getOne(int value) {\n\t\tint result = 0;\n\t\tfor (int i = 1; i <= value; i++) {\n\t\t\tint val = i;\n\t\t\twhile (val == 1 || val >= 10) {\n\t\t\t\tresult += val % 10 == 1 ? 1 : 0;\n\t\t\t\tval /= 10;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n```\n\n打印`\t\tSystem.out.println(getOne(11));`结果为4。正确\n\n\n\n# 0x02 递归实现\n\n\n\n```java\n\tpublic static int getOnes(int value, int count) {\n\t\tif (value == 1) {\n\t\t\treturn ++count;\n\t\t} else {\n\t\t\t// 计算当前数不为1时，所有位包含1的个数。\n\t\t\tint val = value;\n\t\t\twhile (val == 1 || val >= 10) {\n\t\t\t\tcount += val % 10 == 1 ? 1 : 0;\n\t\t\t\tval /= 10;\n\t\t\t}\n\t\t}\n\t\treturn getOnes(--value, count);\n\t}\n```\n\n\n\n# 0x003 其他思想\n\n本段内容来自[简书](http://www.jianshu.com/p/ce709a24bd22)：\n\n1. 此位大于1，这一位上1的个数有 ([n / 10 ^ (b + 1) ] + 1) * 10^b\n2. 此位等于0，为 ([n / 10^(b+1) ] ) * 10^b\n3. 此位等于1，在0的基础上加上n mod 10^b + 1\n\n举个例子，我们来分析 N=30143 的情况：\n\n1. 由于3>1,则个位上出现1的次数为(3014+1)*1\n2. 由于4>1,则十位上出现1的次数为(301+1)*10\n3. 由于1=1，则百位上出现1次数为30*100+(43+1)\n4. 由于千位为0，则千位上出现1次数为3*1000\n\n仔细观察，不难明白其中的道理。以百位为例：100到199共有100个1，而除以100以后位30，所以共有30个100到199，这就构成了300 * 100。最后，当对于千位和万位为0的情况，还有100到143这44个数，所以总共为30*100 + 43 + 1。同样，不难理解，对于十位，有10到19共10个1，共有301个百位以上不为0的情况，最后加上百位以上都是0的情况，则为 （301+1）* 10。\n\n至于代码按规律如何实现，暂时没有思考","source":"_posts/求解1到n中1的个数.md","raw":"---\ntitle: 求解1到n中1的个数\ndate: 2017-07-28 00:11:31\ntags: [Java, 算法, 趣题]\ncategories: [Java, 算法, 趣题]\n---\n\n# 0x00 前言\n\n注意一点的是不管有几位数，每位都要检查是否为1.\n\n\n\n# 0x01 暴力实现\n\n最简单暴力的方法就是直接遍历判断：\n\n```java\n\t/**\n\t * 暴力求解1-n中有多少个1\n\t * \n\t * @param value\n\t * @return\n\t */\n\tpublic static int getOne(int value) {\n\t\tint result = 0;\n\t\tfor (int i = 1; i <= value; i++) {\n\t\t\tint val = i;\n\t\t\twhile (val == 1 || val >= 10) {\n\t\t\t\tresult += val % 10 == 1 ? 1 : 0;\n\t\t\t\tval /= 10;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n```\n\n打印`\t\tSystem.out.println(getOne(11));`结果为4。正确\n\n\n\n# 0x02 递归实现\n\n\n\n```java\n\tpublic static int getOnes(int value, int count) {\n\t\tif (value == 1) {\n\t\t\treturn ++count;\n\t\t} else {\n\t\t\t// 计算当前数不为1时，所有位包含1的个数。\n\t\t\tint val = value;\n\t\t\twhile (val == 1 || val >= 10) {\n\t\t\t\tcount += val % 10 == 1 ? 1 : 0;\n\t\t\t\tval /= 10;\n\t\t\t}\n\t\t}\n\t\treturn getOnes(--value, count);\n\t}\n```\n\n\n\n# 0x003 其他思想\n\n本段内容来自[简书](http://www.jianshu.com/p/ce709a24bd22)：\n\n1. 此位大于1，这一位上1的个数有 ([n / 10 ^ (b + 1) ] + 1) * 10^b\n2. 此位等于0，为 ([n / 10^(b+1) ] ) * 10^b\n3. 此位等于1，在0的基础上加上n mod 10^b + 1\n\n举个例子，我们来分析 N=30143 的情况：\n\n1. 由于3>1,则个位上出现1的次数为(3014+1)*1\n2. 由于4>1,则十位上出现1的次数为(301+1)*10\n3. 由于1=1，则百位上出现1次数为30*100+(43+1)\n4. 由于千位为0，则千位上出现1次数为3*1000\n\n仔细观察，不难明白其中的道理。以百位为例：100到199共有100个1，而除以100以后位30，所以共有30个100到199，这就构成了300 * 100。最后，当对于千位和万位为0的情况，还有100到143这44个数，所以总共为30*100 + 43 + 1。同样，不难理解，对于十位，有10到19共10个1，共有301个百位以上不为0的情况，最后加上百位以上都是0的情况，则为 （301+1）* 10。\n\n至于代码按规律如何实现，暂时没有思考","slug":"求解1到n中1的个数","published":1,"updated":"2017-07-27T16:11:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjt007gwh9chhw2o0vi","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>注意一点的是不管有几位数，每位都要检查是否为1.</p>\n<h1 id=\"0x01-暴力实现\"><a href=\"#0x01-暴力实现\" class=\"headerlink\" title=\"0x01 暴力实现\"></a>0x01 暴力实现</h1><p>最简单暴力的方法就是直接遍历判断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 暴力求解1-n中有多少个1</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@param</span> value</div><div class=\"line\"> * <span class=\"doctag\">@return</span></div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getOne</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= value; i++) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> val = i;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (val == <span class=\"number\">1</span> || val &gt;= <span class=\"number\">10</span>) &#123;</div><div class=\"line\">\t\t\tresult += val % <span class=\"number\">10</span> == <span class=\"number\">1</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</div><div class=\"line\">\t\t\tval /= <span class=\"number\">10</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印<code>System.out.println(getOne(11));</code>结果为4。正确</p>\n<h1 id=\"0x02-递归实现\"><a href=\"#0x02-递归实现\" class=\"headerlink\" title=\"0x02 递归实现\"></a>0x02 递归实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getOnes</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> count)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (value == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> ++count;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 计算当前数不为1时，所有位包含1的个数。</span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> val = value;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (val == <span class=\"number\">1</span> || val &gt;= <span class=\"number\">10</span>) &#123;</div><div class=\"line\">\t\t\tcount += val % <span class=\"number\">10</span> == <span class=\"number\">1</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</div><div class=\"line\">\t\t\tval /= <span class=\"number\">10</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> getOnes(--value, count);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"0x003-其他思想\"><a href=\"#0x003-其他思想\" class=\"headerlink\" title=\"0x003 其他思想\"></a>0x003 其他思想</h1><p>本段内容来自<a href=\"http://www.jianshu.com/p/ce709a24bd22\" target=\"_blank\" rel=\"external\">简书</a>：</p>\n<ol>\n<li>此位大于1，这一位上1的个数有 ([n / 10 ^ (b + 1) ] + 1) * 10^b</li>\n<li>此位等于0，为 ([n / 10^(b+1) ] ) * 10^b</li>\n<li>此位等于1，在0的基础上加上n mod 10^b + 1</li>\n</ol>\n<p>举个例子，我们来分析 N=30143 的情况：</p>\n<ol>\n<li>由于3&gt;1,则个位上出现1的次数为(3014+1)*1</li>\n<li>由于4&gt;1,则十位上出现1的次数为(301+1)*10</li>\n<li>由于1=1，则百位上出现1次数为30*100+(43+1)</li>\n<li>由于千位为0，则千位上出现1次数为3*1000</li>\n</ol>\n<p>仔细观察，不难明白其中的道理。以百位为例：100到199共有100个1，而除以100以后位30，所以共有30个100到199，这就构成了300 <em> 100。最后，当对于千位和万位为0的情况，还有100到143这44个数，所以总共为30</em>100 + 43 + 1。同样，不难理解，对于十位，有10到19共10个1，共有301个百位以上不为0的情况，最后加上百位以上都是0的情况，则为 （301+1）* 10。</p>\n<p>至于代码按规律如何实现，暂时没有思考</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>注意一点的是不管有几位数，每位都要检查是否为1.</p>\n<h1 id=\"0x01-暴力实现\"><a href=\"#0x01-暴力实现\" class=\"headerlink\" title=\"0x01 暴力实现\"></a>0x01 暴力实现</h1><p>最简单暴力的方法就是直接遍历判断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 暴力求解1-n中有多少个1</div><div class=\"line\"> * </div><div class=\"line\"> * <span class=\"doctag\">@param</span> value</div><div class=\"line\"> * <span class=\"doctag\">@return</span></div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getOne</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= value; i++) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> val = i;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (val == <span class=\"number\">1</span> || val &gt;= <span class=\"number\">10</span>) &#123;</div><div class=\"line\">\t\t\tresult += val % <span class=\"number\">10</span> == <span class=\"number\">1</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</div><div class=\"line\">\t\t\tval /= <span class=\"number\">10</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>打印<code>System.out.println(getOne(11));</code>结果为4。正确</p>\n<h1 id=\"0x02-递归实现\"><a href=\"#0x02-递归实现\" class=\"headerlink\" title=\"0x02 递归实现\"></a>0x02 递归实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getOnes</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> count)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (value == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> ++count;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 计算当前数不为1时，所有位包含1的个数。</span></div><div class=\"line\">\t\t<span class=\"keyword\">int</span> val = value;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span> (val == <span class=\"number\">1</span> || val &gt;= <span class=\"number\">10</span>) &#123;</div><div class=\"line\">\t\t\tcount += val % <span class=\"number\">10</span> == <span class=\"number\">1</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</div><div class=\"line\">\t\t\tval /= <span class=\"number\">10</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> getOnes(--value, count);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"0x003-其他思想\"><a href=\"#0x003-其他思想\" class=\"headerlink\" title=\"0x003 其他思想\"></a>0x003 其他思想</h1><p>本段内容来自<a href=\"http://www.jianshu.com/p/ce709a24bd22\">简书</a>：</p>\n<ol>\n<li>此位大于1，这一位上1的个数有 ([n / 10 ^ (b + 1) ] + 1) * 10^b</li>\n<li>此位等于0，为 ([n / 10^(b+1) ] ) * 10^b</li>\n<li>此位等于1，在0的基础上加上n mod 10^b + 1</li>\n</ol>\n<p>举个例子，我们来分析 N=30143 的情况：</p>\n<ol>\n<li>由于3&gt;1,则个位上出现1的次数为(3014+1)*1</li>\n<li>由于4&gt;1,则十位上出现1的次数为(301+1)*10</li>\n<li>由于1=1，则百位上出现1次数为30*100+(43+1)</li>\n<li>由于千位为0，则千位上出现1次数为3*1000</li>\n</ol>\n<p>仔细观察，不难明白其中的道理。以百位为例：100到199共有100个1，而除以100以后位30，所以共有30个100到199，这就构成了300 <em> 100。最后，当对于千位和万位为0的情况，还有100到143这44个数，所以总共为30</em>100 + 43 + 1。同样，不难理解，对于十位，有10到19共10个1，共有301个百位以上不为0的情况，最后加上百位以上都是0的情况，则为 （301+1）* 10。</p>\n<p>至于代码按规律如何实现，暂时没有思考</p>\n"},{"title":"浅谈Android性能优化系列(0)之为什么需要性能优化","date":"2017-07-19T14:40:50.000Z","_content":"\n# 0X00 前言\n\n现在做开发，不管刚入门菜鸟还是资深大牛，总是离不开性能优化/性能调优的话题。那么到底什么是性能优化呢？\n\n个人认为通过技术手段，使程序运行达到了比之前版本更好的效果，就是性能优化。\n\n为什么性能优化是我们绕不开的话题呢？\n\n# 0x01 为什么需要性能优化\n\n关于为什么需要性能优化这个问题，我想很多人都会即时作答：“为用户提供更好的体验\"。\n\n既然说到为用户提供更好体验，设想一下，假如用户并不在意所谓的体验，只要功能完成就行了。那么这时公司还会考虑做性能优化吗？\n\n我想大多数公司都不会去做”这样一件无意义的事“了。公司是以盈利为目的，怎么会在用户不care的点上花费大量人力物力财力呢？\n\n然而现实恰恰相反的，随着科技发展，用户对产品体验要求越来越高，加上当前产品同质化严重，特色功能只能吸引用户，而良好的用户体验才是留住用户的关键。\n\n# 0x02 从哪些方面入手性能优化\n\n只说性能优化太过笼统，为了提供良好用户体验，应该从哪些方面着手呢？\n\n换句话说，在产品体验上，用户会通过感知哪些方面来评价产品好坏？这样一说答案就很明显了，就是平常我们自己使用程序都会唠叨的那几个方面：点几下就崩溃、玩一会就没电、没多久流量就超了、打开页面很卡、安装包太大、占了300兆内存~\n\n> 把上面几个方面归纳下就是：程序稳定性优化、耗电检测优化、网络优化、UI渲染优化、安装包优化和内存优化 6个方面。\n\n\n\n# 0x03 结束语\n\n这是本系列开篇，从为什么要性能优化发散到优化入手的6各方面，为后续章节做铺垫。\n\n目前预计未来会写6篇关于具体方面优化和6篇相关方面工具使用，共计12篇。希望通过这12篇让自己当然希望也能帮助别人对Android整体性能优化有个了解，最终形成自己的知识脉络。","source":"_posts/浅谈Android性能优化系列-0-之为什么需要性能优化.md","raw":"---\ntitle: 浅谈Android性能优化系列(0)之为什么需要性能优化\ndate: 2017-07-19 22:40:50\ntags: Android\ncategories: Android\n---\n\n# 0X00 前言\n\n现在做开发，不管刚入门菜鸟还是资深大牛，总是离不开性能优化/性能调优的话题。那么到底什么是性能优化呢？\n\n个人认为通过技术手段，使程序运行达到了比之前版本更好的效果，就是性能优化。\n\n为什么性能优化是我们绕不开的话题呢？\n\n# 0x01 为什么需要性能优化\n\n关于为什么需要性能优化这个问题，我想很多人都会即时作答：“为用户提供更好的体验\"。\n\n既然说到为用户提供更好体验，设想一下，假如用户并不在意所谓的体验，只要功能完成就行了。那么这时公司还会考虑做性能优化吗？\n\n我想大多数公司都不会去做”这样一件无意义的事“了。公司是以盈利为目的，怎么会在用户不care的点上花费大量人力物力财力呢？\n\n然而现实恰恰相反的，随着科技发展，用户对产品体验要求越来越高，加上当前产品同质化严重，特色功能只能吸引用户，而良好的用户体验才是留住用户的关键。\n\n# 0x02 从哪些方面入手性能优化\n\n只说性能优化太过笼统，为了提供良好用户体验，应该从哪些方面着手呢？\n\n换句话说，在产品体验上，用户会通过感知哪些方面来评价产品好坏？这样一说答案就很明显了，就是平常我们自己使用程序都会唠叨的那几个方面：点几下就崩溃、玩一会就没电、没多久流量就超了、打开页面很卡、安装包太大、占了300兆内存~\n\n> 把上面几个方面归纳下就是：程序稳定性优化、耗电检测优化、网络优化、UI渲染优化、安装包优化和内存优化 6个方面。\n\n\n\n# 0x03 结束语\n\n这是本系列开篇，从为什么要性能优化发散到优化入手的6各方面，为后续章节做铺垫。\n\n目前预计未来会写6篇关于具体方面优化和6篇相关方面工具使用，共计12篇。希望通过这12篇让自己当然希望也能帮助别人对Android整体性能优化有个了解，最终形成自己的知识脉络。","slug":"浅谈Android性能优化系列-0-之为什么需要性能优化","published":1,"updated":"2017-07-19T15:25:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjv007jwh9cw6xoeie4","content":"<h1 id=\"0X00-前言\"><a href=\"#0X00-前言\" class=\"headerlink\" title=\"0X00 前言\"></a>0X00 前言</h1><p>现在做开发，不管刚入门菜鸟还是资深大牛，总是离不开性能优化/性能调优的话题。那么到底什么是性能优化呢？</p>\n<p>个人认为通过技术手段，使程序运行达到了比之前版本更好的效果，就是性能优化。</p>\n<p>为什么性能优化是我们绕不开的话题呢？</p>\n<h1 id=\"0x01-为什么需要性能优化\"><a href=\"#0x01-为什么需要性能优化\" class=\"headerlink\" title=\"0x01 为什么需要性能优化\"></a>0x01 为什么需要性能优化</h1><p>关于为什么需要性能优化这个问题，我想很多人都会即时作答：“为用户提供更好的体验”。</p>\n<p>既然说到为用户提供更好体验，设想一下，假如用户并不在意所谓的体验，只要功能完成就行了。那么这时公司还会考虑做性能优化吗？</p>\n<p>我想大多数公司都不会去做”这样一件无意义的事“了。公司是以盈利为目的，怎么会在用户不care的点上花费大量人力物力财力呢？</p>\n<p>然而现实恰恰相反的，随着科技发展，用户对产品体验要求越来越高，加上当前产品同质化严重，特色功能只能吸引用户，而良好的用户体验才是留住用户的关键。</p>\n<h1 id=\"0x02-从哪些方面入手性能优化\"><a href=\"#0x02-从哪些方面入手性能优化\" class=\"headerlink\" title=\"0x02 从哪些方面入手性能优化\"></a>0x02 从哪些方面入手性能优化</h1><p>只说性能优化太过笼统，为了提供良好用户体验，应该从哪些方面着手呢？</p>\n<p>换句话说，在产品体验上，用户会通过感知哪些方面来评价产品好坏？这样一说答案就很明显了，就是平常我们自己使用程序都会唠叨的那几个方面：点几下就崩溃、玩一会就没电、没多久流量就超了、打开页面很卡、安装包太大、占了300兆内存~</p>\n<blockquote>\n<p>把上面几个方面归纳下就是：程序稳定性优化、耗电检测优化、网络优化、UI渲染优化、安装包优化和内存优化 6个方面。</p>\n</blockquote>\n<h1 id=\"0x03-结束语\"><a href=\"#0x03-结束语\" class=\"headerlink\" title=\"0x03 结束语\"></a>0x03 结束语</h1><p>这是本系列开篇，从为什么要性能优化发散到优化入手的6各方面，为后续章节做铺垫。</p>\n<p>目前预计未来会写6篇关于具体方面优化和6篇相关方面工具使用，共计12篇。希望通过这12篇让自己当然希望也能帮助别人对Android整体性能优化有个了解，最终形成自己的知识脉络。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0X00-前言\"><a href=\"#0X00-前言\" class=\"headerlink\" title=\"0X00 前言\"></a>0X00 前言</h1><p>现在做开发，不管刚入门菜鸟还是资深大牛，总是离不开性能优化/性能调优的话题。那么到底什么是性能优化呢？</p>\n<p>个人认为通过技术手段，使程序运行达到了比之前版本更好的效果，就是性能优化。</p>\n<p>为什么性能优化是我们绕不开的话题呢？</p>\n<h1 id=\"0x01-为什么需要性能优化\"><a href=\"#0x01-为什么需要性能优化\" class=\"headerlink\" title=\"0x01 为什么需要性能优化\"></a>0x01 为什么需要性能优化</h1><p>关于为什么需要性能优化这个问题，我想很多人都会即时作答：“为用户提供更好的体验”。</p>\n<p>既然说到为用户提供更好体验，设想一下，假如用户并不在意所谓的体验，只要功能完成就行了。那么这时公司还会考虑做性能优化吗？</p>\n<p>我想大多数公司都不会去做”这样一件无意义的事“了。公司是以盈利为目的，怎么会在用户不care的点上花费大量人力物力财力呢？</p>\n<p>然而现实恰恰相反的，随着科技发展，用户对产品体验要求越来越高，加上当前产品同质化严重，特色功能只能吸引用户，而良好的用户体验才是留住用户的关键。</p>\n<h1 id=\"0x02-从哪些方面入手性能优化\"><a href=\"#0x02-从哪些方面入手性能优化\" class=\"headerlink\" title=\"0x02 从哪些方面入手性能优化\"></a>0x02 从哪些方面入手性能优化</h1><p>只说性能优化太过笼统，为了提供良好用户体验，应该从哪些方面着手呢？</p>\n<p>换句话说，在产品体验上，用户会通过感知哪些方面来评价产品好坏？这样一说答案就很明显了，就是平常我们自己使用程序都会唠叨的那几个方面：点几下就崩溃、玩一会就没电、没多久流量就超了、打开页面很卡、安装包太大、占了300兆内存~</p>\n<blockquote>\n<p>把上面几个方面归纳下就是：程序稳定性优化、耗电检测优化、网络优化、UI渲染优化、安装包优化和内存优化 6个方面。</p>\n</blockquote>\n<h1 id=\"0x03-结束语\"><a href=\"#0x03-结束语\" class=\"headerlink\" title=\"0x03 结束语\"></a>0x03 结束语</h1><p>这是本系列开篇，从为什么要性能优化发散到优化入手的6各方面，为后续章节做铺垫。</p>\n<p>目前预计未来会写6篇关于具体方面优化和6篇相关方面工具使用，共计12篇。希望通过这12篇让自己当然希望也能帮助别人对Android整体性能优化有个了解，最终形成自己的知识脉络。</p>\n"},{"title":"浅谈Android性能优化系列(1)之安装包大小优化","date":"2017-07-21T03:35:04.000Z","_content":"\n# 0x00 前言\n\n可能会有人有疑问，安装包还需要优化吗？现在流量都用不完的！\n\n这样来说吧，优化有多方面好处的：\n\n①节省用户流量\n\n②安装包越小，用户就越快下载完，缩短了联网时间，联网时间短耗电也就越少\n\n③越快下载完，用户就越能提前使用APP，避免对用户耐心的过多消磨。\n\n所以，安装包优化还是有必要的。\n\n# 0x01 安装包构成\n\n要想优化安装包，首先知道包由哪些部分组成的。这是电视猫app解压后目录：\n\n![安装包构成](浅谈Android性能优化系列-1-之安装包大小优化/安装包构成.png)\n\n目录中com和org两个文件夹是第三方包信息，不用管着两个。\n\n- assets可以存放资源和配置等各种文件，但是这里的资源文件不会像res中那样生成ID，而是通过AssetManager获取\n- dex是Java文件编程成class文件后又经过虚拟机优化压缩形成的\n- lib中存放native类库，根据不同CPU架构有四种类型：armeabi，armeabi-v7a，x86，mips。\n- META-INF保存了app签名信息\n- res中存放了资源文件\n- resources.arsc 记录资源文件和资源ID映射。可以根据ID查找资源\n- AndroidManifest.xml是app配置文件注册四大组件，声明权限等。\n\n\n\n知道了各个部分作用就大概知道了该从哪方面入手了：代码和资源，因为包中这两个部分占了很大一部分。\n\n# 0x02 代码优化\n\n代码优化其实包含了Java代码和Native代码，但是因为Native代码涉及了C和C++，这里不做阐述，但是说下lib库还是有必要的\n\n## lib库\n\n根据cpu架构lib中分为四种类型，但是目前大部分移动设备都是基于arm和arm-v7a的。x86和mips较少。而且据说x86兼容arm指令集，所以适配库优先考虑arm和arm-v7a两种即可。\n\n## Java代码优化：使用ProGuard代码混淆\n\nProGuard具有压缩(移除无效类、方法、属性)、优化、混淆功能。\n\n- 开启混淆\n\n  ```groovy\n      buildTypes {\n          release {\n              minifyEnabled true//开启混淆\n              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //混淆文件\n          }\n      }\n  ```\n\n- 压缩\n\n  压缩功能是默认开启的，如果对某个或某些文件不想压缩可以使用：\n\n  `-dontshrink class * extends android.app.Activity`。\n\n- 优化\n\n  优化optimization默认开启，如果不开启可以使用：\n\n  `-dontoptimize`。一些相对复杂的方法时，压缩后可能会抛出errors，这时可以不压缩。\n\n- 混淆\n\n  混淆也是默认开启,如果对某些文件不想混淆可以使用：\n\n  `-dontobfuscate`。\n\n- 保留\n\n  如果想保留某些类、成员等不被混淆可以使用：\n\n  `-kepp`。\n\n  ​\n\n  关于proguard更多使用方法可参考：\n\n  [Android进阶之ProGuard代码混淆](http://hanhailong.com/2015/12/28/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/)\n\n  [Jean同学的Proguard私房物语](https://my.oschina.net/u/659658/blog/71976)\n\n  ​\n\n# 0x03 资源优化\n\n这里的资源优化主要是Res资源。\n\n## 删除无用资源\n\n因为需求变更，版本更新等因素，很多研发只是一味的把新的资源文件让res下面扔，却没哟及时的把不用的文件给清理掉，长此以往导致res越来越臃肿。\n\nres资源的定时清理是很有必要的，但是资源那么多如何快速清理呢？\n\nAndroid提供了非常好用的工具Lint快速检测res中未使用的资源并给出提示。\n\n运行Analyze—>Run Inspection By Name ，弹窗输入：\n\n![lint](浅谈Android性能优化系列-1-之安装包大小优化/lint.png)\n\n执行结果如下：\n\n![lint_result](浅谈Android性能优化系列-1-之安装包大小优化/lint_result.png)\n\n其中lint.png图片没有使用，可以删除。Lint不只检测图片，而是res中所有资源包括未使用的string。\n\n## 资源图片最少化\n\n这里最少化有2个参考原则：\n\n①简单的图片shape画\n\n②多状态的图片filter画\n\n下面分别说说这两个原则都是什么意思\n\n- 简单的图片shape画\n\n  这里的简单是图形简单，颜色简单，比如矩形、圆角等纯色能用shape方便绘制出来的。\n\n- 多状态的图片filter画\n\n  这里的filter是colorFilter。\n\n  比如一些按钮都有默认背景色和选中背景色。这时设计一般会提供两套图片，如果使用colorFilter，我们只要一套就可以了。\n\n## 图片再压缩\n\n在app打包时，aapt会对图片进行压缩处理，但是这种压缩比较有限。因此我们可以再拿到设计给的图片后，使用一些工具进行二次压缩，比如Zopfli，这时谷歌开源项目。再比如PNGoo。\n\n# 0x04 其他优化\n\n- 使用webp代替png\n\n  webp从4.0开始支持，但是这时不支持透明度。较好地支持从4.2.2开始。\n\n- 精简第三方库\n\n  很多时候可能只需要第三方库的一部分功能，这时可以根据公司业务需求进行精简，这样会有个问题就是后期的库版本更新会是个问题。\n\n- 插件化\n\n  把一些使用率不高的业务模块再需要的时候从服务器下载，动态加载。","source":"_posts/浅谈Android性能优化系列-1-之安装包大小优化.md","raw":"---\ntitle: 浅谈Android性能优化系列(1)之安装包大小优化\ndate: 2017-07-21 11:35:04\ntags: [Android, 性能优化]\ncategories: [Android, 性能优化]\n---\n\n# 0x00 前言\n\n可能会有人有疑问，安装包还需要优化吗？现在流量都用不完的！\n\n这样来说吧，优化有多方面好处的：\n\n①节省用户流量\n\n②安装包越小，用户就越快下载完，缩短了联网时间，联网时间短耗电也就越少\n\n③越快下载完，用户就越能提前使用APP，避免对用户耐心的过多消磨。\n\n所以，安装包优化还是有必要的。\n\n# 0x01 安装包构成\n\n要想优化安装包，首先知道包由哪些部分组成的。这是电视猫app解压后目录：\n\n![安装包构成](浅谈Android性能优化系列-1-之安装包大小优化/安装包构成.png)\n\n目录中com和org两个文件夹是第三方包信息，不用管着两个。\n\n- assets可以存放资源和配置等各种文件，但是这里的资源文件不会像res中那样生成ID，而是通过AssetManager获取\n- dex是Java文件编程成class文件后又经过虚拟机优化压缩形成的\n- lib中存放native类库，根据不同CPU架构有四种类型：armeabi，armeabi-v7a，x86，mips。\n- META-INF保存了app签名信息\n- res中存放了资源文件\n- resources.arsc 记录资源文件和资源ID映射。可以根据ID查找资源\n- AndroidManifest.xml是app配置文件注册四大组件，声明权限等。\n\n\n\n知道了各个部分作用就大概知道了该从哪方面入手了：代码和资源，因为包中这两个部分占了很大一部分。\n\n# 0x02 代码优化\n\n代码优化其实包含了Java代码和Native代码，但是因为Native代码涉及了C和C++，这里不做阐述，但是说下lib库还是有必要的\n\n## lib库\n\n根据cpu架构lib中分为四种类型，但是目前大部分移动设备都是基于arm和arm-v7a的。x86和mips较少。而且据说x86兼容arm指令集，所以适配库优先考虑arm和arm-v7a两种即可。\n\n## Java代码优化：使用ProGuard代码混淆\n\nProGuard具有压缩(移除无效类、方法、属性)、优化、混淆功能。\n\n- 开启混淆\n\n  ```groovy\n      buildTypes {\n          release {\n              minifyEnabled true//开启混淆\n              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' //混淆文件\n          }\n      }\n  ```\n\n- 压缩\n\n  压缩功能是默认开启的，如果对某个或某些文件不想压缩可以使用：\n\n  `-dontshrink class * extends android.app.Activity`。\n\n- 优化\n\n  优化optimization默认开启，如果不开启可以使用：\n\n  `-dontoptimize`。一些相对复杂的方法时，压缩后可能会抛出errors，这时可以不压缩。\n\n- 混淆\n\n  混淆也是默认开启,如果对某些文件不想混淆可以使用：\n\n  `-dontobfuscate`。\n\n- 保留\n\n  如果想保留某些类、成员等不被混淆可以使用：\n\n  `-kepp`。\n\n  ​\n\n  关于proguard更多使用方法可参考：\n\n  [Android进阶之ProGuard代码混淆](http://hanhailong.com/2015/12/28/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/)\n\n  [Jean同学的Proguard私房物语](https://my.oschina.net/u/659658/blog/71976)\n\n  ​\n\n# 0x03 资源优化\n\n这里的资源优化主要是Res资源。\n\n## 删除无用资源\n\n因为需求变更，版本更新等因素，很多研发只是一味的把新的资源文件让res下面扔，却没哟及时的把不用的文件给清理掉，长此以往导致res越来越臃肿。\n\nres资源的定时清理是很有必要的，但是资源那么多如何快速清理呢？\n\nAndroid提供了非常好用的工具Lint快速检测res中未使用的资源并给出提示。\n\n运行Analyze—>Run Inspection By Name ，弹窗输入：\n\n![lint](浅谈Android性能优化系列-1-之安装包大小优化/lint.png)\n\n执行结果如下：\n\n![lint_result](浅谈Android性能优化系列-1-之安装包大小优化/lint_result.png)\n\n其中lint.png图片没有使用，可以删除。Lint不只检测图片，而是res中所有资源包括未使用的string。\n\n## 资源图片最少化\n\n这里最少化有2个参考原则：\n\n①简单的图片shape画\n\n②多状态的图片filter画\n\n下面分别说说这两个原则都是什么意思\n\n- 简单的图片shape画\n\n  这里的简单是图形简单，颜色简单，比如矩形、圆角等纯色能用shape方便绘制出来的。\n\n- 多状态的图片filter画\n\n  这里的filter是colorFilter。\n\n  比如一些按钮都有默认背景色和选中背景色。这时设计一般会提供两套图片，如果使用colorFilter，我们只要一套就可以了。\n\n## 图片再压缩\n\n在app打包时，aapt会对图片进行压缩处理，但是这种压缩比较有限。因此我们可以再拿到设计给的图片后，使用一些工具进行二次压缩，比如Zopfli，这时谷歌开源项目。再比如PNGoo。\n\n# 0x04 其他优化\n\n- 使用webp代替png\n\n  webp从4.0开始支持，但是这时不支持透明度。较好地支持从4.2.2开始。\n\n- 精简第三方库\n\n  很多时候可能只需要第三方库的一部分功能，这时可以根据公司业务需求进行精简，这样会有个问题就是后期的库版本更新会是个问题。\n\n- 插件化\n\n  把一些使用率不高的业务模块再需要的时候从服务器下载，动态加载。","slug":"浅谈Android性能优化系列-1-之安装包大小优化","published":1,"updated":"2017-07-24T09:02:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjjz007owh9c3tso8on2","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>可能会有人有疑问，安装包还需要优化吗？现在流量都用不完的！</p>\n<p>这样来说吧，优化有多方面好处的：</p>\n<p>①节省用户流量</p>\n<p>②安装包越小，用户就越快下载完，缩短了联网时间，联网时间短耗电也就越少</p>\n<p>③越快下载完，用户就越能提前使用APP，避免对用户耐心的过多消磨。</p>\n<p>所以，安装包优化还是有必要的。</p>\n<h1 id=\"0x01-安装包构成\"><a href=\"#0x01-安装包构成\" class=\"headerlink\" title=\"0x01 安装包构成\"></a>0x01 安装包构成</h1><p>要想优化安装包，首先知道包由哪些部分组成的。这是电视猫app解压后目录：</p>\n<p><img src=\"/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/安装包构成.png\" alt=\"安装包构成\"></p>\n<p>目录中com和org两个文件夹是第三方包信息，不用管着两个。</p>\n<ul>\n<li>assets可以存放资源和配置等各种文件，但是这里的资源文件不会像res中那样生成ID，而是通过AssetManager获取</li>\n<li>dex是Java文件编程成class文件后又经过虚拟机优化压缩形成的</li>\n<li>lib中存放native类库，根据不同CPU架构有四种类型：armeabi，armeabi-v7a，x86，mips。</li>\n<li>META-INF保存了app签名信息</li>\n<li>res中存放了资源文件</li>\n<li>resources.arsc 记录资源文件和资源ID映射。可以根据ID查找资源</li>\n<li>AndroidManifest.xml是app配置文件注册四大组件，声明权限等。</li>\n</ul>\n<p>知道了各个部分作用就大概知道了该从哪方面入手了：代码和资源，因为包中这两个部分占了很大一部分。</p>\n<h1 id=\"0x02-代码优化\"><a href=\"#0x02-代码优化\" class=\"headerlink\" title=\"0x02 代码优化\"></a>0x02 代码优化</h1><p>代码优化其实包含了Java代码和Native代码，但是因为Native代码涉及了C和C++，这里不做阐述，但是说下lib库还是有必要的</p>\n<h2 id=\"lib库\"><a href=\"#lib库\" class=\"headerlink\" title=\"lib库\"></a>lib库</h2><p>根据cpu架构lib中分为四种类型，但是目前大部分移动设备都是基于arm和arm-v7a的。x86和mips较少。而且据说x86兼容arm指令集，所以适配库优先考虑arm和arm-v7a两种即可。</p>\n<h2 id=\"Java代码优化：使用ProGuard代码混淆\"><a href=\"#Java代码优化：使用ProGuard代码混淆\" class=\"headerlink\" title=\"Java代码优化：使用ProGuard代码混淆\"></a>Java代码优化：使用ProGuard代码混淆</h2><p>ProGuard具有压缩(移除无效类、方法、属性)、优化、混淆功能。</p>\n<ul>\n<li><p>开启混淆</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">buildTypes &#123;</div><div class=\"line\">    release &#123;</div><div class=\"line\">        minifyEnabled <span class=\"literal\">true</span><span class=\"comment\">//开启混淆</span></div><div class=\"line\">        proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span> <span class=\"comment\">//混淆文件</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>压缩</p>\n<p>压缩功能是默认开启的，如果对某个或某些文件不想压缩可以使用：</p>\n<p><code>-dontshrink class * extends android.app.Activity</code>。</p>\n</li>\n<li><p>优化</p>\n<p>优化optimization默认开启，如果不开启可以使用：</p>\n<p><code>-dontoptimize</code>。一些相对复杂的方法时，压缩后可能会抛出errors，这时可以不压缩。</p>\n</li>\n<li><p>混淆</p>\n<p>混淆也是默认开启,如果对某些文件不想混淆可以使用：</p>\n<p><code>-dontobfuscate</code>。</p>\n</li>\n<li><p>保留</p>\n<p>如果想保留某些类、成员等不被混淆可以使用：</p>\n<p><code>-kepp</code>。</p>\n<p>​</p>\n<p>关于proguard更多使用方法可参考：</p>\n<p><a href=\"http://hanhailong.com/2015/12/28/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/\" target=\"_blank\" rel=\"external\">Android进阶之ProGuard代码混淆</a></p>\n<p><a href=\"https://my.oschina.net/u/659658/blog/71976\" target=\"_blank\" rel=\"external\">Jean同学的Proguard私房物语</a></p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x03-资源优化\"><a href=\"#0x03-资源优化\" class=\"headerlink\" title=\"0x03 资源优化\"></a>0x03 资源优化</h1><p>这里的资源优化主要是Res资源。</p>\n<h2 id=\"删除无用资源\"><a href=\"#删除无用资源\" class=\"headerlink\" title=\"删除无用资源\"></a>删除无用资源</h2><p>因为需求变更，版本更新等因素，很多研发只是一味的把新的资源文件让res下面扔，却没哟及时的把不用的文件给清理掉，长此以往导致res越来越臃肿。</p>\n<p>res资源的定时清理是很有必要的，但是资源那么多如何快速清理呢？</p>\n<p>Android提供了非常好用的工具Lint快速检测res中未使用的资源并给出提示。</p>\n<p>运行Analyze—&gt;Run Inspection By Name ，弹窗输入：</p>\n<p><img src=\"/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/lint.png\" alt=\"lint\"></p>\n<p>执行结果如下：</p>\n<p><img src=\"/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/lint_result.png\" alt=\"lint_result\"></p>\n<p>其中lint.png图片没有使用，可以删除。Lint不只检测图片，而是res中所有资源包括未使用的string。</p>\n<h2 id=\"资源图片最少化\"><a href=\"#资源图片最少化\" class=\"headerlink\" title=\"资源图片最少化\"></a>资源图片最少化</h2><p>这里最少化有2个参考原则：</p>\n<p>①简单的图片shape画</p>\n<p>②多状态的图片filter画</p>\n<p>下面分别说说这两个原则都是什么意思</p>\n<ul>\n<li><p>简单的图片shape画</p>\n<p>这里的简单是图形简单，颜色简单，比如矩形、圆角等纯色能用shape方便绘制出来的。</p>\n</li>\n<li><p>多状态的图片filter画</p>\n<p>这里的filter是colorFilter。</p>\n<p>比如一些按钮都有默认背景色和选中背景色。这时设计一般会提供两套图片，如果使用colorFilter，我们只要一套就可以了。</p>\n</li>\n</ul>\n<h2 id=\"图片再压缩\"><a href=\"#图片再压缩\" class=\"headerlink\" title=\"图片再压缩\"></a>图片再压缩</h2><p>在app打包时，aapt会对图片进行压缩处理，但是这种压缩比较有限。因此我们可以再拿到设计给的图片后，使用一些工具进行二次压缩，比如Zopfli，这时谷歌开源项目。再比如PNGoo。</p>\n<h1 id=\"0x04-其他优化\"><a href=\"#0x04-其他优化\" class=\"headerlink\" title=\"0x04 其他优化\"></a>0x04 其他优化</h1><ul>\n<li><p>使用webp代替png</p>\n<p>webp从4.0开始支持，但是这时不支持透明度。较好地支持从4.2.2开始。</p>\n</li>\n<li><p>精简第三方库</p>\n<p>很多时候可能只需要第三方库的一部分功能，这时可以根据公司业务需求进行精简，这样会有个问题就是后期的库版本更新会是个问题。</p>\n</li>\n<li><p>插件化</p>\n<p>把一些使用率不高的业务模块再需要的时候从服务器下载，动态加载。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>可能会有人有疑问，安装包还需要优化吗？现在流量都用不完的！</p>\n<p>这样来说吧，优化有多方面好处的：</p>\n<p>①节省用户流量</p>\n<p>②安装包越小，用户就越快下载完，缩短了联网时间，联网时间短耗电也就越少</p>\n<p>③越快下载完，用户就越能提前使用APP，避免对用户耐心的过多消磨。</p>\n<p>所以，安装包优化还是有必要的。</p>\n<h1 id=\"0x01-安装包构成\"><a href=\"#0x01-安装包构成\" class=\"headerlink\" title=\"0x01 安装包构成\"></a>0x01 安装包构成</h1><p>要想优化安装包，首先知道包由哪些部分组成的。这是电视猫app解压后目录：</p>\n<p><img src=\"/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/安装包构成.png\" alt=\"安装包构成\"></p>\n<p>目录中com和org两个文件夹是第三方包信息，不用管着两个。</p>\n<ul>\n<li>assets可以存放资源和配置等各种文件，但是这里的资源文件不会像res中那样生成ID，而是通过AssetManager获取</li>\n<li>dex是Java文件编程成class文件后又经过虚拟机优化压缩形成的</li>\n<li>lib中存放native类库，根据不同CPU架构有四种类型：armeabi，armeabi-v7a，x86，mips。</li>\n<li>META-INF保存了app签名信息</li>\n<li>res中存放了资源文件</li>\n<li>resources.arsc 记录资源文件和资源ID映射。可以根据ID查找资源</li>\n<li>AndroidManifest.xml是app配置文件注册四大组件，声明权限等。</li>\n</ul>\n<p>知道了各个部分作用就大概知道了该从哪方面入手了：代码和资源，因为包中这两个部分占了很大一部分。</p>\n<h1 id=\"0x02-代码优化\"><a href=\"#0x02-代码优化\" class=\"headerlink\" title=\"0x02 代码优化\"></a>0x02 代码优化</h1><p>代码优化其实包含了Java代码和Native代码，但是因为Native代码涉及了C和C++，这里不做阐述，但是说下lib库还是有必要的</p>\n<h2 id=\"lib库\"><a href=\"#lib库\" class=\"headerlink\" title=\"lib库\"></a>lib库</h2><p>根据cpu架构lib中分为四种类型，但是目前大部分移动设备都是基于arm和arm-v7a的。x86和mips较少。而且据说x86兼容arm指令集，所以适配库优先考虑arm和arm-v7a两种即可。</p>\n<h2 id=\"Java代码优化：使用ProGuard代码混淆\"><a href=\"#Java代码优化：使用ProGuard代码混淆\" class=\"headerlink\" title=\"Java代码优化：使用ProGuard代码混淆\"></a>Java代码优化：使用ProGuard代码混淆</h2><p>ProGuard具有压缩(移除无效类、方法、属性)、优化、混淆功能。</p>\n<ul>\n<li><p>开启混淆</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">buildTypes &#123;</div><div class=\"line\">    release &#123;</div><div class=\"line\">        minifyEnabled <span class=\"literal\">true</span><span class=\"comment\">//开启混淆</span></div><div class=\"line\">        proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span> <span class=\"comment\">//混淆文件</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>压缩</p>\n<p>压缩功能是默认开启的，如果对某个或某些文件不想压缩可以使用：</p>\n<p><code>-dontshrink class * extends android.app.Activity</code>。</p>\n</li>\n<li><p>优化</p>\n<p>优化optimization默认开启，如果不开启可以使用：</p>\n<p><code>-dontoptimize</code>。一些相对复杂的方法时，压缩后可能会抛出errors，这时可以不压缩。</p>\n</li>\n<li><p>混淆</p>\n<p>混淆也是默认开启,如果对某些文件不想混淆可以使用：</p>\n<p><code>-dontobfuscate</code>。</p>\n</li>\n<li><p>保留</p>\n<p>如果想保留某些类、成员等不被混淆可以使用：</p>\n<p><code>-kepp</code>。</p>\n<p>​</p>\n<p>关于proguard更多使用方法可参考：</p>\n<p><a href=\"http://hanhailong.com/2015/12/28/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/\">Android进阶之ProGuard代码混淆</a></p>\n<p><a href=\"https://my.oschina.net/u/659658/blog/71976\">Jean同学的Proguard私房物语</a></p>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"0x03-资源优化\"><a href=\"#0x03-资源优化\" class=\"headerlink\" title=\"0x03 资源优化\"></a>0x03 资源优化</h1><p>这里的资源优化主要是Res资源。</p>\n<h2 id=\"删除无用资源\"><a href=\"#删除无用资源\" class=\"headerlink\" title=\"删除无用资源\"></a>删除无用资源</h2><p>因为需求变更，版本更新等因素，很多研发只是一味的把新的资源文件让res下面扔，却没哟及时的把不用的文件给清理掉，长此以往导致res越来越臃肿。</p>\n<p>res资源的定时清理是很有必要的，但是资源那么多如何快速清理呢？</p>\n<p>Android提供了非常好用的工具Lint快速检测res中未使用的资源并给出提示。</p>\n<p>运行Analyze—&gt;Run Inspection By Name ，弹窗输入：</p>\n<p><img src=\"/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/lint.png\" alt=\"lint\"></p>\n<p>执行结果如下：</p>\n<p><img src=\"/2017/07/21/浅谈Android性能优化系列-1-之安装包大小优化/lint_result.png\" alt=\"lint_result\"></p>\n<p>其中lint.png图片没有使用，可以删除。Lint不只检测图片，而是res中所有资源包括未使用的string。</p>\n<h2 id=\"资源图片最少化\"><a href=\"#资源图片最少化\" class=\"headerlink\" title=\"资源图片最少化\"></a>资源图片最少化</h2><p>这里最少化有2个参考原则：</p>\n<p>①简单的图片shape画</p>\n<p>②多状态的图片filter画</p>\n<p>下面分别说说这两个原则都是什么意思</p>\n<ul>\n<li><p>简单的图片shape画</p>\n<p>这里的简单是图形简单，颜色简单，比如矩形、圆角等纯色能用shape方便绘制出来的。</p>\n</li>\n<li><p>多状态的图片filter画</p>\n<p>这里的filter是colorFilter。</p>\n<p>比如一些按钮都有默认背景色和选中背景色。这时设计一般会提供两套图片，如果使用colorFilter，我们只要一套就可以了。</p>\n</li>\n</ul>\n<h2 id=\"图片再压缩\"><a href=\"#图片再压缩\" class=\"headerlink\" title=\"图片再压缩\"></a>图片再压缩</h2><p>在app打包时，aapt会对图片进行压缩处理，但是这种压缩比较有限。因此我们可以再拿到设计给的图片后，使用一些工具进行二次压缩，比如Zopfli，这时谷歌开源项目。再比如PNGoo。</p>\n<h1 id=\"0x04-其他优化\"><a href=\"#0x04-其他优化\" class=\"headerlink\" title=\"0x04 其他优化\"></a>0x04 其他优化</h1><ul>\n<li><p>使用webp代替png</p>\n<p>webp从4.0开始支持，但是这时不支持透明度。较好地支持从4.2.2开始。</p>\n</li>\n<li><p>精简第三方库</p>\n<p>很多时候可能只需要第三方库的一部分功能，这时可以根据公司业务需求进行精简，这样会有个问题就是后期的库版本更新会是个问题。</p>\n</li>\n<li><p>插件化</p>\n<p>把一些使用率不高的业务模块再需要的时候从服务器下载，动态加载。</p>\n</li>\n</ul>\n"},{"title":"番茄工作法使用说明书","date":"2017-04-21T12:55:54.000Z","_content":"今天花了点时间把番茄工作法这本书看完了，和以前上学时45分钟每节课的感觉差不多，只是这个时间更短，流程也更细化，容易让人集中注意力。\n\n先来几个问题看看中刀的人有多少：\n1.有拖延症，上午的工作要拖到下午，下午的工作要拖到明天或者有反正周六要加班，那就周五多玩玩，刷刷微博这样的思想。\n2.经常我们想看一本书，看了一点后就厌烦抛诸脑后，等过一段时间兴致又来了想继续读，发现前面的内容已经忘了不得已要从头开始，如此往复，一年到头一本书还在原地徘徊，年终总结时才悔恨不已。\n3.上班就开始干活，但是手头的事情刚干了一点，又一摊新的工作挤进来，然后倒手又去忙新的事情，经常下班了感觉忙了一天却没有一件拿得出手的已完成的活来交差。\n如果你有上面的一种或者几种那么番茄工作法适合你。\n## 番茄工作法的历史\n番茄工作法是由弗朗西斯科·西里洛在1992年创建的，但其实在更早的时候西里洛就已经使用了。20世纪80年代西里洛还在大学时，由于学习效率低下作业完不成，就在想怎么让自己踏实的学一会，哪怕十分钟也行。如果有人监督帮忙掐表，会不会很好，后来西里洛找到了厨房定时器，形状酷似番茄，就这样他邂逅了番茄钟。\n\n![未命名.png](http://upload-images.jianshu.io/upload_images/1796052-be51678192608453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 什么是番茄工作法？\n简单的说就是列出要做的事，标记当天要完成的，设置闹钟为25分钟，然后从第一件事情开始做。还要有每日回顾、每日承诺、中断和预估等。\n\n```\n番茄工作法是一套简单的流程，它可以让我们提高时间观念、提升注意力、加强自我决策意识、改善目前不好的工作流程从而提高工作效率，当然这一切好处的前提是正确并长期的执行了番茄法。\n```\n\n## 番茄工作法需要哪些工具？\n一个番茄钟\n铅笔/橡皮\n三张表格(活动清单、今日待办、记录)\n\n![fullsizerender.jpg](http://upload-images.jianshu.io/upload_images/1796052-3a5435880d169f91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 番茄工作法流程详解\n### 将近期要完成的活动/任务加入到活动清单\n把近几天准备工作的内容填写到活动清单中，活动清单内容力求简洁，不要求别人看懂，只需要自己几个月后仍能看懂即可。\n如果某件事明确了必须在某时间之前完成，则可以在活动末尾加上最后期限作为提醒。\n\n\n![fullsizerender(1).jpg](http://upload-images.jianshu.io/upload_images/1796052-bcb5ae9b4fa83b5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 从活动清单中选择今日要完成的几项抄入到今日待办中\n今日待办的任务一定是要从活动清单抄入过来的，如果是自己又单独创建的那活动清单有何意义？填写今日待办时要注意划分优先级(事情的重要程度)，然后给每个待办预估需要多少番茄钟来完成，在待办后面用方格表示出来。\n\n\n![fullsizerender(4).jpg](http://upload-images.jianshu.io/upload_images/1796052-6386cf28a2aa20ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n```\n从开始的活动清单列举，到今日待办的筛选，有没有觉得原本杂乱无章的事情，现在有了头绪而且当天\b目标已经明确只需要放手去做了。无形中注意力已经转移到所选活动了。\n```\n### 准备好工作后，启动番茄钟时间设定为25分钟。\n注意每个番茄钟都是原子性的，即不能再分割，一旦番茄钟启动，25分钟必须从一而终。\n可能有人会有疑问：如果番茄钟期间渴了怎么办？有人打电话或者有同事来询问怎么办？别急，这些都是中断，参见步骤4。\n### 开始工作，直到番茄钟响铃结束\n工作期间可能会受到中断，在日常工作中，中断是不可完全避免的，需要自己处理好中断。\n中断有两种形式：内部中断和外部中断。\n```内部中断 是自己造成的，是直觉向大脑发出信号，告诉我让我去专注当下活动以外的事情。```\n\n比如工作了一会，突然想打开qq去群里扯皮几句，想起有个电话没有回复，水杯没水了要去续杯等，这些都是来自自身内部的本能，其实是想拖延，这时该怎么办？接受、记录然后继续番茄钟。\n首先看引起中断原因，如果是突然想起没有做的事情，那么可以在今日待办(如果想起的事情不紧急可以直接加入到活动清单中，并在左边加一个“U”表示计划外事件“unplanned”)下方添加一个“计划外紧急”栏目，记录中断原因(下图中的③)，并在今日待办的当前活动后面添加一个 撇号 ' (下图中的①)，表示当下活动产生一个内部中断，记录完成继续番茄钟。\n 至于说要聊天扯皮和续杯，等到番茄钟结束后再去，当然如果只是喝水那你想喝多少喝多少。\n如果作为初学者感觉内部中断太多，可以尝试缩小番茄钟为5、10、15分钟。当然番茄钟的每次更改至少要保持两个星期再次更改。\n```外部中断 是别人造成的，有人向你询问请你帮忙，等你答复，外部中断往往具有互动性。但是我们不能因为保护番茄钟就拒绝帮忙同事，毕竟低头不见抬头见的。```\n可以在番茄钟期间手机、邮件静音，\n同事来面谈，如果比较急可以商量稍后推迟下，用下一个番茄钟来解决中断事件，而不是在当前活动直接中断处理；如果不着急可以添加到计划外事件，同时在当前活动后添加一个减号 -(下图中的②)，表示受到一次外部中断；如果非常着急，那么不得已只有废弃当前的番茄钟，先帮同事解决问题，过后休息一会然后开启新的番茄钟开始专注起来。\n\n每个番茄钟结束都要在今日待办的当下活动方格中画×。如果当下活动已经完成则可以给活动内容划一条横线表示完成状态(下图中的③)。\n\n![fullsizerender(5).jpg](http://upload-images.jianshu.io/upload_images/1796052-4ab23cde90bb31c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 休息\n小休时间一般为3-5分钟，每隔4个番茄钟就大休一次，大休一般15-30分钟。注意休息期间要站起来走动一下，让自己能消除对上一个番茄钟的思考，完全抽身出来放松下。可以泡杯茶或咖啡，去个厕所，窗台发呆等，总之拒绝任何用脑的活动。\n以下说明了休息时箭头所指从最佳到最差休息方式：\n![fullsizerender(3).jpg](http://upload-images.jianshu.io/upload_images/1796052-32cc2cfdbfaad96f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 开始下一个番茄钟，重复3-5步\n\n### 下班前记录\n记录什么内容？记录当天完成的番茄钟数、被打断数、今日待办完成数等，通过记录可以知晓自己承诺完成了多少，相差多少，如果差距很大，就要寻找原因。经过一段时间的记录，数据可视化，看自己的承诺和已完成是否越来越接近。通过记录发现总结不足，在以后的清单中持续改善。\n\n以上只介绍了番茄工作法流程和一些需要注意的点，其他一些边缘内容或者没有get到的点欢迎探讨。","source":"_posts/番茄工作法使用说明书.md","raw":"---\ntitle: 番茄工作法使用说明书\ndate: 2017-04-21 20:55:54\ntags: 职场杂谈\ncategories: 职场杂谈\n---\n今天花了点时间把番茄工作法这本书看完了，和以前上学时45分钟每节课的感觉差不多，只是这个时间更短，流程也更细化，容易让人集中注意力。\n\n先来几个问题看看中刀的人有多少：\n1.有拖延症，上午的工作要拖到下午，下午的工作要拖到明天或者有反正周六要加班，那就周五多玩玩，刷刷微博这样的思想。\n2.经常我们想看一本书，看了一点后就厌烦抛诸脑后，等过一段时间兴致又来了想继续读，发现前面的内容已经忘了不得已要从头开始，如此往复，一年到头一本书还在原地徘徊，年终总结时才悔恨不已。\n3.上班就开始干活，但是手头的事情刚干了一点，又一摊新的工作挤进来，然后倒手又去忙新的事情，经常下班了感觉忙了一天却没有一件拿得出手的已完成的活来交差。\n如果你有上面的一种或者几种那么番茄工作法适合你。\n## 番茄工作法的历史\n番茄工作法是由弗朗西斯科·西里洛在1992年创建的，但其实在更早的时候西里洛就已经使用了。20世纪80年代西里洛还在大学时，由于学习效率低下作业完不成，就在想怎么让自己踏实的学一会，哪怕十分钟也行。如果有人监督帮忙掐表，会不会很好，后来西里洛找到了厨房定时器，形状酷似番茄，就这样他邂逅了番茄钟。\n\n![未命名.png](http://upload-images.jianshu.io/upload_images/1796052-be51678192608453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 什么是番茄工作法？\n简单的说就是列出要做的事，标记当天要完成的，设置闹钟为25分钟，然后从第一件事情开始做。还要有每日回顾、每日承诺、中断和预估等。\n\n```\n番茄工作法是一套简单的流程，它可以让我们提高时间观念、提升注意力、加强自我决策意识、改善目前不好的工作流程从而提高工作效率，当然这一切好处的前提是正确并长期的执行了番茄法。\n```\n\n## 番茄工作法需要哪些工具？\n一个番茄钟\n铅笔/橡皮\n三张表格(活动清单、今日待办、记录)\n\n![fullsizerender.jpg](http://upload-images.jianshu.io/upload_images/1796052-3a5435880d169f91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 番茄工作法流程详解\n### 将近期要完成的活动/任务加入到活动清单\n把近几天准备工作的内容填写到活动清单中，活动清单内容力求简洁，不要求别人看懂，只需要自己几个月后仍能看懂即可。\n如果某件事明确了必须在某时间之前完成，则可以在活动末尾加上最后期限作为提醒。\n\n\n![fullsizerender(1).jpg](http://upload-images.jianshu.io/upload_images/1796052-bcb5ae9b4fa83b5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 从活动清单中选择今日要完成的几项抄入到今日待办中\n今日待办的任务一定是要从活动清单抄入过来的，如果是自己又单独创建的那活动清单有何意义？填写今日待办时要注意划分优先级(事情的重要程度)，然后给每个待办预估需要多少番茄钟来完成，在待办后面用方格表示出来。\n\n\n![fullsizerender(4).jpg](http://upload-images.jianshu.io/upload_images/1796052-6386cf28a2aa20ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n```\n从开始的活动清单列举，到今日待办的筛选，有没有觉得原本杂乱无章的事情，现在有了头绪而且当天\b目标已经明确只需要放手去做了。无形中注意力已经转移到所选活动了。\n```\n### 准备好工作后，启动番茄钟时间设定为25分钟。\n注意每个番茄钟都是原子性的，即不能再分割，一旦番茄钟启动，25分钟必须从一而终。\n可能有人会有疑问：如果番茄钟期间渴了怎么办？有人打电话或者有同事来询问怎么办？别急，这些都是中断，参见步骤4。\n### 开始工作，直到番茄钟响铃结束\n工作期间可能会受到中断，在日常工作中，中断是不可完全避免的，需要自己处理好中断。\n中断有两种形式：内部中断和外部中断。\n```内部中断 是自己造成的，是直觉向大脑发出信号，告诉我让我去专注当下活动以外的事情。```\n\n比如工作了一会，突然想打开qq去群里扯皮几句，想起有个电话没有回复，水杯没水了要去续杯等，这些都是来自自身内部的本能，其实是想拖延，这时该怎么办？接受、记录然后继续番茄钟。\n首先看引起中断原因，如果是突然想起没有做的事情，那么可以在今日待办(如果想起的事情不紧急可以直接加入到活动清单中，并在左边加一个“U”表示计划外事件“unplanned”)下方添加一个“计划外紧急”栏目，记录中断原因(下图中的③)，并在今日待办的当前活动后面添加一个 撇号 ' (下图中的①)，表示当下活动产生一个内部中断，记录完成继续番茄钟。\n 至于说要聊天扯皮和续杯，等到番茄钟结束后再去，当然如果只是喝水那你想喝多少喝多少。\n如果作为初学者感觉内部中断太多，可以尝试缩小番茄钟为5、10、15分钟。当然番茄钟的每次更改至少要保持两个星期再次更改。\n```外部中断 是别人造成的，有人向你询问请你帮忙，等你答复，外部中断往往具有互动性。但是我们不能因为保护番茄钟就拒绝帮忙同事，毕竟低头不见抬头见的。```\n可以在番茄钟期间手机、邮件静音，\n同事来面谈，如果比较急可以商量稍后推迟下，用下一个番茄钟来解决中断事件，而不是在当前活动直接中断处理；如果不着急可以添加到计划外事件，同时在当前活动后添加一个减号 -(下图中的②)，表示受到一次外部中断；如果非常着急，那么不得已只有废弃当前的番茄钟，先帮同事解决问题，过后休息一会然后开启新的番茄钟开始专注起来。\n\n每个番茄钟结束都要在今日待办的当下活动方格中画×。如果当下活动已经完成则可以给活动内容划一条横线表示完成状态(下图中的③)。\n\n![fullsizerender(5).jpg](http://upload-images.jianshu.io/upload_images/1796052-4ab23cde90bb31c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 休息\n小休时间一般为3-5分钟，每隔4个番茄钟就大休一次，大休一般15-30分钟。注意休息期间要站起来走动一下，让自己能消除对上一个番茄钟的思考，完全抽身出来放松下。可以泡杯茶或咖啡，去个厕所，窗台发呆等，总之拒绝任何用脑的活动。\n以下说明了休息时箭头所指从最佳到最差休息方式：\n![fullsizerender(3).jpg](http://upload-images.jianshu.io/upload_images/1796052-32cc2cfdbfaad96f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 开始下一个番茄钟，重复3-5步\n\n### 下班前记录\n记录什么内容？记录当天完成的番茄钟数、被打断数、今日待办完成数等，通过记录可以知晓自己承诺完成了多少，相差多少，如果差距很大，就要寻找原因。经过一段时间的记录，数据可视化，看自己的承诺和已完成是否越来越接近。通过记录发现总结不足，在以后的清单中持续改善。\n\n以上只介绍了番茄工作法流程和一些需要注意的点，其他一些边缘内容或者没有get到的点欢迎探讨。","slug":"番茄工作法使用说明书","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjk2007rwh9crpynje2x","content":"<p>今天花了点时间把番茄工作法这本书看完了，和以前上学时45分钟每节课的感觉差不多，只是这个时间更短，流程也更细化，容易让人集中注意力。</p>\n<p>先来几个问题看看中刀的人有多少：<br>1.有拖延症，上午的工作要拖到下午，下午的工作要拖到明天或者有反正周六要加班，那就周五多玩玩，刷刷微博这样的思想。<br>2.经常我们想看一本书，看了一点后就厌烦抛诸脑后，等过一段时间兴致又来了想继续读，发现前面的内容已经忘了不得已要从头开始，如此往复，一年到头一本书还在原地徘徊，年终总结时才悔恨不已。<br>3.上班就开始干活，但是手头的事情刚干了一点，又一摊新的工作挤进来，然后倒手又去忙新的事情，经常下班了感觉忙了一天却没有一件拿得出手的已完成的活来交差。<br>如果你有上面的一种或者几种那么番茄工作法适合你。</p>\n<h2 id=\"番茄工作法的历史\"><a href=\"#番茄工作法的历史\" class=\"headerlink\" title=\"番茄工作法的历史\"></a>番茄工作法的历史</h2><p>番茄工作法是由弗朗西斯科·西里洛在1992年创建的，但其实在更早的时候西里洛就已经使用了。20世纪80年代西里洛还在大学时，由于学习效率低下作业完不成，就在想怎么让自己踏实的学一会，哪怕十分钟也行。如果有人监督帮忙掐表，会不会很好，后来西里洛找到了厨房定时器，形状酷似番茄，就这样他邂逅了番茄钟。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-be51678192608453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"未命名.png\"></p>\n<h2 id=\"什么是番茄工作法？\"><a href=\"#什么是番茄工作法？\" class=\"headerlink\" title=\"什么是番茄工作法？\"></a>什么是番茄工作法？</h2><p>简单的说就是列出要做的事，标记当天要完成的，设置闹钟为25分钟，然后从第一件事情开始做。还要有每日回顾、每日承诺、中断和预估等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">番茄工作法是一套简单的流程，它可以让我们提高时间观念、提升注意力、加强自我决策意识、改善目前不好的工作流程从而提高工作效率，当然这一切好处的前提是正确并长期的执行了番茄法。</div></pre></td></tr></table></figure>\n<h2 id=\"番茄工作法需要哪些工具？\"><a href=\"#番茄工作法需要哪些工具？\" class=\"headerlink\" title=\"番茄工作法需要哪些工具？\"></a>番茄工作法需要哪些工具？</h2><p>一个番茄钟<br>铅笔/橡皮<br>三张表格(活动清单、今日待办、记录)</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-3a5435880d169f91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender.jpg\"></p>\n<h2 id=\"番茄工作法流程详解\"><a href=\"#番茄工作法流程详解\" class=\"headerlink\" title=\"番茄工作法流程详解\"></a>番茄工作法流程详解</h2><h3 id=\"将近期要完成的活动-任务加入到活动清单\"><a href=\"#将近期要完成的活动-任务加入到活动清单\" class=\"headerlink\" title=\"将近期要完成的活动/任务加入到活动清单\"></a>将近期要完成的活动/任务加入到活动清单</h3><p>把近几天准备工作的内容填写到活动清单中，活动清单内容力求简洁，不要求别人看懂，只需要自己几个月后仍能看懂即可。<br>如果某件事明确了必须在某时间之前完成，则可以在活动末尾加上最后期限作为提醒。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-bcb5ae9b4fa83b5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(1).jpg\"></p>\n<h3 id=\"从活动清单中选择今日要完成的几项抄入到今日待办中\"><a href=\"#从活动清单中选择今日要完成的几项抄入到今日待办中\" class=\"headerlink\" title=\"从活动清单中选择今日要完成的几项抄入到今日待办中\"></a>从活动清单中选择今日要完成的几项抄入到今日待办中</h3><p>今日待办的任务一定是要从活动清单抄入过来的，如果是自己又单独创建的那活动清单有何意义？填写今日待办时要注意划分优先级(事情的重要程度)，然后给每个待办预估需要多少番茄钟来完成，在待办后面用方格表示出来。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6386cf28a2aa20ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(4).jpg\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">从开始的活动清单列举，到今日待办的筛选，有没有觉得原本杂乱无章的事情，现在有了头绪而且当天\b目标已经明确只需要放手去做了。无形中注意力已经转移到所选活动了。</div></pre></td></tr></table></figure>\n<h3 id=\"准备好工作后，启动番茄钟时间设定为25分钟。\"><a href=\"#准备好工作后，启动番茄钟时间设定为25分钟。\" class=\"headerlink\" title=\"准备好工作后，启动番茄钟时间设定为25分钟。\"></a>准备好工作后，启动番茄钟时间设定为25分钟。</h3><p>注意每个番茄钟都是原子性的，即不能再分割，一旦番茄钟启动，25分钟必须从一而终。<br>可能有人会有疑问：如果番茄钟期间渴了怎么办？有人打电话或者有同事来询问怎么办？别急，这些都是中断，参见步骤4。</p>\n<h3 id=\"开始工作，直到番茄钟响铃结束\"><a href=\"#开始工作，直到番茄钟响铃结束\" class=\"headerlink\" title=\"开始工作，直到番茄钟响铃结束\"></a>开始工作，直到番茄钟响铃结束</h3><p>工作期间可能会受到中断，在日常工作中，中断是不可完全避免的，需要自己处理好中断。<br>中断有两种形式：内部中断和外部中断。<br><figure class=\"highlight plain\"><figcaption><span>是自己造成的，是直觉向大脑发出信号，告诉我让我去专注当下活动以外的事情。```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">比如工作了一会，突然想打开qq去群里扯皮几句，想起有个电话没有回复，水杯没水了要去续杯等，这些都是来自自身内部的本能，其实是想拖延，这时该怎么办？接受、记录然后继续番茄钟。</div><div class=\"line\">首先看引起中断原因，如果是突然想起没有做的事情，那么可以在今日待办(如果想起的事情不紧急可以直接加入到活动清单中，并在左边加一个“U”表示计划外事件“unplanned”)下方添加一个“计划外紧急”栏目，记录中断原因(下图中的③)，并在今日待办的当前活动后面添加一个 撇号 &apos; (下图中的①)，表示当下活动产生一个内部中断，记录完成继续番茄钟。</div><div class=\"line\"> 至于说要聊天扯皮和续杯，等到番茄钟结束后再去，当然如果只是喝水那你想喝多少喝多少。</div><div class=\"line\">如果作为初学者感觉内部中断太多，可以尝试缩小番茄钟为5、10、15分钟。当然番茄钟的每次更改至少要保持两个星期再次更改。</div><div class=\"line\">```外部中断 是别人造成的，有人向你询问请你帮忙，等你答复，外部中断往往具有互动性。但是我们不能因为保护番茄钟就拒绝帮忙同事，毕竟低头不见抬头见的。</div></pre></td></tr></table></figure></p>\n<p>可以在番茄钟期间手机、邮件静音，<br>同事来面谈，如果比较急可以商量稍后推迟下，用下一个番茄钟来解决中断事件，而不是在当前活动直接中断处理；如果不着急可以添加到计划外事件，同时在当前活动后添加一个减号 -(下图中的②)，表示受到一次外部中断；如果非常着急，那么不得已只有废弃当前的番茄钟，先帮同事解决问题，过后休息一会然后开启新的番茄钟开始专注起来。</p>\n<p>每个番茄钟结束都要在今日待办的当下活动方格中画×。如果当下活动已经完成则可以给活动内容划一条横线表示完成状态(下图中的③)。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-4ab23cde90bb31c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(5).jpg\"></p>\n<h3 id=\"休息\"><a href=\"#休息\" class=\"headerlink\" title=\"休息\"></a>休息</h3><p>小休时间一般为3-5分钟，每隔4个番茄钟就大休一次，大休一般15-30分钟。注意休息期间要站起来走动一下，让自己能消除对上一个番茄钟的思考，完全抽身出来放松下。可以泡杯茶或咖啡，去个厕所，窗台发呆等，总之拒绝任何用脑的活动。<br>以下说明了休息时箭头所指从最佳到最差休息方式：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-32cc2cfdbfaad96f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(3).jpg\"></p>\n<h3 id=\"开始下一个番茄钟，重复3-5步\"><a href=\"#开始下一个番茄钟，重复3-5步\" class=\"headerlink\" title=\"开始下一个番茄钟，重复3-5步\"></a>开始下一个番茄钟，重复3-5步</h3><h3 id=\"下班前记录\"><a href=\"#下班前记录\" class=\"headerlink\" title=\"下班前记录\"></a>下班前记录</h3><p>记录什么内容？记录当天完成的番茄钟数、被打断数、今日待办完成数等，通过记录可以知晓自己承诺完成了多少，相差多少，如果差距很大，就要寻找原因。经过一段时间的记录，数据可视化，看自己的承诺和已完成是否越来越接近。通过记录发现总结不足，在以后的清单中持续改善。</p>\n<p>以上只介绍了番茄工作法流程和一些需要注意的点，其他一些边缘内容或者没有get到的点欢迎探讨。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天花了点时间把番茄工作法这本书看完了，和以前上学时45分钟每节课的感觉差不多，只是这个时间更短，流程也更细化，容易让人集中注意力。</p>\n<p>先来几个问题看看中刀的人有多少：<br>1.有拖延症，上午的工作要拖到下午，下午的工作要拖到明天或者有反正周六要加班，那就周五多玩玩，刷刷微博这样的思想。<br>2.经常我们想看一本书，看了一点后就厌烦抛诸脑后，等过一段时间兴致又来了想继续读，发现前面的内容已经忘了不得已要从头开始，如此往复，一年到头一本书还在原地徘徊，年终总结时才悔恨不已。<br>3.上班就开始干活，但是手头的事情刚干了一点，又一摊新的工作挤进来，然后倒手又去忙新的事情，经常下班了感觉忙了一天却没有一件拿得出手的已完成的活来交差。<br>如果你有上面的一种或者几种那么番茄工作法适合你。</p>\n<h2 id=\"番茄工作法的历史\"><a href=\"#番茄工作法的历史\" class=\"headerlink\" title=\"番茄工作法的历史\"></a>番茄工作法的历史</h2><p>番茄工作法是由弗朗西斯科·西里洛在1992年创建的，但其实在更早的时候西里洛就已经使用了。20世纪80年代西里洛还在大学时，由于学习效率低下作业完不成，就在想怎么让自己踏实的学一会，哪怕十分钟也行。如果有人监督帮忙掐表，会不会很好，后来西里洛找到了厨房定时器，形状酷似番茄，就这样他邂逅了番茄钟。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-be51678192608453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"未命名.png\"></p>\n<h2 id=\"什么是番茄工作法？\"><a href=\"#什么是番茄工作法？\" class=\"headerlink\" title=\"什么是番茄工作法？\"></a>什么是番茄工作法？</h2><p>简单的说就是列出要做的事，标记当天要完成的，设置闹钟为25分钟，然后从第一件事情开始做。还要有每日回顾、每日承诺、中断和预估等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">番茄工作法是一套简单的流程，它可以让我们提高时间观念、提升注意力、加强自我决策意识、改善目前不好的工作流程从而提高工作效率，当然这一切好处的前提是正确并长期的执行了番茄法。</div></pre></td></tr></table></figure>\n<h2 id=\"番茄工作法需要哪些工具？\"><a href=\"#番茄工作法需要哪些工具？\" class=\"headerlink\" title=\"番茄工作法需要哪些工具？\"></a>番茄工作法需要哪些工具？</h2><p>一个番茄钟<br>铅笔/橡皮<br>三张表格(活动清单、今日待办、记录)</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-3a5435880d169f91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender.jpg\"></p>\n<h2 id=\"番茄工作法流程详解\"><a href=\"#番茄工作法流程详解\" class=\"headerlink\" title=\"番茄工作法流程详解\"></a>番茄工作法流程详解</h2><h3 id=\"将近期要完成的活动-任务加入到活动清单\"><a href=\"#将近期要完成的活动-任务加入到活动清单\" class=\"headerlink\" title=\"将近期要完成的活动/任务加入到活动清单\"></a>将近期要完成的活动/任务加入到活动清单</h3><p>把近几天准备工作的内容填写到活动清单中，活动清单内容力求简洁，不要求别人看懂，只需要自己几个月后仍能看懂即可。<br>如果某件事明确了必须在某时间之前完成，则可以在活动末尾加上最后期限作为提醒。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-bcb5ae9b4fa83b5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(1).jpg\"></p>\n<h3 id=\"从活动清单中选择今日要完成的几项抄入到今日待办中\"><a href=\"#从活动清单中选择今日要完成的几项抄入到今日待办中\" class=\"headerlink\" title=\"从活动清单中选择今日要完成的几项抄入到今日待办中\"></a>从活动清单中选择今日要完成的几项抄入到今日待办中</h3><p>今日待办的任务一定是要从活动清单抄入过来的，如果是自己又单独创建的那活动清单有何意义？填写今日待办时要注意划分优先级(事情的重要程度)，然后给每个待办预估需要多少番茄钟来完成，在待办后面用方格表示出来。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6386cf28a2aa20ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(4).jpg\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">从开始的活动清单列举，到今日待办的筛选，有没有觉得原本杂乱无章的事情，现在有了头绪而且当天\b目标已经明确只需要放手去做了。无形中注意力已经转移到所选活动了。</div></pre></td></tr></table></figure>\n<h3 id=\"准备好工作后，启动番茄钟时间设定为25分钟。\"><a href=\"#准备好工作后，启动番茄钟时间设定为25分钟。\" class=\"headerlink\" title=\"准备好工作后，启动番茄钟时间设定为25分钟。\"></a>准备好工作后，启动番茄钟时间设定为25分钟。</h3><p>注意每个番茄钟都是原子性的，即不能再分割，一旦番茄钟启动，25分钟必须从一而终。<br>可能有人会有疑问：如果番茄钟期间渴了怎么办？有人打电话或者有同事来询问怎么办？别急，这些都是中断，参见步骤4。</p>\n<h3 id=\"开始工作，直到番茄钟响铃结束\"><a href=\"#开始工作，直到番茄钟响铃结束\" class=\"headerlink\" title=\"开始工作，直到番茄钟响铃结束\"></a>开始工作，直到番茄钟响铃结束</h3><p>工作期间可能会受到中断，在日常工作中，中断是不可完全避免的，需要自己处理好中断。<br>中断有两种形式：内部中断和外部中断。<br><figure class=\"highlight plain\"><figcaption><span>是自己造成的，是直觉向大脑发出信号，告诉我让我去专注当下活动以外的事情。```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">比如工作了一会，突然想打开qq去群里扯皮几句，想起有个电话没有回复，水杯没水了要去续杯等，这些都是来自自身内部的本能，其实是想拖延，这时该怎么办？接受、记录然后继续番茄钟。</div><div class=\"line\">首先看引起中断原因，如果是突然想起没有做的事情，那么可以在今日待办(如果想起的事情不紧急可以直接加入到活动清单中，并在左边加一个“U”表示计划外事件“unplanned”)下方添加一个“计划外紧急”栏目，记录中断原因(下图中的③)，并在今日待办的当前活动后面添加一个 撇号 &apos; (下图中的①)，表示当下活动产生一个内部中断，记录完成继续番茄钟。</div><div class=\"line\"> 至于说要聊天扯皮和续杯，等到番茄钟结束后再去，当然如果只是喝水那你想喝多少喝多少。</div><div class=\"line\">如果作为初学者感觉内部中断太多，可以尝试缩小番茄钟为5、10、15分钟。当然番茄钟的每次更改至少要保持两个星期再次更改。</div><div class=\"line\">```外部中断 是别人造成的，有人向你询问请你帮忙，等你答复，外部中断往往具有互动性。但是我们不能因为保护番茄钟就拒绝帮忙同事，毕竟低头不见抬头见的。</div></pre></td></tr></table></figure></p>\n<p>可以在番茄钟期间手机、邮件静音，<br>同事来面谈，如果比较急可以商量稍后推迟下，用下一个番茄钟来解决中断事件，而不是在当前活动直接中断处理；如果不着急可以添加到计划外事件，同时在当前活动后添加一个减号 -(下图中的②)，表示受到一次外部中断；如果非常着急，那么不得已只有废弃当前的番茄钟，先帮同事解决问题，过后休息一会然后开启新的番茄钟开始专注起来。</p>\n<p>每个番茄钟结束都要在今日待办的当下活动方格中画×。如果当下活动已经完成则可以给活动内容划一条横线表示完成状态(下图中的③)。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-4ab23cde90bb31c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(5).jpg\"></p>\n<h3 id=\"休息\"><a href=\"#休息\" class=\"headerlink\" title=\"休息\"></a>休息</h3><p>小休时间一般为3-5分钟，每隔4个番茄钟就大休一次，大休一般15-30分钟。注意休息期间要站起来走动一下，让自己能消除对上一个番茄钟的思考，完全抽身出来放松下。可以泡杯茶或咖啡，去个厕所，窗台发呆等，总之拒绝任何用脑的活动。<br>以下说明了休息时箭头所指从最佳到最差休息方式：<br><img src=\"http://upload-images.jianshu.io/upload_images/1796052-32cc2cfdbfaad96f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fullsizerender(3).jpg\"></p>\n<h3 id=\"开始下一个番茄钟，重复3-5步\"><a href=\"#开始下一个番茄钟，重复3-5步\" class=\"headerlink\" title=\"开始下一个番茄钟，重复3-5步\"></a>开始下一个番茄钟，重复3-5步</h3><h3 id=\"下班前记录\"><a href=\"#下班前记录\" class=\"headerlink\" title=\"下班前记录\"></a>下班前记录</h3><p>记录什么内容？记录当天完成的番茄钟数、被打断数、今日待办完成数等，通过记录可以知晓自己承诺完成了多少，相差多少，如果差距很大，就要寻找原因。经过一段时间的记录，数据可视化，看自己的承诺和已完成是否越来越接近。通过记录发现总结不足，在以后的清单中持续改善。</p>\n<p>以上只介绍了番茄工作法流程和一些需要注意的点，其他一些边缘内容或者没有get到的点欢迎探讨。</p>\n"},{"title":"字符串前的r和u","date":"2017-08-06T08:55:54.000Z","_content":"\n# 前言\n\n在看python代码时经常看到这样的代码\n\n```python\nprint(r\"aa\\nbb\")\nprint(u\"aa\\nbb\")\n```\n\n字符串使用时直接引用就好了，前面的r和u这两个前缀是什么鬼？有什么作用？\n\n纸上得来终觉浅，绝知此事要躬行。\n\n要了解r和u的作用还是实际操作来看看\n\n# 说明\n\n- r的作用\n\n  首先看看r的作用，执行如下代码看看结果：\n\n  ```python\n  print(\"aa\\nbb\")\n  print(r\"aa\\nbb\")\n  ```\n\n  打印结果是这样子：\n\n  ```\n  aa\n  bb\n  aa\\nbb\n  ```\n\n  第一个打印，**\\n**把字符串截开了，而第二个打印是全部打印。\n\n  在python中，**\\n**是换行符作用。所以第一个打印才是正常的。\n\n  第二个打印中的**r作用就是取消字符串中的转移字符的作用，让其老老实实作为一个普通字符串**。\n\n  接下来看看u的作用：\n\n- u的作用\n\n  u表示将后面跟的字符串以unicode格式存储，否则会使用源文件的默认编码格式来编码字符串","source":"_posts/字符串前的r和u.md","raw":"---\ntitle: 字符串前的r和u\ndate: 2017-08-06 16:55:54\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n在看python代码时经常看到这样的代码\n\n```python\nprint(r\"aa\\nbb\")\nprint(u\"aa\\nbb\")\n```\n\n字符串使用时直接引用就好了，前面的r和u这两个前缀是什么鬼？有什么作用？\n\n纸上得来终觉浅，绝知此事要躬行。\n\n要了解r和u的作用还是实际操作来看看\n\n# 说明\n\n- r的作用\n\n  首先看看r的作用，执行如下代码看看结果：\n\n  ```python\n  print(\"aa\\nbb\")\n  print(r\"aa\\nbb\")\n  ```\n\n  打印结果是这样子：\n\n  ```\n  aa\n  bb\n  aa\\nbb\n  ```\n\n  第一个打印，**\\n**把字符串截开了，而第二个打印是全部打印。\n\n  在python中，**\\n**是换行符作用。所以第一个打印才是正常的。\n\n  第二个打印中的**r作用就是取消字符串中的转移字符的作用，让其老老实实作为一个普通字符串**。\n\n  接下来看看u的作用：\n\n- u的作用\n\n  u表示将后面跟的字符串以unicode格式存储，否则会使用源文件的默认编码格式来编码字符串","slug":"字符串前的r和u","published":1,"updated":"2017-08-08T05:52:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjk5007wwh9cp6byqwdc","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在看python代码时经常看到这样的代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(<span class=\"string\">r\"aa\\nbb\"</span>)</div><div class=\"line\">print(<span class=\"string\">u\"aa\\nbb\"</span>)</div></pre></td></tr></table></figure>\n<p>字符串使用时直接引用就好了，前面的r和u这两个前缀是什么鬼？有什么作用？</p>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n<p>要了解r和u的作用还是实际操作来看看</p>\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><ul>\n<li><p>r的作用</p>\n<p>首先看看r的作用，执行如下代码看看结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(<span class=\"string\">\"aa\\nbb\"</span>)</div><div class=\"line\">print(<span class=\"string\">r\"aa\\nbb\"</span>)</div></pre></td></tr></table></figure>\n<p>打印结果是这样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aa</div><div class=\"line\">bb</div><div class=\"line\">aa\\nbb</div></pre></td></tr></table></figure>\n<p>第一个打印，<strong>\\n</strong>把字符串截开了，而第二个打印是全部打印。</p>\n<p>在python中，<strong>\\n</strong>是换行符作用。所以第一个打印才是正常的。</p>\n<p>第二个打印中的<strong>r作用就是取消字符串中的转移字符的作用，让其老老实实作为一个普通字符串</strong>。</p>\n<p>接下来看看u的作用：</p>\n</li>\n<li><p>u的作用</p>\n<p>u表示将后面跟的字符串以unicode格式存储，否则会使用源文件的默认编码格式来编码字符串</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在看python代码时经常看到这样的代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(<span class=\"string\">r\"aa\\nbb\"</span>)</div><div class=\"line\">print(<span class=\"string\">u\"aa\\nbb\"</span>)</div></pre></td></tr></table></figure>\n<p>字符串使用时直接引用就好了，前面的r和u这两个前缀是什么鬼？有什么作用？</p>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n<p>要了解r和u的作用还是实际操作来看看</p>\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><ul>\n<li><p>r的作用</p>\n<p>首先看看r的作用，执行如下代码看看结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">print(<span class=\"string\">\"aa\\nbb\"</span>)</div><div class=\"line\">print(<span class=\"string\">r\"aa\\nbb\"</span>)</div></pre></td></tr></table></figure>\n<p>打印结果是这样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">aa</div><div class=\"line\">bb</div><div class=\"line\">aa\\nbb</div></pre></td></tr></table></figure>\n<p>第一个打印，<strong>\\n</strong>把字符串截开了，而第二个打印是全部打印。</p>\n<p>在python中，<strong>\\n</strong>是换行符作用。所以第一个打印才是正常的。</p>\n<p>第二个打印中的<strong>r作用就是取消字符串中的转移字符的作用，让其老老实实作为一个普通字符串</strong>。</p>\n<p>接下来看看u的作用：</p>\n</li>\n<li><p>u的作用</p>\n<p>u表示将后面跟的字符串以unicode格式存储，否则会使用源文件的默认编码格式来编码字符串</p>\n</li>\n</ul>\n"},{"title":"数学归纳法","date":"2017-05-16T06:08:56.000Z","_content":"\n# 什么是数学归纳法\n\n数学归纳法就是证明一个命题在自然数范围内成立\n\n这里命题也可以当成是断言。\n\n比如断言自然数n，nx2为偶数。\n\n\n\n# 求储蓄罐里的钱\n\n有一个空储蓄罐，\n\n第一天，往里面存1元钱；\n\n第二天，往里面存2元钱；\n\n第三天，往里面存3元钱；\n\n第四天，往里面存4元钱；\n\n。\n\n。\n\n。\n\n每天都存钱，第一百天时储蓄罐里一共有多少钱？\n\n这个问题如何求解呢？其实最直接的方法就是从1开始加，一直加到100，但是这种暴力求解效率极差。\n\n 德国9岁孩子高斯也遇到了同样问题，但是他却马上得出了答案。\n\n他是这么考虑的：\n\n1+2+3…+100顺序计算结果和100+99+98...+1这样的逆序结果是一样的。\n\n这样的话，顺序的1+逆序的100，顺序的2+逆序的99，顺序的3+逆序的98，这样最后结果是100个101相加 = 100x101 = 10100 。因为逆序和顺序相等，所以这个和是2倍的顺序，所以顺序的和为10100/2 =5050。最终得出1加到100的和为5050。\n\n高斯据此得出以下公式：\n\n1+2+3…+100 = （100+1）x100/2；\n\n当然上面只是求1到100的和，那如果要求1到1000，到10000呢，公式是不是仍然成立？\n\n高斯断言：对于任意自然数n：1+2+3…+n = （n+1)xn/2都成立；\n\n接下来要证明高斯的断言是否成立。\n\n# 数学归纳法证明\n\n最简单的数学归纳法是证明当n等于任意一个自然数时断言成立，证明包括两步：\n\n1.证明n=1时，断言p(1)成立\n\n2.证明n=k为任何自然数时，若p(k)成立，则p(k+1)也成立。\n\n\n\n由此，关于高斯公式的证明如下：\n\n1.当n=1时， 1 = （1+1）x1/2 = 1，高斯公式成立；\n\n2.当n=k时，1+2+...+k = (k+1)xk/2 成立;\n\n3.当n=k+1时，证明1+2+...+k+(k+1) = ((k+1)+1)x(k+1)/2成立；\n\n因为2成立，所以3中公式代入后：\n\n (k+1)xk/2+（k+1） = ((k+1)+1)x(k+1)/2\n\n（k+1）x（k+2）/2 =  （k+1）x（k+2）/2 \n\n左右两边相等，\n\n得出结论：对于自然数n，断言p(n)都成立。\n\n\n\n# 为什么数学归纳法只证明两步就成立了\n\n\n\n1.证明断言p(1)成立，也就是n=1成立；\n\n2.通过p(m)成立推导出p(m+1)也成立。\n\n3.根据上面结论，p(1+1)也就是p(2)成立；\n\n4.p(2+1)也就是p(3)成立；\n\n5.p(3+1)也就是p(4)成立；\n\n6.循环推导，最终推导出值为n时p(n)成立。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/数学归纳法.md","raw":"---\ntitle: 数学归纳法\ndate: 2017-05-16 14:08:56\ntags: 程序员的数学\ncategories: 程序员的数学\n---\n\n# 什么是数学归纳法\n\n数学归纳法就是证明一个命题在自然数范围内成立\n\n这里命题也可以当成是断言。\n\n比如断言自然数n，nx2为偶数。\n\n\n\n# 求储蓄罐里的钱\n\n有一个空储蓄罐，\n\n第一天，往里面存1元钱；\n\n第二天，往里面存2元钱；\n\n第三天，往里面存3元钱；\n\n第四天，往里面存4元钱；\n\n。\n\n。\n\n。\n\n每天都存钱，第一百天时储蓄罐里一共有多少钱？\n\n这个问题如何求解呢？其实最直接的方法就是从1开始加，一直加到100，但是这种暴力求解效率极差。\n\n 德国9岁孩子高斯也遇到了同样问题，但是他却马上得出了答案。\n\n他是这么考虑的：\n\n1+2+3…+100顺序计算结果和100+99+98...+1这样的逆序结果是一样的。\n\n这样的话，顺序的1+逆序的100，顺序的2+逆序的99，顺序的3+逆序的98，这样最后结果是100个101相加 = 100x101 = 10100 。因为逆序和顺序相等，所以这个和是2倍的顺序，所以顺序的和为10100/2 =5050。最终得出1加到100的和为5050。\n\n高斯据此得出以下公式：\n\n1+2+3…+100 = （100+1）x100/2；\n\n当然上面只是求1到100的和，那如果要求1到1000，到10000呢，公式是不是仍然成立？\n\n高斯断言：对于任意自然数n：1+2+3…+n = （n+1)xn/2都成立；\n\n接下来要证明高斯的断言是否成立。\n\n# 数学归纳法证明\n\n最简单的数学归纳法是证明当n等于任意一个自然数时断言成立，证明包括两步：\n\n1.证明n=1时，断言p(1)成立\n\n2.证明n=k为任何自然数时，若p(k)成立，则p(k+1)也成立。\n\n\n\n由此，关于高斯公式的证明如下：\n\n1.当n=1时， 1 = （1+1）x1/2 = 1，高斯公式成立；\n\n2.当n=k时，1+2+...+k = (k+1)xk/2 成立;\n\n3.当n=k+1时，证明1+2+...+k+(k+1) = ((k+1)+1)x(k+1)/2成立；\n\n因为2成立，所以3中公式代入后：\n\n (k+1)xk/2+（k+1） = ((k+1)+1)x(k+1)/2\n\n（k+1）x（k+2）/2 =  （k+1）x（k+2）/2 \n\n左右两边相等，\n\n得出结论：对于自然数n，断言p(n)都成立。\n\n\n\n# 为什么数学归纳法只证明两步就成立了\n\n\n\n1.证明断言p(1)成立，也就是n=1成立；\n\n2.通过p(m)成立推导出p(m+1)也成立。\n\n3.根据上面结论，p(1+1)也就是p(2)成立；\n\n4.p(2+1)也就是p(3)成立；\n\n5.p(3+1)也就是p(4)成立；\n\n6.循环推导，最终推导出值为n时p(n)成立。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"数学归纳法","published":1,"updated":"2017-05-17T03:38:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjk7007zwh9c7kd9mys7","content":"<h1 id=\"什么是数学归纳法\"><a href=\"#什么是数学归纳法\" class=\"headerlink\" title=\"什么是数学归纳法\"></a>什么是数学归纳法</h1><p>数学归纳法就是证明一个命题在自然数范围内成立</p>\n<p>这里命题也可以当成是断言。</p>\n<p>比如断言自然数n，nx2为偶数。</p>\n<h1 id=\"求储蓄罐里的钱\"><a href=\"#求储蓄罐里的钱\" class=\"headerlink\" title=\"求储蓄罐里的钱\"></a>求储蓄罐里的钱</h1><p>有一个空储蓄罐，</p>\n<p>第一天，往里面存1元钱；</p>\n<p>第二天，往里面存2元钱；</p>\n<p>第三天，往里面存3元钱；</p>\n<p>第四天，往里面存4元钱；</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>每天都存钱，第一百天时储蓄罐里一共有多少钱？</p>\n<p>这个问题如何求解呢？其实最直接的方法就是从1开始加，一直加到100，但是这种暴力求解效率极差。</p>\n<p> 德国9岁孩子高斯也遇到了同样问题，但是他却马上得出了答案。</p>\n<p>他是这么考虑的：</p>\n<p>1+2+3…+100顺序计算结果和100+99+98…+1这样的逆序结果是一样的。</p>\n<p>这样的话，顺序的1+逆序的100，顺序的2+逆序的99，顺序的3+逆序的98，这样最后结果是100个101相加 = 100x101 = 10100 。因为逆序和顺序相等，所以这个和是2倍的顺序，所以顺序的和为10100/2 =5050。最终得出1加到100的和为5050。</p>\n<p>高斯据此得出以下公式：</p>\n<p>1+2+3…+100 = （100+1）x100/2；</p>\n<p>当然上面只是求1到100的和，那如果要求1到1000，到10000呢，公式是不是仍然成立？</p>\n<p>高斯断言：对于任意自然数n：1+2+3…+n = （n+1)xn/2都成立；</p>\n<p>接下来要证明高斯的断言是否成立。</p>\n<h1 id=\"数学归纳法证明\"><a href=\"#数学归纳法证明\" class=\"headerlink\" title=\"数学归纳法证明\"></a>数学归纳法证明</h1><p>最简单的数学归纳法是证明当n等于任意一个自然数时断言成立，证明包括两步：</p>\n<p>1.证明n=1时，断言p(1)成立</p>\n<p>2.证明n=k为任何自然数时，若p(k)成立，则p(k+1)也成立。</p>\n<p>由此，关于高斯公式的证明如下：</p>\n<p>1.当n=1时， 1 = （1+1）x1/2 = 1，高斯公式成立；</p>\n<p>2.当n=k时，1+2+…+k = (k+1)xk/2 成立;</p>\n<p>3.当n=k+1时，证明1+2+…+k+(k+1) = ((k+1)+1)x(k+1)/2成立；</p>\n<p>因为2成立，所以3中公式代入后：</p>\n<p> (k+1)xk/2+（k+1） = ((k+1)+1)x(k+1)/2</p>\n<p>（k+1）x（k+2）/2 =  （k+1）x（k+2）/2 </p>\n<p>左右两边相等，</p>\n<p>得出结论：对于自然数n，断言p(n)都成立。</p>\n<h1 id=\"为什么数学归纳法只证明两步就成立了\"><a href=\"#为什么数学归纳法只证明两步就成立了\" class=\"headerlink\" title=\"为什么数学归纳法只证明两步就成立了\"></a>为什么数学归纳法只证明两步就成立了</h1><p>1.证明断言p(1)成立，也就是n=1成立；</p>\n<p>2.通过p(m)成立推导出p(m+1)也成立。</p>\n<p>3.根据上面结论，p(1+1)也就是p(2)成立；</p>\n<p>4.p(2+1)也就是p(3)成立；</p>\n<p>5.p(3+1)也就是p(4)成立；</p>\n<p>6.循环推导，最终推导出值为n时p(n)成立。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是数学归纳法\"><a href=\"#什么是数学归纳法\" class=\"headerlink\" title=\"什么是数学归纳法\"></a>什么是数学归纳法</h1><p>数学归纳法就是证明一个命题在自然数范围内成立</p>\n<p>这里命题也可以当成是断言。</p>\n<p>比如断言自然数n，nx2为偶数。</p>\n<h1 id=\"求储蓄罐里的钱\"><a href=\"#求储蓄罐里的钱\" class=\"headerlink\" title=\"求储蓄罐里的钱\"></a>求储蓄罐里的钱</h1><p>有一个空储蓄罐，</p>\n<p>第一天，往里面存1元钱；</p>\n<p>第二天，往里面存2元钱；</p>\n<p>第三天，往里面存3元钱；</p>\n<p>第四天，往里面存4元钱；</p>\n<p>。</p>\n<p>。</p>\n<p>。</p>\n<p>每天都存钱，第一百天时储蓄罐里一共有多少钱？</p>\n<p>这个问题如何求解呢？其实最直接的方法就是从1开始加，一直加到100，但是这种暴力求解效率极差。</p>\n<p> 德国9岁孩子高斯也遇到了同样问题，但是他却马上得出了答案。</p>\n<p>他是这么考虑的：</p>\n<p>1+2+3…+100顺序计算结果和100+99+98…+1这样的逆序结果是一样的。</p>\n<p>这样的话，顺序的1+逆序的100，顺序的2+逆序的99，顺序的3+逆序的98，这样最后结果是100个101相加 = 100x101 = 10100 。因为逆序和顺序相等，所以这个和是2倍的顺序，所以顺序的和为10100/2 =5050。最终得出1加到100的和为5050。</p>\n<p>高斯据此得出以下公式：</p>\n<p>1+2+3…+100 = （100+1）x100/2；</p>\n<p>当然上面只是求1到100的和，那如果要求1到1000，到10000呢，公式是不是仍然成立？</p>\n<p>高斯断言：对于任意自然数n：1+2+3…+n = （n+1)xn/2都成立；</p>\n<p>接下来要证明高斯的断言是否成立。</p>\n<h1 id=\"数学归纳法证明\"><a href=\"#数学归纳法证明\" class=\"headerlink\" title=\"数学归纳法证明\"></a>数学归纳法证明</h1><p>最简单的数学归纳法是证明当n等于任意一个自然数时断言成立，证明包括两步：</p>\n<p>1.证明n=1时，断言p(1)成立</p>\n<p>2.证明n=k为任何自然数时，若p(k)成立，则p(k+1)也成立。</p>\n<p>由此，关于高斯公式的证明如下：</p>\n<p>1.当n=1时， 1 = （1+1）x1/2 = 1，高斯公式成立；</p>\n<p>2.当n=k时，1+2+…+k = (k+1)xk/2 成立;</p>\n<p>3.当n=k+1时，证明1+2+…+k+(k+1) = ((k+1)+1)x(k+1)/2成立；</p>\n<p>因为2成立，所以3中公式代入后：</p>\n<p> (k+1)xk/2+（k+1） = ((k+1)+1)x(k+1)/2</p>\n<p>（k+1）x（k+2）/2 =  （k+1）x（k+2）/2 </p>\n<p>左右两边相等，</p>\n<p>得出结论：对于自然数n，断言p(n)都成立。</p>\n<h1 id=\"为什么数学归纳法只证明两步就成立了\"><a href=\"#为什么数学归纳法只证明两步就成立了\" class=\"headerlink\" title=\"为什么数学归纳法只证明两步就成立了\"></a>为什么数学归纳法只证明两步就成立了</h1><p>1.证明断言p(1)成立，也就是n=1成立；</p>\n<p>2.通过p(m)成立推导出p(m+1)也成立。</p>\n<p>3.根据上面结论，p(1+1)也就是p(2)成立；</p>\n<p>4.p(2+1)也就是p(3)成立；</p>\n<p>5.p(3+1)也就是p(4)成立；</p>\n<p>6.循环推导，最终推导出值为n时p(n)成立。</p>\n"},{"title":"用Python提取excel中有用数据","date":"2017-07-21T02:06:40.000Z","_content":"\n# 0x00 前言\n\n前些天有人给了我两个书单列表，都是excel样式的，每个excel中有大概三千个书名的样子。如果让我找我需要的相关书籍，这是一个不小的工作量。既然才学过Python，就萌生了使用Python提取自己感兴趣的书籍的想法。\n\n# 0x01 第三方模块引入 \n\n在Python中\n\n```python\n# 针对 07版excel（xlsx结尾的）,我们可以使用openpyxl来操作读写excel\n# 针对 03版excel（xls结尾的），我们可以使用xlrd读，xlwt包来写\n# 针对 doc文档，我们可以使用docx操作\n```\n\n知道需要哪些模块了，接下来就是安装所需模块。\n\n网上很多都是先下载包，解压后本地执行`python setup.py install`。这显得很麻烦，我直接使用pip命令进行安装了。终端执行`pip install xlrd`，同样使用该方式安装其他所需库即可。\n\n> 无须下载，简单快捷。\n\n# 0x02 开始编程\n\n## 创建项目并把excel拷贝到项目根目录\n\n![创建项目](用Python提取excel中有用数据/创建项目.png)\n\n## 导入刚才安装的模块\n\n```python\nimport xlrd\nimport threading\nimport docx\n```\n\n`threading`是Python自带的线程模块\n\n## 读取excel\n\n```python\ndef read_xls(path, find='', row=-1, col=-1):\n    \"\"\"接收xls文件并读取指定内容返回\n    *path* 接收xls路径\n    *find* 要查找的内容，为列表格式\n    *row* 行数，-1说明没有指定，查找所有行\n    *col* 列数，-1说明没有指定，查找所有列\n    \"\"\"\n    xls = xlrd.open_workbook(path)\n    names = xls.sheet_names()\n    print(names)\n    sheet = xls.sheet_by_name(names[0])\n    row = int(row)\n    col = int(col)\n    python_books = []\n    for i in range(0, sheet.nrows):\n        if -1 != row:  # 指定行\n            if -1 != col:  # 指定列\n                if row == i:\n                    for j in sheet.ncols:\n                        if j == col:\n                            text = sheet.cell_value(i, j)\n            else:  # 没指定列\n                if row == i:\n                    text = sheet.row_values(i)\n        else:  # 没指定行\n            if -1 != col:  # 指定列\n                text = sheet.cell_value(i, col)\n            else:  # 没指定列\n                text = sheet.cell_value(i, 4)\n        if find != \"\":\n            for content in find:\n                if content in text:\n                    print(text + '\\n')\n                    python_books.append(text)\n\n        else:\n            print(text + '\\n')\n    return python_books\n```\n\n虽然只是个简单的数据提取，但是为了提高程序灵活性，文件路径、行列及搜索值仍然通过传参方式。\n\n`read_xls`实现了读取excel中指定的相关内容到列表，下面要实现存储内容到doc文档。\n\n## 保存内容到doc文档\n\n```python\ndef save_doc(name, contents, create_new=False):\n    \"\"\"\n    *param name* doc文档名称\n    *param contents* 文档内容，为列表格式\n    *return*\n    \"\"\"\n    if create_new:\n        doc = docx.Document()\n    else:\n        doc = docx.Document(name)\n    for pb in contents:\n        doc.add_paragraph(pb)\n    if create_new:\n        doc.save(name + '.docx')\n    else:\n        doc.save(name)\n```\n\n该方法实现的是，如果create_new为true则直接创建一个doc文档存储内容，并将文档命名为name。如果为false则直接打开一个名称为name的文档进行存储。\n\n因为这些都是IO操作，应该在工作线程执行。但是这是两个独立的方法，所以还需进行一次包装。\n\n## 2个方法封装\n\n```python\ndef wrapper(path, find, row, col):\n    \"\"\"包装类，封装读取xls文件方法和保存到doc文档方法\n    *param path*\n    *param find*\n    *param row*\n    *param col*\n    *return*\n    \"\"\"\n    python_books = read_xls(path, find, row, col)\n    save_doc(name=path, contents=python_books, create_new=True)\n```\n\n\n\n## 开启2个工作线程读取并存储内容\n\n```python\nfind = ['python', 'PYTHON', 'Python']\nthread1 = threading.Thread(target=wrapper,\n                           kwargs={'find': find, 'path': 'ebook1.xls', 'col': '4', 'row': '-1'})\nthread1.start()\n\nthread2 = threading.Thread(target=wrapper,\n                           kwargs={'find': find, 'path': 'ebook2.xls', 'col': '4', 'row': '-1'})\nthread2.start()\n```\n\n## 查看结果\n\n执行后会在项目根目录生成2个对应的doc文档：\n\n![项目结果](用Python提取excel中有用数据/项目结果.png)\n\n打开doc文档看看具体内容吧：\n\n![doc文档内容](用Python提取excel中有用数据/doc文档内容.png)\n\n","source":"_posts/用Python提取excel中有用数据.md","raw":"---\ntitle: 用Python提取excel中有用数据\ndate: 2017-07-21 10:06:40\ntags: [Python, excel, xlrd ]\ncategories: [Python, excel, xlrd ]\n---\n\n# 0x00 前言\n\n前些天有人给了我两个书单列表，都是excel样式的，每个excel中有大概三千个书名的样子。如果让我找我需要的相关书籍，这是一个不小的工作量。既然才学过Python，就萌生了使用Python提取自己感兴趣的书籍的想法。\n\n# 0x01 第三方模块引入 \n\n在Python中\n\n```python\n# 针对 07版excel（xlsx结尾的）,我们可以使用openpyxl来操作读写excel\n# 针对 03版excel（xls结尾的），我们可以使用xlrd读，xlwt包来写\n# 针对 doc文档，我们可以使用docx操作\n```\n\n知道需要哪些模块了，接下来就是安装所需模块。\n\n网上很多都是先下载包，解压后本地执行`python setup.py install`。这显得很麻烦，我直接使用pip命令进行安装了。终端执行`pip install xlrd`，同样使用该方式安装其他所需库即可。\n\n> 无须下载，简单快捷。\n\n# 0x02 开始编程\n\n## 创建项目并把excel拷贝到项目根目录\n\n![创建项目](用Python提取excel中有用数据/创建项目.png)\n\n## 导入刚才安装的模块\n\n```python\nimport xlrd\nimport threading\nimport docx\n```\n\n`threading`是Python自带的线程模块\n\n## 读取excel\n\n```python\ndef read_xls(path, find='', row=-1, col=-1):\n    \"\"\"接收xls文件并读取指定内容返回\n    *path* 接收xls路径\n    *find* 要查找的内容，为列表格式\n    *row* 行数，-1说明没有指定，查找所有行\n    *col* 列数，-1说明没有指定，查找所有列\n    \"\"\"\n    xls = xlrd.open_workbook(path)\n    names = xls.sheet_names()\n    print(names)\n    sheet = xls.sheet_by_name(names[0])\n    row = int(row)\n    col = int(col)\n    python_books = []\n    for i in range(0, sheet.nrows):\n        if -1 != row:  # 指定行\n            if -1 != col:  # 指定列\n                if row == i:\n                    for j in sheet.ncols:\n                        if j == col:\n                            text = sheet.cell_value(i, j)\n            else:  # 没指定列\n                if row == i:\n                    text = sheet.row_values(i)\n        else:  # 没指定行\n            if -1 != col:  # 指定列\n                text = sheet.cell_value(i, col)\n            else:  # 没指定列\n                text = sheet.cell_value(i, 4)\n        if find != \"\":\n            for content in find:\n                if content in text:\n                    print(text + '\\n')\n                    python_books.append(text)\n\n        else:\n            print(text + '\\n')\n    return python_books\n```\n\n虽然只是个简单的数据提取，但是为了提高程序灵活性，文件路径、行列及搜索值仍然通过传参方式。\n\n`read_xls`实现了读取excel中指定的相关内容到列表，下面要实现存储内容到doc文档。\n\n## 保存内容到doc文档\n\n```python\ndef save_doc(name, contents, create_new=False):\n    \"\"\"\n    *param name* doc文档名称\n    *param contents* 文档内容，为列表格式\n    *return*\n    \"\"\"\n    if create_new:\n        doc = docx.Document()\n    else:\n        doc = docx.Document(name)\n    for pb in contents:\n        doc.add_paragraph(pb)\n    if create_new:\n        doc.save(name + '.docx')\n    else:\n        doc.save(name)\n```\n\n该方法实现的是，如果create_new为true则直接创建一个doc文档存储内容，并将文档命名为name。如果为false则直接打开一个名称为name的文档进行存储。\n\n因为这些都是IO操作，应该在工作线程执行。但是这是两个独立的方法，所以还需进行一次包装。\n\n## 2个方法封装\n\n```python\ndef wrapper(path, find, row, col):\n    \"\"\"包装类，封装读取xls文件方法和保存到doc文档方法\n    *param path*\n    *param find*\n    *param row*\n    *param col*\n    *return*\n    \"\"\"\n    python_books = read_xls(path, find, row, col)\n    save_doc(name=path, contents=python_books, create_new=True)\n```\n\n\n\n## 开启2个工作线程读取并存储内容\n\n```python\nfind = ['python', 'PYTHON', 'Python']\nthread1 = threading.Thread(target=wrapper,\n                           kwargs={'find': find, 'path': 'ebook1.xls', 'col': '4', 'row': '-1'})\nthread1.start()\n\nthread2 = threading.Thread(target=wrapper,\n                           kwargs={'find': find, 'path': 'ebook2.xls', 'col': '4', 'row': '-1'})\nthread2.start()\n```\n\n## 查看结果\n\n执行后会在项目根目录生成2个对应的doc文档：\n\n![项目结果](用Python提取excel中有用数据/项目结果.png)\n\n打开doc文档看看具体内容吧：\n\n![doc文档内容](用Python提取excel中有用数据/doc文档内容.png)\n\n","slug":"用Python提取excel中有用数据","published":1,"updated":"2017-07-21T03:08:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjka0083wh9cj7w31vxm","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>前些天有人给了我两个书单列表，都是excel样式的，每个excel中有大概三千个书名的样子。如果让我找我需要的相关书籍，这是一个不小的工作量。既然才学过Python，就萌生了使用Python提取自己感兴趣的书籍的想法。</p>\n<h1 id=\"0x01-第三方模块引入\"><a href=\"#0x01-第三方模块引入\" class=\"headerlink\" title=\"0x01 第三方模块引入\"></a>0x01 第三方模块引入</h1><p>在Python中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 针对 07版excel（xlsx结尾的）,我们可以使用openpyxl来操作读写excel</span></div><div class=\"line\"><span class=\"comment\"># 针对 03版excel（xls结尾的），我们可以使用xlrd读，xlwt包来写</span></div><div class=\"line\"><span class=\"comment\"># 针对 doc文档，我们可以使用docx操作</span></div></pre></td></tr></table></figure>\n<p>知道需要哪些模块了，接下来就是安装所需模块。</p>\n<p>网上很多都是先下载包，解压后本地执行<code>python setup.py install</code>。这显得很麻烦，我直接使用pip命令进行安装了。终端执行<code>pip install xlrd</code>，同样使用该方式安装其他所需库即可。</p>\n<blockquote>\n<p>无须下载，简单快捷。</p>\n</blockquote>\n<h1 id=\"0x02-开始编程\"><a href=\"#0x02-开始编程\" class=\"headerlink\" title=\"0x02 开始编程\"></a>0x02 开始编程</h1><h2 id=\"创建项目并把excel拷贝到项目根目录\"><a href=\"#创建项目并把excel拷贝到项目根目录\" class=\"headerlink\" title=\"创建项目并把excel拷贝到项目根目录\"></a>创建项目并把excel拷贝到项目根目录</h2><p><img src=\"/2017/07/21/用Python提取excel中有用数据/创建项目.png\" alt=\"创建项目\"></p>\n<h2 id=\"导入刚才安装的模块\"><a href=\"#导入刚才安装的模块\" class=\"headerlink\" title=\"导入刚才安装的模块\"></a>导入刚才安装的模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> xlrd</div><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"><span class=\"keyword\">import</span> docx</div></pre></td></tr></table></figure>\n<p><code>threading</code>是Python自带的线程模块</p>\n<h2 id=\"读取excel\"><a href=\"#读取excel\" class=\"headerlink\" title=\"读取excel\"></a>读取excel</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_xls</span><span class=\"params\">(path, find=<span class=\"string\">''</span>, row=<span class=\"number\">-1</span>, col=<span class=\"number\">-1</span>)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"接收xls文件并读取指定内容返回</span></div><div class=\"line\">    *path* 接收xls路径</div><div class=\"line\">    *find* 要查找的内容，为列表格式</div><div class=\"line\">    *row* 行数，-1说明没有指定，查找所有行</div><div class=\"line\">    *col* 列数，-1说明没有指定，查找所有列</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    xls = xlrd.open_workbook(path)</div><div class=\"line\">    names = xls.sheet_names()</div><div class=\"line\">    print(names)</div><div class=\"line\">    sheet = xls.sheet_by_name(names[<span class=\"number\">0</span>])</div><div class=\"line\">    row = int(row)</div><div class=\"line\">    col = int(col)</div><div class=\"line\">    python_books = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, sheet.nrows):</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">-1</span> != row:  <span class=\"comment\"># 指定行</span></div><div class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">-1</span> != col:  <span class=\"comment\"># 指定列</span></div><div class=\"line\">                <span class=\"keyword\">if</span> row == i:</div><div class=\"line\">                    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> sheet.ncols:</div><div class=\"line\">                        <span class=\"keyword\">if</span> j == col:</div><div class=\"line\">                            text = sheet.cell_value(i, j)</div><div class=\"line\">            <span class=\"keyword\">else</span>:  <span class=\"comment\"># 没指定列</span></div><div class=\"line\">                <span class=\"keyword\">if</span> row == i:</div><div class=\"line\">                    text = sheet.row_values(i)</div><div class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 没指定行</span></div><div class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">-1</span> != col:  <span class=\"comment\"># 指定列</span></div><div class=\"line\">                text = sheet.cell_value(i, col)</div><div class=\"line\">            <span class=\"keyword\">else</span>:  <span class=\"comment\"># 没指定列</span></div><div class=\"line\">                text = sheet.cell_value(i, <span class=\"number\">4</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> find != <span class=\"string\">\"\"</span>:</div><div class=\"line\">            <span class=\"keyword\">for</span> content <span class=\"keyword\">in</span> find:</div><div class=\"line\">                <span class=\"keyword\">if</span> content <span class=\"keyword\">in</span> text:</div><div class=\"line\">                    print(text + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">                    python_books.append(text)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            print(text + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> python_books</div></pre></td></tr></table></figure>\n<p>虽然只是个简单的数据提取，但是为了提高程序灵活性，文件路径、行列及搜索值仍然通过传参方式。</p>\n<p><code>read_xls</code>实现了读取excel中指定的相关内容到列表，下面要实现存储内容到doc文档。</p>\n<h2 id=\"保存内容到doc文档\"><a href=\"#保存内容到doc文档\" class=\"headerlink\" title=\"保存内容到doc文档\"></a>保存内容到doc文档</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_doc</span><span class=\"params\">(name, contents, create_new=False)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    *param name* doc文档名称</div><div class=\"line\">    *param contents* 文档内容，为列表格式</div><div class=\"line\">    *return*</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> create_new:</div><div class=\"line\">        doc = docx.Document()</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        doc = docx.Document(name)</div><div class=\"line\">    <span class=\"keyword\">for</span> pb <span class=\"keyword\">in</span> contents:</div><div class=\"line\">        doc.add_paragraph(pb)</div><div class=\"line\">    <span class=\"keyword\">if</span> create_new:</div><div class=\"line\">        doc.save(name + <span class=\"string\">'.docx'</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        doc.save(name)</div></pre></td></tr></table></figure>\n<p>该方法实现的是，如果create_new为true则直接创建一个doc文档存储内容，并将文档命名为name。如果为false则直接打开一个名称为name的文档进行存储。</p>\n<p>因为这些都是IO操作，应该在工作线程执行。但是这是两个独立的方法，所以还需进行一次包装。</p>\n<h2 id=\"2个方法封装\"><a href=\"#2个方法封装\" class=\"headerlink\" title=\"2个方法封装\"></a>2个方法封装</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(path, find, row, col)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"包装类，封装读取xls文件方法和保存到doc文档方法</span></div><div class=\"line\">    *param path*</div><div class=\"line\">    *param find*</div><div class=\"line\">    *param row*</div><div class=\"line\">    *param col*</div><div class=\"line\">    *return*</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    python_books = read_xls(path, find, row, col)</div><div class=\"line\">    save_doc(name=path, contents=python_books, create_new=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"开启2个工作线程读取并存储内容\"><a href=\"#开启2个工作线程读取并存储内容\" class=\"headerlink\" title=\"开启2个工作线程读取并存储内容\"></a>开启2个工作线程读取并存储内容</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">find = [<span class=\"string\">'python'</span>, <span class=\"string\">'PYTHON'</span>, <span class=\"string\">'Python'</span>]</div><div class=\"line\">thread1 = threading.Thread(target=wrapper,</div><div class=\"line\">                           kwargs=&#123;<span class=\"string\">'find'</span>: find, <span class=\"string\">'path'</span>: <span class=\"string\">'ebook1.xls'</span>, <span class=\"string\">'col'</span>: <span class=\"string\">'4'</span>, <span class=\"string\">'row'</span>: <span class=\"string\">'-1'</span>&#125;)</div><div class=\"line\">thread1.start()</div><div class=\"line\"></div><div class=\"line\">thread2 = threading.Thread(target=wrapper,</div><div class=\"line\">                           kwargs=&#123;<span class=\"string\">'find'</span>: find, <span class=\"string\">'path'</span>: <span class=\"string\">'ebook2.xls'</span>, <span class=\"string\">'col'</span>: <span class=\"string\">'4'</span>, <span class=\"string\">'row'</span>: <span class=\"string\">'-1'</span>&#125;)</div><div class=\"line\">thread2.start()</div></pre></td></tr></table></figure>\n<h2 id=\"查看结果\"><a href=\"#查看结果\" class=\"headerlink\" title=\"查看结果\"></a>查看结果</h2><p>执行后会在项目根目录生成2个对应的doc文档：</p>\n<p><img src=\"/2017/07/21/用Python提取excel中有用数据/项目结果.png\" alt=\"项目结果\"></p>\n<p>打开doc文档看看具体内容吧：</p>\n<p><img src=\"/2017/07/21/用Python提取excel中有用数据/doc文档内容.png\" alt=\"doc文档内容\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>前些天有人给了我两个书单列表，都是excel样式的，每个excel中有大概三千个书名的样子。如果让我找我需要的相关书籍，这是一个不小的工作量。既然才学过Python，就萌生了使用Python提取自己感兴趣的书籍的想法。</p>\n<h1 id=\"0x01-第三方模块引入\"><a href=\"#0x01-第三方模块引入\" class=\"headerlink\" title=\"0x01 第三方模块引入\"></a>0x01 第三方模块引入</h1><p>在Python中</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 针对 07版excel（xlsx结尾的）,我们可以使用openpyxl来操作读写excel</span></div><div class=\"line\"><span class=\"comment\"># 针对 03版excel（xls结尾的），我们可以使用xlrd读，xlwt包来写</span></div><div class=\"line\"><span class=\"comment\"># 针对 doc文档，我们可以使用docx操作</span></div></pre></td></tr></table></figure>\n<p>知道需要哪些模块了，接下来就是安装所需模块。</p>\n<p>网上很多都是先下载包，解压后本地执行<code>python setup.py install</code>。这显得很麻烦，我直接使用pip命令进行安装了。终端执行<code>pip install xlrd</code>，同样使用该方式安装其他所需库即可。</p>\n<blockquote>\n<p>无须下载，简单快捷。</p>\n</blockquote>\n<h1 id=\"0x02-开始编程\"><a href=\"#0x02-开始编程\" class=\"headerlink\" title=\"0x02 开始编程\"></a>0x02 开始编程</h1><h2 id=\"创建项目并把excel拷贝到项目根目录\"><a href=\"#创建项目并把excel拷贝到项目根目录\" class=\"headerlink\" title=\"创建项目并把excel拷贝到项目根目录\"></a>创建项目并把excel拷贝到项目根目录</h2><p><img src=\"/2017/07/21/用Python提取excel中有用数据/创建项目.png\" alt=\"创建项目\"></p>\n<h2 id=\"导入刚才安装的模块\"><a href=\"#导入刚才安装的模块\" class=\"headerlink\" title=\"导入刚才安装的模块\"></a>导入刚才安装的模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> xlrd</div><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"><span class=\"keyword\">import</span> docx</div></pre></td></tr></table></figure>\n<p><code>threading</code>是Python自带的线程模块</p>\n<h2 id=\"读取excel\"><a href=\"#读取excel\" class=\"headerlink\" title=\"读取excel\"></a>读取excel</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">read_xls</span><span class=\"params\">(path, find=<span class=\"string\">''</span>, row=<span class=\"number\">-1</span>, col=<span class=\"number\">-1</span>)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"接收xls文件并读取指定内容返回</span></div><div class=\"line\">    *path* 接收xls路径</div><div class=\"line\">    *find* 要查找的内容，为列表格式</div><div class=\"line\">    *row* 行数，-1说明没有指定，查找所有行</div><div class=\"line\">    *col* 列数，-1说明没有指定，查找所有列</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    xls = xlrd.open_workbook(path)</div><div class=\"line\">    names = xls.sheet_names()</div><div class=\"line\">    print(names)</div><div class=\"line\">    sheet = xls.sheet_by_name(names[<span class=\"number\">0</span>])</div><div class=\"line\">    row = int(row)</div><div class=\"line\">    col = int(col)</div><div class=\"line\">    python_books = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, sheet.nrows):</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">-1</span> != row:  <span class=\"comment\"># 指定行</span></div><div class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">-1</span> != col:  <span class=\"comment\"># 指定列</span></div><div class=\"line\">                <span class=\"keyword\">if</span> row == i:</div><div class=\"line\">                    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> sheet.ncols:</div><div class=\"line\">                        <span class=\"keyword\">if</span> j == col:</div><div class=\"line\">                            text = sheet.cell_value(i, j)</div><div class=\"line\">            <span class=\"keyword\">else</span>:  <span class=\"comment\"># 没指定列</span></div><div class=\"line\">                <span class=\"keyword\">if</span> row == i:</div><div class=\"line\">                    text = sheet.row_values(i)</div><div class=\"line\">        <span class=\"keyword\">else</span>:  <span class=\"comment\"># 没指定行</span></div><div class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">-1</span> != col:  <span class=\"comment\"># 指定列</span></div><div class=\"line\">                text = sheet.cell_value(i, col)</div><div class=\"line\">            <span class=\"keyword\">else</span>:  <span class=\"comment\"># 没指定列</span></div><div class=\"line\">                text = sheet.cell_value(i, <span class=\"number\">4</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> find != <span class=\"string\">\"\"</span>:</div><div class=\"line\">            <span class=\"keyword\">for</span> content <span class=\"keyword\">in</span> find:</div><div class=\"line\">                <span class=\"keyword\">if</span> content <span class=\"keyword\">in</span> text:</div><div class=\"line\">                    print(text + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">                    python_books.append(text)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            print(text + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> python_books</div></pre></td></tr></table></figure>\n<p>虽然只是个简单的数据提取，但是为了提高程序灵活性，文件路径、行列及搜索值仍然通过传参方式。</p>\n<p><code>read_xls</code>实现了读取excel中指定的相关内容到列表，下面要实现存储内容到doc文档。</p>\n<h2 id=\"保存内容到doc文档\"><a href=\"#保存内容到doc文档\" class=\"headerlink\" title=\"保存内容到doc文档\"></a>保存内容到doc文档</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_doc</span><span class=\"params\">(name, contents, create_new=False)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    *param name* doc文档名称</div><div class=\"line\">    *param contents* 文档内容，为列表格式</div><div class=\"line\">    *return*</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> create_new:</div><div class=\"line\">        doc = docx.Document()</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        doc = docx.Document(name)</div><div class=\"line\">    <span class=\"keyword\">for</span> pb <span class=\"keyword\">in</span> contents:</div><div class=\"line\">        doc.add_paragraph(pb)</div><div class=\"line\">    <span class=\"keyword\">if</span> create_new:</div><div class=\"line\">        doc.save(name + <span class=\"string\">'.docx'</span>)</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        doc.save(name)</div></pre></td></tr></table></figure>\n<p>该方法实现的是，如果create_new为true则直接创建一个doc文档存储内容，并将文档命名为name。如果为false则直接打开一个名称为name的文档进行存储。</p>\n<p>因为这些都是IO操作，应该在工作线程执行。但是这是两个独立的方法，所以还需进行一次包装。</p>\n<h2 id=\"2个方法封装\"><a href=\"#2个方法封装\" class=\"headerlink\" title=\"2个方法封装\"></a>2个方法封装</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(path, find, row, col)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"包装类，封装读取xls文件方法和保存到doc文档方法</span></div><div class=\"line\">    *param path*</div><div class=\"line\">    *param find*</div><div class=\"line\">    *param row*</div><div class=\"line\">    *param col*</div><div class=\"line\">    *return*</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    python_books = read_xls(path, find, row, col)</div><div class=\"line\">    save_doc(name=path, contents=python_books, create_new=<span class=\"keyword\">True</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"开启2个工作线程读取并存储内容\"><a href=\"#开启2个工作线程读取并存储内容\" class=\"headerlink\" title=\"开启2个工作线程读取并存储内容\"></a>开启2个工作线程读取并存储内容</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">find = [<span class=\"string\">'python'</span>, <span class=\"string\">'PYTHON'</span>, <span class=\"string\">'Python'</span>]</div><div class=\"line\">thread1 = threading.Thread(target=wrapper,</div><div class=\"line\">                           kwargs=&#123;<span class=\"string\">'find'</span>: find, <span class=\"string\">'path'</span>: <span class=\"string\">'ebook1.xls'</span>, <span class=\"string\">'col'</span>: <span class=\"string\">'4'</span>, <span class=\"string\">'row'</span>: <span class=\"string\">'-1'</span>&#125;)</div><div class=\"line\">thread1.start()</div><div class=\"line\"></div><div class=\"line\">thread2 = threading.Thread(target=wrapper,</div><div class=\"line\">                           kwargs=&#123;<span class=\"string\">'find'</span>: find, <span class=\"string\">'path'</span>: <span class=\"string\">'ebook2.xls'</span>, <span class=\"string\">'col'</span>: <span class=\"string\">'4'</span>, <span class=\"string\">'row'</span>: <span class=\"string\">'-1'</span>&#125;)</div><div class=\"line\">thread2.start()</div></pre></td></tr></table></figure>\n<h2 id=\"查看结果\"><a href=\"#查看结果\" class=\"headerlink\" title=\"查看结果\"></a>查看结果</h2><p>执行后会在项目根目录生成2个对应的doc文档：</p>\n<p><img src=\"/2017/07/21/用Python提取excel中有用数据/项目结果.png\" alt=\"项目结果\"></p>\n<p>打开doc文档看看具体内容吧：</p>\n<p><img src=\"/2017/07/21/用Python提取excel中有用数据/doc文档内容.png\" alt=\"doc文档内容\"></p>\n"},{"title":"算法排序之交换排序","date":"2017-05-03T13:04:13.000Z","_content":"\n# 实现目标\n\n本例中希望通过交换排序，使得数组最终按非递减顺序排列。\n\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\n\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\n\n# 实现分析\n\n- 说明\n\n  希望数组按非递减顺序排列，我们可以得到两点消息：1、数组中可能会有重复的元素，所以才说是非递减。2、排序后第一个元素是最小值 ，最后一个元素是最大值。\n\n- 阐述实现\n\n  第一轮，第一个元素分别与后面的每个元素比较，如果大于后面的元素则进行交换，把较小值交换到第一个元素位置，本轮结束后的第一个元素就是数组中最小值。\n\n  第二轮，由于第一轮的第一个元素已经求出了最小值，所以第二轮从第二个元素开始，与后面的每个元素分别比较，如果大于后面的元素则进行交换，把较小值交换到第二个元素位置，本轮结束后的第二个元素就是数组中倒数第二小的值。\n\n  以此类推，进行n-1轮比较，n为数组长度。之所以是n-1轮而不是n轮，是因为第i轮的i个元素要和后面的元素进行比较，如果是n轮，它本身就是最后的元素，不需要比较了。\n\n- 阐述转换通用代码\n\n  交换方法提取：\n\n  ```\n  void swap(int[] arr, int i,int j){\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp ;\n  }\n  ```\n\n  第一轮：\n\n  ```\n  int i=0；\n  for(int j=i+1;j<n;j++){\n    if(arr[i]>arr[j]){\n      swap(arr,i,j);\n    }\n  }\n  ```\n\n  第二轮：\n\n  ```\n  int i=1；\n  for(int j=i+1;j<n;j++){\n    if(arr[i]>arr[j]){\n      swap(arr,i,j);\n    }\n  }\n  ```\n\n  每轮遍历出一个当前未排序中最小值，以此类推，遍历n-1轮：\n\n  ```\n  for(int i=0;i<n-1;i++){\n    \n  }\n  ```\n\n  ​\n\n\n\n# 代码实现\n\n```\n\tpublic static void swapSort(int[] arr) {\n\t\tint length = arr.length;\n\t\tfor (int i = 0; i < length-1 ; i++) {\n\t\t\tfor (int j = i + 1; j < length; j++) {\n\t\t\t\tif (arr[i] >  arr[j]) {\n\t\t\t\t\tint tmp = arr[i];\n\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\tarr[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n","source":"_posts/算法排序之交换排序.md","raw":"---\ntitle: 算法排序之交换排序\ndate: 2017-05-03 21:04:13\ntags: 算法\ncategories: 算法\n---\n\n# 实现目标\n\n本例中希望通过交换排序，使得数组最终按非递减顺序排列。\n\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\n\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\n\n# 实现分析\n\n- 说明\n\n  希望数组按非递减顺序排列，我们可以得到两点消息：1、数组中可能会有重复的元素，所以才说是非递减。2、排序后第一个元素是最小值 ，最后一个元素是最大值。\n\n- 阐述实现\n\n  第一轮，第一个元素分别与后面的每个元素比较，如果大于后面的元素则进行交换，把较小值交换到第一个元素位置，本轮结束后的第一个元素就是数组中最小值。\n\n  第二轮，由于第一轮的第一个元素已经求出了最小值，所以第二轮从第二个元素开始，与后面的每个元素分别比较，如果大于后面的元素则进行交换，把较小值交换到第二个元素位置，本轮结束后的第二个元素就是数组中倒数第二小的值。\n\n  以此类推，进行n-1轮比较，n为数组长度。之所以是n-1轮而不是n轮，是因为第i轮的i个元素要和后面的元素进行比较，如果是n轮，它本身就是最后的元素，不需要比较了。\n\n- 阐述转换通用代码\n\n  交换方法提取：\n\n  ```\n  void swap(int[] arr, int i,int j){\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp ;\n  }\n  ```\n\n  第一轮：\n\n  ```\n  int i=0；\n  for(int j=i+1;j<n;j++){\n    if(arr[i]>arr[j]){\n      swap(arr,i,j);\n    }\n  }\n  ```\n\n  第二轮：\n\n  ```\n  int i=1；\n  for(int j=i+1;j<n;j++){\n    if(arr[i]>arr[j]){\n      swap(arr,i,j);\n    }\n  }\n  ```\n\n  每轮遍历出一个当前未排序中最小值，以此类推，遍历n-1轮：\n\n  ```\n  for(int i=0;i<n-1;i++){\n    \n  }\n  ```\n\n  ​\n\n\n\n# 代码实现\n\n```\n\tpublic static void swapSort(int[] arr) {\n\t\tint length = arr.length;\n\t\tfor (int i = 0; i < length-1 ; i++) {\n\t\t\tfor (int j = i + 1; j < length; j++) {\n\t\t\t\tif (arr[i] >  arr[j]) {\n\t\t\t\t\tint tmp = arr[i];\n\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\tarr[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n","slug":"算法排序之交换排序","published":1,"updated":"2017-05-03T14:27:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjkt0087wh9c9n92hntb","content":"<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><p>本例中希望通过交换排序，使得数组最终按非递减顺序排列。</p>\n<p>数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }</p>\n<p>数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }</p>\n<h1 id=\"实现分析\"><a href=\"#实现分析\" class=\"headerlink\" title=\"实现分析\"></a>实现分析</h1><ul>\n<li><p>说明</p>\n<p>希望数组按非递减顺序排列，我们可以得到两点消息：1、数组中可能会有重复的元素，所以才说是非递减。2、排序后第一个元素是最小值 ，最后一个元素是最大值。</p>\n</li>\n<li><p>阐述实现</p>\n<p>第一轮，第一个元素分别与后面的每个元素比较，如果大于后面的元素则进行交换，把较小值交换到第一个元素位置，本轮结束后的第一个元素就是数组中最小值。</p>\n<p>第二轮，由于第一轮的第一个元素已经求出了最小值，所以第二轮从第二个元素开始，与后面的每个元素分别比较，如果大于后面的元素则进行交换，把较小值交换到第二个元素位置，本轮结束后的第二个元素就是数组中倒数第二小的值。</p>\n<p>以此类推，进行n-1轮比较，n为数组长度。之所以是n-1轮而不是n轮，是因为第i轮的i个元素要和后面的元素进行比较，如果是n轮，它本身就是最后的元素，不需要比较了。</p>\n</li>\n<li><p>阐述转换通用代码</p>\n<p>交换方法提取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void swap(int[] arr, int i,int j)&#123;</div><div class=\"line\">  int tmp = arr[i];</div><div class=\"line\">  arr[i] = arr[j];</div><div class=\"line\">  arr[j] = tmp ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int i=0；</div><div class=\"line\">for(int j=i+1;j&lt;n;j++)&#123;</div><div class=\"line\">  if(arr[i]&gt;arr[j])&#123;</div><div class=\"line\">    swap(arr,i,j);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int i=1；</div><div class=\"line\">for(int j=i+1;j&lt;n;j++)&#123;</div><div class=\"line\">  if(arr[i]&gt;arr[j])&#123;</div><div class=\"line\">    swap(arr,i,j);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每轮遍历出一个当前未排序中最小值，以此类推，遍历n-1轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(int i=0;i&lt;n-1;i++)&#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void swapSort(int[] arr) &#123;</div><div class=\"line\">\tint length = arr.length;</div><div class=\"line\">\tfor (int i = 0; i &lt; length-1 ; i++) &#123;</div><div class=\"line\">\t\tfor (int j = i + 1; j &lt; length; j++) &#123;</div><div class=\"line\">\t\t\tif (arr[i] &gt;  arr[j]) &#123;</div><div class=\"line\">\t\t\t\tint tmp = arr[i];</div><div class=\"line\">\t\t\t\tarr[i] = arr[j];</div><div class=\"line\">\t\t\t\tarr[j] = tmp;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><p>本例中希望通过交换排序，使得数组最终按非递减顺序排列。</p>\n<p>数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }</p>\n<p>数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }</p>\n<h1 id=\"实现分析\"><a href=\"#实现分析\" class=\"headerlink\" title=\"实现分析\"></a>实现分析</h1><ul>\n<li><p>说明</p>\n<p>希望数组按非递减顺序排列，我们可以得到两点消息：1、数组中可能会有重复的元素，所以才说是非递减。2、排序后第一个元素是最小值 ，最后一个元素是最大值。</p>\n</li>\n<li><p>阐述实现</p>\n<p>第一轮，第一个元素分别与后面的每个元素比较，如果大于后面的元素则进行交换，把较小值交换到第一个元素位置，本轮结束后的第一个元素就是数组中最小值。</p>\n<p>第二轮，由于第一轮的第一个元素已经求出了最小值，所以第二轮从第二个元素开始，与后面的每个元素分别比较，如果大于后面的元素则进行交换，把较小值交换到第二个元素位置，本轮结束后的第二个元素就是数组中倒数第二小的值。</p>\n<p>以此类推，进行n-1轮比较，n为数组长度。之所以是n-1轮而不是n轮，是因为第i轮的i个元素要和后面的元素进行比较，如果是n轮，它本身就是最后的元素，不需要比较了。</p>\n</li>\n<li><p>阐述转换通用代码</p>\n<p>交换方法提取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">void swap(int[] arr, int i,int j)&#123;</div><div class=\"line\">  int tmp = arr[i];</div><div class=\"line\">  arr[i] = arr[j];</div><div class=\"line\">  arr[j] = tmp ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int i=0；</div><div class=\"line\">for(int j=i+1;j&lt;n;j++)&#123;</div><div class=\"line\">  if(arr[i]&gt;arr[j])&#123;</div><div class=\"line\">    swap(arr,i,j);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">int i=1；</div><div class=\"line\">for(int j=i+1;j&lt;n;j++)&#123;</div><div class=\"line\">  if(arr[i]&gt;arr[j])&#123;</div><div class=\"line\">    swap(arr,i,j);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每轮遍历出一个当前未排序中最小值，以此类推，遍历n-1轮：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(int i=0;i&lt;n-1;i++)&#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void swapSort(int[] arr) &#123;</div><div class=\"line\">\tint length = arr.length;</div><div class=\"line\">\tfor (int i = 0; i &lt; length-1 ; i++) &#123;</div><div class=\"line\">\t\tfor (int j = i + 1; j &lt; length; j++) &#123;</div><div class=\"line\">\t\t\tif (arr[i] &gt;  arr[j]) &#123;</div><div class=\"line\">\t\t\t\tint tmp = arr[i];</div><div class=\"line\">\t\t\t\tarr[i] = arr[j];</div><div class=\"line\">\t\t\t\tarr[j] = tmp;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"算法查找之二分查找","date":"2017-05-03T14:52:40.000Z","_content":"\n# 实现目标\n\n查看24是否在数组{ 8，14，24，28，30，31，32 }中，\n\n如果在数组中则返回数组元素下标，否则返回-1 。\n\n数组下标从0开始，查找24时最终返回下标2。\n\n# 实现分析\n\n- 说明\n\n  二分法前提是数组是有序的；\n\n  要查找的数我们称为关键值\n\n- 阐述实现\n\n  在一个有序数组中二分查找一个数，数组长度为n。\n\n  1、设置左右下标变量：left，right，初始时left为0，right为n-1。\n\n  2、求出中间下标，得到中间数\n\n  3、如果中间数等于关键值则直接返回下标，\n\n  ​\t如果中间数大于关键值则 right为中间下标-1\n\n  ​\t如果中间数小于关键值则 left为中间下标+1\n\n  4、如果未结束，则重复步骤2和3，重复的前提是不管left和right的值\t\t\t如何改变，都要保证left<right。\n\n- 阐述转换通用代码\n\n  步骤1：` int left=0,right =n-1;`\n\n  步骤4中说重复2和3步，说明这是一个循环，循环条件是left<right，\n\n  所以使用` while(left<right)`\n\n\n\n# 代码实现\n\n```\n\tpublic static int binarySearch(int[] arr, int key) {\n\t\tint left = 0, right = arr.length - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right) >> 1;\n\t\t\tif (arr[mid] == key) {\n\t\t\t\treturn mid;\n\t\t\t} else if (arr[mid] > key) {\n\t\t\t\tright = mid - 1;\n\t\t\t} else {\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n```\n\n","source":"_posts/算法查找之二分查找.md","raw":"---\ntitle: 算法查找之二分查找\ndate: 2017-05-03 22:52:40\ntags: 算法\ncategories: 算法\n---\n\n# 实现目标\n\n查看24是否在数组{ 8，14，24，28，30，31，32 }中，\n\n如果在数组中则返回数组元素下标，否则返回-1 。\n\n数组下标从0开始，查找24时最终返回下标2。\n\n# 实现分析\n\n- 说明\n\n  二分法前提是数组是有序的；\n\n  要查找的数我们称为关键值\n\n- 阐述实现\n\n  在一个有序数组中二分查找一个数，数组长度为n。\n\n  1、设置左右下标变量：left，right，初始时left为0，right为n-1。\n\n  2、求出中间下标，得到中间数\n\n  3、如果中间数等于关键值则直接返回下标，\n\n  ​\t如果中间数大于关键值则 right为中间下标-1\n\n  ​\t如果中间数小于关键值则 left为中间下标+1\n\n  4、如果未结束，则重复步骤2和3，重复的前提是不管left和right的值\t\t\t如何改变，都要保证left<right。\n\n- 阐述转换通用代码\n\n  步骤1：` int left=0,right =n-1;`\n\n  步骤4中说重复2和3步，说明这是一个循环，循环条件是left<right，\n\n  所以使用` while(left<right)`\n\n\n\n# 代码实现\n\n```\n\tpublic static int binarySearch(int[] arr, int key) {\n\t\tint left = 0, right = arr.length - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right) >> 1;\n\t\t\tif (arr[mid] == key) {\n\t\t\t\treturn mid;\n\t\t\t} else if (arr[mid] > key) {\n\t\t\t\tright = mid - 1;\n\t\t\t} else {\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n```\n\n","slug":"算法查找之二分查找","published":1,"updated":"2017-05-03T16:14:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjkv008bwh9cturo16hm","content":"<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><p>查看24是否在数组{ 8，14，24，28，30，31，32 }中，</p>\n<p>如果在数组中则返回数组元素下标，否则返回-1 。</p>\n<p>数组下标从0开始，查找24时最终返回下标2。</p>\n<h1 id=\"实现分析\"><a href=\"#实现分析\" class=\"headerlink\" title=\"实现分析\"></a>实现分析</h1><ul>\n<li><p>说明</p>\n<p>二分法前提是数组是有序的；</p>\n<p>要查找的数我们称为关键值</p>\n</li>\n<li><p>阐述实现</p>\n<p>在一个有序数组中二分查找一个数，数组长度为n。</p>\n<p>1、设置左右下标变量：left，right，初始时left为0，right为n-1。</p>\n<p>2、求出中间下标，得到中间数</p>\n<p>3、如果中间数等于关键值则直接返回下标，</p>\n<p>​    如果中间数大于关键值则 right为中间下标-1</p>\n<p>​    如果中间数小于关键值则 left为中间下标+1</p>\n<p>4、如果未结束，则重复步骤2和3，重复的前提是不管left和right的值            如何改变，都要保证left&lt;right。</p>\n</li>\n<li><p>阐述转换通用代码</p>\n<p>步骤1：<code>int left=0,right =n-1;</code></p>\n<p>步骤4中说重复2和3步，说明这是一个循环，循环条件是left&lt;right，</p>\n<p>所以使用<code>while(left&lt;right)</code></p>\n</li>\n</ul>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int binarySearch(int[] arr, int key) &#123;</div><div class=\"line\">\tint left = 0, right = arr.length - 1;</div><div class=\"line\">\twhile (left &lt; right) &#123;</div><div class=\"line\">\t\tint mid = (left + right) &gt;&gt; 1;</div><div class=\"line\">\t\tif (arr[mid] == key) &#123;</div><div class=\"line\">\t\t\treturn mid;</div><div class=\"line\">\t\t&#125; else if (arr[mid] &gt; key) &#123;</div><div class=\"line\">\t\t\tright = mid - 1;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tleft = mid + 1;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><p>查看24是否在数组{ 8，14，24，28，30，31，32 }中，</p>\n<p>如果在数组中则返回数组元素下标，否则返回-1 。</p>\n<p>数组下标从0开始，查找24时最终返回下标2。</p>\n<h1 id=\"实现分析\"><a href=\"#实现分析\" class=\"headerlink\" title=\"实现分析\"></a>实现分析</h1><ul>\n<li><p>说明</p>\n<p>二分法前提是数组是有序的；</p>\n<p>要查找的数我们称为关键值</p>\n</li>\n<li><p>阐述实现</p>\n<p>在一个有序数组中二分查找一个数，数组长度为n。</p>\n<p>1、设置左右下标变量：left，right，初始时left为0，right为n-1。</p>\n<p>2、求出中间下标，得到中间数</p>\n<p>3、如果中间数等于关键值则直接返回下标，</p>\n<p>​    如果中间数大于关键值则 right为中间下标-1</p>\n<p>​    如果中间数小于关键值则 left为中间下标+1</p>\n<p>4、如果未结束，则重复步骤2和3，重复的前提是不管left和right的值            如何改变，都要保证left&lt;right。</p>\n</li>\n<li><p>阐述转换通用代码</p>\n<p>步骤1：<code>int left=0,right =n-1;</code></p>\n<p>步骤4中说重复2和3步，说明这是一个循环，循环条件是left&lt;right，</p>\n<p>所以使用<code>while(left&lt;right)</code></p>\n</li>\n</ul>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int binarySearch(int[] arr, int key) &#123;</div><div class=\"line\">\tint left = 0, right = arr.length - 1;</div><div class=\"line\">\twhile (left &lt; right) &#123;</div><div class=\"line\">\t\tint mid = (left + right) &gt;&gt; 1;</div><div class=\"line\">\t\tif (arr[mid] == key) &#123;</div><div class=\"line\">\t\t\treturn mid;</div><div class=\"line\">\t\t&#125; else if (arr[mid] &gt; key) &#123;</div><div class=\"line\">\t\t\tright = mid - 1;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tleft = mid + 1;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"算法排序之快速排序","date":"2017-05-16T10:21:50.000Z","_content":"\n# 实现目标\n\n本例中希望通过快速排序，使得数组最终按非递减顺序排列。\n\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\n\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\n\n\n\n# 实现分析\n\n快排是根据分治思想，\n\n①选取一个基数，\n\n②将无序数组分为大小两个数组，其中一个数组值全都比基数小，另一个数组值全都比基数大。\n\n③然后将这两个数组分别再次分组，递归重复①②的步骤直到每个拆分后的数组不可再分割为止。也就是说最后每个元素单独为一个数组为止。\n\n④最后得出数组就是排序好的。\n\n\n\n# 代码实现\n\n```\n\tpublic static int partition3(int[] arr, int low, int high) {\n\t\tint i, j;\n\t\ti = low;\n\t\tint base = arr[i];\n\t\tfor (j = i + 1; j <= high; j++) {\n\t\t\tif (arr[j] < base) {\n\t\t\t\ti++;\n\t\t\t\tswap(arr, i, j);\n\t\t\t}\n\t\t}\n\t\tswap(arr, low, i);\n\t\treturn i;\n\t}\n\n\t/**\n\t*交换数组中两个值\n\t**/\n\tpublic static void swap(int[] arr, int i, int j) {\n\t\tif (i != j) {\n\t\t\tint tmp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = tmp;\n\t\t}\n\t}\n\n\t/**\n\t*right为数组最大下标而不是数组长度\n\t**/\n\tpublic static void quickSort(int[] arr, int left, int right) {\n\t\tif (left < right) {\n\t\t\tint piv = partition3(arr, left, right);\n\t\t\tquickSort(arr, left, piv - 1);\n\t\t\tquickSort(arr, piv + 1, right);\n\t\t}\n\n\t}\n```\n\n\n\n","source":"_posts/算法排序之快速排序.md","raw":"---\ntitle: 算法排序之快速排序\ndate: 2017-05-16 18:21:50\ntags: 算法\ncategories: 算法\n---\n\n# 实现目标\n\n本例中希望通过快速排序，使得数组最终按非递减顺序排列。\n\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\n\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\n\n\n\n# 实现分析\n\n快排是根据分治思想，\n\n①选取一个基数，\n\n②将无序数组分为大小两个数组，其中一个数组值全都比基数小，另一个数组值全都比基数大。\n\n③然后将这两个数组分别再次分组，递归重复①②的步骤直到每个拆分后的数组不可再分割为止。也就是说最后每个元素单独为一个数组为止。\n\n④最后得出数组就是排序好的。\n\n\n\n# 代码实现\n\n```\n\tpublic static int partition3(int[] arr, int low, int high) {\n\t\tint i, j;\n\t\ti = low;\n\t\tint base = arr[i];\n\t\tfor (j = i + 1; j <= high; j++) {\n\t\t\tif (arr[j] < base) {\n\t\t\t\ti++;\n\t\t\t\tswap(arr, i, j);\n\t\t\t}\n\t\t}\n\t\tswap(arr, low, i);\n\t\treturn i;\n\t}\n\n\t/**\n\t*交换数组中两个值\n\t**/\n\tpublic static void swap(int[] arr, int i, int j) {\n\t\tif (i != j) {\n\t\t\tint tmp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = tmp;\n\t\t}\n\t}\n\n\t/**\n\t*right为数组最大下标而不是数组长度\n\t**/\n\tpublic static void quickSort(int[] arr, int left, int right) {\n\t\tif (left < right) {\n\t\t\tint piv = partition3(arr, left, right);\n\t\t\tquickSort(arr, left, piv - 1);\n\t\t\tquickSort(arr, piv + 1, right);\n\t\t}\n\n\t}\n```\n\n\n\n","slug":"算法排序之快速排序","published":1,"updated":"2017-05-16T15:39:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjkz008ewh9c37oxc0zn","content":"<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><p>本例中希望通过快速排序，使得数组最终按非递减顺序排列。</p>\n<p>数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }</p>\n<p>数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }</p>\n<h1 id=\"实现分析\"><a href=\"#实现分析\" class=\"headerlink\" title=\"实现分析\"></a>实现分析</h1><p>快排是根据分治思想，</p>\n<p>①选取一个基数，</p>\n<p>②将无序数组分为大小两个数组，其中一个数组值全都比基数小，另一个数组值全都比基数大。</p>\n<p>③然后将这两个数组分别再次分组，递归重复①②的步骤直到每个拆分后的数组不可再分割为止。也就是说最后每个元素单独为一个数组为止。</p>\n<p>④最后得出数组就是排序好的。</p>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int partition3(int[] arr, int low, int high) &#123;</div><div class=\"line\">\tint i, j;</div><div class=\"line\">\ti = low;</div><div class=\"line\">\tint base = arr[i];</div><div class=\"line\">\tfor (j = i + 1; j &lt;= high; j++) &#123;</div><div class=\"line\">\t\tif (arr[j] &lt; base) &#123;</div><div class=\"line\">\t\t\ti++;</div><div class=\"line\">\t\t\tswap(arr, i, j);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tswap(arr, low, i);</div><div class=\"line\">\treturn i;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*交换数组中两个值</div><div class=\"line\">**/</div><div class=\"line\">public static void swap(int[] arr, int i, int j) &#123;</div><div class=\"line\">\tif (i != j) &#123;</div><div class=\"line\">\t\tint tmp = arr[i];</div><div class=\"line\">\t\tarr[i] = arr[j];</div><div class=\"line\">\t\tarr[j] = tmp;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*right为数组最大下标而不是数组长度</div><div class=\"line\">**/</div><div class=\"line\">public static void quickSort(int[] arr, int left, int right) &#123;</div><div class=\"line\">\tif (left &lt; right) &#123;</div><div class=\"line\">\t\tint piv = partition3(arr, left, right);</div><div class=\"line\">\t\tquickSort(arr, left, piv - 1);</div><div class=\"line\">\t\tquickSort(arr, piv + 1, right);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><p>本例中希望通过快速排序，使得数组最终按非递减顺序排列。</p>\n<p>数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }</p>\n<p>数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }</p>\n<h1 id=\"实现分析\"><a href=\"#实现分析\" class=\"headerlink\" title=\"实现分析\"></a>实现分析</h1><p>快排是根据分治思想，</p>\n<p>①选取一个基数，</p>\n<p>②将无序数组分为大小两个数组，其中一个数组值全都比基数小，另一个数组值全都比基数大。</p>\n<p>③然后将这两个数组分别再次分组，递归重复①②的步骤直到每个拆分后的数组不可再分割为止。也就是说最后每个元素单独为一个数组为止。</p>\n<p>④最后得出数组就是排序好的。</p>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int partition3(int[] arr, int low, int high) &#123;</div><div class=\"line\">\tint i, j;</div><div class=\"line\">\ti = low;</div><div class=\"line\">\tint base = arr[i];</div><div class=\"line\">\tfor (j = i + 1; j &lt;= high; j++) &#123;</div><div class=\"line\">\t\tif (arr[j] &lt; base) &#123;</div><div class=\"line\">\t\t\ti++;</div><div class=\"line\">\t\t\tswap(arr, i, j);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tswap(arr, low, i);</div><div class=\"line\">\treturn i;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*交换数组中两个值</div><div class=\"line\">**/</div><div class=\"line\">public static void swap(int[] arr, int i, int j) &#123;</div><div class=\"line\">\tif (i != j) &#123;</div><div class=\"line\">\t\tint tmp = arr[i];</div><div class=\"line\">\t\tarr[i] = arr[j];</div><div class=\"line\">\t\tarr[j] = tmp;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">*right为数组最大下标而不是数组长度</div><div class=\"line\">**/</div><div class=\"line\">public static void quickSort(int[] arr, int left, int right) &#123;</div><div class=\"line\">\tif (left &lt; right) &#123;</div><div class=\"line\">\t\tint piv = partition3(arr, left, right);</div><div class=\"line\">\t\tquickSort(arr, left, piv - 1);</div><div class=\"line\">\t\tquickSort(arr, piv + 1, right);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"详解设计模式之建造者模式","date":"2017-05-10T04:28:13.000Z","_content":"\n\n\n","source":"_posts/详解设计模式之建造者模式.md","raw":"---\ntitle: 详解设计模式之建造者模式\ndate: 2017-05-10 12:28:13\ntags: 设计模式\ncategories: 设计模式\n---\n\n\n\n","slug":"详解设计模式之建造者模式","published":1,"updated":"2017-05-10T07:24:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjl1008iwh9cm22264qp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"详解设计模式之单例模式","date":"2017-04-21T14:22:50.000Z","_content":"####1、什么是单例?\n单例顾名思义就是单个实例。日常工作都是自由的通过构造方法创建对象的，所以听到单例时，我们应该意识到其下是暗含了2层意思的，①构造方法不在为你所用，你不需要知道如何创建对象。②我会给你提供获取实例的方法，不需要你自己动手创建。\n\n![单例示意图.png](http://upload-images.jianshu.io/upload_images/1796052-fc54578715942157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不清楚uml类关系的请移步[UML--类图详解](http://www.jianshu.com/p/bf23234d5d2b)\n####2、\b什么情况下使用单例?\n当你需要内存中只有一个对象的时候。\n\n####3、为什么使用单例？\n单例保证了内存中数据的唯一性，同时也降低了内存的开销。\n####3、\b如何实现单例？\n在1中了解到两层含义后，对我们创建单例类是有帮助的，总结下就是：①私有化构造方法  ②对外提供获取实例方法\n\n- 饿汉式\n所谓饿汉式，就是在类加载的时候就迫不及待的创建对象，等到调用获取实例方法直接拿到对象返回即可。\n看实现代码：\n\n```\npublic class HungarySingleton {\n\tprivate static HungarySingleton intance = new HungarySingleton();\n\t\n\tprivate HungarySingleton(){\n\t\t\n\t}\n\tpublic static HungarySingleton getInstance(){\n\t\treturn intance;\n\t}\n}\n```\n*懒汉式是最简单的单例模式，在类加载的时候就实例化，避免了多线程问题的同时保证了实例唯一性。缺点是即使不需要时候也会被实例，会占用内存。所以推荐在实例占用内存不多的情况下使用，否则请使用下面几种方式。*\n\n- 懒汉式\n懒汉式，就是在首次调用的时候才会创建实例，相比饿汉式，延迟了初始化。\n\n```\npublic class LayzySingleton {\n\tprivate static LayzySingleton instance = null;\n\n\tprivate LayzySingleton() {\n\n\t}\n\tpublic LayzySingleton getInstatnce() {\n\t\tif (null == instance) {\n\t\t\tinstance = new LayzySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n上面代码有个问题，就是在多线程调用中会有产生多个实例的隐患，所以需要使用线程同步：\n\n```\npublic class LayzySingleton {\n\tprivate static LayzySingleton instance = null;\n\n\tprivate LayzySingleton() {\n\n\t}\n\tpublic synchronized LayzySingleton getInstatnce() {\n\t\tif (null == instance) {\n\t\t\tinstance = new LayzySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n*synchronized的加入虽然解决了多实例的隐患，但是又带来了性能低下的问题，因为我们只需要在首次创建对象时让同步产生作用即可，其后的调用无需同步，现在只要是调用该方法就同步，看来还需要改进*\n下面使用双重校验加锁(DCL)：\n\n```\npublic class LayzySingleton {\n\tprivate static LayzySingleton instance = null;\n\n\tprivate LayzySingleton() {\n\n\t}\n\tpublic  LayzySingleton getInstatnce() {\n\t\tif (null == instance) {\n\t\t\tsynchronized(LayzySingleton.class){\n\t\t\t\tif (null == instance) {\n\t\t\t\t\tinstance = new LayzySingleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n现在多线程问题解决了，性能也得到优化了是不是双重校验加锁就完美了呢？\nNO~\n在Java并发编程中的指令重排序中有讲到双重校验加锁失效问题。\n要禁止指令重排序需要使用volatile修饰变量\n\n\n```\n\tprivate volatile static LayzySingleton instance = null;\n```\n\n- 静态内部类\n如果觉得饿汉式占内存，懒汉式又要考虑多线程问题，那么可以使用静态内部类可能是你想要的：\n\n```\npublic class Singleton {\n\t\n\tprivate Singleton(){\n\t\t\n\t}\n\tpublic Singleton getInstance(){\n\t\treturn Holder.instance;\n\t}\n\tprivate class Holder{\n\t\tprivate  static final  Singleton instance = new Singleton();\n\t}\n}\n```\n*静态内部类避免了加载Singleton类时就初始化问题，只有在调用getInstance时才会致使Holder类被加载并初始化，同时也避免了线程安全问题和性能问题，推荐使用此方法。*\n\n- 枚举式\n  如果觉得上面的还是麻烦，可以使用枚举单例，\n代码实现：\n\n```\npublic enum EnumSingleton {\n\t\n\tINSTANCE ;\n\t\n\tint num = 33;\n\tString config = \"jenson\";\n\t\n\tpublic void doSomething(){\n\t\t\n\t}\n}\n```\n*枚举单例也可以有属性可以有方法，重要的是枚举默认就是线程安全的。*","source":"_posts/详解设计模式之单例模式.md","raw":"---\ntitle: 详解设计模式之单例模式\ndate: 2017-04-21 22:22:50\ntags: 设计模式\ncategories: 设计模式\n---\n####1、什么是单例?\n单例顾名思义就是单个实例。日常工作都是自由的通过构造方法创建对象的，所以听到单例时，我们应该意识到其下是暗含了2层意思的，①构造方法不在为你所用，你不需要知道如何创建对象。②我会给你提供获取实例的方法，不需要你自己动手创建。\n\n![单例示意图.png](http://upload-images.jianshu.io/upload_images/1796052-fc54578715942157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不清楚uml类关系的请移步[UML--类图详解](http://www.jianshu.com/p/bf23234d5d2b)\n####2、\b什么情况下使用单例?\n当你需要内存中只有一个对象的时候。\n\n####3、为什么使用单例？\n单例保证了内存中数据的唯一性，同时也降低了内存的开销。\n####3、\b如何实现单例？\n在1中了解到两层含义后，对我们创建单例类是有帮助的，总结下就是：①私有化构造方法  ②对外提供获取实例方法\n\n- 饿汉式\n所谓饿汉式，就是在类加载的时候就迫不及待的创建对象，等到调用获取实例方法直接拿到对象返回即可。\n看实现代码：\n\n```\npublic class HungarySingleton {\n\tprivate static HungarySingleton intance = new HungarySingleton();\n\t\n\tprivate HungarySingleton(){\n\t\t\n\t}\n\tpublic static HungarySingleton getInstance(){\n\t\treturn intance;\n\t}\n}\n```\n*懒汉式是最简单的单例模式，在类加载的时候就实例化，避免了多线程问题的同时保证了实例唯一性。缺点是即使不需要时候也会被实例，会占用内存。所以推荐在实例占用内存不多的情况下使用，否则请使用下面几种方式。*\n\n- 懒汉式\n懒汉式，就是在首次调用的时候才会创建实例，相比饿汉式，延迟了初始化。\n\n```\npublic class LayzySingleton {\n\tprivate static LayzySingleton instance = null;\n\n\tprivate LayzySingleton() {\n\n\t}\n\tpublic LayzySingleton getInstatnce() {\n\t\tif (null == instance) {\n\t\t\tinstance = new LayzySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n上面代码有个问题，就是在多线程调用中会有产生多个实例的隐患，所以需要使用线程同步：\n\n```\npublic class LayzySingleton {\n\tprivate static LayzySingleton instance = null;\n\n\tprivate LayzySingleton() {\n\n\t}\n\tpublic synchronized LayzySingleton getInstatnce() {\n\t\tif (null == instance) {\n\t\t\tinstance = new LayzySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n*synchronized的加入虽然解决了多实例的隐患，但是又带来了性能低下的问题，因为我们只需要在首次创建对象时让同步产生作用即可，其后的调用无需同步，现在只要是调用该方法就同步，看来还需要改进*\n下面使用双重校验加锁(DCL)：\n\n```\npublic class LayzySingleton {\n\tprivate static LayzySingleton instance = null;\n\n\tprivate LayzySingleton() {\n\n\t}\n\tpublic  LayzySingleton getInstatnce() {\n\t\tif (null == instance) {\n\t\t\tsynchronized(LayzySingleton.class){\n\t\t\t\tif (null == instance) {\n\t\t\t\t\tinstance = new LayzySingleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n现在多线程问题解决了，性能也得到优化了是不是双重校验加锁就完美了呢？\nNO~\n在Java并发编程中的指令重排序中有讲到双重校验加锁失效问题。\n要禁止指令重排序需要使用volatile修饰变量\n\n\n```\n\tprivate volatile static LayzySingleton instance = null;\n```\n\n- 静态内部类\n如果觉得饿汉式占内存，懒汉式又要考虑多线程问题，那么可以使用静态内部类可能是你想要的：\n\n```\npublic class Singleton {\n\t\n\tprivate Singleton(){\n\t\t\n\t}\n\tpublic Singleton getInstance(){\n\t\treturn Holder.instance;\n\t}\n\tprivate class Holder{\n\t\tprivate  static final  Singleton instance = new Singleton();\n\t}\n}\n```\n*静态内部类避免了加载Singleton类时就初始化问题，只有在调用getInstance时才会致使Holder类被加载并初始化，同时也避免了线程安全问题和性能问题，推荐使用此方法。*\n\n- 枚举式\n  如果觉得上面的还是麻烦，可以使用枚举单例，\n代码实现：\n\n```\npublic enum EnumSingleton {\n\t\n\tINSTANCE ;\n\t\n\tint num = 33;\n\tString config = \"jenson\";\n\t\n\tpublic void doSomething(){\n\t\t\n\t}\n}\n```\n*枚举单例也可以有属性可以有方法，重要的是枚举默认就是线程安全的。*","slug":"详解设计模式之单例模式","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjl3008mwh9cuid7z3l0","content":"<p>####1、什么是单例?<br>单例顾名思义就是单个实例。日常工作都是自由的通过构造方法创建对象的，所以听到单例时，我们应该意识到其下是暗含了2层意思的，①构造方法不在为你所用，你不需要知道如何创建对象。②我会给你提供获取实例的方法，不需要你自己动手创建。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-fc54578715942157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单例示意图.png\"></p>\n<p>不清楚uml类关系的请移步<a href=\"http://www.jianshu.com/p/bf23234d5d2b\" target=\"_blank\" rel=\"external\">UML–类图详解</a></p>\n<p>####2、\b什么情况下使用单例?<br>当你需要内存中只有一个对象的时候。</p>\n<p>####3、为什么使用单例？<br>单例保证了内存中数据的唯一性，同时也降低了内存的开销。</p>\n<p>####3、\b如何实现单例？<br>在1中了解到两层含义后，对我们创建单例类是有帮助的，总结下就是：①私有化构造方法  ②对外提供获取实例方法</p>\n<ul>\n<li>饿汉式<br>所谓饿汉式，就是在类加载的时候就迫不及待的创建对象，等到调用获取实例方法直接拿到对象返回即可。<br>看实现代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class HungarySingleton &#123;</div><div class=\"line\">\tprivate static HungarySingleton intance = new HungarySingleton();</div><div class=\"line\">\t</div><div class=\"line\">\tprivate HungarySingleton()&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static HungarySingleton getInstance()&#123;</div><div class=\"line\">\t\treturn intance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>懒汉式是最简单的单例模式，在类加载的时候就实例化，避免了多线程问题的同时保证了实例唯一性。缺点是即使不需要时候也会被实例，会占用内存。所以推荐在实例占用内存不多的情况下使用，否则请使用下面几种方式。</em></p>\n<ul>\n<li>懒汉式<br>懒汉式，就是在首次调用的时候才会创建实例，相比饿汉式，延迟了初始化。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class LayzySingleton &#123;</div><div class=\"line\">\tprivate static LayzySingleton instance = null;</div><div class=\"line\"></div><div class=\"line\">\tprivate LayzySingleton() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic LayzySingleton getInstatnce() &#123;</div><div class=\"line\">\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\tinstance = new LayzySingleton();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码有个问题，就是在多线程调用中会有产生多个实例的隐患，所以需要使用线程同步：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class LayzySingleton &#123;</div><div class=\"line\">\tprivate static LayzySingleton instance = null;</div><div class=\"line\"></div><div class=\"line\">\tprivate LayzySingleton() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic synchronized LayzySingleton getInstatnce() &#123;</div><div class=\"line\">\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\tinstance = new LayzySingleton();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>synchronized的加入虽然解决了多实例的隐患，但是又带来了性能低下的问题，因为我们只需要在首次创建对象时让同步产生作用即可，其后的调用无需同步，现在只要是调用该方法就同步，看来还需要改进</em><br>下面使用双重校验加锁(DCL)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class LayzySingleton &#123;</div><div class=\"line\">\tprivate static LayzySingleton instance = null;</div><div class=\"line\"></div><div class=\"line\">\tprivate LayzySingleton() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic  LayzySingleton getInstatnce() &#123;</div><div class=\"line\">\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\tsynchronized(LayzySingleton.class)&#123;</div><div class=\"line\">\t\t\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\t\t\tinstance = new LayzySingleton();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在多线程问题解决了，性能也得到优化了是不是双重校验加锁就完美了呢？<br>NO~<br>在Java并发编程中的指令重排序中有讲到双重校验加锁失效问题。<br>要禁止指令重排序需要使用volatile修饰变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">private volatile static LayzySingleton instance = null;</div></pre></td></tr></table></figure>\n<ul>\n<li>静态内部类<br>如果觉得饿汉式占内存，懒汉式又要考虑多线程问题，那么可以使用静态内部类可能是你想要的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Singleton &#123;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate Singleton()&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic Singleton getInstance()&#123;</div><div class=\"line\">\t\treturn Holder.instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tprivate class Holder&#123;</div><div class=\"line\">\t\tprivate  static final  Singleton instance = new Singleton();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>静态内部类避免了加载Singleton类时就初始化问题，只有在调用getInstance时才会致使Holder类被加载并初始化，同时也避免了线程安全问题和性能问题，推荐使用此方法。</em></p>\n<ul>\n<li>枚举式<br>如果觉得上面的还是麻烦，可以使用枚举单例，<br>代码实现：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum EnumSingleton &#123;</div><div class=\"line\">\t</div><div class=\"line\">\tINSTANCE ;</div><div class=\"line\">\t</div><div class=\"line\">\tint num = 33;</div><div class=\"line\">\tString config = &quot;jenson&quot;;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void doSomething()&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>枚举单例也可以有属性可以有方法，重要的是枚举默认就是线程安全的。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>####1、什么是单例?<br>单例顾名思义就是单个实例。日常工作都是自由的通过构造方法创建对象的，所以听到单例时，我们应该意识到其下是暗含了2层意思的，①构造方法不在为你所用，你不需要知道如何创建对象。②我会给你提供获取实例的方法，不需要你自己动手创建。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-fc54578715942157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单例示意图.png\"></p>\n<p>不清楚uml类关系的请移步<a href=\"http://www.jianshu.com/p/bf23234d5d2b\">UML–类图详解</a></p>\n<p>####2、\b什么情况下使用单例?<br>当你需要内存中只有一个对象的时候。</p>\n<p>####3、为什么使用单例？<br>单例保证了内存中数据的唯一性，同时也降低了内存的开销。</p>\n<p>####3、\b如何实现单例？<br>在1中了解到两层含义后，对我们创建单例类是有帮助的，总结下就是：①私有化构造方法  ②对外提供获取实例方法</p>\n<ul>\n<li>饿汉式<br>所谓饿汉式，就是在类加载的时候就迫不及待的创建对象，等到调用获取实例方法直接拿到对象返回即可。<br>看实现代码：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class HungarySingleton &#123;</div><div class=\"line\">\tprivate static HungarySingleton intance = new HungarySingleton();</div><div class=\"line\">\t</div><div class=\"line\">\tprivate HungarySingleton()&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic static HungarySingleton getInstance()&#123;</div><div class=\"line\">\t\treturn intance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>懒汉式是最简单的单例模式，在类加载的时候就实例化，避免了多线程问题的同时保证了实例唯一性。缺点是即使不需要时候也会被实例，会占用内存。所以推荐在实例占用内存不多的情况下使用，否则请使用下面几种方式。</em></p>\n<ul>\n<li>懒汉式<br>懒汉式，就是在首次调用的时候才会创建实例，相比饿汉式，延迟了初始化。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class LayzySingleton &#123;</div><div class=\"line\">\tprivate static LayzySingleton instance = null;</div><div class=\"line\"></div><div class=\"line\">\tprivate LayzySingleton() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic LayzySingleton getInstatnce() &#123;</div><div class=\"line\">\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\tinstance = new LayzySingleton();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码有个问题，就是在多线程调用中会有产生多个实例的隐患，所以需要使用线程同步：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class LayzySingleton &#123;</div><div class=\"line\">\tprivate static LayzySingleton instance = null;</div><div class=\"line\"></div><div class=\"line\">\tprivate LayzySingleton() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic synchronized LayzySingleton getInstatnce() &#123;</div><div class=\"line\">\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\tinstance = new LayzySingleton();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>synchronized的加入虽然解决了多实例的隐患，但是又带来了性能低下的问题，因为我们只需要在首次创建对象时让同步产生作用即可，其后的调用无需同步，现在只要是调用该方法就同步，看来还需要改进</em><br>下面使用双重校验加锁(DCL)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class LayzySingleton &#123;</div><div class=\"line\">\tprivate static LayzySingleton instance = null;</div><div class=\"line\"></div><div class=\"line\">\tprivate LayzySingleton() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic  LayzySingleton getInstatnce() &#123;</div><div class=\"line\">\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\tsynchronized(LayzySingleton.class)&#123;</div><div class=\"line\">\t\t\t\tif (null == instance) &#123;</div><div class=\"line\">\t\t\t\t\tinstance = new LayzySingleton();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在多线程问题解决了，性能也得到优化了是不是双重校验加锁就完美了呢？<br>NO~<br>在Java并发编程中的指令重排序中有讲到双重校验加锁失效问题。<br>要禁止指令重排序需要使用volatile修饰变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">private volatile static LayzySingleton instance = null;</div></pre></td></tr></table></figure>\n<ul>\n<li>静态内部类<br>如果觉得饿汉式占内存，懒汉式又要考虑多线程问题，那么可以使用静态内部类可能是你想要的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Singleton &#123;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate Singleton()&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic Singleton getInstance()&#123;</div><div class=\"line\">\t\treturn Holder.instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tprivate class Holder&#123;</div><div class=\"line\">\t\tprivate  static final  Singleton instance = new Singleton();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>静态内部类避免了加载Singleton类时就初始化问题，只有在调用getInstance时才会致使Holder类被加载并初始化，同时也避免了线程安全问题和性能问题，推荐使用此方法。</em></p>\n<ul>\n<li>枚举式<br>如果觉得上面的还是麻烦，可以使用枚举单例，<br>代码实现：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public enum EnumSingleton &#123;</div><div class=\"line\">\t</div><div class=\"line\">\tINSTANCE ;</div><div class=\"line\">\t</div><div class=\"line\">\tint num = 33;</div><div class=\"line\">\tString config = &quot;jenson&quot;;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void doSomething()&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>枚举单例也可以有属性可以有方法，重要的是枚举默认就是线程安全的。</em></p>\n"},{"title":"详解设计模式之简单工厂模式","date":"2017-04-21T14:22:50.000Z","_content":"####1、什么是简单工厂模式？\n把一些相关类的对象的创建封装在另一个类中，这样在上层的客户端不需要明白相关类对象是如何创建的，只需要调用另一个类的相关方法获取实例即可。另一个类就是所说的工厂类。为了避免每次使用工厂时都创建工厂实例，获取相关类实例的方法一般使用静态方法，所以简单工厂一般也叫静态工厂。\n\n####2、\b什么时候使用工厂模式？\n当你要对上层隐藏一些对象从而达到解耦的效果时可以使用简单工厂。\n####3、\b如何使用工厂模式？\n- 先看下不使用模式如何创建接口实例\n\n![不使用模式.png](http://upload-images.jianshu.io/upload_images/1796052-6f2ed596ea68547b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n汽车接口代码：\n```\npublic interface CarApi {\n\tpublic void run();\n}\n```\n起亚汽车实现代码：\n\n```\npublic class KiaImpl implements CarApi {\n\n\t@Override\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"起亚跑起来\");\n\t}\n\n}\n```\n客户端代码：\n\n\n```\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCarApi carApi = new KiaImpl();\n\t\tcarApi.run();\n\t}\n}\n```  \n如上，不使用模式的时候，客户端不仅依赖接口，更知道了接口的实现类是KiaImpl。要知道Java面向接口编程就是为了封装隔离，达到解耦模块的目的。这里虽然使用了接口，但是充其量只用到了其多态，至于封装隔离还是没影的事儿。\n- 看下使用简单工厂是如何实现的\n\n![使用模式.png](http://upload-images.jianshu.io/upload_images/1796052-cc51abbba4547d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n汽车接口和起亚实现代码如上不变，宝马实现代码如下：\n\n```\npublic class BmwImpl implements CarApi {\n\n\t@Override\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"宝马跑起来\");\n\t}\n\n}\n```\n汽车工厂代码如下：\n\n```\npublic class CarFactory {\n\tpublic static CarApi getCar(int type) {\n\t\tCarApi car;\n\t\tif (type == 0) {\n\t\t\tcar = new KiaImpl();\n\t\t} else {\n\t\t\tcar = new BmwImpl();\n\t\t}\n\t\treturn car;\n\t}\n}\n```\n客户端代码如下：\n\n```\n public class Client {\n\tpublic static void main(String[] args) {\n//\t\tCarApi carApi = new KiaImpl();\n//\t\tcarApi.run();\n\t\tCarApi kia = CarFactory.getCar(0);\n\t\tkia.run();\n\t\tCarApi bmw = CarFactory.getCar(1);\n\t\tbmw.run();\n\t}\n}\n```\n\n通过客户端代码可知，把实现类封装在工厂后，客户端只需要调用工厂静态方法就能拿到实现类实例，而不需要知道这些实现类是如何创建实现的，达到了解耦的目的。\n\n有一点要注意：如果接口有多个实现类，在工厂中如何确定想要获取哪个实例？这时就要在静态方法中传入参数，这时客户端就要知道参数类型代表的意思。所以此时底层要向上层暴露一些信息以供使用。","source":"_posts/详解设计模式之简单工厂模式.md","raw":"---\ntitle: 详解设计模式之简单工厂模式\ndate: 2017-04-21 22:22:50\ntags: 设计模式\ncategories: 设计模式\n---\n####1、什么是简单工厂模式？\n把一些相关类的对象的创建封装在另一个类中，这样在上层的客户端不需要明白相关类对象是如何创建的，只需要调用另一个类的相关方法获取实例即可。另一个类就是所说的工厂类。为了避免每次使用工厂时都创建工厂实例，获取相关类实例的方法一般使用静态方法，所以简单工厂一般也叫静态工厂。\n\n####2、\b什么时候使用工厂模式？\n当你要对上层隐藏一些对象从而达到解耦的效果时可以使用简单工厂。\n####3、\b如何使用工厂模式？\n- 先看下不使用模式如何创建接口实例\n\n![不使用模式.png](http://upload-images.jianshu.io/upload_images/1796052-6f2ed596ea68547b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n汽车接口代码：\n```\npublic interface CarApi {\n\tpublic void run();\n}\n```\n起亚汽车实现代码：\n\n```\npublic class KiaImpl implements CarApi {\n\n\t@Override\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"起亚跑起来\");\n\t}\n\n}\n```\n客户端代码：\n\n\n```\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCarApi carApi = new KiaImpl();\n\t\tcarApi.run();\n\t}\n}\n```  \n如上，不使用模式的时候，客户端不仅依赖接口，更知道了接口的实现类是KiaImpl。要知道Java面向接口编程就是为了封装隔离，达到解耦模块的目的。这里虽然使用了接口，但是充其量只用到了其多态，至于封装隔离还是没影的事儿。\n- 看下使用简单工厂是如何实现的\n\n![使用模式.png](http://upload-images.jianshu.io/upload_images/1796052-cc51abbba4547d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n汽车接口和起亚实现代码如上不变，宝马实现代码如下：\n\n```\npublic class BmwImpl implements CarApi {\n\n\t@Override\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"宝马跑起来\");\n\t}\n\n}\n```\n汽车工厂代码如下：\n\n```\npublic class CarFactory {\n\tpublic static CarApi getCar(int type) {\n\t\tCarApi car;\n\t\tif (type == 0) {\n\t\t\tcar = new KiaImpl();\n\t\t} else {\n\t\t\tcar = new BmwImpl();\n\t\t}\n\t\treturn car;\n\t}\n}\n```\n客户端代码如下：\n\n```\n public class Client {\n\tpublic static void main(String[] args) {\n//\t\tCarApi carApi = new KiaImpl();\n//\t\tcarApi.run();\n\t\tCarApi kia = CarFactory.getCar(0);\n\t\tkia.run();\n\t\tCarApi bmw = CarFactory.getCar(1);\n\t\tbmw.run();\n\t}\n}\n```\n\n通过客户端代码可知，把实现类封装在工厂后，客户端只需要调用工厂静态方法就能拿到实现类实例，而不需要知道这些实现类是如何创建实现的，达到了解耦的目的。\n\n有一点要注意：如果接口有多个实现类，在工厂中如何确定想要获取哪个实例？这时就要在静态方法中传入参数，这时客户端就要知道参数类型代表的意思。所以此时底层要向上层暴露一些信息以供使用。","slug":"详解设计模式之简单工厂模式","published":1,"updated":"2017-07-24T06:20:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjl6008qwh9ctdleda7x","content":"<p>####1、什么是简单工厂模式？<br>把一些相关类的对象的创建封装在另一个类中，这样在上层的客户端不需要明白相关类对象是如何创建的，只需要调用另一个类的相关方法获取实例即可。另一个类就是所说的工厂类。为了避免每次使用工厂时都创建工厂实例，获取相关类实例的方法一般使用静态方法，所以简单工厂一般也叫静态工厂。</p>\n<p>####2、\b什么时候使用工厂模式？<br>当你要对上层隐藏一些对象从而达到解耦的效果时可以使用简单工厂。</p>\n<p>####3、\b如何使用工厂模式？</p>\n<ul>\n<li>先看下不使用模式如何创建接口实例</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6f2ed596ea68547b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"不使用模式.png\"><br>汽车接口代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface CarApi &#123;</div><div class=\"line\">\tpublic void run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>起亚汽车实现代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class KiaImpl implements CarApi &#123;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void run() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tSystem.out.println(&quot;起亚跑起来&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户端代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Client &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tCarApi carApi = new KiaImpl();</div><div class=\"line\">\t\tcarApi.run();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\">如上，不使用模式的时候，客户端不仅依赖接口，更知道了接口的实现类是KiaImpl。要知道Java面向接口编程就是为了封装隔离，达到解耦模块的目的。这里虽然使用了接口，但是充其量只用到了其多态，至于封装隔离还是没影的事儿。</div><div class=\"line\">- 看下使用简单工厂是如何实现的</div><div class=\"line\"></div><div class=\"line\">![使用模式.png](http://upload-images.jianshu.io/upload_images/1796052-cc51abbba4547d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\">汽车接口和起亚实现代码如上不变，宝马实现代码如下：</div></pre></td></tr></table></figure>\n<p>public class BmwImpl implements CarApi {</p>\n<pre><code>@Override\npublic void run() {\n    // TODO Auto-generated method stub\n    System.out.println(&quot;宝马跑起来&quot;);\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">汽车工厂代码如下：</div></pre></td></tr></table></figure></p>\n<p>public class CarFactory {<br>    public static CarApi getCar(int type) {<br>        CarApi car;<br>        if (type == 0) {<br>            car = new KiaImpl();<br>        } else {<br>            car = new BmwImpl();<br>        }<br>        return car;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">客户端代码如下：</div></pre></td></tr></table></figure></p>\n<p> public class Client {<br>    public static void main(String[] args) {<br>//        CarApi carApi = new KiaImpl();<br>//        carApi.run();<br>        CarApi kia = CarFactory.getCar(0);<br>        kia.run();<br>        CarApi bmw = CarFactory.getCar(1);<br>        bmw.run();<br>    }<br>}<br>```</p>\n<p>通过客户端代码可知，把实现类封装在工厂后，客户端只需要调用工厂静态方法就能拿到实现类实例，而不需要知道这些实现类是如何创建实现的，达到了解耦的目的。</p>\n<p>有一点要注意：如果接口有多个实现类，在工厂中如何确定想要获取哪个实例？这时就要在静态方法中传入参数，这时客户端就要知道参数类型代表的意思。所以此时底层要向上层暴露一些信息以供使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>####1、什么是简单工厂模式？<br>把一些相关类的对象的创建封装在另一个类中，这样在上层的客户端不需要明白相关类对象是如何创建的，只需要调用另一个类的相关方法获取实例即可。另一个类就是所说的工厂类。为了避免每次使用工厂时都创建工厂实例，获取相关类实例的方法一般使用静态方法，所以简单工厂一般也叫静态工厂。</p>\n<p>####2、\b什么时候使用工厂模式？<br>当你要对上层隐藏一些对象从而达到解耦的效果时可以使用简单工厂。</p>\n<p>####3、\b如何使用工厂模式？</p>\n<ul>\n<li>先看下不使用模式如何创建接口实例</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1796052-6f2ed596ea68547b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"不使用模式.png\"><br>汽车接口代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface CarApi &#123;</div><div class=\"line\">\tpublic void run();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>起亚汽车实现代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class KiaImpl implements CarApi &#123;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void run() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tSystem.out.println(&quot;起亚跑起来&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>客户端代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Client &#123;</div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tCarApi carApi = new KiaImpl();</div><div class=\"line\">\t\tcarApi.run();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\">如上，不使用模式的时候，客户端不仅依赖接口，更知道了接口的实现类是KiaImpl。要知道Java面向接口编程就是为了封装隔离，达到解耦模块的目的。这里虽然使用了接口，但是充其量只用到了其多态，至于封装隔离还是没影的事儿。</div><div class=\"line\">- 看下使用简单工厂是如何实现的</div><div class=\"line\"></div><div class=\"line\">![使用模式.png](http://upload-images.jianshu.io/upload_images/1796052-cc51abbba4547d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class=\"line\">汽车接口和起亚实现代码如上不变，宝马实现代码如下：</div></pre></td></tr></table></figure>\n<p>public class BmwImpl implements CarApi {</p>\n<pre><code>@Override\npublic void run() {\n    // TODO Auto-generated method stub\n    System.out.println(&quot;宝马跑起来&quot;);\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">汽车工厂代码如下：</div></pre></td></tr></table></figure></p>\n<p>public class CarFactory {<br>    public static CarApi getCar(int type) {<br>        CarApi car;<br>        if (type == 0) {<br>            car = new KiaImpl();<br>        } else {<br>            car = new BmwImpl();<br>        }<br>        return car;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">客户端代码如下：</div></pre></td></tr></table></figure></p>\n<p> public class Client {<br>    public static void main(String[] args) {<br>//        CarApi carApi = new KiaImpl();<br>//        carApi.run();<br>        CarApi kia = CarFactory.getCar(0);<br>        kia.run();<br>        CarApi bmw = CarFactory.getCar(1);<br>        bmw.run();<br>    }<br>}<br>```</p>\n<p>通过客户端代码可知，把实现类封装在工厂后，客户端只需要调用工厂静态方法就能拿到实现类实例，而不需要知道这些实现类是如何创建实现的，达到了解耦的目的。</p>\n<p>有一点要注意：如果接口有多个实现类，在工厂中如何确定想要获取哪个实例？这时就要在静态方法中传入参数，这时客户端就要知道参数类型代表的意思。所以此时底层要向上层暴露一些信息以供使用。</p>\n"},{"title":"详解设计模式之责任链模式","date":"2017-05-10T04:36:14.000Z","_content":"\n# 说在前面的话\n\n责任链模式也叫职责链，抛开设计模式不谈，单看“责任链”这三个字，关注点一下子就放到了“链”字上了。链即锁链、链条，像链子一样环环相扣的东西。比如我们数据结构中的链表，当前对象持有下一个对象的地址。同样，设计模式中的责任链也是如此，任务一环套一环，环环相扣。\n\n# 面试流程分析\n\n作为技术人员离职再就业少不了要面试的，那么我们就拿面试流程来细说。假设面试流程分为三步：组长面试，CTO面试，HR终面，一共三面。\n\n## 不考虑其他任何方面的优化，一个人的面试如何实现？\n\n```\n\t//面试类\n\tstatic class Viewer {\n\t\tpublic void interview(int level) {\n\n\t\t\tif (0 == level) {// 组长面试\n\t\t\t\t// TODO\n\t\t\t} else if (1 == level) {// CTO面试\n\t\t\t\t// TODO\n\t\t\t} else if (2 == level) {// HR终面\n\t\t\t\t// TODO\n\t\t\t}\n\t\t}\n\t}\n```\n\n```\n\t//客户端\n\tpublic static void main(String[] args) {\n\n\t\tViewer viewer = new Viewer();\n\t\tviewer.interview(0);\n\t\tviewer.interview(1);\n\t\tviewer.interview(2);\n\n\t}\n```\n\n从上面实现方式可以看出，面试方法，如果要面试三次，那么客户端要调用三次，面试方法interview中对level判断，不同级别有不同人面试，如果以后增加四面，那么就要修改interview方法。\n\n另外每次的面试 `viewer.interview` 都在客户端调用，但是按照正常流程组长面试完，如果觉得可以，应该流程传递到CTO哪里了，CTO谈完了觉得技术良好，最后交给HR谈待遇，流程抽象提取后是这样：\n\n\n\n![屏幕快照 2017-05-10 下午4.21.27](详解设计模式之责任链模式/屏幕快照 2017-05-10 下午4.21.27.png)\n\n这不就是开头说的“链”吗？\n\n## 下面看看用链如何实现面试的：\n\n\n\n先定义一个链接口来控制面试流程：\n\n```\npublic interface Chain {\n\n\t/**\n\t * 面试方法\n\t * \n\t * @param level\n\t */\n\tvoid interview();\n\n\t/**\n\t * 是否通过\n\t * \n\t * @return\n\t */\n\tboolean isCross();\n\n\t/**\n\t * 下一个面试官\n\t * \n\t * @param chain\n\t */\n\tvoid next(Chain chain);\n}\n```\n\n然后定义组长Grouper、CTO、HR三个面试官类实现Chain接口。\n\n```\n\tstatic class Grouper implements Chain {\n\t\tprivate Chain next = null;\n\n\t\t@Override\n\t\tpublic void interview() {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t\tif (isCross() && next != null) {\n\t\t\t\tSystem.out.println(\"组长面试通过\");\n\t\t\t\tnext.interview();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCross() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void next(Chain chain) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tthis.next = chain;\n\t\t}\n\n\t}\n\n\tstatic class CTO implements Chain {\n\t\tprivate Chain next = null;\n\n\t\t@Override\n\t\tpublic void interview() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif (isCross() && next != null) {\n\t\t\t\tSystem.out.println(\"CTO面试通过\");\n\t\t\t\tnext.interview();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCross() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void next(Chain chain) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tthis.next = chain;\n\t\t}\n\n\t}\n\n\tstatic class HR implements Chain {\n\t\tprivate Chain next = null;\n\n\t\t@Override\n\t\tpublic void interview() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tSystem.out.println(\"HR面试通过\");\n\t\t\tif (isCross() && next != null) {\n\t\t\t\tnext.interview();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCross() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void next(Chain chain) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t}\n\n\t}\n```\n\n然后看看客户端调用：\n\n```\n\tpublic static void main(String[] args) {\n\t\tGrouper grouper = new Grouper();\n\t\tCTO cto = new CTO();\n\t\tHR hr = new HR();\n\t\tgrouper.next(cto);\n\t\tcto.next(hr);\n\t\tgrouper.interview();\n\t}\n```\n\n通过` grouper.next(cto);`和`cto.next(hr);` 设置完链式关系，最后只要通过`grouper.interview();` 调用一次面试就可以了。因为grouper最为链首，其中存储了下一个链元素next。只要条件达成（本次面试通过），则自动执行下一个任务，这就是任务链的好处。\n\n可能还有一个疑问：`grouper.next(cto);` 等流程还是在客户端设置的，这无疑要增加了客户端对底层这些类的认知度。\n\n其实完全可以把这些细节隐藏在底层的。比如我们把流程在Grouper构造方法中设置：\n\n```\n\t\tpublic Grouper() {\n\t\t\tCTO cto = new CTO();\n\t\t\tHR hr = new HR();\n\t\t\tnext(cto);\n\t\t\tcto.next(hr);\n\t\t}\n```\n\n这时客户端是如此的简洁：\n\n```\n\tpublic static void main(String[] args) {\n\t\tGrouper grouper = new Grouper();\n\t\tgrouper.interview();\n\t}\n```\n\n其实上面的一般方法还有其他的实现方法，但是无疑常见的实现要么耦合性较强，要么需要客户端对底层认知度高。\n\n说了半天，现在来步入主题看看到底什么是责任链\n\n\n\n# 责任链模式\n\n- 模式出现意图\n\n  让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着链传递请求，直到有一个对象处理它或者处理完毕为止。\n\n\n\n- 责任链uml图\n\n![屏幕快照 2017-05-10 下午5.17.19](详解设计模式之责任链模式/屏幕快照 2017-05-10 下午5.17.19.png)\n\n","source":"_posts/详解设计模式之责任链模式.md","raw":"---\ntitle: 详解设计模式之责任链模式\ndate: 2017-05-10 12:36:14\ntags: 设计模式\ncategories: 设计模式\n---\n\n# 说在前面的话\n\n责任链模式也叫职责链，抛开设计模式不谈，单看“责任链”这三个字，关注点一下子就放到了“链”字上了。链即锁链、链条，像链子一样环环相扣的东西。比如我们数据结构中的链表，当前对象持有下一个对象的地址。同样，设计模式中的责任链也是如此，任务一环套一环，环环相扣。\n\n# 面试流程分析\n\n作为技术人员离职再就业少不了要面试的，那么我们就拿面试流程来细说。假设面试流程分为三步：组长面试，CTO面试，HR终面，一共三面。\n\n## 不考虑其他任何方面的优化，一个人的面试如何实现？\n\n```\n\t//面试类\n\tstatic class Viewer {\n\t\tpublic void interview(int level) {\n\n\t\t\tif (0 == level) {// 组长面试\n\t\t\t\t// TODO\n\t\t\t} else if (1 == level) {// CTO面试\n\t\t\t\t// TODO\n\t\t\t} else if (2 == level) {// HR终面\n\t\t\t\t// TODO\n\t\t\t}\n\t\t}\n\t}\n```\n\n```\n\t//客户端\n\tpublic static void main(String[] args) {\n\n\t\tViewer viewer = new Viewer();\n\t\tviewer.interview(0);\n\t\tviewer.interview(1);\n\t\tviewer.interview(2);\n\n\t}\n```\n\n从上面实现方式可以看出，面试方法，如果要面试三次，那么客户端要调用三次，面试方法interview中对level判断，不同级别有不同人面试，如果以后增加四面，那么就要修改interview方法。\n\n另外每次的面试 `viewer.interview` 都在客户端调用，但是按照正常流程组长面试完，如果觉得可以，应该流程传递到CTO哪里了，CTO谈完了觉得技术良好，最后交给HR谈待遇，流程抽象提取后是这样：\n\n\n\n![屏幕快照 2017-05-10 下午4.21.27](详解设计模式之责任链模式/屏幕快照 2017-05-10 下午4.21.27.png)\n\n这不就是开头说的“链”吗？\n\n## 下面看看用链如何实现面试的：\n\n\n\n先定义一个链接口来控制面试流程：\n\n```\npublic interface Chain {\n\n\t/**\n\t * 面试方法\n\t * \n\t * @param level\n\t */\n\tvoid interview();\n\n\t/**\n\t * 是否通过\n\t * \n\t * @return\n\t */\n\tboolean isCross();\n\n\t/**\n\t * 下一个面试官\n\t * \n\t * @param chain\n\t */\n\tvoid next(Chain chain);\n}\n```\n\n然后定义组长Grouper、CTO、HR三个面试官类实现Chain接口。\n\n```\n\tstatic class Grouper implements Chain {\n\t\tprivate Chain next = null;\n\n\t\t@Override\n\t\tpublic void interview() {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t\tif (isCross() && next != null) {\n\t\t\t\tSystem.out.println(\"组长面试通过\");\n\t\t\t\tnext.interview();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCross() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void next(Chain chain) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tthis.next = chain;\n\t\t}\n\n\t}\n\n\tstatic class CTO implements Chain {\n\t\tprivate Chain next = null;\n\n\t\t@Override\n\t\tpublic void interview() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif (isCross() && next != null) {\n\t\t\t\tSystem.out.println(\"CTO面试通过\");\n\t\t\t\tnext.interview();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCross() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void next(Chain chain) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tthis.next = chain;\n\t\t}\n\n\t}\n\n\tstatic class HR implements Chain {\n\t\tprivate Chain next = null;\n\n\t\t@Override\n\t\tpublic void interview() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tSystem.out.println(\"HR面试通过\");\n\t\t\tif (isCross() && next != null) {\n\t\t\t\tnext.interview();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCross() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void next(Chain chain) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t}\n\n\t}\n```\n\n然后看看客户端调用：\n\n```\n\tpublic static void main(String[] args) {\n\t\tGrouper grouper = new Grouper();\n\t\tCTO cto = new CTO();\n\t\tHR hr = new HR();\n\t\tgrouper.next(cto);\n\t\tcto.next(hr);\n\t\tgrouper.interview();\n\t}\n```\n\n通过` grouper.next(cto);`和`cto.next(hr);` 设置完链式关系，最后只要通过`grouper.interview();` 调用一次面试就可以了。因为grouper最为链首，其中存储了下一个链元素next。只要条件达成（本次面试通过），则自动执行下一个任务，这就是任务链的好处。\n\n可能还有一个疑问：`grouper.next(cto);` 等流程还是在客户端设置的，这无疑要增加了客户端对底层这些类的认知度。\n\n其实完全可以把这些细节隐藏在底层的。比如我们把流程在Grouper构造方法中设置：\n\n```\n\t\tpublic Grouper() {\n\t\t\tCTO cto = new CTO();\n\t\t\tHR hr = new HR();\n\t\t\tnext(cto);\n\t\t\tcto.next(hr);\n\t\t}\n```\n\n这时客户端是如此的简洁：\n\n```\n\tpublic static void main(String[] args) {\n\t\tGrouper grouper = new Grouper();\n\t\tgrouper.interview();\n\t}\n```\n\n其实上面的一般方法还有其他的实现方法，但是无疑常见的实现要么耦合性较强，要么需要客户端对底层认知度高。\n\n说了半天，现在来步入主题看看到底什么是责任链\n\n\n\n# 责任链模式\n\n- 模式出现意图\n\n  让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着链传递请求，直到有一个对象处理它或者处理完毕为止。\n\n\n\n- 责任链uml图\n\n![屏幕快照 2017-05-10 下午5.17.19](详解设计模式之责任链模式/屏幕快照 2017-05-10 下午5.17.19.png)\n\n","slug":"详解设计模式之责任链模式","published":1,"updated":"2017-05-10T09:18:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjla008uwh9ctvqbdxl7","content":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>责任链模式也叫职责链，抛开设计模式不谈，单看“责任链”这三个字，关注点一下子就放到了“链”字上了。链即锁链、链条，像链子一样环环相扣的东西。比如我们数据结构中的链表，当前对象持有下一个对象的地址。同样，设计模式中的责任链也是如此，任务一环套一环，环环相扣。</p>\n<h1 id=\"面试流程分析\"><a href=\"#面试流程分析\" class=\"headerlink\" title=\"面试流程分析\"></a>面试流程分析</h1><p>作为技术人员离职再就业少不了要面试的，那么我们就拿面试流程来细说。假设面试流程分为三步：组长面试，CTO面试，HR终面，一共三面。</p>\n<h2 id=\"不考虑其他任何方面的优化，一个人的面试如何实现？\"><a href=\"#不考虑其他任何方面的优化，一个人的面试如何实现？\" class=\"headerlink\" title=\"不考虑其他任何方面的优化，一个人的面试如何实现？\"></a>不考虑其他任何方面的优化，一个人的面试如何实现？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//面试类</div><div class=\"line\">static class Viewer &#123;</div><div class=\"line\">\tpublic void interview(int level) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif (0 == level) &#123;// 组长面试</div><div class=\"line\">\t\t\t// TODO</div><div class=\"line\">\t\t&#125; else if (1 == level) &#123;// CTO面试</div><div class=\"line\">\t\t\t// TODO</div><div class=\"line\">\t\t&#125; else if (2 == level) &#123;// HR终面</div><div class=\"line\">\t\t\t// TODO</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//客户端</div><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\"></div><div class=\"line\">\tViewer viewer = new Viewer();</div><div class=\"line\">\tviewer.interview(0);</div><div class=\"line\">\tviewer.interview(1);</div><div class=\"line\">\tviewer.interview(2);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面实现方式可以看出，面试方法，如果要面试三次，那么客户端要调用三次，面试方法interview中对level判断，不同级别有不同人面试，如果以后增加四面，那么就要修改interview方法。</p>\n<p>另外每次的面试 <code>viewer.interview</code> 都在客户端调用，但是按照正常流程组长面试完，如果觉得可以，应该流程传递到CTO哪里了，CTO谈完了觉得技术良好，最后交给HR谈待遇，流程抽象提取后是这样：</p>\n<p><img src=\"/2017/05/10/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午4.21.27.png\" alt=\"屏幕快照 2017-05-10 下午4.21.27\"></p>\n<p>这不就是开头说的“链”吗？</p>\n<h2 id=\"下面看看用链如何实现面试的：\"><a href=\"#下面看看用链如何实现面试的：\" class=\"headerlink\" title=\"下面看看用链如何实现面试的：\"></a>下面看看用链如何实现面试的：</h2><p>先定义一个链接口来控制面试流程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Chain &#123;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 面试方法</div><div class=\"line\">\t * </div><div class=\"line\">\t * @param level</div><div class=\"line\">\t */</div><div class=\"line\">\tvoid interview();</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 是否通过</div><div class=\"line\">\t * </div><div class=\"line\">\t * @return</div><div class=\"line\">\t */</div><div class=\"line\">\tboolean isCross();</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 下一个面试官</div><div class=\"line\">\t * </div><div class=\"line\">\t * @param chain</div><div class=\"line\">\t */</div><div class=\"line\">\tvoid next(Chain chain);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后定义组长Grouper、CTO、HR三个面试官类实现Chain接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">static class Grouper implements Chain &#123;</div><div class=\"line\">\tprivate Chain next = null;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void interview() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\"></div><div class=\"line\">\t\tif (isCross() &amp;&amp; next != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(&quot;组长面试通过&quot;);</div><div class=\"line\">\t\t\tnext.interview();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean isCross() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void next(Chain chain) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tthis.next = chain;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static class CTO implements Chain &#123;</div><div class=\"line\">\tprivate Chain next = null;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void interview() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tif (isCross() &amp;&amp; next != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(&quot;CTO面试通过&quot;);</div><div class=\"line\">\t\t\tnext.interview();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean isCross() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void next(Chain chain) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tthis.next = chain;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static class HR implements Chain &#123;</div><div class=\"line\">\tprivate Chain next = null;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void interview() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tSystem.out.println(&quot;HR面试通过&quot;);</div><div class=\"line\">\t\tif (isCross() &amp;&amp; next != null) &#123;</div><div class=\"line\">\t\t\tnext.interview();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean isCross() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void next(Chain chain) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后看看客户端调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">\tGrouper grouper = new Grouper();</div><div class=\"line\">\tCTO cto = new CTO();</div><div class=\"line\">\tHR hr = new HR();</div><div class=\"line\">\tgrouper.next(cto);</div><div class=\"line\">\tcto.next(hr);</div><div class=\"line\">\tgrouper.interview();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过<code>grouper.next(cto);</code>和<code>cto.next(hr);</code> 设置完链式关系，最后只要通过<code>grouper.interview();</code> 调用一次面试就可以了。因为grouper最为链首，其中存储了下一个链元素next。只要条件达成（本次面试通过），则自动执行下一个任务，这就是任务链的好处。</p>\n<p>可能还有一个疑问：<code>grouper.next(cto);</code> 等流程还是在客户端设置的，这无疑要增加了客户端对底层这些类的认知度。</p>\n<p>其实完全可以把这些细节隐藏在底层的。比如我们把流程在Grouper构造方法中设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Grouper() &#123;</div><div class=\"line\">\tCTO cto = new CTO();</div><div class=\"line\">\tHR hr = new HR();</div><div class=\"line\">\tnext(cto);</div><div class=\"line\">\tcto.next(hr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时客户端是如此的简洁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">\tGrouper grouper = new Grouper();</div><div class=\"line\">\tgrouper.interview();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实上面的一般方法还有其他的实现方法，但是无疑常见的实现要么耦合性较强，要么需要客户端对底层认知度高。</p>\n<p>说了半天，现在来步入主题看看到底什么是责任链</p>\n<h1 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h1><ul>\n<li><p>模式出现意图</p>\n<p>让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着链传递请求，直到有一个对象处理它或者处理完毕为止。</p>\n</li>\n</ul>\n<ul>\n<li>责任链uml图</li>\n</ul>\n<p><img src=\"/2017/05/10/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午5.17.19.png\" alt=\"屏幕快照 2017-05-10 下午5.17.19\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说在前面的话\"><a href=\"#说在前面的话\" class=\"headerlink\" title=\"说在前面的话\"></a>说在前面的话</h1><p>责任链模式也叫职责链，抛开设计模式不谈，单看“责任链”这三个字，关注点一下子就放到了“链”字上了。链即锁链、链条，像链子一样环环相扣的东西。比如我们数据结构中的链表，当前对象持有下一个对象的地址。同样，设计模式中的责任链也是如此，任务一环套一环，环环相扣。</p>\n<h1 id=\"面试流程分析\"><a href=\"#面试流程分析\" class=\"headerlink\" title=\"面试流程分析\"></a>面试流程分析</h1><p>作为技术人员离职再就业少不了要面试的，那么我们就拿面试流程来细说。假设面试流程分为三步：组长面试，CTO面试，HR终面，一共三面。</p>\n<h2 id=\"不考虑其他任何方面的优化，一个人的面试如何实现？\"><a href=\"#不考虑其他任何方面的优化，一个人的面试如何实现？\" class=\"headerlink\" title=\"不考虑其他任何方面的优化，一个人的面试如何实现？\"></a>不考虑其他任何方面的优化，一个人的面试如何实现？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//面试类</div><div class=\"line\">static class Viewer &#123;</div><div class=\"line\">\tpublic void interview(int level) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif (0 == level) &#123;// 组长面试</div><div class=\"line\">\t\t\t// TODO</div><div class=\"line\">\t\t&#125; else if (1 == level) &#123;// CTO面试</div><div class=\"line\">\t\t\t// TODO</div><div class=\"line\">\t\t&#125; else if (2 == level) &#123;// HR终面</div><div class=\"line\">\t\t\t// TODO</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//客户端</div><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\"></div><div class=\"line\">\tViewer viewer = new Viewer();</div><div class=\"line\">\tviewer.interview(0);</div><div class=\"line\">\tviewer.interview(1);</div><div class=\"line\">\tviewer.interview(2);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面实现方式可以看出，面试方法，如果要面试三次，那么客户端要调用三次，面试方法interview中对level判断，不同级别有不同人面试，如果以后增加四面，那么就要修改interview方法。</p>\n<p>另外每次的面试 <code>viewer.interview</code> 都在客户端调用，但是按照正常流程组长面试完，如果觉得可以，应该流程传递到CTO哪里了，CTO谈完了觉得技术良好，最后交给HR谈待遇，流程抽象提取后是这样：</p>\n<p><img src=\"/2017/05/10/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午4.21.27.png\" alt=\"屏幕快照 2017-05-10 下午4.21.27\"></p>\n<p>这不就是开头说的“链”吗？</p>\n<h2 id=\"下面看看用链如何实现面试的：\"><a href=\"#下面看看用链如何实现面试的：\" class=\"headerlink\" title=\"下面看看用链如何实现面试的：\"></a>下面看看用链如何实现面试的：</h2><p>先定义一个链接口来控制面试流程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public interface Chain &#123;</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 面试方法</div><div class=\"line\">\t * </div><div class=\"line\">\t * @param level</div><div class=\"line\">\t */</div><div class=\"line\">\tvoid interview();</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 是否通过</div><div class=\"line\">\t * </div><div class=\"line\">\t * @return</div><div class=\"line\">\t */</div><div class=\"line\">\tboolean isCross();</div><div class=\"line\"></div><div class=\"line\">\t/**</div><div class=\"line\">\t * 下一个面试官</div><div class=\"line\">\t * </div><div class=\"line\">\t * @param chain</div><div class=\"line\">\t */</div><div class=\"line\">\tvoid next(Chain chain);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后定义组长Grouper、CTO、HR三个面试官类实现Chain接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">static class Grouper implements Chain &#123;</div><div class=\"line\">\tprivate Chain next = null;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void interview() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\"></div><div class=\"line\">\t\tif (isCross() &amp;&amp; next != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(&quot;组长面试通过&quot;);</div><div class=\"line\">\t\t\tnext.interview();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean isCross() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void next(Chain chain) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tthis.next = chain;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static class CTO implements Chain &#123;</div><div class=\"line\">\tprivate Chain next = null;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void interview() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tif (isCross() &amp;&amp; next != null) &#123;</div><div class=\"line\">\t\t\tSystem.out.println(&quot;CTO面试通过&quot;);</div><div class=\"line\">\t\t\tnext.interview();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean isCross() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void next(Chain chain) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tthis.next = chain;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static class HR implements Chain &#123;</div><div class=\"line\">\tprivate Chain next = null;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void interview() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\tSystem.out.println(&quot;HR面试通过&quot;);</div><div class=\"line\">\t\tif (isCross() &amp;&amp; next != null) &#123;</div><div class=\"line\">\t\t\tnext.interview();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic boolean isCross() &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void next(Chain chain) &#123;</div><div class=\"line\">\t\t// TODO Auto-generated method stub</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后看看客户端调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">\tGrouper grouper = new Grouper();</div><div class=\"line\">\tCTO cto = new CTO();</div><div class=\"line\">\tHR hr = new HR();</div><div class=\"line\">\tgrouper.next(cto);</div><div class=\"line\">\tcto.next(hr);</div><div class=\"line\">\tgrouper.interview();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过<code>grouper.next(cto);</code>和<code>cto.next(hr);</code> 设置完链式关系，最后只要通过<code>grouper.interview();</code> 调用一次面试就可以了。因为grouper最为链首，其中存储了下一个链元素next。只要条件达成（本次面试通过），则自动执行下一个任务，这就是任务链的好处。</p>\n<p>可能还有一个疑问：<code>grouper.next(cto);</code> 等流程还是在客户端设置的，这无疑要增加了客户端对底层这些类的认知度。</p>\n<p>其实完全可以把这些细节隐藏在底层的。比如我们把流程在Grouper构造方法中设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Grouper() &#123;</div><div class=\"line\">\tCTO cto = new CTO();</div><div class=\"line\">\tHR hr = new HR();</div><div class=\"line\">\tnext(cto);</div><div class=\"line\">\tcto.next(hr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时客户端是如此的简洁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void main(String[] args) &#123;</div><div class=\"line\">\tGrouper grouper = new Grouper();</div><div class=\"line\">\tgrouper.interview();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实上面的一般方法还有其他的实现方法，但是无疑常见的实现要么耦合性较强，要么需要客户端对底层认知度高。</p>\n<p>说了半天，现在来步入主题看看到底什么是责任链</p>\n<h1 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h1><ul>\n<li><p>模式出现意图</p>\n<p>让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着链传递请求，直到有一个对象处理它或者处理完毕为止。</p>\n</li>\n</ul>\n<ul>\n<li>责任链uml图</li>\n</ul>\n<p><img src=\"/2017/05/10/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午5.17.19.png\" alt=\"屏幕快照 2017-05-10 下午5.17.19\"></p>\n"},{"title":"算法之朴素模式匹配","date":"2017-05-25T07:49:26.000Z","_content":"\n# 0x00 前言\n\n不论英文还是中文，在看文章时经常会遇到查找某个单词或字组的时候，把一篇文章看作是一个大的字符串，要查找的内容作为子串，这种在大串中查找子串的操作叫做串的模式匹配。\n\n我们知道了这种行为叫串的模式匹配，但我们不清楚的是到底如何匹配，具体的操作是什么？\n\n# 0x01 我如何操作\n\n在我看来要从大串中寻找子串，最直接的方法就是从大串起始位置开始，挨个字符比对，如果存在子串总会找出来。这种简单直接的方法称为 **朴素的模式匹配算法**\n\n# 0x02 代码实现\n\n如果借用字符串截取操作，直接实现子串的查找就比较方便：\n\n```\n\tpublic static int index(String s, String t, int pos) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\twhile (pos <= (m - n + 1)) {\n\t\t\tString sub = s.substring(pos, n);\n\t\t\t//直接在对比位置截取和子串相同长度的一个串来和子串对比\n\t\t\tif (t.equals(sub)) {\n\t\t\t\treturn pos;\n\t\t\t} else {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n```\n\n\n\n\n\n\n\n","source":"_posts/算法之朴素模式匹配.md","raw":"---\ntitle: 算法之朴素模式匹配\ndate: 2017-05-25 15:49:26\ntags: 算法\ncategories: 算法\n---\n\n# 0x00 前言\n\n不论英文还是中文，在看文章时经常会遇到查找某个单词或字组的时候，把一篇文章看作是一个大的字符串，要查找的内容作为子串，这种在大串中查找子串的操作叫做串的模式匹配。\n\n我们知道了这种行为叫串的模式匹配，但我们不清楚的是到底如何匹配，具体的操作是什么？\n\n# 0x01 我如何操作\n\n在我看来要从大串中寻找子串，最直接的方法就是从大串起始位置开始，挨个字符比对，如果存在子串总会找出来。这种简单直接的方法称为 **朴素的模式匹配算法**\n\n# 0x02 代码实现\n\n如果借用字符串截取操作，直接实现子串的查找就比较方便：\n\n```\n\tpublic static int index(String s, String t, int pos) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\twhile (pos <= (m - n + 1)) {\n\t\t\tString sub = s.substring(pos, n);\n\t\t\t//直接在对比位置截取和子串相同长度的一个串来和子串对比\n\t\t\tif (t.equals(sub)) {\n\t\t\t\treturn pos;\n\t\t\t} else {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n```\n\n\n\n\n\n\n\n","slug":"算法之朴素模式匹配","published":1,"updated":"2017-05-25T09:47:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjld008xwh9c587xbwee","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>不论英文还是中文，在看文章时经常会遇到查找某个单词或字组的时候，把一篇文章看作是一个大的字符串，要查找的内容作为子串，这种在大串中查找子串的操作叫做串的模式匹配。</p>\n<p>我们知道了这种行为叫串的模式匹配，但我们不清楚的是到底如何匹配，具体的操作是什么？</p>\n<h1 id=\"0x01-我如何操作\"><a href=\"#0x01-我如何操作\" class=\"headerlink\" title=\"0x01 我如何操作\"></a>0x01 我如何操作</h1><p>在我看来要从大串中寻找子串，最直接的方法就是从大串起始位置开始，挨个字符比对，如果存在子串总会找出来。这种简单直接的方法称为 <strong>朴素的模式匹配算法</strong></p>\n<h1 id=\"0x02-代码实现\"><a href=\"#0x02-代码实现\" class=\"headerlink\" title=\"0x02 代码实现\"></a>0x02 代码实现</h1><p>如果借用字符串截取操作，直接实现子串的查找就比较方便：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int index(String s, String t, int pos) &#123;</div><div class=\"line\">\tint m = s.length();</div><div class=\"line\">\tint n = t.length();</div><div class=\"line\">\twhile (pos &lt;= (m - n + 1)) &#123;</div><div class=\"line\">\t\tString sub = s.substring(pos, n);</div><div class=\"line\">\t\t//直接在对比位置截取和子串相同长度的一个串来和子串对比</div><div class=\"line\">\t\tif (t.equals(sub)) &#123;</div><div class=\"line\">\t\t\treturn pos;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tpos++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>不论英文还是中文，在看文章时经常会遇到查找某个单词或字组的时候，把一篇文章看作是一个大的字符串，要查找的内容作为子串，这种在大串中查找子串的操作叫做串的模式匹配。</p>\n<p>我们知道了这种行为叫串的模式匹配，但我们不清楚的是到底如何匹配，具体的操作是什么？</p>\n<h1 id=\"0x01-我如何操作\"><a href=\"#0x01-我如何操作\" class=\"headerlink\" title=\"0x01 我如何操作\"></a>0x01 我如何操作</h1><p>在我看来要从大串中寻找子串，最直接的方法就是从大串起始位置开始，挨个字符比对，如果存在子串总会找出来。这种简单直接的方法称为 <strong>朴素的模式匹配算法</strong></p>\n<h1 id=\"0x02-代码实现\"><a href=\"#0x02-代码实现\" class=\"headerlink\" title=\"0x02 代码实现\"></a>0x02 代码实现</h1><p>如果借用字符串截取操作，直接实现子串的查找就比较方便：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int index(String s, String t, int pos) &#123;</div><div class=\"line\">\tint m = s.length();</div><div class=\"line\">\tint n = t.length();</div><div class=\"line\">\twhile (pos &lt;= (m - n + 1)) &#123;</div><div class=\"line\">\t\tString sub = s.substring(pos, n);</div><div class=\"line\">\t\t//直接在对比位置截取和子串相同长度的一个串来和子串对比</div><div class=\"line\">\t\tif (t.equals(sub)) &#123;</div><div class=\"line\">\t\t\treturn pos;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tpos++;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"设计一个有获取元素最小值getMin的栈","date":"2017-05-17T08:24:42.000Z","_content":"\n# 0x00 前言\n\n栈可以看成一个瓶子，只有一个口，另一端被封底。这样数据进出都只能从一个口经过。这样就导致的一个直接结果就是数据FILO问题。要找到栈中最小数据，单靠一个栈不能完成，需要外部提供辅助。\n\n# 0x01 分析\n\n\n\n一个存好数据的栈，要从里面找到最小数值，不可避免的要把数据出栈，然后进行对比。这时有个问题就来了，找到最小数值后，其他数据还有用吗？换句话说，其他数据还要不要了？如果不要的话，比较完成后不用再次存储，如果要德话，比较期间还要注意数据的保存。这里注意要分这两种情况来考虑。\n\n# 0x02 不要其他数据的实现\n\n既然不需要其他数据，那就直接把数据弹出栈就好了，每次弹栈时对比临时值，如果当前弹栈数据比临时值大则直接弹栈，否则就把值赋给临时值。\n\n```\npublic class StackMin {\n\tprivate Stack<Integer> stack = new Stack<>();\n\n\tpublic int getStackMin() {\n\t\tint min = 0;\n\t\twhile (!stack.isEmpty()) {\n\t\t\tint current = stack.pop();\n\t\t\tif (min != 0) {\n\t\t\t\tif (min > current) {\n\t\t\t\t\tmin = current;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = current;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStackMin stackMin = new StackMin();\n\t\tstackMin.stack.push(9);\n\t\tstackMin.stack.push(5);\n\t\tstackMin.stack.push(2);\n\t\tstackMin.stack.push(7);\n\t\tSystem.out.println(stackMin.getStackMin());\n\t}\n}\n\n```\n\n这里代码只实现了getStackMin方法，栈的其他方法就直接定义一个方法后直接调用Stack方法即可。\n\n# 0x03 需要其他数据的实现\n\n如果要保留栈的数据，那最直接的想法是在弹栈比较期间，把弹出栈的数据顺路给入道一个新的栈中，这里相比上面，需要多一个栈即可实现。\n\n```\npublic class StackMin {\n\tprivate Stack<Integer> stack = new Stack<>();\n\tprivate Stack<Integer> backUp = new Stack<>();//备份栈\n\n\tpublic int getStackMin() {\n\t\tint min = 0;\n\t\twhile (!stack.isEmpty()) {\n\t\t\tint current = stack.pop();\n\t\t\tif (min != 0) {\n\t\t\t\tif (min > current) {\n\t\t\t\t\tmin = current;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = current;\n\t\t\t}\n\t\t\tbackUp.push(current);//弹出栈时进入备份栈\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStackMin stackMin = new StackMin();\n\t\tstackMin.stack.push(9);\n\t\tstackMin.stack.push(5);\n\t\tstackMin.stack.push(2);\n\t\tstackMin.stack.push(7);\n\t\tSystem.out.println(stackMin.getStackMin());\n\t}\n}\n\n```\n\n","source":"_posts/设计一个有获取元素最小值getMin的栈.md","raw":"---\ntitle: 设计一个有获取元素最小值getMin的栈\ndate: 2017-05-17 16:24:42\ntags: 算法\ncategories: 算法\n---\n\n# 0x00 前言\n\n栈可以看成一个瓶子，只有一个口，另一端被封底。这样数据进出都只能从一个口经过。这样就导致的一个直接结果就是数据FILO问题。要找到栈中最小数据，单靠一个栈不能完成，需要外部提供辅助。\n\n# 0x01 分析\n\n\n\n一个存好数据的栈，要从里面找到最小数值，不可避免的要把数据出栈，然后进行对比。这时有个问题就来了，找到最小数值后，其他数据还有用吗？换句话说，其他数据还要不要了？如果不要的话，比较完成后不用再次存储，如果要德话，比较期间还要注意数据的保存。这里注意要分这两种情况来考虑。\n\n# 0x02 不要其他数据的实现\n\n既然不需要其他数据，那就直接把数据弹出栈就好了，每次弹栈时对比临时值，如果当前弹栈数据比临时值大则直接弹栈，否则就把值赋给临时值。\n\n```\npublic class StackMin {\n\tprivate Stack<Integer> stack = new Stack<>();\n\n\tpublic int getStackMin() {\n\t\tint min = 0;\n\t\twhile (!stack.isEmpty()) {\n\t\t\tint current = stack.pop();\n\t\t\tif (min != 0) {\n\t\t\t\tif (min > current) {\n\t\t\t\t\tmin = current;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = current;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStackMin stackMin = new StackMin();\n\t\tstackMin.stack.push(9);\n\t\tstackMin.stack.push(5);\n\t\tstackMin.stack.push(2);\n\t\tstackMin.stack.push(7);\n\t\tSystem.out.println(stackMin.getStackMin());\n\t}\n}\n\n```\n\n这里代码只实现了getStackMin方法，栈的其他方法就直接定义一个方法后直接调用Stack方法即可。\n\n# 0x03 需要其他数据的实现\n\n如果要保留栈的数据，那最直接的想法是在弹栈比较期间，把弹出栈的数据顺路给入道一个新的栈中，这里相比上面，需要多一个栈即可实现。\n\n```\npublic class StackMin {\n\tprivate Stack<Integer> stack = new Stack<>();\n\tprivate Stack<Integer> backUp = new Stack<>();//备份栈\n\n\tpublic int getStackMin() {\n\t\tint min = 0;\n\t\twhile (!stack.isEmpty()) {\n\t\t\tint current = stack.pop();\n\t\t\tif (min != 0) {\n\t\t\t\tif (min > current) {\n\t\t\t\t\tmin = current;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = current;\n\t\t\t}\n\t\t\tbackUp.push(current);//弹出栈时进入备份栈\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStackMin stackMin = new StackMin();\n\t\tstackMin.stack.push(9);\n\t\tstackMin.stack.push(5);\n\t\tstackMin.stack.push(2);\n\t\tstackMin.stack.push(7);\n\t\tSystem.out.println(stackMin.getStackMin());\n\t}\n}\n\n```\n\n","slug":"设计一个有获取元素最小值getMin的栈","published":1,"updated":"2017-05-18T08:28:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj66nwjme00afwh9cr62khni7","content":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>栈可以看成一个瓶子，只有一个口，另一端被封底。这样数据进出都只能从一个口经过。这样就导致的一个直接结果就是数据FILO问题。要找到栈中最小数据，单靠一个栈不能完成，需要外部提供辅助。</p>\n<h1 id=\"0x01-分析\"><a href=\"#0x01-分析\" class=\"headerlink\" title=\"0x01 分析\"></a>0x01 分析</h1><p>一个存好数据的栈，要从里面找到最小数值，不可避免的要把数据出栈，然后进行对比。这时有个问题就来了，找到最小数值后，其他数据还有用吗？换句话说，其他数据还要不要了？如果不要的话，比较完成后不用再次存储，如果要德话，比较期间还要注意数据的保存。这里注意要分这两种情况来考虑。</p>\n<h1 id=\"0x02-不要其他数据的实现\"><a href=\"#0x02-不要其他数据的实现\" class=\"headerlink\" title=\"0x02 不要其他数据的实现\"></a>0x02 不要其他数据的实现</h1><p>既然不需要其他数据，那就直接把数据弹出栈就好了，每次弹栈时对比临时值，如果当前弹栈数据比临时值大则直接弹栈，否则就把值赋给临时值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class StackMin &#123;</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\tpublic int getStackMin() &#123;</div><div class=\"line\">\t\tint min = 0;</div><div class=\"line\">\t\twhile (!stack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tint current = stack.pop();</div><div class=\"line\">\t\t\tif (min != 0) &#123;</div><div class=\"line\">\t\t\t\tif (min &gt; current) &#123;</div><div class=\"line\">\t\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn min;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tStackMin stackMin = new StackMin();</div><div class=\"line\">\t\tstackMin.stack.push(9);</div><div class=\"line\">\t\tstackMin.stack.push(5);</div><div class=\"line\">\t\tstackMin.stack.push(2);</div><div class=\"line\">\t\tstackMin.stack.push(7);</div><div class=\"line\">\t\tSystem.out.println(stackMin.getStackMin());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里代码只实现了getStackMin方法，栈的其他方法就直接定义一个方法后直接调用Stack方法即可。</p>\n<h1 id=\"0x03-需要其他数据的实现\"><a href=\"#0x03-需要其他数据的实现\" class=\"headerlink\" title=\"0x03 需要其他数据的实现\"></a>0x03 需要其他数据的实现</h1><p>如果要保留栈的数据，那最直接的想法是在弹栈比较期间，把弹出栈的数据顺路给入道一个新的栈中，这里相比上面，需要多一个栈即可实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class StackMin &#123;</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; backUp = new Stack&lt;&gt;();//备份栈</div><div class=\"line\"></div><div class=\"line\">\tpublic int getStackMin() &#123;</div><div class=\"line\">\t\tint min = 0;</div><div class=\"line\">\t\twhile (!stack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tint current = stack.pop();</div><div class=\"line\">\t\t\tif (min != 0) &#123;</div><div class=\"line\">\t\t\t\tif (min &gt; current) &#123;</div><div class=\"line\">\t\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tbackUp.push(current);//弹出栈时进入备份栈</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn min;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tStackMin stackMin = new StackMin();</div><div class=\"line\">\t\tstackMin.stack.push(9);</div><div class=\"line\">\t\tstackMin.stack.push(5);</div><div class=\"line\">\t\tstackMin.stack.push(2);</div><div class=\"line\">\t\tstackMin.stack.push(7);</div><div class=\"line\">\t\tSystem.out.println(stackMin.getStackMin());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h1><p>栈可以看成一个瓶子，只有一个口，另一端被封底。这样数据进出都只能从一个口经过。这样就导致的一个直接结果就是数据FILO问题。要找到栈中最小数据，单靠一个栈不能完成，需要外部提供辅助。</p>\n<h1 id=\"0x01-分析\"><a href=\"#0x01-分析\" class=\"headerlink\" title=\"0x01 分析\"></a>0x01 分析</h1><p>一个存好数据的栈，要从里面找到最小数值，不可避免的要把数据出栈，然后进行对比。这时有个问题就来了，找到最小数值后，其他数据还有用吗？换句话说，其他数据还要不要了？如果不要的话，比较完成后不用再次存储，如果要德话，比较期间还要注意数据的保存。这里注意要分这两种情况来考虑。</p>\n<h1 id=\"0x02-不要其他数据的实现\"><a href=\"#0x02-不要其他数据的实现\" class=\"headerlink\" title=\"0x02 不要其他数据的实现\"></a>0x02 不要其他数据的实现</h1><p>既然不需要其他数据，那就直接把数据弹出栈就好了，每次弹栈时对比临时值，如果当前弹栈数据比临时值大则直接弹栈，否则就把值赋给临时值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class StackMin &#123;</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\tpublic int getStackMin() &#123;</div><div class=\"line\">\t\tint min = 0;</div><div class=\"line\">\t\twhile (!stack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tint current = stack.pop();</div><div class=\"line\">\t\t\tif (min != 0) &#123;</div><div class=\"line\">\t\t\t\tif (min &gt; current) &#123;</div><div class=\"line\">\t\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn min;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tStackMin stackMin = new StackMin();</div><div class=\"line\">\t\tstackMin.stack.push(9);</div><div class=\"line\">\t\tstackMin.stack.push(5);</div><div class=\"line\">\t\tstackMin.stack.push(2);</div><div class=\"line\">\t\tstackMin.stack.push(7);</div><div class=\"line\">\t\tSystem.out.println(stackMin.getStackMin());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里代码只实现了getStackMin方法，栈的其他方法就直接定义一个方法后直接调用Stack方法即可。</p>\n<h1 id=\"0x03-需要其他数据的实现\"><a href=\"#0x03-需要其他数据的实现\" class=\"headerlink\" title=\"0x03 需要其他数据的实现\"></a>0x03 需要其他数据的实现</h1><p>如果要保留栈的数据，那最直接的想法是在弹栈比较期间，把弹出栈的数据顺路给入道一个新的栈中，这里相比上面，需要多一个栈即可实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class StackMin &#123;</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</div><div class=\"line\">\tprivate Stack&lt;Integer&gt; backUp = new Stack&lt;&gt;();//备份栈</div><div class=\"line\"></div><div class=\"line\">\tpublic int getStackMin() &#123;</div><div class=\"line\">\t\tint min = 0;</div><div class=\"line\">\t\twhile (!stack.isEmpty()) &#123;</div><div class=\"line\">\t\t\tint current = stack.pop();</div><div class=\"line\">\t\t\tif (min != 0) &#123;</div><div class=\"line\">\t\t\t\tif (min &gt; current) &#123;</div><div class=\"line\">\t\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tmin = current;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tbackUp.push(current);//弹出栈时进入备份栈</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn min;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tpublic static void main(String[] args) &#123;</div><div class=\"line\">\t\tStackMin stackMin = new StackMin();</div><div class=\"line\">\t\tstackMin.stack.push(9);</div><div class=\"line\">\t\tstackMin.stack.push(5);</div><div class=\"line\">\t\tstackMin.stack.push(2);</div><div class=\"line\">\t\tstackMin.stack.push(7);</div><div class=\"line\">\t\tSystem.out.println(stackMin.getStackMin());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"Python操作xml","date":"2017-08-13T08:30:54.000Z","_content":"\n# 前言\n\nxml和json是客户端和服务端进行数据交互的常用格式。所以掌握这些数据格式的解析是很必要的。python提供了两种xml解析方法。一种是常见的行业标准做法：sax和dom解析，另一种是python特有的解析方法，而在标准库中ElementTree首先推荐。\n\n# ElementTree模块\n\n## 导入模块\n\n```python\nfrom xml.etree.ElementTree import ElementTree, parse as eleParse, Element\nfrom urllib import request, parse\n```\n\n## 开始解析\n\n通过数据源，创建**ElementTree**。这里使用模块中的**parse**方法。\n\n```python\ndoc = parse(source=source)\n```\n\n**这里的参数source是一个文件名或者包含xml数据的文件对象。**\n\n## 常用方法\n\n`doc.findtext('username')`返回指定标签的元素文本\n\n`doc.iterfind('category')`返回所有匹配子元素\n\n`doc.findall(path)`返回所有匹配子元素\n\n`item.attrib['id']`返回元素属性，这里的item是Element对象\n\n\n\n# DOM模块\n\n\n\n\n\n# SAX模块\n\n","source":"_posts/Python操作xml.md","raw":"---\ntitle: Python操作xml\ndate: 2017-08-13 16:30:54\ntags: Python\ncategories: Python\n---\n\n# 前言\n\nxml和json是客户端和服务端进行数据交互的常用格式。所以掌握这些数据格式的解析是很必要的。python提供了两种xml解析方法。一种是常见的行业标准做法：sax和dom解析，另一种是python特有的解析方法，而在标准库中ElementTree首先推荐。\n\n# ElementTree模块\n\n## 导入模块\n\n```python\nfrom xml.etree.ElementTree import ElementTree, parse as eleParse, Element\nfrom urllib import request, parse\n```\n\n## 开始解析\n\n通过数据源，创建**ElementTree**。这里使用模块中的**parse**方法。\n\n```python\ndoc = parse(source=source)\n```\n\n**这里的参数source是一个文件名或者包含xml数据的文件对象。**\n\n## 常用方法\n\n`doc.findtext('username')`返回指定标签的元素文本\n\n`doc.iterfind('category')`返回所有匹配子元素\n\n`doc.findall(path)`返回所有匹配子元素\n\n`item.attrib['id']`返回元素属性，这里的item是Element对象\n\n\n\n# DOM模块\n\n\n\n\n\n# SAX模块\n\n","slug":"Python操作xml","published":1,"updated":"2017-08-15T08:45:46.000Z","_id":"cj6d7hm6g0000rk9cuzbdsdfm","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>xml和json是客户端和服务端进行数据交互的常用格式。所以掌握这些数据格式的解析是很必要的。python提供了两种xml解析方法。一种是常见的行业标准做法：sax和dom解析，另一种是python特有的解析方法，而在标准库中ElementTree首先推荐。</p>\n<h1 id=\"ElementTree模块\"><a href=\"#ElementTree模块\" class=\"headerlink\" title=\"ElementTree模块\"></a>ElementTree模块</h1><h2 id=\"导入模块\"><a href=\"#导入模块\" class=\"headerlink\" title=\"导入模块\"></a>导入模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> xml.etree.ElementTree <span class=\"keyword\">import</span> ElementTree, parse <span class=\"keyword\">as</span> eleParse, Element</div><div class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request, parse</div></pre></td></tr></table></figure>\n<h2 id=\"开始解析\"><a href=\"#开始解析\" class=\"headerlink\" title=\"开始解析\"></a>开始解析</h2><p>通过数据源，创建<strong>ElementTree</strong>。这里使用模块中的<strong>parse</strong>方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">doc = parse(source=source)</div></pre></td></tr></table></figure>\n<p><strong>这里的参数source是一个文件名或者包含xml数据的文件对象。</strong></p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><p><code>doc.findtext(&#39;username&#39;)</code>返回指定标签的元素文本</p>\n<p><code>doc.iterfind(&#39;category&#39;)</code>返回所有匹配子元素</p>\n<p><code>doc.findall(path)</code>返回所有匹配子元素</p>\n<p><code>item.attrib[&#39;id&#39;]</code>返回元素属性，这里的item是Element对象</p>\n<h1 id=\"DOM模块\"><a href=\"#DOM模块\" class=\"headerlink\" title=\"DOM模块\"></a>DOM模块</h1><h1 id=\"SAX模块\"><a href=\"#SAX模块\" class=\"headerlink\" title=\"SAX模块\"></a>SAX模块</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>xml和json是客户端和服务端进行数据交互的常用格式。所以掌握这些数据格式的解析是很必要的。python提供了两种xml解析方法。一种是常见的行业标准做法：sax和dom解析，另一种是python特有的解析方法，而在标准库中ElementTree首先推荐。</p>\n<h1 id=\"ElementTree模块\"><a href=\"#ElementTree模块\" class=\"headerlink\" title=\"ElementTree模块\"></a>ElementTree模块</h1><h2 id=\"导入模块\"><a href=\"#导入模块\" class=\"headerlink\" title=\"导入模块\"></a>导入模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> xml.etree.ElementTree <span class=\"keyword\">import</span> ElementTree, parse <span class=\"keyword\">as</span> eleParse, Element</div><div class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request, parse</div></pre></td></tr></table></figure>\n<h2 id=\"开始解析\"><a href=\"#开始解析\" class=\"headerlink\" title=\"开始解析\"></a>开始解析</h2><p>通过数据源，创建<strong>ElementTree</strong>。这里使用模块中的<strong>parse</strong>方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">doc = parse(source=source)</div></pre></td></tr></table></figure>\n<p><strong>这里的参数source是一个文件名或者包含xml数据的文件对象。</strong></p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><p><code>doc.findtext(&#39;username&#39;)</code>返回指定标签的元素文本</p>\n<p><code>doc.iterfind(&#39;category&#39;)</code>返回所有匹配子元素</p>\n<p><code>doc.findall(path)</code>返回所有匹配子元素</p>\n<p><code>item.attrib[&#39;id&#39;]</code>返回元素属性，这里的item是Element对象</p>\n<h1 id=\"DOM模块\"><a href=\"#DOM模块\" class=\"headerlink\" title=\"DOM模块\"></a>DOM模块</h1><h1 id=\"SAX模块\"><a href=\"#SAX模块\" class=\"headerlink\" title=\"SAX模块\"></a>SAX模块</h1>"},{"title":"Python使用MD5","date":"2017-08-13T09:17:54.000Z","_content":"\n# 前言\n\n最近接口测试时用到了md5加密，接口是给app端调用的，但是用java做比较麻烦。所以干脆使用Python来调试好了。\n\n# 使用\n\n## 方法一：使用`from hashlib import md5`模块\n\n```python\n md5_ = md5()\n md5_.update((mac + as_token).encode('utf-8'))\n print(md5_.hexdigest())\n```\n\n**这个update方法需要编码后传入，否则抛异常**\n\n## 方法二：直接使用`import md5`模块\n\n```python\nimport md5\nm = md5.new()\ns = \"hahaha\"\nm.update(s)\nprint (m.degest())\nprint (m.hexdigest()) #返回结果\n```\n\n网上很多人说可以使用这个模块，但是在我的Python3.6版本中，md5这个模块变成了保留模块。\n\n所以推荐使用方法一。","source":"_posts/Python使用MD5.md","raw":"---\ntitle: Python使用MD5\ndate: 2017-08-13 17:17:54\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n最近接口测试时用到了md5加密，接口是给app端调用的，但是用java做比较麻烦。所以干脆使用Python来调试好了。\n\n# 使用\n\n## 方法一：使用`from hashlib import md5`模块\n\n```python\n md5_ = md5()\n md5_.update((mac + as_token).encode('utf-8'))\n print(md5_.hexdigest())\n```\n\n**这个update方法需要编码后传入，否则抛异常**\n\n## 方法二：直接使用`import md5`模块\n\n```python\nimport md5\nm = md5.new()\ns = \"hahaha\"\nm.update(s)\nprint (m.degest())\nprint (m.hexdigest()) #返回结果\n```\n\n网上很多人说可以使用这个模块，但是在我的Python3.6版本中，md5这个模块变成了保留模块。\n\n所以推荐使用方法一。","slug":"Python使用MD5","published":1,"updated":"2017-08-13T09:28:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6d7hm6k0001rk9cyhkeazj5","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近接口测试时用到了md5加密，接口是给app端调用的，但是用java做比较麻烦。所以干脆使用Python来调试好了。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"方法一：使用from-hashlib-import-md5模块\"><a href=\"#方法一：使用from-hashlib-import-md5模块\" class=\"headerlink\" title=\"方法一：使用from hashlib import md5模块\"></a>方法一：使用<code>from hashlib import md5</code>模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">md5_ = md5()</div><div class=\"line\">md5_.update((mac + as_token).encode(<span class=\"string\">'utf-8'</span>))</div><div class=\"line\">print(md5_.hexdigest())</div></pre></td></tr></table></figure>\n<p><strong>这个update方法需要编码后传入，否则抛异常</strong></p>\n<h2 id=\"方法二：直接使用import-md5模块\"><a href=\"#方法二：直接使用import-md5模块\" class=\"headerlink\" title=\"方法二：直接使用import md5模块\"></a>方法二：直接使用<code>import md5</code>模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> md5</div><div class=\"line\">m = md5.new()</div><div class=\"line\">s = <span class=\"string\">\"hahaha\"</span></div><div class=\"line\">m.update(s)</div><div class=\"line\"><span class=\"keyword\">print</span> (m.degest())</div><div class=\"line\"><span class=\"keyword\">print</span> (m.hexdigest()) <span class=\"comment\">#返回结果</span></div></pre></td></tr></table></figure>\n<p>网上很多人说可以使用这个模块，但是在我的Python3.6版本中，md5这个模块变成了保留模块。</p>\n<p>所以推荐使用方法一。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近接口测试时用到了md5加密，接口是给app端调用的，但是用java做比较麻烦。所以干脆使用Python来调试好了。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"方法一：使用from-hashlib-import-md5模块\"><a href=\"#方法一：使用from-hashlib-import-md5模块\" class=\"headerlink\" title=\"方法一：使用from hashlib import md5模块\"></a>方法一：使用<code>from hashlib import md5</code>模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">md5_ = md5()</div><div class=\"line\">md5_.update((mac + as_token).encode(<span class=\"string\">'utf-8'</span>))</div><div class=\"line\">print(md5_.hexdigest())</div></pre></td></tr></table></figure>\n<p><strong>这个update方法需要编码后传入，否则抛异常</strong></p>\n<h2 id=\"方法二：直接使用import-md5模块\"><a href=\"#方法二：直接使用import-md5模块\" class=\"headerlink\" title=\"方法二：直接使用import md5模块\"></a>方法二：直接使用<code>import md5</code>模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> md5</div><div class=\"line\">m = md5.new()</div><div class=\"line\">s = <span class=\"string\">\"hahaha\"</span></div><div class=\"line\">m.update(s)</div><div class=\"line\"><span class=\"keyword\">print</span> (m.degest())</div><div class=\"line\"><span class=\"keyword\">print</span> (m.hexdigest()) <span class=\"comment\">#返回结果</span></div></pre></td></tr></table></figure>\n<p>网上很多人说可以使用这个模块，但是在我的Python3.6版本中，md5这个模块变成了保留模块。</p>\n<p>所以推荐使用方法一。</p>\n"},{"title":"bytes和str转换","date":"2017-08-13T08:27:54.000Z","_content":"\n# 前言\n\n日常开发中很多时候要用到bytes和str的互相转换，每次都查浪费时间。干脆整理一次记在脑子里。\n\n# bytes转str\n\n- 默认解码 bytes.decode()\n- gbk方式解码 bytes.decode(‘gbk’)\n\n# str转bytes\n\n- utf8方式编码 str.encode(encoding=\"utf-8\")\n- gbk方式编码 str.encode(encoding=\"gbk\")","source":"_posts/bytes和str转换.md","raw":"---\ntitle: bytes和str转换\ndate: 2017-08-13 16:27:54\ntags: Python\ncategories: Python\n---\n\n# 前言\n\n日常开发中很多时候要用到bytes和str的互相转换，每次都查浪费时间。干脆整理一次记在脑子里。\n\n# bytes转str\n\n- 默认解码 bytes.decode()\n- gbk方式解码 bytes.decode(‘gbk’)\n\n# str转bytes\n\n- utf8方式编码 str.encode(encoding=\"utf-8\")\n- gbk方式编码 str.encode(encoding=\"gbk\")","slug":"bytes和str转换","published":1,"updated":"2017-08-13T09:16:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6d7hm9c0003rk9cp5tk13sv","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>日常开发中很多时候要用到bytes和str的互相转换，每次都查浪费时间。干脆整理一次记在脑子里。</p>\n<h1 id=\"bytes转str\"><a href=\"#bytes转str\" class=\"headerlink\" title=\"bytes转str\"></a>bytes转str</h1><ul>\n<li>默认解码 bytes.decode()</li>\n<li>gbk方式解码 bytes.decode(‘gbk’)</li>\n</ul>\n<h1 id=\"str转bytes\"><a href=\"#str转bytes\" class=\"headerlink\" title=\"str转bytes\"></a>str转bytes</h1><ul>\n<li>utf8方式编码 str.encode(encoding=”utf-8”)</li>\n<li>gbk方式编码 str.encode(encoding=”gbk”)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>日常开发中很多时候要用到bytes和str的互相转换，每次都查浪费时间。干脆整理一次记在脑子里。</p>\n<h1 id=\"bytes转str\"><a href=\"#bytes转str\" class=\"headerlink\" title=\"bytes转str\"></a>bytes转str</h1><ul>\n<li>默认解码 bytes.decode()</li>\n<li>gbk方式解码 bytes.decode(‘gbk’)</li>\n</ul>\n<h1 id=\"str转bytes\"><a href=\"#str转bytes\" class=\"headerlink\" title=\"str转bytes\"></a>str转bytes</h1><ul>\n<li>utf8方式编码 str.encode(encoding=”utf-8”)</li>\n<li>gbk方式编码 str.encode(encoding=”gbk”)</li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.22.23.png","slug":"屏幕快照 2017-04-27 下午3.22.23.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/为什么每一个IT人员应该有一把人体工学电脑椅/58f074a8N70fcfb6a.jpg","slug":"58f074a8N70fcfb6a.jpg","post":"cj66nwji00061wh9ciarvcq2f","modified":0,"renderable":0},{"_id":"source/_posts/Android网络框架执行流程分析/流程.png","slug":"流程.png","post":"cj66nwjdg0029wh9cxn6c7eus","modified":0,"renderable":0},{"_id":"source/_posts/Mac终端光标变成粗体/设置光标.png","slug":"设置光标.png","post":"cj66nwjdo002hwh9cieox1an1","modified":0,"renderable":0},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112391191.jpg","slug":"mmexport1493112391191.jpg","post":"cj66nwj9d0008wh9cd1h3hylv","modified":0,"renderable":0},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112393720.jpg","slug":"mmexport1493112393720.jpg","post":"cj66nwj9d0008wh9cd1h3hylv","modified":0,"renderable":0},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112396013.jpg","slug":"mmexport1493112396013.jpg","post":"cj66nwj9d0008wh9cd1h3hylv","modified":0,"renderable":0},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112398170.jpg","slug":"mmexport1493112398170.jpg","post":"cj66nwj9d0008wh9cd1h3hylv","modified":0,"renderable":0},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112400267.jpg","slug":"mmexport1493112400267.jpg","post":"cj66nwj9d0008wh9cd1h3hylv","modified":0,"renderable":0},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112402523.jpg","slug":"mmexport1493112402523.jpg","post":"cj66nwj9d0008wh9cd1h3hylv","modified":0,"renderable":0},{"_id":"source/_posts/2016圆明园荷花节/mmexport1493112405316.jpg","slug":"mmexport1493112405316.jpg","post":"cj66nwj9d0008wh9cd1h3hylv","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb.jpeg","slug":"psb.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb1.jpeg","slug":"psb1.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb2.jpeg","slug":"psb2.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb3.jpeg","slug":"psb3.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb4.jpeg","slug":"psb4.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb5.jpeg","slug":"psb5.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb6.jpeg","slug":"psb6.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/2015圆明园荷花节/psb7.jpeg","slug":"psb7.jpeg","post":"cj66nwj780001wh9cdlsi9d46","modified":0,"renderable":0},{"_id":"source/_posts/Android内存分析工具之MAT详解/0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png","slug":"0B8D42B7-E5A5-431D-9658-2A99C923CF4E.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/Android内存分析工具之MAT详解/1A94CD89-1BE9-46BC-9449-8B55EE34D741.png","slug":"1A94CD89-1BE9-46BC-9449-8B55EE34D741.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午1.49.26.png","slug":"屏幕快照 2017-04-27 下午1.49.26.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.08.27.png","slug":"屏幕快照 2017-04-27 下午2.08.27.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午2.21.48.png","slug":"屏幕快照 2017-04-27 下午2.21.48.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.11.33.png","slug":"屏幕快照 2017-04-27 下午3.11.33.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/Android内存分析工具之MAT详解/屏幕快照 2017-04-27 下午3.19.06.png","slug":"屏幕快照 2017-04-27 下午3.19.06.png","post":"cj66nwj9p0009wh9ce9kc2y61","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午10.29.17.png","slug":"屏幕快照 2017-04-24 下午10.29.17.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.04.06.png","slug":"屏幕快照 2017-04-24 下午11.04.06.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.14.36.png","slug":"屏幕快照 2017-04-24 下午11.14.36.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午11.57.46.png","slug":"屏幕快照 2017-04-24 下午11.57.46.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-24 下午9.57.43.png","slug":"屏幕快照 2017-04-24 下午9.57.43.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 上午12.26.47.png","slug":"屏幕快照 2017-04-25 上午12.26.47.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 上午9.49.56.png","slug":"屏幕快照 2017-04-25 上午9.49.56.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午12.56.36.png","slug":"屏幕快照 2017-04-25 下午12.56.36.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/Android开发之JNI深入解析/屏幕快照 2017-04-25 下午2.54.18.png","slug":"屏幕快照 2017-04-25 下午2.54.18.png","post":"cj66nwjbo000kwh9cpbkb80wu","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610075354_IMG_6200.JPG","slug":"20160610075354_IMG_6200.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610075557_IMG_6209.JPG","slug":"20160610075557_IMG_6209.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610075842_IMG_6219.JPG","slug":"20160610075842_IMG_6219.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610080912_IMG_6235.JPG","slug":"20160610080912_IMG_6235.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610081259_IMG_6245.JPG","slug":"20160610081259_IMG_6245.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610082906_IMG_6261.JPG","slug":"20160610082906_IMG_6261.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610083541_IMG_6276.JPG","slug":"20160610083541_IMG_6276.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610084538_IMG_6283.JPG","slug":"20160610084538_IMG_6283.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610091441_IMG_6323.JPG","slug":"20160610091441_IMG_6323.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610095757_IMG_6325.JPG","slug":"20160610095757_IMG_6325.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610100357_IMG_6326.JPG","slug":"20160610100357_IMG_6326.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610101211_IMG_6337.JPG","slug":"20160610101211_IMG_6337.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610101300_IMG_6342.JPG","slug":"20160610101300_IMG_6342.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610101355_IMG_6343.JPG","slug":"20160610101355_IMG_6343.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610102213_IMG_6353.JPG","slug":"20160610102213_IMG_6353.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610104345_IMG_6371.JPG","slug":"20160610104345_IMG_6371.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/2016公司清明节坝上草原/20160610110010_IMG_6396.JPG","slug":"20160610110010_IMG_6396.JPG","post":"cj66nwjbx000uwh9cxwl7c0yi","modified":0,"renderable":0},{"_id":"source/_posts/hexo添加网易云音乐播放器/音乐界面.png","slug":"音乐界面.png","post":"cj66nwjgz0050wh9cn4ob401j","modified":0,"renderable":0},{"_id":"source/_posts/关于Intent那些事/请求流程.png","slug":"请求流程.png","post":"cj66nwjia006cwh9cdttfdwjf","modified":0,"renderable":0},{"_id":"source/_posts/为什么每一个IT人员应该有一把人体工学电脑椅/1918606_151944_1.gif","slug":"1918606_151944_1.gif","post":"cj66nwji00061wh9ciarvcq2f","modified":0,"renderable":0},{"_id":"source/_posts/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午4.21.27.png","slug":"屏幕快照 2017-05-10 下午4.21.27.png","post":"cj66nwjla008uwh9ctvqbdxl7","modified":0,"renderable":0},{"_id":"source/_posts/详解设计模式之责任链模式/屏幕快照 2017-05-10 下午5.17.19.png","slug":"屏幕快照 2017-05-10 下午5.17.19.png","post":"cj66nwjla008uwh9ctvqbdxl7","modified":0,"renderable":0},{"_id":"source/_posts/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.33.13.png","slug":"屏幕快照 2017-04-25 下午3.33.13.png","post":"cj66nwjh30054wh9c880ff3xc","modified":0,"renderable":0},{"_id":"source/_posts/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.34.46.png","slug":"屏幕快照 2017-04-25 下午3.34.46.png","post":"cj66nwjh30054wh9c880ff3xc","modified":0,"renderable":0},{"_id":"source/_posts/hexo本地图片发布后不能显示的问题/屏幕快照 2017-04-25 下午3.45.37.png","slug":"屏幕快照 2017-04-25 下午3.45.37.png","post":"cj66nwjh30054wh9c880ff3xc","modified":0,"renderable":0},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化/lint.png","slug":"lint.png","post":"cj66nwjjz007owh9c3tso8on2","modified":0,"renderable":0},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化/lint_result.png","slug":"lint_result.png","post":"cj66nwjjz007owh9c3tso8on2","modified":0,"renderable":0},{"_id":"source/_posts/浅谈Android性能优化系列-1-之安装包大小优化/安装包构成.png","slug":"安装包构成.png","post":"cj66nwjjz007owh9c3tso8on2","modified":0,"renderable":0},{"_id":"source/_posts/用Python提取excel中有用数据/doc文档内容.png","slug":"doc文档内容.png","post":"cj66nwjka0083wh9cj7w31vxm","modified":0,"renderable":0},{"_id":"source/_posts/用Python提取excel中有用数据/创建项目.png","slug":"创建项目.png","post":"cj66nwjka0083wh9cj7w31vxm","modified":0,"renderable":0},{"_id":"source/_posts/用Python提取excel中有用数据/项目结果.png","slug":"项目结果.png","post":"cj66nwjka0083wh9cj7w31vxm","modified":0,"renderable":0},{"_id":"source/_posts/hexo更换主题及配置/menu配置.png","slug":"menu配置.png","post":"cj66nwjgc004hwh9comvoi62k","modified":0,"renderable":0},{"_id":"source/_posts/hexo更换主题及配置/关于我.png","slug":"关于我.png","post":"cj66nwjgc004hwh9comvoi62k","modified":0,"renderable":0},{"_id":"source/_posts/hexo更换主题及配置/打赏效果图.png","slug":"打赏效果图.png","post":"cj66nwjgc004hwh9comvoi62k","modified":0,"renderable":0},{"_id":"source/_posts/hexo更换主题及配置/换主题.png","slug":"换主题.png","post":"cj66nwjgc004hwh9comvoi62k","modified":0,"renderable":0},{"_id":"source/_posts/hexo更换主题及配置/模块缺失.png","slug":"模块缺失.png","post":"cj66nwjgc004hwh9comvoi62k","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj66nwj9d0008wh9cd1h3hylv","category_id":"cj66nwj7q0004wh9ci2ncsbuj","_id":"cj66nwjbl000ewh9c6btpethu"},{"post_id":"cj66nwj780001wh9cdlsi9d46","category_id":"cj66nwj7q0004wh9ci2ncsbuj","_id":"cj66nwjbo000jwh9c5d4388qo"},{"post_id":"cj66nwj7i0003wh9cfwbzn0mv","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwjbs000nwh9cy9joomc2"},{"post_id":"cj66nwjbo000kwh9cpbkb80wu","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjbw000swh9c6e21sx4c"},{"post_id":"cj66nwj810007wh9ca1yxr937","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjbz000xwh9cx085jhx6"},{"post_id":"cj66nwjbq000mwh9c0lrf6x3i","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjc30010wh9czhyvqoan"},{"post_id":"cj66nwjbu000rwh9cdg908awk","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjc70015wh9c440yv0bn"},{"post_id":"cj66nwj9p0009wh9ce9kc2y61","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjca0018wh9ccbzdtecd"},{"post_id":"cj66nwjbx000uwh9cxwl7c0yi","category_id":"cj66nwj7q0004wh9ci2ncsbuj","_id":"cj66nwjcc001bwh9crgz29koy"},{"post_id":"cj66nwjc0000zwh9ce4dx7txw","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjcj001gwh9cnby1qphw"},{"post_id":"cj66nwja5000dwh9cog2t6xju","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjco001jwh9ckm34vtu8"},{"post_id":"cj66nwjc50012wh9cjix7qj81","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjcq001mwh9ceeocvyg3"},{"post_id":"cj66nwjc80017wh9cyi5kuhgh","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjcv001rwh9cverjm1jv"},{"post_id":"cj66nwjbm000gwh9cjmkaes7g","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjd1001uwh9cf7qbhy09"},{"post_id":"cj66nwjca001awh9c3y5p2niu","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjd7001zwh9cua14kjak"},{"post_id":"cj66nwjcr001owh9co1zkx13j","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjda0022wh9cwhytvn9u"},{"post_id":"cj66nwjd1001wwh9cz2yajftu","category_id":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjdf0027wh9cov5rcepd"},{"post_id":"cj66nwjd80021wh9c6r3ht0zu","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjdi002awh9c7838humj"},{"post_id":"cj66nwjcm001iwh9cked65ckj","category_id":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjdn002fwh9ck9cc1nph"},{"post_id":"cj66nwjdg0029wh9cxn6c7eus","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjdr002iwh9c16hupr4e"},{"post_id":"cj66nwjco001lwh9ce3rz1a5r","category_id":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjdw002nwh9cnmpu2yh4"},{"post_id":"cj66nwjdo002hwh9cieox1an1","category_id":"cj66nwjdm002dwh9csy08ys7q","_id":"cj66nwjdy002qwh9cfyiz855b"},{"post_id":"cj66nwjcw001twh9cy77lz2mw","category_id":"cj66nwjdm002dwh9csy08ys7q","_id":"cj66nwje1002vwh9c6xe5lmrk"},{"post_id":"cj66nwjdr002kwh9c3zcfeyl5","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwje4002ywh9cs9500h3a"},{"post_id":"cj66nwjdw002pwh9cyyq023rd","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwje80031wh9cdszbdrpn"},{"post_id":"cj66nwjcf001dwh9cqtt8nlop","category_id":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjef0036wh9cdv1c7y31"},{"post_id":"cj66nwjcf001dwh9cqtt8nlop","category_id":"cj66nwjdv002lwh9cx8dx0ssr","_id":"cj66nwjek0039wh9c463k0fnj"},{"post_id":"cj66nwjdy002swh9cr9ry1c5g","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjeo003dwh9c3lyi3ua5"},{"post_id":"cj66nwje1002xwh9cdy6cs4hc","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjes003hwh9cfie8ltw0"},{"post_id":"cj66nwje40030wh9cr5h24d4y","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjex003lwh9ce3k8bmjo"},{"post_id":"cj66nwjda0024wh9cigvofhzo","category_id":"cj66nwje0002twh9c36i7kck7","_id":"cj66nwjf2003owh9c8rty4zco"},{"post_id":"cj66nwje90033wh9cfhi443al","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjf6003rwh9ckaf5nwc4"},{"post_id":"cj66nwjeg0038wh9cm1fp6ojd","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjfa003vwh9crosjnlp2"},{"post_id":"cj66nwjel003bwh9c9l09isiq","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjfe003zwh9cclwhkhut"},{"post_id":"cj66nwjeo003fwh9copbrxdij","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjfh0042wh9cv9hlf8am"},{"post_id":"cj66nwjes003jwh9ch8ly3wue","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjfk0047wh9cerw5on2z"},{"post_id":"cj66nwjdj002cwh9c0eavtrpy","category_id":"cj66nwjec0034wh9cqbtqbz36","_id":"cj66nwjfo004awh9csehsw0nz"},{"post_id":"cj66nwjdj002cwh9c0eavtrpy","category_id":"cj66nwjes003gwh9ct40r00y1","_id":"cj66nwjgc004fwh9co9dvw2rt"},{"post_id":"cj66nwjey003nwh9cwcuzdx9k","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjge004iwh9c99dsjpbb"},{"post_id":"cj66nwjf2003qwh9cjz06lvr1","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjgi004nwh9cvekw2m1w"},{"post_id":"cj66nwjf2003qwh9cjz06lvr1","category_id":"cj66nwjfd003ywh9c1aa12h36","_id":"cj66nwjgp004qwh9c5i7hfqll"},{"post_id":"cj66nwjf7003twh9coi7ug4c8","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjgv004vwh9cbol060kj"},{"post_id":"cj66nwjf7003twh9coi7ug4c8","category_id":"cj66nwjfd003ywh9c1aa12h36","_id":"cj66nwjgy004ywh9c9skskhrl"},{"post_id":"cj66nwjfp004cwh9cc0i2phzu","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwjh20052wh9cyt6oy6pq"},{"post_id":"cj66nwjgc004hwh9comvoi62k","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwjh60056wh9cxh4w0anp"},{"post_id":"cj66nwjfa003xwh9cplnpr6s2","category_id":"cj66nwjga004ewh9cb7uwghww","_id":"cj66nwjha0059wh9czfsko093"},{"post_id":"cj66nwjgi004pwh9cnsm2dql9","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwjhj005ewh9cauhctw1l"},{"post_id":"cj66nwjfe0041wh9cmg7pteb9","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjhn005hwh9codzzhcor"},{"post_id":"cj66nwjfe0041wh9cmg7pteb9","category_id":"cj66nwjgh004mwh9c8snxv8p3","_id":"cj66nwjhq005lwh9cszty9v5k"},{"post_id":"cj66nwjgp004swh9c5nzadn4q","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjhr005owh9cgekhzlxc"},{"post_id":"cj66nwjgw004xwh9ctm499ko9","category_id":"cj66nwjdm002dwh9csy08ys7q","_id":"cj66nwjht005rwh9cjynjn5fi"},{"post_id":"cj66nwjgz0050wh9cn4ob401j","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwjhv005uwh9ckfzmw72e"},{"post_id":"cj66nwjh30054wh9c880ff3xc","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwji0005zwh9cxz81o9gg"},{"post_id":"cj66nwjh60058wh9ceer6nz7b","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwji40062wh9co6kn5357"},{"post_id":"cj66nwjfl0049wh9ctq6xj5qe","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwji80065wh9cz04m5e2y"},{"post_id":"cj66nwjfl0049wh9ctq6xj5qe","category_id":"cj66nwjh40055wh9cdsbpb9p4","_id":"cj66nwjia006awh9ctaga7yk6"},{"post_id":"cj66nwjha005bwh9ccca1ktm0","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjid006dwh9cjiqd74ll"},{"post_id":"cj66nwjhj005gwh9c8bhgj2l9","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjih006hwh9cveguufrg"},{"post_id":"cj66nwjgf004kwh9c1cvuvn6g","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjil006kwh9ctth35a47"},{"post_id":"cj66nwjgf004kwh9c1cvuvn6g","category_id":"cj66nwjgh004mwh9c8snxv8p3","_id":"cj66nwjip006nwh9c1itjq2zo"},{"post_id":"cj66nwjhn005jwh9cms5lrqmx","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjj8006qwh9cnqz3hfi4"},{"post_id":"cj66nwjhq005nwh9cgl9i1yf6","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjjd006vwh9cqthil6gq"},{"post_id":"cj66nwjfi0044wh9ck0hug71w","category_id":"cj66nwjgt004uwh9ck50nng15","_id":"cj66nwjjg006ywh9cqf4o76ep"},{"post_id":"cj66nwjfi0044wh9ck0hug71w","category_id":"cj66nwjhp005kwh9cdll8q344","_id":"cj66nwjjk0071wh9czlvdkswb"},{"post_id":"cj66nwjhs005qwh9c6xlb2nd9","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjjn0076wh9chbafiuoc"},{"post_id":"cj66nwjhv005wwh9coqhuu78x","category_id":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjjp0079wh9cx654akvk"},{"post_id":"cj66nwjht005twh9cqwhuiy5c","category_id":"cj66nwjhy005xwh9c0fhxenhk","_id":"cj66nwjjs007ewh9cmy7jr60l"},{"post_id":"cj66nwji80067wh9c6u91zwk5","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwjjv007hwh9cqxzso6h9"},{"post_id":"cj66nwjia006cwh9cdttfdwjf","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjjz007mwh9caeqx3pg6"},{"post_id":"cj66nwji00061wh9ciarvcq2f","category_id":"cj66nwji90068wh9cto2f4g3f","_id":"cj66nwjk1007pwh9c180zqxfd"},{"post_id":"cj66nwjid006fwh9cypyxle1j","category_id":"cj66nwj9r000awh9c2ijq2i1e","_id":"cj66nwjk5007uwh9cs0p2kesd"},{"post_id":"cj66nwjih006jwh9ckdy9b0wh","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjk7007xwh9c490vqw7q"},{"post_id":"cj66nwji50064wh9cueetfu44","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjka0081wh9cmqsevbvh"},{"post_id":"cj66nwji50064wh9cueetfu44","category_id":"cj66nwjig006gwh9cq5aidrqm","_id":"cj66nwjkt0085wh9cen9eh7jw"},{"post_id":"cj66nwjil006mwh9cl0uleut8","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjkv0089wh9c2gg3z8u2"},{"post_id":"cj66nwjjd006xwh9cqeqluefd","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjkx008cwh9cmcq9w7dm"},{"post_id":"cj66nwjjg0070wh9cj6ch8vv2","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjl1008gwh9c9wpd0jac"},{"post_id":"cj66nwjiq006pwh9cb7819vws","category_id":"cj66nwjjb006twh9cxih4ju1y","_id":"cj66nwjl3008kwh9cbrpr1f3p"},{"post_id":"cj66nwjj9006swh9c77akhy20","category_id":"cj66nwjjb006twh9cxih4ju1y","_id":"cj66nwjl5008owh9cf5f4k6ep"},{"post_id":"cj66nwjjv007jwh9cw6xoeie4","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjla008swh9cmflewt4i"},{"post_id":"cj66nwjjn0078wh9coxj6j0p7","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjld008vwh9cy56ee3nd"},{"post_id":"cj66nwjjn0078wh9coxj6j0p7","category_id":"cj66nwjjx007kwh9cdrteifcp","_id":"cj66nwjlg008zwh9czsfjaobo"},{"post_id":"cj66nwjk2007rwh9crpynje2x","category_id":"cj66nwji90068wh9cto2f4g3f","_id":"cj66nwjli0091wh9ca7xgo31w"},{"post_id":"cj66nwjk5007wwh9cp6byqwdc","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjli0094wh9cq01oeh4t"},{"post_id":"cj66nwjkt0087wh9c9n92hntb","category_id":"cj66nwjhy005xwh9c0fhxenhk","_id":"cj66nwjli0096wh9cb3qoqm3b"},{"post_id":"cj66nwjkv008bwh9cturo16hm","category_id":"cj66nwjhy005xwh9c0fhxenhk","_id":"cj66nwjlj0098wh9cnc88m43j"},{"post_id":"cj66nwjkz008ewh9c37oxc0zn","category_id":"cj66nwjhy005xwh9c0fhxenhk","_id":"cj66nwjlk009bwh9ci5aj9igi"},{"post_id":"cj66nwjjk0073wh9c9avz0o4c","category_id":"cj66nwjjr007cwh9ctachpdfp","_id":"cj66nwjlk009dwh9cv4y2gkwf"},{"post_id":"cj66nwjjk0073wh9c9avz0o4c","category_id":"cj66nwjku0088wh9ci75p3gef","_id":"cj66nwjlk009gwh9cqi87bbji"},{"post_id":"cj66nwjl1008iwh9cm22264qp","category_id":"cj66nwjga004ewh9cb7uwghww","_id":"cj66nwjlk009iwh9cgm754j6j"},{"post_id":"cj66nwjl3008mwh9cuid7z3l0","category_id":"cj66nwjga004ewh9cb7uwghww","_id":"cj66nwjll009kwh9caak8hqzq"},{"post_id":"cj66nwjjz007owh9c3tso8on2","category_id":"cj66nwjbo000hwh9c21q3l849","_id":"cj66nwjll009mwh9cseko7l9k"},{"post_id":"cj66nwjjz007owh9c3tso8on2","category_id":"cj66nwjl2008jwh9ctn6u85us","_id":"cj66nwjll009owh9c6gyvd7hu"},{"post_id":"cj66nwjl6008qwh9ctdleda7x","category_id":"cj66nwjga004ewh9cb7uwghww","_id":"cj66nwjll009qwh9cauxki53f"},{"post_id":"cj66nwjla008uwh9ctvqbdxl7","category_id":"cj66nwjga004ewh9cb7uwghww","_id":"cj66nwjll009swh9cq0demldg"},{"post_id":"cj66nwjk7007zwh9c7kd9mys7","category_id":"cj66nwjl9008rwh9ccdmvrgi4","_id":"cj66nwjll009uwh9cjoso7miv"},{"post_id":"cj66nwjld008xwh9c587xbwee","category_id":"cj66nwjhy005xwh9c0fhxenhk","_id":"cj66nwjll009wwh9ct7xjhpym"},{"post_id":"cj66nwjjp007bwh9cx08rha5s","category_id":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjlm009ywh9c39y4xe7t"},{"post_id":"cj66nwjjp007bwh9cx08rha5s","category_id":"cj66nwjk4007swh9cpupajgjl","_id":"cj66nwjlm00a0wh9c2g1tilqk"},{"post_id":"cj66nwjjp007bwh9cx08rha5s","category_id":"cj66nwjlf008ywh9cgcb8vdof","_id":"cj66nwjlm00a2wh9c702ya2eu"},{"post_id":"cj66nwjjt007gwh9chhw2o0vi","category_id":"cj66nwjcs001pwh9ceqcv46lv","_id":"cj66nwjlm00a4wh9cs0wv7rft"},{"post_id":"cj66nwjjt007gwh9chhw2o0vi","category_id":"cj66nwjk4007swh9cpupajgjl","_id":"cj66nwjlm00a6wh9cjplm0bio"},{"post_id":"cj66nwjjt007gwh9chhw2o0vi","category_id":"cj66nwjlf008ywh9cgcb8vdof","_id":"cj66nwjlm00a8wh9ccki4m61q"},{"post_id":"cj66nwjka0083wh9cj7w31vxm","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj66nwjlm00aawh9civkjvai4"},{"post_id":"cj66nwjka0083wh9cj7w31vxm","category_id":"cj66nwjli0093wh9c53ga0s23","_id":"cj66nwjlm00acwh9cgf0io6sd"},{"post_id":"cj66nwjka0083wh9cj7w31vxm","category_id":"cj66nwjlk009fwh9cd3iefjvt","_id":"cj66nwjln00aewh9c5tjgk5lh"},{"post_id":"cj66nwjme00afwh9cr62khni7","category_id":"cj66nwjhy005xwh9c0fhxenhk","_id":"cj66nwjmi00ahwh9cexjl8ipo"},{"post_id":"cj6d7hm6g0000rk9cuzbdsdfm","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj6d7hm9g0004rk9crfa6fl4n"},{"post_id":"cj6d7hm6k0001rk9cyhkeazj5","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj6d7hm9n0006rk9c9p3ad8b5"},{"post_id":"cj6d7hm9c0003rk9cp5tk13sv","category_id":"cj66nwjci001ewh9cu9m4idgk","_id":"cj6d7hm9o0008rk9cx0fh7bdj"}],"PostTag":[{"post_id":"cj66nwj9d0008wh9cd1h3hylv","tag_id":"cj66nwj7w0005wh9c0v1m2ei9","_id":"cj66nwja4000cwh9cdxdbq2oa"},{"post_id":"cj66nwj780001wh9cdlsi9d46","tag_id":"cj66nwj7w0005wh9c0v1m2ei9","_id":"cj66nwjbl000fwh9c4n51tivc"},{"post_id":"cj66nwj7i0003wh9cfwbzn0mv","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwjbq000lwh9c86bn8djv"},{"post_id":"cj66nwjbo000kwh9cpbkb80wu","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjbs000qwh9cnwjcwcdn"},{"post_id":"cj66nwj810007wh9ca1yxr937","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjbw000twh9cpkh4eurh"},{"post_id":"cj66nwjbq000mwh9c0lrf6x3i","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjc0000ywh9cmqpbfeg3"},{"post_id":"cj66nwjbu000rwh9cdg908awk","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjc40011wh9c9qebrbnf"},{"post_id":"cj66nwj9p0009wh9ce9kc2y61","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjc70016wh9cr7e1jhej"},{"post_id":"cj66nwjbx000uwh9cxwl7c0yi","tag_id":"cj66nwj7w0005wh9c0v1m2ei9","_id":"cj66nwjca0019wh9cn4tos170"},{"post_id":"cj66nwjc0000zwh9ce4dx7txw","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjcc001cwh9crigs6cvr"},{"post_id":"cj66nwja5000dwh9cog2t6xju","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjcl001hwh9c6jf0p1fr"},{"post_id":"cj66nwjc50012wh9cjix7qj81","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjco001kwh9cs1kd6pqc"},{"post_id":"cj66nwjc80017wh9cyi5kuhgh","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjcq001nwh9cnfepkgke"},{"post_id":"cj66nwjbm000gwh9cjmkaes7g","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjcv001swh9c1g82qteu"},{"post_id":"cj66nwjca001awh9c3y5p2niu","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjd1001vwh9c4067esnv"},{"post_id":"cj66nwjcr001owh9co1zkx13j","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjd80020wh9c3v14yweq"},{"post_id":"cj66nwjd1001wwh9cz2yajftu","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjda0023wh9chsfd56y5"},{"post_id":"cj66nwjd80021wh9c6r3ht0zu","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjdf0028wh9cblkmm4in"},{"post_id":"cj66nwjcf001dwh9cqtt8nlop","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjdi002bwh9c66wiyl0f"},{"post_id":"cj66nwjcf001dwh9cqtt8nlop","tag_id":"cj66nwjd5001ywh9cetcszgdj","_id":"cj66nwjdn002gwh9cx0zpx1qh"},{"post_id":"cj66nwjdg0029wh9cxn6c7eus","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjdr002jwh9c0sgzixf3"},{"post_id":"cj66nwjcm001iwh9cked65ckj","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjdw002owh9ce16esi43"},{"post_id":"cj66nwjco001lwh9ce3rz1a5r","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjdy002rwh9cag95vdl3"},{"post_id":"cj66nwjdr002kwh9c3zcfeyl5","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwje1002wwh9cqe7ildft"},{"post_id":"cj66nwjdw002pwh9cyyq023rd","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwje4002zwh9ciicy6q03"},{"post_id":"cj66nwjcw001twh9cy77lz2mw","tag_id":"cj66nwjdv002mwh9c14ide20s","_id":"cj66nwje80032wh9camubwl5q"},{"post_id":"cj66nwjdy002swh9cr9ry1c5g","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjeg0037wh9cie63xx8i"},{"post_id":"cj66nwje1002xwh9cdy6cs4hc","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjek003awh9ckbd8oq4h"},{"post_id":"cj66nwje40030wh9cr5h24d4y","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjeo003ewh9cp42s14qt"},{"post_id":"cj66nwjda0024wh9cigvofhzo","tag_id":"cj66nwje1002uwh9cv58b8ej6","_id":"cj66nwjes003iwh9clcol2gwc"},{"post_id":"cj66nwje90033wh9cfhi443al","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjex003mwh9cvmvlrws6"},{"post_id":"cj66nwjeg0038wh9cm1fp6ojd","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjf2003pwh9cpe9bu46p"},{"post_id":"cj66nwjel003bwh9c9l09isiq","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjf6003swh9c5phdjfgy"},{"post_id":"cj66nwjeo003fwh9copbrxdij","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjfa003wwh9cqwjyzgyw"},{"post_id":"cj66nwjdj002cwh9c0eavtrpy","tag_id":"cj66nwjec0035wh9c3ur5wjz6","_id":"cj66nwjfe0040wh9czpubcz05"},{"post_id":"cj66nwjdj002cwh9c0eavtrpy","tag_id":"cj66nwjdv002mwh9c14ide20s","_id":"cj66nwjfi0043wh9cz2ufvd8l"},{"post_id":"cj66nwjes003jwh9ch8ly3wue","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjfk0048wh9cqjlmpzcv"},{"post_id":"cj66nwjey003nwh9cwcuzdx9k","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjfo004bwh9c6f4eif9r"},{"post_id":"cj66nwjdo002hwh9cieox1an1","tag_id":"cj66nwjdv002mwh9c14ide20s","_id":"cj66nwjgc004gwh9cdqt7pla5"},{"post_id":"cj66nwjf2003qwh9cjz06lvr1","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjge004jwh9cddcwmp65"},{"post_id":"cj66nwjf2003qwh9cjz06lvr1","tag_id":"cj66nwjf9003uwh9c971sx3g2","_id":"cj66nwjgi004owh9cc2iadu59"},{"post_id":"cj66nwjf7003twh9coi7ug4c8","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjgp004rwh9cg4hj1xro"},{"post_id":"cj66nwjf7003twh9coi7ug4c8","tag_id":"cj66nwjf9003uwh9c971sx3g2","_id":"cj66nwjgv004wwh9creio5dqe"},{"post_id":"cj66nwjfp004cwh9cc0i2phzu","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwjgz004zwh9c25zuu4n3"},{"post_id":"cj66nwjgc004hwh9comvoi62k","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwjh30053wh9c8bse4mok"},{"post_id":"cj66nwjfa003xwh9cplnpr6s2","tag_id":"cj66nwjga004dwh9cwuiypur7","_id":"cj66nwjh60057wh9ckzpna7k1"},{"post_id":"cj66nwjgi004pwh9cnsm2dql9","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwjha005awh9chrzvusuc"},{"post_id":"cj66nwjfe0041wh9cmg7pteb9","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjhj005fwh9c5b7l9kbr"},{"post_id":"cj66nwjfe0041wh9cmg7pteb9","tag_id":"cj66nwjgh004lwh9clqfwvtce","_id":"cj66nwjhn005iwh9cztuxhzes"},{"post_id":"cj66nwjgp004swh9c5nzadn4q","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjhq005mwh9ckup3l8c7"},{"post_id":"cj66nwjgw004xwh9ctm499ko9","tag_id":"cj66nwjdv002mwh9c14ide20s","_id":"cj66nwjhr005pwh9c649eedrz"},{"post_id":"cj66nwjfi0044wh9ck0hug71w","tag_id":"cj66nwjgt004twh9chd7y2n9u","_id":"cj66nwjht005swh9cb4keogh7"},{"post_id":"cj66nwjfi0044wh9ck0hug71w","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwjhv005vwh9coi0q1ppl"},{"post_id":"cj66nwjgz0050wh9cn4ob401j","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwji00060wh9c4z7gaefu"},{"post_id":"cj66nwjh30054wh9c880ff3xc","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwji40063wh9c2mz10b0s"},{"post_id":"cj66nwjh60058wh9ceer6nz7b","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwji80066wh9cqdm2nfcn"},{"post_id":"cj66nwjfl0049wh9ctq6xj5qe","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjia006bwh9cb9s61pgd"},{"post_id":"cj66nwjfl0049wh9ctq6xj5qe","tag_id":"cj66nwjh20051wh9cogbzalz4","_id":"cj66nwjid006ewh9c7pt0teyv"},{"post_id":"cj66nwjha005bwh9ccca1ktm0","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjih006iwh9crqx7gnd1"},{"post_id":"cj66nwjhj005gwh9c8bhgj2l9","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjil006lwh9clywkvg5i"},{"post_id":"cj66nwjgf004kwh9c1cvuvn6g","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjip006owh9ceeaod1lr"},{"post_id":"cj66nwjgf004kwh9c1cvuvn6g","tag_id":"cj66nwjgh004lwh9clqfwvtce","_id":"cj66nwjj8006rwh9cvseo3tuz"},{"post_id":"cj66nwjhn005jwh9cms5lrqmx","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjjd006wwh9cnlaw1gq2"},{"post_id":"cj66nwjhq005nwh9cgl9i1yf6","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjjg006zwh9cj04mx7vi"},{"post_id":"cj66nwjhs005qwh9c6xlb2nd9","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjjk0072wh9c37strcw5"},{"post_id":"cj66nwjhv005wwh9coqhuu78x","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjjn0077wh9ceqwsmi4u"},{"post_id":"cj66nwji50064wh9cueetfu44","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjjp007awh9cd2ufjevj"},{"post_id":"cj66nwji50064wh9cueetfu44","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjjt007fwh9cm4c7mie2"},{"post_id":"cj66nwjht005twh9cqwhuiy5c","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjjv007iwh9cfcv7bdfn"},{"post_id":"cj66nwji80067wh9c6u91zwk5","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwjjz007nwh9cktjl7at4"},{"post_id":"cj66nwjia006cwh9cdttfdwjf","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjk1007qwh9csdrke8gz"},{"post_id":"cj66nwji00061wh9ciarvcq2f","tag_id":"cj66nwjia0069wh9cdxgbp73y","_id":"cj66nwjk5007vwh9cjefa3ec5"},{"post_id":"cj66nwjid006fwh9cypyxle1j","tag_id":"cj66nwj9s000bwh9c150pqgro","_id":"cj66nwjk7007ywh9c3ddsgcdw"},{"post_id":"cj66nwjih006jwh9ckdy9b0wh","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjka0082wh9cg4fei38z"},{"post_id":"cj66nwjil006mwh9cl0uleut8","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjkt0086wh9cceimzg98"},{"post_id":"cj66nwjjd006xwh9cqeqluefd","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjkv008awh9cd11vb0wc"},{"post_id":"cj66nwjjg0070wh9cj6ch8vv2","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjky008dwh9c7dnqabxl"},{"post_id":"cj66nwjiq006pwh9cb7819vws","tag_id":"cj66nwjjc006uwh9cs2ikzgfg","_id":"cj66nwjl1008hwh9cbo2q2xtl"},{"post_id":"cj66nwjj9006swh9c77akhy20","tag_id":"cj66nwjjc006uwh9cs2ikzgfg","_id":"cj66nwjl3008lwh9c581lljod"},{"post_id":"cj66nwjjp007bwh9cx08rha5s","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjl5008pwh9cntimiksb"},{"post_id":"cj66nwjjp007bwh9cx08rha5s","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjla008twh9cy2x4o7kg"},{"post_id":"cj66nwjjp007bwh9cx08rha5s","tag_id":"cj66nwjjc006uwh9cs2ikzgfg","_id":"cj66nwjld008wwh9c03zz21so"},{"post_id":"cj66nwjjt007gwh9chhw2o0vi","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjlg0090wh9cbnccnkj7"},{"post_id":"cj66nwjjt007gwh9chhw2o0vi","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjli0092wh9cot6tm8f6"},{"post_id":"cj66nwjjt007gwh9chhw2o0vi","tag_id":"cj66nwjjc006uwh9cs2ikzgfg","_id":"cj66nwjli0095wh9cwp1zb2ip"},{"post_id":"cj66nwjjk0073wh9c9avz0o4c","tag_id":"cj66nwjjr007dwh9crhi9h6jg","_id":"cj66nwjli0097wh9czhgw15re"},{"post_id":"cj66nwjjk0073wh9c9avz0o4c","tag_id":"cj66nwjcs001qwh9cvvcvuspw","_id":"cj66nwjlj0099wh9cae18xyaz"},{"post_id":"cj66nwjjv007jwh9cw6xoeie4","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjlk009cwh9cf20dxck0"},{"post_id":"cj66nwjjn0078wh9coxj6j0p7","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjlk009ewh9crg0iqujh"},{"post_id":"cj66nwjjn0078wh9coxj6j0p7","tag_id":"cj66nwjjy007lwh9c23y5sc4q","_id":"cj66nwjlk009hwh9cn8cqfgi9"},{"post_id":"cj66nwjk2007rwh9crpynje2x","tag_id":"cj66nwjia0069wh9cdxgbp73y","_id":"cj66nwjlk009jwh9cdrkg304l"},{"post_id":"cj66nwjk5007wwh9cp6byqwdc","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjll009lwh9ck83jyr81"},{"post_id":"cj66nwjjz007owh9c3tso8on2","tag_id":"cj66nwjbo000iwh9cyex3vu67","_id":"cj66nwjll009nwh9ccfjp7mpt"},{"post_id":"cj66nwjjz007owh9c3tso8on2","tag_id":"cj66nwjk4007twh9c8wrqpnok","_id":"cj66nwjll009pwh9cxva7w0pt"},{"post_id":"cj66nwjkt0087wh9c9n92hntb","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjll009rwh9cjw4sjjmb"},{"post_id":"cj66nwjkv008bwh9cturo16hm","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjll009twh9c0h6dqrca"},{"post_id":"cj66nwjk7007zwh9c7kd9mys7","tag_id":"cj66nwjkt0084wh9c6ntb8pec","_id":"cj66nwjll009vwh9cdo7g76ro"},{"post_id":"cj66nwjkz008ewh9c37oxc0zn","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjlm009xwh9cwnkd4h80"},{"post_id":"cj66nwjl1008iwh9cm22264qp","tag_id":"cj66nwjga004dwh9cwuiypur7","_id":"cj66nwjlm009zwh9cjhuzi2xj"},{"post_id":"cj66nwjl3008mwh9cuid7z3l0","tag_id":"cj66nwjga004dwh9cwuiypur7","_id":"cj66nwjlm00a1wh9c6253g8wq"},{"post_id":"cj66nwjl6008qwh9ctdleda7x","tag_id":"cj66nwjga004dwh9cwuiypur7","_id":"cj66nwjlm00a3wh9cabo86402"},{"post_id":"cj66nwjka0083wh9cj7w31vxm","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj66nwjlm00a5wh9cshd0b3mw"},{"post_id":"cj66nwjka0083wh9cj7w31vxm","tag_id":"cj66nwjl1008fwh9cw2v5u8i3","_id":"cj66nwjlm00a7wh9cnr27ch33"},{"post_id":"cj66nwjka0083wh9cj7w31vxm","tag_id":"cj66nwjl4008nwh9c6azgrmdf","_id":"cj66nwjlm00a9wh9c7ot3w8f4"},{"post_id":"cj66nwjla008uwh9ctvqbdxl7","tag_id":"cj66nwjga004dwh9cwuiypur7","_id":"cj66nwjlm00abwh9c6e4r4us1"},{"post_id":"cj66nwjld008xwh9c587xbwee","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjlm00adwh9c2bucsg8k"},{"post_id":"cj66nwjme00afwh9cr62khni7","tag_id":"cj66nwjhz005ywh9ctiw0qj8t","_id":"cj66nwjmi00agwh9cwcfcvaqw"},{"post_id":"cj6d7hm6g0000rk9cuzbdsdfm","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj6d7hm9c0002rk9cn3j5bojp"},{"post_id":"cj6d7hm6k0001rk9cyhkeazj5","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj6d7hm9j0005rk9ceslcsiys"},{"post_id":"cj6d7hm9c0003rk9cp5tk13sv","tag_id":"cj66nwjci001fwh9ckd633u11","_id":"cj6d7hm9n0007rk9coj8exorq"}],"Tag":[{"name":"生活","_id":"cj66nwj7w0005wh9c0v1m2ei9"},{"name":"网络","_id":"cj66nwj9s000bwh9c150pqgro"},{"name":"Android","_id":"cj66nwjbo000iwh9cyex3vu67"},{"name":"Python","_id":"cj66nwjci001fwh9ckd633u11"},{"name":"Java","_id":"cj66nwjcs001qwh9cvvcvuspw"},{"name":"多线程","_id":"cj66nwjd5001ywh9cetcszgdj"},{"name":"工具","_id":"cj66nwjdv002mwh9c14ide20s"},{"name":"MAC","_id":"cj66nwje1002uwh9cv58b8ej6"},{"name":"Mac","_id":"cj66nwjec0035wh9c3ur5wjz6"},{"name":"自己写爬虫","_id":"cj66nwjf9003uwh9c971sx3g2"},{"name":"设计模式","_id":"cj66nwjga004dwh9cwuiypur7"},{"name":"自动化","_id":"cj66nwjgh004lwh9clqfwvtce"},{"name":"WireShakr","_id":"cj66nwjgt004twh9chd7y2n9u"},{"name":"WordCloud","_id":"cj66nwjh20051wh9cogbzalz4"},{"name":"算法","_id":"cj66nwjhz005ywh9ctiw0qj8t"},{"name":"职场杂谈","_id":"cj66nwjia0069wh9cdxgbp73y"},{"name":"趣题","_id":"cj66nwjjc006uwh9cs2ikzgfg"},{"name":"GC","_id":"cj66nwjjr007dwh9crhi9h6jg"},{"name":"源码解析","_id":"cj66nwjjy007lwh9c23y5sc4q"},{"name":"性能优化","_id":"cj66nwjk4007twh9c8wrqpnok"},{"name":"程序员的数学","_id":"cj66nwjkt0084wh9c6ntb8pec"},{"name":"excel","_id":"cj66nwjl1008fwh9cw2v5u8i3"},{"name":"xlrd","_id":"cj66nwjl4008nwh9c6azgrmdf"}]}}